/**
 * Valid type arguments for Set/GetSimVarValue
 */
var SimVarValueType;
(function (SimVarValueType) {
    SimVarValueType["Amps"] = "Amperes";
    SimVarValueType["Bool"] = "bool";
    SimVarValueType["Celsius"] = "celsius";
    SimVarValueType["Degree"] = "degrees";
    SimVarValueType["Enum"] = "enum";
    SimVarValueType["Farenheit"] = "farenheit";
    SimVarValueType["Feet"] = "feet";
    SimVarValueType["FPM"] = "feet per minute";
    SimVarValueType["GAL"] = "gallons";
    SimVarValueType["GPH"] = "gph";
    SimVarValueType["Hours"] = "Hours";
    SimVarValueType["HPA"] = "hectopascals";
    SimVarValueType["InHG"] = "inches of mercury";
    SimVarValueType["KHz"] = "KHz";
    SimVarValueType["Knots"] = "knots";
    SimVarValueType["LBS"] = "pounds";
    SimVarValueType["LLA"] = "latlonalt";
    SimVarValueType["Mach"] = "mach";
    SimVarValueType["MB"] = "Millibars";
    SimVarValueType["Meters"] = "meters";
    SimVarValueType["MetersPerSecond"] = "meters per second";
    SimVarValueType["MetersPerSecondSquared"] = "meters per second squared";
    SimVarValueType["MillimetersWater"] = "millimeters of water";
    SimVarValueType["MHz"] = "MHz";
    SimVarValueType["NM"] = "nautical mile";
    SimVarValueType["Number"] = "number";
    SimVarValueType["Percent"] = "percent";
    SimVarValueType["PercentOver100"] = "percent over 100";
    SimVarValueType["Pounds"] = "pounds";
    SimVarValueType["PPH"] = "Pounds per hour";
    SimVarValueType["PSI"] = "psi";
    SimVarValueType["Radians"] = "radians";
    SimVarValueType["Rankine"] = "rankine";
    SimVarValueType["RPM"] = "Rpm";
    SimVarValueType["Seconds"] = "seconds";
    SimVarValueType["SlugsPerCubicFoot"] = "slug per cubic foot";
    SimVarValueType["String"] = "string";
    SimVarValueType["Volts"] = "Volts";
})(SimVarValueType || (SimVarValueType = {}));
const latlonaltRegEx = new RegExp(/latlonalt/i);
const latlonaltpbhRegex = new RegExp(/latlonaltpbh/i);
const pbhRegex = new RegExp(/pbh/i);
const pid_structRegex = new RegExp(/pid_struct/i);
const xyzRegex = new RegExp(/xyz/i);
const stringRegex = new RegExp(/string/i);
const boolRegex = new RegExp(/boolean|bool/i);
const numberRegex = new RegExp(/number/i);
const defaultSource = '';
SimVar.GetSimVarValue = (name, unit, dataSource = defaultSource) => {
    try {
        if (simvar) {
            let output;
            const registeredID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (registeredID >= 0) {
                if (numberRegex.test(unit)) {
                    output = simvar.getValueReg(registeredID);
                }
                else if (stringRegex.test(unit)) {
                    output = simvar.getValueReg_String(registeredID);
                }
                else if (latlonaltRegEx.test(unit)) {
                    output = new LatLongAlt(simvar.getValue_LatLongAlt(name, dataSource));
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    output = new LatLongAltPBH(simvar.getValue_LatLongAltPBH(name, dataSource));
                }
                else if (pbhRegex.test(unit)) {
                    output = new PitchBankHeading(simvar.getValue_PBH(name, dataSource));
                }
                else if (pid_structRegex.test(unit)) {
                    output = new PID_STRUCT(simvar.getValue_PID_STRUCT(name, dataSource));
                }
                else if (xyzRegex.test(unit)) {
                    output = new XYZ(simvar.getValue_XYZ(name, dataSource));
                }
                else {
                    output = simvar.getValueReg(registeredID);
                }
            }
            return output;
        }
        else {
            console.warn('SimVar handler is not defined (' + name + ')');
        }
    }
    catch (error) {
        console.warn('ERROR ', error, ' GetSimVarValue ' + name + ' unit : ' + unit);
        return null;
    }
    return null;
};
SimVar.SetSimVarValue = (name, unit, value, dataSource = defaultSource) => {
    if (value == undefined) {
        console.warn(name + ' : Trying to set a null value');
        return Promise.resolve();
    }
    try {
        if (simvar) {
            const regID = SimVar.GetRegisteredId(name, unit, dataSource);
            if (regID >= 0) {
                if (stringRegex.test(unit)) {
                    return Coherent.call('setValueReg_String', regID, value);
                }
                else if (boolRegex.test(unit)) {
                    return Coherent.call('setValueReg_Bool', regID, !!value);
                }
                else if (numberRegex.test(unit)) {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
                else if (latlonaltRegEx.test(unit)) {
                    return Coherent.call('setValue_LatLongAlt', name, value, dataSource);
                }
                else if (latlonaltpbhRegex.test(unit)) {
                    return Coherent.call('setValue_LatLongAltPBH', name, value, dataSource);
                }
                else if (pbhRegex.test(unit)) {
                    return Coherent.call('setValue_PBH', name, value, dataSource);
                }
                else if (pid_structRegex.test(unit)) {
                    return Coherent.call('setValue_PID_STRUCT', name, value, dataSource);
                }
                else if (xyzRegex.test(unit)) {
                    return Coherent.call('setValue_XYZ', name, value, dataSource);
                }
                else {
                    return Coherent.call('setValueReg_Number', regID, value);
                }
            }
        }
        else {
            console.warn('SimVar handler is not defined');
        }
    }
    catch (error) {
        console.warn('error SetSimVarValue ' + error);
    }
    return Promise.resolve();
};

/**
 * A utility class for working with common aeronautical constants and calculations.
 */
class AeroMath {
    // ---- Ideal gas law relationships for air ----
    /**
     * Gets the static pressure of air, in hectopascals, given temperature and density.
     * @param temperature The temperature, in degrees Celsius.
     * @param density The density, in kilograms per cubic meter.
     * @returns The static pressure of air, in hectopascals, with the specified temperature and density.
     */
    static pressureAir(temperature, density) {
        return density * AeroMath.R_AIR * (temperature + 273.15) / 100;
    }
    /**
     * Gets the density of air, in kilograms per cubic meter, given static pressure and temperature.
     * @param pressure The static pressure, in hectopascals.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The density of air, in kilograms per cubic meter, with the specified static pressure and temperature.
     */
    static densityAir(pressure, temperature) {
        return pressure * 100 / (AeroMath.R_AIR * (temperature + 273.15));
    }
    /**
     * Gets the temperature of air, in degrees Celsius, given static pressure and density.
     * @param pressure The static pressure, in hectopascals.
     * @param density The density, in kilograms per cubic meter.
     * @returns The temperature of air, in degrees Celsius, with the specified static pressure and temperature.
     */
    static temperatureAir(pressure, density) {
        return pressure * 100 / (AeroMath.R_AIR * density) - 273.15;
    }
    // ---- Other properties of air ----.
    /**
     * Gets the speed of sound in air, in meters per second, for a given temperature.
     * @param temperature The temperature, in degrees Celsius.
     * @returns The speed of sound in air, in meters per second, for the given temperature.
     */
    static soundSpeedAir(temperature) {
        // speed of sound = sqrt(gamma * R * T)
        // gamma = 1.4
        // R = specific gas constant of dry air
        return Math.sqrt(401.8798068394 * (temperature + 273.15));
    }
    // ---- Pressure ratios ----
    /**
     * Gets the ratio of total pressure to static pressure for a given mach number in a subsonic compressible airflow.
     * @param mach The mach number.
     * @returns The ratio of total pressure to static pressure for the specific mach number.
     */
    static totalPressureRatioAir(mach) {
        return Math.pow(1 + 0.2 * mach * mach, 3.5);
    }
    // ---- Temperature ratios ----
    /**
     * Gets the ratio of total air temperature to static air temperature for a given mach number.
     * @param mach The mach number.
     * @param recovery The recovery factor. This is a value in the range `[0, 1]` representing the fraction of the
     * kinetic energy of the airflow that is converted to heat. Defaults to 1.
     * @returns The ratio of total air temperature to static air temperature for the specified mach number.
     */
    static totalTemperatureRatioAir(mach, recovery = 1) {
        return 1 + 0.2 * recovery * mach * mach;
    }
    // ---- ISA modeling ----
    /**
     * Gets the ISA temperature, in degrees Celsius, at a given pressure altitude. The supported pressure altitude range
     * is from -610 to 80000 meters above MSL. This method will return the temperature at -610 meters for all altitudes
     * below this range, and the temperature at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA temperature, in degrees Celsius, for the specified pressure altitude.
     */
    static isaTemperature(altitude) {
        // We don't use lookup table for perf reasons.
        if (altitude < 11000) {
            return 15 + Math.max(altitude, -610) * -0.0065;
        }
        else if (altitude < 20000) {
            return -56.5;
        }
        else if (altitude < 32000) {
            return -56.5 + (altitude - 20000) * 0.001;
        }
        else if (altitude < 47000) {
            return -44.5 + (altitude - 32000) * 0.0028;
        }
        else if (altitude < 51000) {
            return -2.5;
        }
        else if (altitude < 71000) {
            return -2.5 + (altitude - 51000) * -0.0028;
        }
        else {
            return -58.5 + (Math.min(altitude, 80000) - 71000) * -0.002;
        }
    }
    /**
     * Gets the ISA pressure, in hectopascals, at a given pressure altitude. The supported pressure altitude range is
     * from -610 to 80000 meters above MSL. This method will return the pressure at -610 meters for all altitudes below
     * this range, and the pressure at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The ISA pressure, in hectopascals, for the specified pressure altitude.
     */
    static isaPressure(altitude) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // P(h) = P(h0) * (1 + dT/dh / T(h0) * (h - h0)) ^ (-g / (R * dT/dh))
        // Temperature constant with altitude:
        // P(h) = P(h0) * e^(-g / (R * T) * (h - h0))
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (altitude < -610) {
            // Modeling stops at -610 meters, so return the pressure for -610 meters for any altitude below this.
            return 1088.707021458965;
        }
        else if (altitude <= 11000) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return 1013.25 * Math.pow(1 - 2.25577e-5 * altitude, 5.25580);
        }
        else if (altitude <= 20000) {
            // Tropopause
            // dT/dh = 0
            return 226.32547681422847 * Math.exp(-1.57686e-4 * (altitude - 11000));
        }
        else if (altitude <= 32000) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 54.7512459834976 * Math.pow(1 + 4.61574e-6 * (altitude - 20000), -34.1627);
        }
        else if (altitude <= 47000) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 8.68079131804552 * Math.pow(1 + 1.22458e-5 * (altitude - 32000), -12.2010);
        }
        else if (altitude <= 51000) {
            // Stratopause
            // dT/dh = 0
            return 1.1091650294132658 * Math.exp(-1.26225e-4 * (altitude - 47000));
        }
        else if (altitude <= 71000) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return 0.6694542213945832 * Math.pow(1 - 1.03455e-5 * (altitude - 51000), 12.2010);
        }
        else if (altitude <= 80000) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return 0.03956893750841349 * Math.pow(1 - 9.31749e-6 * (altitude - 71000), 17.0814);
        }
        else {
            // Modeling stops at 80000 meters, so return the pressure for 80000 meters for any altitude above this.
            return 0.008864013902895545;
        }
    }
    /**
     * Gets the pressure altitude, in meters above MSL, corresponding to a given ISA pressure. The supported pressure
     * altitude range is from -610 to 80000 meters above MSL. This method will return -610 meters for all pressures above
     * the pressure at -610 meters, and 80000 meters for all pressures below the pressure at 80000 meters.
     * @param pressure The ISA pressure for which to get the altitude, in hectopascals.
     * @returns The pressure altitude, in meters above MSL, corresponding to the specified ISA pressure.
     */
    static isaAltitude(pressure) {
        // ISA pressure modeling uses the following equation:
        // dP/dh = -density/g
        // Using the ideal gas law to substitute density with temperature and solving the above DE generates two
        // different equations depending on whether temperature is constant with respect to altitude:
        // Temperature varies with altitude:
        // h(P) = T(h0) / dT/dh * ((P / P(h0)) ^ (-(R * dT/dh) / g) - 1) + h0
        // Temperature constant with altitude:
        // h(P) = -(R * T) / g * ln(P / P(h0)) + h0
        // g = gravitational acceleration
        // R = specific gas constant of dry air
        if (pressure > 1088.707021458965) {
            // Modeling stops at -610 meters, so return -610 meters for any pressure above the pressure at this altitude.
            return -610;
        }
        else if (pressure > 226.32547681422847) {
            // Troposphere
            // dT/dh = -0.0065 kelvin per meter
            return -44330.76067152236 * (Math.pow(pressure / 1013.25, 0.1902659918566155) - 1);
        }
        else if (pressure > 54.7512459834976) {
            // Tropopause
            // dT/dh = 0
            return -6341.717083317479 * Math.log(pressure / 226.32547681422847) + 11000;
        }
        else if (pressure > 8.68079131804552) {
            // Lower stratosphere
            // dT/dh = 0.001 kelvin per meter
            return 216649.984617851092 * (Math.pow(pressure / 54.7512459834976, -0.02927169105486393) - 1) + 20000;
        }
        else if (pressure > 1.1091650294132658) {
            // Upper stratosphere
            // dT/dh = 0.0028 kelvin per meter
            return 81660.6509987098 * (Math.pow(pressure / 8.68079131804552, -0.08196049504139005) - 1) + 32000;
        }
        else if (pressure > 0.6694542213945832) {
            // Stratopause
            // dT/dh = 0
            return -7922.360863537334 * Math.log(pressure / 1.1091650294132658) + 47000;
        }
        else if (pressure > 0.03956893750841349) {
            // Lower mesosphere
            // dT/dh = -0.0028 kelvin per meter
            return -96660.38374172345 * (Math.pow(pressure / 0.6694542213945832, 0.08196049504139005) - 1) + 51000;
        }
        else if (pressure > 0.008864013902895545) {
            // Upper mesosphere
            // dT/dh = -0.002 kelvin per meter
            return -107325.0414006347 * (Math.pow(pressure / 0.03956893750841349, 0.05854321074385004) - 1) + 71000;
        }
        else {
            // Modeling stops at 80000 meters, so return 80000 meters for any pressure below the pressure at this altitude.
            return 80000;
        }
    }
    /**
     * Gets the ISA density, in kilograms per cubic meter, at a given pressure altitude. The supported pressure altitude
     * range is from -610 to 80000 meters above MSL. This method will return the density at -610 meters for all altitudes
     * below this range, and the density at 80000 meters for all altitudes above this range.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The ISA density, in kilograms per cubic meter, for the specified pressure altitude.
     */
    static isaDensity(altitude, deltaIsa = 0) {
        return AeroMath.densityAir(AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the speed of sound, in meters per second, at a given pressure altitude under ISA conditions.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The speed of sound, in meters per second, at the specified pressure altitude under ISA conditions.
     */
    static soundSpeedIsa(altitude, deltaIsa = 0) {
        return this.soundSpeedAir(AeroMath.isaTemperature(altitude) + deltaIsa);
    }
    /**
     * Gets the offset to apply to pressure altitude, in meters, to obtain indicated altitude for a given barometric setting.
     * @param baro The barometic setting for which to get the offset, in hectopascals.
     * @returns The offset to apply to pressure altitude, in meters, to obtain indicated altitude for the specified barometric setting.
     */
    static baroPressureAltitudeOffset(baro) {
        return 44307.694 * (Math.pow(baro / 1013.25, 0.190284) - 1);
    }
    // ---- Speed conversions ----
    // The following section contains methods for converting between different speeds: CAS, TAS, and mach.
    // All conversions are based on the following:
    // Constants:
    // gamma (adiabatic index of air) = 1.4
    // pressure_sea_level_isa = 1013.25 hPa
    // sound_speed_sea_level_isa = 340.2964 m/s
    // Relationship between mach and impact pressure (only valid for subsonic flow):
    // mach = sqrt(5 * ((impact_pressure / static_pressure + 1) ^ ((gamma - 1) / gamma)) - 1)
    // impact_pressure = static_pressure * ((1 + 0.2 * mach ^ 2) ^ (gamma / (gamma - 1)) - 1)
    // Relationship between mach and airspeed:
    // mach = airspeed / sound_speed
    // airspeed = mach * sound_speed
    /**
     * Converts true airspeed (TAS) to mach number.
     * @param tas The true airspeed to convert, in the same units as `soundSpeed`.
     * @param soundSpeed The speed of sound, in the same units as `tas`.
     * @returns The mach number equivalent of the specified true airspeed.
     */
    static tasToMach(tas, soundSpeed) {
        return tas / soundSpeed;
    }
    /**
     * Converts true airspeed (TAS) to mach number under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The mach number equivalent of the specified true airspeed at the specified pressure altitude under ISA
     * conditions.
     */
    static tasToMachIsa(tas, altitude, deltaIsa = 0) {
        return tas / AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts mach number to true airspeed (TAS).
     * @param mach The mach number to convert.
     * @param soundSpeed The speed of sound.
     * @returns The true airspeed equivalent of the specified mach number, in the same units as `soundSpeed`.
     */
    static machToTas(mach, soundSpeed) {
        return mach * soundSpeed;
    }
    /**
     * Converts mach number to true airspeed (TAS), in meters per second, under ISA conditions.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified mach number at the specified
     * pressure altitude under ISA conditions.
     */
    static machToTasIsa(mach, altitude, deltaIsa = 0) {
        return mach * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number. The conversion is only valid for subsonic speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified static pressure.
     */
    static casToMach(cas, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate mach from CAS by
        // calculating the impact pressure using sea level ISA conditions, then using that impact pressure to calculate
        // mach using ambient static pressure.
        const mach0 = cas / AeroMath.SOUND_SPEED_SEA_LEVEL_ISA;
        const impactPressure = 1013.25 * (Math.pow(1 + (0.2 * mach0 * mach0), 3.5) - 1);
        return Math.sqrt(5 * (Math.pow(impactPressure / pressure + 1, 2 / 7) - 1));
    }
    /**
     * Converts calibrated airspeed (CAS) to mach number under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The mach number equivalent of the specified calibrated airspeed at the specified pressure altitude under
     * ISA conditions.
     */
    static casToMachIsa(cas, altitude) {
        return AeroMath.casToMach(cas, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS). The conversion is only valid for subsonic speeds.
     * @param mach The mach number to convert.
     * @param pressure The ambient static pressure, in hectopascals.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number at the specified
     * static pressure.
     */
    static machToCas(mach, pressure) {
        // Calibrated airspeed is effectively the airspeed at sea level under ISA conditions that would produce the same
        // impact pressure as the airplane's observed impact pressure. Therefore, we can calculate CAS from mach by
        // calculating the impact pressure using ambient static pressure, then using that impact pressure to calculate
        // CAS using sea level ISA conditions.
        const impactPressure = pressure * (Math.pow(1 + 0.2 * mach * mach, 3.5) - 1);
        return AeroMath.SOUND_SPEED_SEA_LEVEL_ISA * Math.sqrt(5 * (Math.pow(impactPressure / 1013.25 + 1, 2 / 7) - 1));
    }
    /**
     * Converts mach number to calibrated airspeed (CAS) under ISA conditions. The conversion is only valid for subsonic
     * speeds.
     * @param mach The mach number to convert.
     * @param altitude The pressure altitude, in meters above MSL.
     * @returns The calibrated airspeed equivalent in meters per second of the specified mach number  at the specified
     * pressure altitude under ISA conditions.
     */
    static machToCasIsa(mach, altitude) {
        return AeroMath.machToCas(mach, AeroMath.isaPressure(altitude));
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS).
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * ambient pressure and temperature.
     */
    static casToTas(cas, pressure, temperature) {
        return AeroMath.casToMach(cas, pressure) * AeroMath.soundSpeedAir(temperature);
    }
    /**
     * Converts calibrated airspeed (CAS) to true airspeed (TAS) under ISA conditions.
     * @param cas The calibrated airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The true airspeed equivalent, in meters per second, of the specified calibrated airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static casToTasIsa(cas, altitude, deltaIsa = 0) {
        return AeroMath.casToMachIsa(cas, altitude) * AeroMath.soundSpeedIsa(altitude, deltaIsa);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS).
     * @param tas The true airspeed to convert, in meters per second.
     * @param pressure The ambient static pressure, in hectopascals.
     * @param temperature The ambient static temperature, in degrees Celsius.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * ambient pressure and temperature.
     */
    static tasToCas(tas, pressure, temperature) {
        return AeroMath.machToCas(tas / AeroMath.soundSpeedAir(temperature), pressure);
    }
    /**
     * Converts true airspeed (TAS) to calibrated airspeed (CAS) under ISA conditions.
     * @param tas The true airspeed to convert, in meters per second.
     * @param altitude The pressure altitude, in meters above MSL.
     * @param deltaIsa The deviation from ISA temperature, in degrees Celsius. Defaults to `0`.
     * @returns The calibrated airspeed equivalent, in meters per second, of the specified true airspeed at the specified
     * pressure altitude under ISA conditions.
     */
    static tasToCasIsa(tas, altitude, deltaIsa = 0) {
        return AeroMath.machToCasIsa(tas / AeroMath.soundSpeedIsa(altitude, deltaIsa), altitude);
    }
    // ---- Lift and drag equations ----
    // force_coefficient = force / (dynamic_pressure * area)
    // dynamic_pressure = 0.5 * density * speed ^ 2
    /**
     * Calculates a fluid flow force coefficient given a force and flow parameters.
     * @param force The flow force, in newtons.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force coefficient given the specified force and flow parameters.
     */
    static flowCoefFromForce(force, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return force / (dynamicPressure * area);
    }
    /**
     * Calculates a fluid flow force given a coefficient and flow parameters.
     * @param coef The flow force coefficient.
     * @param area The reference area, in meters squared.
     * @param arg3 The flow dynamic pressure, in hectopascals, if `arg4` is not defined; otherwise the flow density, in
     * kilograms per cubic meter.
     * @param arg4 The flow speed, in meters per second.
     * @returns The fluid flow force given the specified coefficient and flow parameters.
     */
    static flowForceFromCoef(coef, area, arg3, arg4) {
        const dynamicPressure = arg4 === undefined ? arg3 * 100 : 0.5 * arg3 * arg4 * arg4;
        return coef * dynamicPressure * area;
    }
}
/** The ideal gas constant, in units of joules per mole per kelvin. */
AeroMath.R = 8.314462618153;
/** The specific gas constant of dry air, in units of joules per kilogram per kelvin. */
AeroMath.R_AIR = 287.057;
/** Approximate value of the adiabatic index of air near room temperature. */
AeroMath.GAMMA_AIR = 1.4;
/** The speed of sound in air at sea level under ISA conditions, in meters per second. */
AeroMath.SOUND_SPEED_SEA_LEVEL_ISA = 340.2964;
AeroMath.liftCoefficient = AeroMath.flowCoefFromForce;
AeroMath.lift = AeroMath.flowForceFromCoef;
AeroMath.dragCoefficient = AeroMath.flowCoefFromForce;
AeroMath.drag = AeroMath.flowForceFromCoef;

/**
 * A number with an associated unit. Each NumberUnit is created with a reference unit type,
 * which cannot be changed after instantiation. The reference unit type determines how the
 * value of the NumberUnit is internally represented. Each NumberUnit also maintains an
 * active unit type, which can be dynamically changed at any time.
 */
class NumberUnit {
    /**
     * Constructor.
     * @param number - the initial numeric value of the new NumberUnit.
     * @param unit - the unit type of the new NumberUnit.
     */
    constructor(number, unit) {
        this._number = number;
        this._unit = unit;
        this.readonly = new NumberUnitReadOnly(this);
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this._number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this._unit;
    }
    /**
     * Converts a value to a numeric value with this NumberUnit's unit type.
     * @param value - the value.
     * @param unit - the unit type of the new value. Defaults to this NumberUnit's unit type. This argument is ignored if
     * value is a NumberUnit.
     * @returns the numeric of the value with this NumberUnit's unit type.
     */
    toNumberOfThisUnit(value, unit) {
        if ((typeof value !== 'number') && this.unit.canConvert(value.unit)) {
            return this.unit.convertFrom(value.number, value.unit);
        }
        if (typeof value === 'number' && (!unit || this.unit.canConvert(unit))) {
            return unit ? this.unit.convertFrom(value, unit) : value;
        }
        return undefined;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const converted = this.toNumberOfThisUnit(arg1, arg2);
        if (converted !== undefined) {
            this._number = converted;
            return this;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number + converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number += converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const converted = this.toNumberOfThisUnit(arg1, isArg2NumberUnit ? undefined : arg2);
        if (converted !== undefined) {
            let out = isArg2NumberUnit ? arg2 : arg3;
            if (out) {
                out.set(this.number - converted, this.unit);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                out = this;
                this._number -= converted;
            }
            return out;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    scale(factor, out) {
        if (out) {
            return out.set(this.number * factor, this.unit);
        }
        else {
            this._number *= factor;
            return this;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted) {
            return this.number / converted;
        }
        throw new Error('Invalid unit conversion attempted.');
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    abs(out) {
        if (out) {
            return out.set(Math.abs(this.number), this.unit);
        }
        else {
            this._number = Math.abs(this._number);
            return this;
        }
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.unit.convertTo(this.number, unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            throw new Error('Invalid unit conversion attempted.');
        }
        const diff = this.number - converted;
        if (Math.abs(diff) < 1e-14) {
            return 0;
        }
        return Math.sign(diff);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(value, unit) {
        const converted = this.toNumberOfThisUnit(value, unit);
        if (converted === undefined) {
            return false;
        }
        if (isNaN(converted) && this.isNaN()) {
            return true;
        }
        const diff = this.number - converted;
        return !isNaN(diff) && Math.abs(diff) < 1e-14;
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return isNaN(this.number);
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return new NumberUnit(this.number, this.unit);
    }
}
/**
 * A read-only interface for a WT_NumberUnit.
 */
class NumberUnitReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only NumberUnit.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * Gets this NumberUnit's numeric value.
     * @returns This NumberUnit's numeric value.
     */
    get number() {
        return this.source.number;
    }
    /**
     * Gets this NumberUnit's unit type.
     * @returns This NumberUnit's unit type.
     */
    get unit() {
        return this.source.unit;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    add(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.add(arg1, arg2, out);
        }
        else {
            return this.source.add(arg1, out);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    subtract(arg1, arg2, arg3) {
        const isArg2NumberUnit = arg2 instanceof NumberUnit;
        const out = (isArg2NumberUnit ? arg2 : arg3);
        if (typeof arg1 === 'number') {
            return this.source.subtract(arg1, arg2, out);
        }
        else {
            return this.source.subtract(arg1, out);
        }
    }
    /**
     * Scales this NumberUnit by a unit-less factor and returns the result.
     * @param factor The factor by which to scale.
     * @param out The NumberUnit to which to write the result.
     * @returns The scaled value.
     */
    scale(factor, out) {
        return this.source.scale(factor, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    ratio(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.ratio(arg1, arg2);
        }
        else {
            return this.source.ratio(arg1);
        }
    }
    /**
     * Calculates the absolute value of this NumberUnit and returns the result.
     * @param out The NumberUnit to which to write the result.
     * @returns The absolute value.
     */
    abs(out) {
        return this.source.abs(out);
    }
    /**
     * Returns the numeric value of this NumberUnit after conversion to a specified unit.
     * @param unit The unit to which to convert.
     * @returns The converted numeric value.
     * @throws Error if this NumberUnit's unit type cannot be converted to the specified unit.
     */
    asUnit(unit) {
        return this.source.asUnit(unit);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    compare(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.compare(arg1, arg2);
        }
        else {
            return this.source.compare(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2);
        }
        else {
            return this.source.equals(arg1);
        }
    }
    /**
     * Checks whether this NumberUnit has a numeric value of NaN.
     * @returns Whether this NumberUnit has a numeric value of NaN.
     */
    isNaN() {
        return this.source.isNaN();
    }
    /**
     * Copies this NumberUnit.
     * @returns A copy of this NumberUnit.
     */
    copy() {
        return this.source.copy();
    }
}
/**
 * A unit of measurement.
 */
class AbstractUnit {
    /**
     * Constructor.
     * @param name The name of this unit.
     */
    constructor(name) {
        this.name = name;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return this.family === otherUnit.family;
    }
    /** @inheritdoc */
    createNumber(value) {
        return new NumberUnit(value, this);
    }
    /** @inheritdoc */
    equals(other) {
        return this.family === other.family && this.name === other.name;
    }
}
/**
 * A unit that can be converted to another unit of the same type via a fixed linear transformation.
 */
class SimpleUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param name The name of this unit.
     * @param scaleFactor The relative linear scale of the new unit compared to the standard unit of the same family.
     * @param zeroOffset The zero offset of the new unit compared to the standard unit of the same family.
     */
    constructor(family, name, scaleFactor, zeroOffset = 0) {
        super(name);
        this.family = family;
        this.scaleFactor = scaleFactor;
        this.zeroOffset = zeroOffset;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof SimpleUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return (value + this.zeroOffset) * (this.scaleFactor / toUnit.scaleFactor) - toUnit.zeroOffset;
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return (value + fromUnit.zeroOffset) * (fromUnit.scaleFactor / this.scaleFactor) - this.zeroOffset;
    }
}
/**
 * A unit of measure composed of the multiplicative combination of multiple elementary units.
 */
class CompoundUnit extends AbstractUnit {
    /**
     * Constructor.
     * @param family The family to which this unit belongs.
     * @param numerator An array of CompoundableUnits containing all the units in the numerator of the compound unit.
     * @param denominator An array of CompoundableUnits containing all the units in the denominator of the compound unit.
     * @param name The name of this unit. If not defined, one will be automatically generated.
     */
    constructor(family, numerator, denominator, name) {
        // if not specified, build name from component units.
        if (name === undefined) {
            name = '';
            let i = 0;
            while (i < numerator.length - 1) {
                name += `${numerator[i++].name}-`;
            }
            name += `${numerator[i].name}`;
            if (denominator.length > 0) {
                name += ' per ';
                i = 0;
                while (i < denominator.length - 1) {
                    name += `${denominator[i++].name}-`;
                }
                name += `${denominator[i].name}`;
            }
        }
        super(name);
        this.family = family;
        this.numerator = Array.from(numerator);
        this.denominator = Array.from(denominator);
        this.numerator.sort((a, b) => a.family.localeCompare(b.family));
        this.denominator.sort((a, b) => a.family.localeCompare(b.family));
        this.scaleFactor = this.getScaleFactor();
    }
    /**
     * Gets the scale factor for this unit.
     * @returns the scale factor for this unit.
     */
    getScaleFactor() {
        let factor = 1;
        factor = this.numerator.reduce((prev, curr) => prev * curr.scaleFactor, factor);
        factor = this.denominator.reduce((prev, curr) => prev / curr.scaleFactor, factor);
        return factor;
    }
    /** @inheritdoc */
    canConvert(otherUnit) {
        return otherUnit instanceof CompoundUnit && super.canConvert(otherUnit);
    }
    /** @inheritdoc */
    convertTo(value, toUnit) {
        if (!this.canConvert(toUnit)) {
            throw new Error(`Invalid conversion from ${this.name} to ${toUnit.name}.`);
        }
        return value * (this.scaleFactor / toUnit.scaleFactor);
    }
    /** @inheritdoc */
    convertFrom(value, fromUnit) {
        if (!this.canConvert(fromUnit)) {
            throw new Error(`Invalid conversion from ${fromUnit.name} to ${this.name}.`);
        }
        return value * (fromUnit.scaleFactor / this.scaleFactor);
    }
}
/**
 * Predefined unit families.
 */
var UnitFamily;
(function (UnitFamily) {
    UnitFamily["Distance"] = "distance";
    UnitFamily["Angle"] = "angle";
    UnitFamily["Duration"] = "duration";
    UnitFamily["Weight"] = "weight";
    UnitFamily["Mass"] = "weight";
    UnitFamily["Volume"] = "volume";
    UnitFamily["Pressure"] = "pressure";
    UnitFamily["Temperature"] = "temperature";
    UnitFamily["TemperatureDelta"] = "temperature_delta";
    UnitFamily["Speed"] = "speed";
    UnitFamily["Acceleration"] = "acceleration";
    UnitFamily["WeightFlux"] = "weight_flux";
    UnitFamily["MassFlux"] = "weight_flux";
    UnitFamily["VolumeFlux"] = "volume_flux";
    UnitFamily["Density"] = "density";
    UnitFamily["Force"] = "force";
})(UnitFamily || (UnitFamily = {}));
/**
 * Predefined unit types.
 */
class UnitType {
}
UnitType.METER = new SimpleUnit(UnitFamily.Distance, 'meter', 1);
UnitType.FOOT = new SimpleUnit(UnitFamily.Distance, 'foot', 0.3048);
UnitType.KILOMETER = new SimpleUnit(UnitFamily.Distance, 'kilometer', 1000);
/** Statute mile. */
UnitType.MILE = new SimpleUnit(UnitFamily.Distance, 'mile', 1609.34);
/** Nautical mile. */
UnitType.NMILE = new SimpleUnit(UnitFamily.Distance, 'nautical mile', 1852);
/** Great-arc radian. The average radius of Earth. */
UnitType.GA_RADIAN = new SimpleUnit(UnitFamily.Distance, 'great arc radian', 6378100);
/** 9.80665 meters, for internal use. */
UnitType.G_METER = new SimpleUnit(UnitFamily.Distance, '9.80665 meter', 9.80665);
UnitType.RADIAN = new SimpleUnit(UnitFamily.Angle, 'radian', 1);
UnitType.DEGREE = new SimpleUnit(UnitFamily.Angle, 'degree', Math.PI / 180);
UnitType.ARC_MIN = new SimpleUnit(UnitFamily.Angle, 'minute', Math.PI / 180 / 60);
UnitType.ARC_SEC = new SimpleUnit(UnitFamily.Angle, 'second', Math.PI / 180 / 3600);
UnitType.MILLISECOND = new SimpleUnit(UnitFamily.Duration, 'millisecond', 0.001);
UnitType.SECOND = new SimpleUnit(UnitFamily.Duration, 'second', 1);
UnitType.MINUTE = new SimpleUnit(UnitFamily.Duration, 'minute', 60);
UnitType.HOUR = new SimpleUnit(UnitFamily.Duration, 'hour', 3600);
UnitType.KILOGRAM = new SimpleUnit(UnitFamily.Weight, 'kilogram', 1);
UnitType.POUND = new SimpleUnit(UnitFamily.Weight, 'pound', 0.453592);
UnitType.SLUG = new SimpleUnit(UnitFamily.Weight, 'slug', 14.59390);
UnitType.TON = new SimpleUnit(UnitFamily.Weight, 'ton', 907.185);
UnitType.TONNE = new SimpleUnit(UnitFamily.Weight, 'tonne', 1000);
/** Weight equivalent of one liter of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LITER_FUEL = new SimpleUnit(UnitFamily.Weight, 'liter', 0.80283679);
/** Weight equivalent of one gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'gallon', 3.0390664);
/** Weight equivalent of one imperial gallon of fuel, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IMP_GALLON_FUEL = new SimpleUnit(UnitFamily.Weight, 'imperial gallon', 3.6497683);
UnitType.LITER = new SimpleUnit(UnitFamily.Volume, 'liter', 1);
UnitType.GALLON = new SimpleUnit(UnitFamily.Volume, 'gallon', 3.78541);
/** Hectopascal. */
UnitType.HPA = new SimpleUnit(UnitFamily.Pressure, 'hectopascal', 1);
/** Atmosphere. */
UnitType.ATM = new SimpleUnit(UnitFamily.Pressure, 'atmosphere', 1013.25);
/** Inch of mercury. */
UnitType.IN_HG = new SimpleUnit(UnitFamily.Pressure, 'inch of mercury', 33.8639);
/** Millimeter of mercury. */
UnitType.MM_HG = new SimpleUnit(UnitFamily.Pressure, 'millimeter of mercury', 1.33322);
/** Pound per square inch. */
UnitType.PSI = new SimpleUnit(UnitFamily.Pressure, 'pound per square inch', 68.9476);
UnitType.KELVIN = new SimpleUnit(UnitFamily.Temperature, 'kelvin', 1, 0);
UnitType.CELSIUS = new SimpleUnit(UnitFamily.Temperature, '° Celsius', 1, 273.15);
UnitType.FAHRENHEIT = new SimpleUnit(UnitFamily.Temperature, '° Fahrenheit', 5 / 9, 459.67);
UnitType.RANKINE = new SimpleUnit(UnitFamily.Temperature, '° Rankine', 5 / 9, 0);
/** Change in degrees Celsius. */
UnitType.DELTA_CELSIUS = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Celsius', 1);
/** Change in degrees Fahrenheit. */
UnitType.DELTA_FAHRENHEIT = new SimpleUnit(UnitFamily.TemperatureDelta, 'Δ° Fahrenheit', 5 / 9);
UnitType.KNOT = new CompoundUnit(UnitFamily.Speed, [UnitType.NMILE], [UnitType.HOUR], 'knot');
/** Kilometer per hour. */
UnitType.KPH = new CompoundUnit(UnitFamily.Speed, [UnitType.KILOMETER], [UnitType.HOUR]);
/** Miles per hour. */
UnitType.MPH = new CompoundUnit(UnitFamily.Speed, [UnitType.MILE], [UnitType.HOUR]);
/** Meter per minute. */
UnitType.MPM = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.MINUTE]);
/** Meter per second. */
UnitType.MPS = new CompoundUnit(UnitFamily.Speed, [UnitType.METER], [UnitType.SECOND]);
/** Foot per minute. */
UnitType.FPM = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.MINUTE]);
/** Foot per second. */
UnitType.FPS = new CompoundUnit(UnitFamily.Speed, [UnitType.FOOT], [UnitType.SECOND]);
/** Meter per minute per second. */
UnitType.MPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.MINUTE, UnitType.SECOND]);
/** Meter per second per second. */
UnitType.MPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Foot per minute per second. */
UnitType.FPM_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.MINUTE, UnitType.SECOND]);
/** Foot per second per second. */
UnitType.FPS_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.FOOT], [UnitType.SECOND, UnitType.SECOND]);
/** Knot per second. */
UnitType.KNOT_PER_SEC = new CompoundUnit(UnitFamily.Acceleration, [UnitType.NMILE], [UnitType.HOUR, UnitType.SECOND]);
/** Average gravitational acceleration on Earth at sea level. */
UnitType.G_ACCEL = new CompoundUnit(UnitFamily.Acceleration, [UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);
/** Kilogram per hour. */
UnitType.KGH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.KILOGRAM], [UnitType.HOUR]);
/** Pound per hour. */
UnitType.PPH = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.POUND], [UnitType.HOUR]);
/** Weight equivalent of one liter of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.LPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.LITER_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.GPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.GALLON_FUEL], [UnitType.HOUR]);
/** Weight equivalent of one imperial gallon of fuel per hour, using the generic conversion 1 gallon = 6.7 pounds. */
UnitType.IGPH_FUEL = new CompoundUnit(UnitFamily.WeightFlux, [UnitType.IMP_GALLON_FUEL], [UnitType.HOUR]);
/** Density in slugs per cubic foot */
UnitType.SLUG_PER_FT3 = new CompoundUnit(UnitFamily.Density, [UnitType.SLUG], [UnitType.FOOT, UnitType.FOOT, UnitType.FOOT]);
/** Density in kilograms per cubic meter */
UnitType.KG_PER_M3 = new CompoundUnit(UnitFamily.Density, [UnitType.KILOGRAM], [UnitType.METER, UnitType.METER, UnitType.METER]);
/** Newton. */
UnitType.NEWTON = new CompoundUnit(UnitFamily.Force, [UnitType.KILOGRAM, UnitType.METER], [UnitType.SECOND, UnitType.SECOND]);
/** Pound (force). */
UnitType.POUND_FORCE = new CompoundUnit(UnitFamily.Force, [UnitType.POUND, UnitType.G_METER], [UnitType.SECOND, UnitType.SECOND]);

/**
 * A basic event-bus publisher.
 */
class BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer = undefined) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.publishActive = false;
        this.pacer = pacer;
    }
    /**
     * Start publishing.
     */
    startPublish() {
        this.publishActive = true;
    }
    /**
     * Stop publishing.
     */
    stopPublish() {
        this.publishActive = false;
    }
    /**
     * Tells whether or not the publisher is currently active.
     * @returns True if the publisher is active, false otherwise.
     */
    isPublishing() {
        return this.publishActive;
    }
    /**
     * A callback called when the publisher receives an update cycle.
     */
    onUpdate() {
        return;
    }
    /**
     * Publish a message if publishing is acpive
     * @param topic The topic key to publish to.
     * @param data The data type for chosen topic.
     * @param sync Whether or not the event should be synced to other instruments. Defaults to `false`.
     * @param isCached Whether or not the event should be cached. Defaults to `true`.
     */
    publish(topic, data, sync = false, isCached = true) {
        if (this.publishActive && (!this.pacer || this.pacer.canPublish(topic, data))) {
            this.publisher.pub(topic, data, sync, isCached);
        }
    }
}
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class SimVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.resolvedSimVars = new Map();
        this.indexedSimVars = new Map();
        this.subscribed = new Set();
        for (const [topic, entry] of simVarMap) {
            if (entry.indexed) {
                this.indexedSimVars.set(topic, {
                    name: entry.name,
                    type: entry.type,
                    map: entry.map,
                    indexes: entry.indexed === true ? undefined : new Set(entry.indexed),
                    defaultIndex: entry.defaultIndex,
                });
            }
            else {
                this.resolvedSimVars.set(topic, Object.assign({}, entry));
            }
        }
        const handleSubscribedTopic = (topic) => {
            if (this.resolvedSimVars.has(topic)) {
                // If topic matches an already resolved topic -> start publishing.
                this.onTopicSubscribed(topic);
            }
            else {
                // Check if topic matches indexed topic.
                this.tryMatchIndexedSubscribedTopic(topic);
            }
        };
        // Iterate over each subscribed topic on the bus to see if it matches any of our topics. If so, start publishing.
        this.bus.forEachSubscribedTopic(handleSubscribedTopic);
        // Listen to first-time topic subscriptions. If any of them match our topics, start publishing.
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(handleSubscribedTopic);
    }
    /**
     * Checks if a subscribed topic matches one of this publisher's indexed topics, and if so resolves and starts
     * publishing the indexed topic.
     * @param topic The subscribed topic to check.
     */
    tryMatchIndexedSubscribedTopic(topic) {
        var _a;
        if (this.indexedSimVars.size === 0) {
            return;
        }
        let entry = this.indexedSimVars.get(topic);
        if (entry) {
            // The subscribed topic matches an unsuffixed topic -> check if the unsuffixed topic should be published and if
            // so, resolve the default index.
            if (entry.defaultIndex !== null) {
                const resolved = this.resolveIndexedSimVar(topic, entry, (_a = entry.defaultIndex) !== null && _a !== void 0 ? _a : 1);
                if (resolved !== undefined) {
                    this.onTopicSubscribed(resolved);
                }
            }
            return;
        }
        if (!SimVarPublisher.INDEXED_REGEX.test(topic)) { // Don't generate an array if we don't have to.
            return;
        }
        const match = topic.match(SimVarPublisher.INDEXED_REGEX);
        const [, matchedTopic, index] = match;
        entry = this.indexedSimVars.get(matchedTopic);
        if (entry) {
            const resolved = this.resolveIndexedSimVar(matchedTopic, entry, parseInt(index));
            if (resolved !== undefined) {
                this.onTopicSubscribed(resolved);
            }
        }
    }
    /**
     * Attempts to resolve an indexed topic with an index, generating a version of the topic which is mapped to an
     * indexed simvar. The resolved indexed topic can then be published.
     * @param topic The topic to resolve.
     * @param entry The entry of the topic to resolve.
     * @param index The index with which to resolve the topic. If not defined, the topic will resolve to itself (without
     * a suffix) and will be mapped the index-1 version of its simvar.
     * @returns The resolved indexed topic, or `undefined` if the topic could not be resolved with the specified index.
     */
    resolveIndexedSimVar(topic, entry, index) {
        index !== null && index !== void 0 ? index : (index = 1);
        const resolvedTopic = `${topic}_${index}`;
        if (this.resolvedSimVars.has(resolvedTopic)) {
            return resolvedTopic;
        }
        const defaultIndex = entry.defaultIndex === undefined ? 1 : entry.defaultIndex;
        // Ensure that the index we are trying to resolve is a valid index for the topic.
        if (entry.indexes !== undefined && !entry.indexes.has(index)) {
            return undefined;
        }
        this.resolvedSimVars.set(resolvedTopic, {
            name: entry.name.replace('#index#', `${index !== null && index !== void 0 ? index : 1}`),
            type: entry.type,
            map: entry.map,
            unsuffixedTopic: defaultIndex === index ? topic : undefined
        });
        return resolvedTopic;
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry !== undefined) {
            const value = this.getValueFromEntry(entry);
            this.publish(topic, value);
            // Check if we need to publish the same value to the unsuffixed version of the topic.
            if (entry.unsuffixedTopic) {
                this.publish(entry.unsuffixedTopic, value);
            }
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.resolvedSimVars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return this.getValueFromEntry(entry);
    }
    /**
     * Gets the current value for a resolved topic entry.
     * @param entry An entry for a resolved topic.
     * @returns The current value for the specified entry.
     */
    getValueFromEntry(entry) {
        return entry.map === undefined
            ? this.getSimVarValue(entry)
            : entry.map(this.getSimVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getSimVarValue(entry) {
        const svValue = SimVar.GetSimVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}
SimVarPublisher.INDEXED_REGEX = /(.*)_(0|[1-9]\d*)$/;
/**
 * A base class for publishers that need to handle simvars with built-in
 * support for pacing callbacks.
 */
class GameVarPublisher extends BasePublisher {
    /**
     * Create a SimVarPublisher
     * @param simVarMap A map of simvar event type keys to a SimVarDefinition.
     * @param bus The EventBus to use for publishing.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(simVarMap, bus, pacer) {
        super(bus, pacer);
        this.simvars = simVarMap;
        this.subscribed = new Set();
        // Start polling all simvars for which there are existing subscriptions.
        for (const topic of this.simvars.keys()) {
            if (bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((topic) => {
            if (this.simvars.has(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when one of this publisher's topics is subscribed to for the first time.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        if (this.subscribed.has(topic)) {
            return;
        }
        this.subscribed.add(topic);
        // Immediately publish the current value if publishing is active.
        if (this.publishActive) {
            this.publishTopic(topic);
        }
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    subscribe(data) {
        return;
    }
    /**
     * NOOP - For backwards compatibility.
     * @deprecated
     * @param data Key of the event type in the simVarMap
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    unsubscribe(data) {
        return;
    }
    /**
     * Publish all subscribed data points to the bus.
     */
    onUpdate() {
        for (const topic of this.subscribed.values()) {
            this.publishTopic(topic);
        }
    }
    /**
     * Publishes data to the event bus for a topic.
     * @param topic The topic to publish.
     */
    publishTopic(topic) {
        const value = this.getValue(topic);
        if (value !== undefined) {
            this.publish(topic, value);
        }
    }
    /**
     * Gets the current value for a topic.
     * @param topic A topic.
     * @returns The current value for the specified topic.
     */
    getValue(topic) {
        const entry = this.simvars.get(topic);
        if (entry === undefined) {
            return undefined;
        }
        return entry.map === undefined
            ? this.getGameVarValue(entry)
            : entry.map(this.getGameVarValue(entry));
    }
    /**
     * Gets the value of the SimVar
     * @param entry The SimVar definition entry
     * @returns The value of the SimVar
     */
    getGameVarValue(entry) {
        const svValue = SimVar.GetGameVarValue(entry.name, entry.type);
        if (entry.type === SimVarValueType.Bool) {
            return svValue === 1;
        }
        return svValue;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for air data computer information.
 */
class AdcPublisher extends SimVarPublisher {
    /**
     * Creates an AdcPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['ias', { name: 'AIRSPEED INDICATED:#index#', type: SimVarValueType.Knots, indexed: true }],
            ['tas', { name: 'AIRSPEED TRUE:#index#', type: SimVarValueType.Knots, indexed: true }],
            [
                'mach_to_kias_factor',
                {
                    name: 'AIRSPEED INDICATED:#index#',
                    type: SimVarValueType.Knots,
                    map: (kias) => {
                        const factor = kias < 1 || this.mach === 0 ? AeroMath.machToCas(1, this.pressure) : kias / this.mach;
                        return isFinite(factor) ? factor : 1;
                    },
                    indexed: true
                }
            ],
            ['indicated_alt', { name: 'INDICATED ALTITUDE:#index#', type: SimVarValueType.Feet, indexed: true }],
            ['altimeter_baro_setting_inhg', { name: 'KOHLSMAN SETTING HG:#index#', type: SimVarValueType.InHG, indexed: true }],
            ['altimeter_baro_setting_mb', { name: 'KOHLSMAN SETTING MB:#index#', type: SimVarValueType.MB, indexed: true }],
            ['altimeter_baro_preselect_raw', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, indexed: true }],
            ['altimeter_baro_preselect_inhg', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => UnitType.HPA.convertTo(raw / 16, UnitType.IN_HG), indexed: true }],
            ['altimeter_baro_preselect_mb', { name: 'L:XMLVAR_Baro#index#_SavedPressure', type: SimVarValueType.Number, map: raw => raw / 16, indexed: true }],
            ['altimeter_baro_is_std', { name: 'L:XMLVAR_Baro#index#_ForcedToSTD', type: SimVarValueType.Bool, indexed: true }],
            ['radio_alt', { name: 'RADIO HEIGHT', type: SimVarValueType.Feet }],
            ['pressure_alt', { name: 'PRESSURE ALTITUDE', type: SimVarValueType.Feet }],
            ['vertical_speed', { name: 'VERTICAL SPEED', type: SimVarValueType.FPM }],
            ['ambient_density', { name: 'AMBIENT DENSITY', type: SimVarValueType.SlugsPerCubicFoot }],
            ['ambient_temp_c', { name: 'AMBIENT TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_pressure_inhg', { name: 'AMBIENT PRESSURE', type: SimVarValueType.InHG }],
            ['isa_temp_c', { name: 'STANDARD ATM TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ram_air_temp_c', { name: 'TOTAL AIR TEMPERATURE', type: SimVarValueType.Celsius }],
            ['ambient_wind_velocity', { name: 'AMBIENT WIND VELOCITY', type: SimVarValueType.Knots }],
            ['ambient_wind_direction', { name: 'AMBIENT WIND DIRECTION', type: SimVarValueType.Degree }],
            ['on_ground', { name: 'SIM ON GROUND', type: SimVarValueType.Bool }],
            ['aoa', { name: 'INCIDENCE ALPHA', type: SimVarValueType.Degree }],
            ['stall_aoa', { name: 'STALL ALPHA', type: SimVarValueType.Degree }],
            ['zero_lift_aoa', { name: 'ZERO LIFT ALPHA', type: SimVarValueType.Degree }],
            ['mach_number', { name: 'AIRSPEED MACH', type: SimVarValueType.Mach }],
        ]);
        super(simvars, bus, pacer);
        this.mach = 0;
        this.pressure = 1013.25;
        (_a = this.needUpdateMachToKiasData) !== null && _a !== void 0 ? _a : (this.needUpdateMachToKiasData = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('mach_to_kias_factor')) {
            this.needUpdateMachToKiasData = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        const isSlewing = SimVar.GetSimVarValue('IS SLEW ACTIVE', 'bool');
        if (!isSlewing) {
            if (this.needUpdateMachToKiasData) {
                this.mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number);
                this.pressure = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.HPA);
            }
            super.onUpdate();
        }
    }
}

/**
 * Utility class for manipulating bit flags.
 */
class BitFlags {
    /**
     * Generates a bit flag with a boolean value of true at a specified index.
     * @param index The index of the flag. Must be between 0 and 32, inclusive.
     * @returns a bit flag.
     * @throws Error if index is out of bounds.
     */
    static createFlag(index) {
        if (index < 0 || index > 32) {
            throw new Error(`Invalid index ${index} for bit flag. Index must be between 0 and 32.`);
        }
        return 1 << index;
    }
    /**
     * Gets the inverse of some bit flags.
     * @param flags The bit flag group containing the flags to invert.
     * @param mask An optional bit mask to use when applying the inverse operation. The operation will only be performed
     * at the indexes where the mask has a value of 1 (true). If a mask is not specified, the operation will be performed
     * at all indexes.
     * @returns the inverse
     */
    static not(flags, mask = ~0) {
        return flags ^ mask;
    }
    /**
     * Gets the union of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the union of the bit flags.
     */
    static union(...flags) {
        let result = 0;
        const len = flags.length;
        for (let i = 0; i < len; i++) {
            result |= flags[i];
        }
        return result;
    }
    /**
     * Gets the intersection of zero or more bit flags.
     * @param flags A list of bit flags.
     * @returns the intersection of the bit flags.
     */
    static intersection(...flags) {
        const len = flags.length;
        if (len === 0) {
            return 0;
        }
        let result = flags[0];
        for (let i = 1; i < len; i++) {
            result &= flags[i];
        }
        return result;
    }
    /**
     * Changes a bit flag group by setting values at specific indexes.
     * @param flags The bit flag group to change.
     * @param valuesToSet A bit flag group containing the values to set.
     * @param mask A mask defining the indexes to set. Only indexes at which the mask has a value of `1` (`true`) will
     * be set.
     * @returns The result of changing `flags` using the specified values and indexes.
     */
    static set(flags, valuesToSet, mask) {
        return (flags & ~mask) | (valuesToSet & mask);
    }
    /**
     * Checks if a bit flag group meets at least one condition from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets at least one condition.
     */
    static isAny(flags, conditions) {
        return (flags & conditions) !== 0;
    }
    /**
     * Checks if a bit flag group meets all the conditions from a list of conditions.
     * @param flags A bit flag group.
     * @param conditions The conditions to meet, as a bit flag group.
     * @returns whether the bit flag group meets all the conditions.
     */
    static isAll(flags, conditions) {
        return (flags & conditions) === conditions;
    }
    /**
     * Iterates through a bit flag group and executes a callback function once for each flag.
     * @param flags A bit flag group.
     * @param callback A function which will be called once for each flag.
     * @param valueFilter The value on which to filter. If defined, only flags with values equal to the filter will be
     * iterated, otherwise all flags will be iterated regardless of their values.
     * @param startIndex The index of the flag at which to start (inclusive). Defaults to 0.
     * @param endIndex The index of the flag at which to end (exclusive). Defaults to 32.
     */
    static forEach(flags, callback, valueFilter, startIndex, endIndex) {
        startIndex = Utils.Clamp(startIndex !== null && startIndex !== void 0 ? startIndex : (startIndex = 0), 0, 32);
        endIndex = Utils.Clamp(endIndex !== null && endIndex !== void 0 ? endIndex : (endIndex = 32), 0, 32);
        for (let i = startIndex; i < endIndex; i++) {
            const value = (flags & (1 << i)) !== 0;
            if (valueFilter === undefined || valueFilter === value) {
                callback(value, i, flags);
            }
        }
    }
}

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values.
 *
 * When a new raw value is added to the sequence, it and the last smoothed value are weighted according to the time
 * elapsed since the last smoothed value was calculated (i.e. since the last raw value was added) and averaged. The
 * calculation of the weighting is such that the weight of each raw value in the sequence decays exponentially with the
 * "age" (i.e. time elapsed between when that value was added to the sequence and when the latest value was added to
 * the sequence) of the value.
 */
class ExpSmoother {
    /**
     * Creates a new instance of ExpSmoother.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param initial The initial smoothed value of this smoother. Defaults to null.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, initial = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.dtThreshold = dtThreshold;
        this.lastValue = initial;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or null if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        let next;
        if (this.tau > 0 && this.lastValue !== null) {
            const factor = this.calculateFactor(dt);
            next = ExpSmoother.smooth(raw, this.lastValue, factor);
        }
        else {
            next = raw;
        }
        this.lastValue = next;
        return next;
    }
    /**
     * Calculates the smoothing factor for a given time interval.
     * @param dt A time interval, in seconds.
     * @returns the smoothing factor for the given time interval.
     */
    calculateFactor(dt) {
        if (dt > this.dtThreshold) {
            return 0;
        }
        else {
            return Math.exp(-dt / this.tau);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        return this.lastValue = (value !== null && value !== void 0 ? value : null);
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A calculator for lookahead values based on past trends. The calculator accepts a series of input values separated
 * by discrete time intervals, computes a rate of change at each time step, and uses this rate of change to predict
 * what the input value will be at some arbitrary length of time in the future assuming the rate of change remains
 * constant.
 */
class Lookahead {
    /**
     * Constructor.
     * @param lookahead This calculator's lookahead time.
     * @param valueSmoothingTau The smoothing time constant to apply to the calculator's input values before rate of
     * change is computed. A value of `0` is equivalent to no smoothing. Defaults to `0`.
     * @param trendSmoothingTau The smoothing time constant to apply to the calculator's computed trend values. A value
     * of `0` is equivalent to no smoothing. Defaults to `0`.
     */
    constructor(lookahead, valueSmoothingTau = 0, trendSmoothingTau = 0) {
        this.lookahead = lookahead;
        this.lastSmoothedValue = null;
        this.lastTrendValue = 0;
        this.lastLookaheadValue = null;
        this.lastSmoothedLookaheadValue = null;
        this.valueSmoother = new ExpSmoother(valueSmoothingTau);
        this.trendSmoother = new ExpSmoother(trendSmoothingTau);
    }
    /**
     * Gets this calculator's last computed lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param smoothed Whether to retrieve the lookahead value computed using the last smoothed input value instead of
     * the raw input value as the present (`t = 0`) value. Defaults to `false`.
     * @returns This calculator's last computed lookahead value.
     */
    last(smoothed = false) {
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Gets this calculator's last computed trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @returns This calculator's last computed trend value.
     */
    lastTrend() {
        return this.lastTrendValue;
    }
    /**
     * Adds a new input value and gets the next lookahead value. The lookahead value is the predicted value of this
     * calculator's input when projected into the future by an amount equal to the lookahead time assuming the current
     * rate of change of the input remains constant.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @param smoothed Whether to return the lookahead value computed using the smoothed input value instead of the raw
     * input value as the present (`t = 0`) value. Note that this argument does not determine whether smoothing is
     * applied for the purposes of calculating rate of change (smoothing is always applied for this purpose if a positive
     * time constant is defined). Defaults to `false`.
     * @returns The next lookahead value.
     */
    next(value, dt, smoothed = false) {
        const oldSmoothedValue = this.lastSmoothedValue;
        let trend;
        if (dt < 0) {
            return this.reset(value);
        }
        else if (dt > 0) {
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
            if (oldSmoothedValue === null) {
                this.trendSmoother.reset();
                trend = 0;
            }
            else {
                trend = this.trendSmoother.next((this.lastSmoothedValue - oldSmoothedValue) / dt * this.lookahead, dt);
            }
        }
        else {
            trend = this.lastTrendValue;
            this.lastSmoothedValue = this.valueSmoother.next(value, dt);
        }
        this.lastTrendValue = trend;
        this.lastLookaheadValue = value + trend;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue + trend;
        return smoothed ? this.lastSmoothedLookaheadValue : this.lastLookaheadValue;
    }
    /**
     * Adds a new input value and gets the next trend value. The trend value is the equal to the rate of change of this
     * calculator's input values multiplied by the lookahead time.
     * @param value The new input value.
     * @param dt The elapsed time since the last input value was added.
     * @returns The next trend value.
     */
    nextTrend(value, dt) {
        this.next(value, dt);
        return this.lastTrendValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value) {
        this.lastSmoothedValue = this.valueSmoother.reset(value);
        this.trendSmoother.reset();
        this.lastTrendValue = 0;
        this.lastLookaheadValue = this.lastSmoothedValue;
        this.lastSmoothedLookaheadValue = this.lastSmoothedValue;
        return this.lastLookaheadValue;
    }
}

/**
 * A utitlity class for basic math.
 */
class MathUtils {
    /**
     * Clamps a numerical value to the min/max range.
     * @param value The value to be clamped.
     * @param min The minimum.
     * @param max The maximum.
     *
     * @returns The clamped numerical value..
     */
    static clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }
    /**
     * Rounds a number.
     * @param value The number to round.
     * @param precision The precision with which to round. Defaults to `1`.
     * @returns The rounded number.
     */
    static round(value, precision = 1) {
        return Math.round(value / precision) * precision;
    }
    /**
     * Ceils a number.
     * @param value The number to ceil.
     * @param precision The precision with which to ceil. Defaults to `1`.
     * @returns The ceiled number.
     */
    static ceil(value, precision = 1) {
        return Math.ceil(value / precision) * precision;
    }
    /**
     * Floors a number.
     * @param value The number to floor.
     * @param precision The precision with which to floor. Defaults to `1`.
     * @returns The floored number.
     */
    static floor(value, precision = 1) {
        return Math.floor(value / precision) * precision;
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 2 * pi)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in radians.
     * @param end The ending angle, in radians.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in radians, in the range `[0, 2 * pi)`.
     */
    static diffAngle(start, end, directional = true) {
        const diff = ((end - start) % MathUtils.TWO_PI + MathUtils.TWO_PI) % MathUtils.TWO_PI;
        return directional ? diff : Math.min(diff, MathUtils.TWO_PI - diff);
    }
    /**
     * Calculates the angular difference between two angles in the range `[0, 360)`. The calculation supports both
     * directional and non-directional differences. The directional difference is the angle swept from the start angle
     * to the end angle proceeding in the direction of increasing angle. The non-directional difference is the smaller
     * of the two angles swept from the start angle to the end angle proceeding in either direction.
     * @param start The starting angle, in degrees.
     * @param end The ending angle, in degrees.
     * @param directional Whether to calculate the directional difference. Defaults to `true`.
     * @returns The angular difference between the two angles, in degrees, in the range `[0, 360)`.
     */
    static diffAngleDeg(start, end, directional = true) {
        const diff = ((end - start) % 360 + 360) % 360;
        return directional ? diff : Math.min(diff, 360 - diff);
    }
    /**
     * Linearly interpolates a keyed value along one dimension.
     * @param x The key of the value to interpolate.
     * @param x0 The key of the first known value.
     * @param x1 The key of the second known value.
     * @param y0 The first known value.
     * @param y1 The second known value.
     * @param clampStart Whether to clamp the interpolated value to the first known value. Defaults to false.
     * @param clampEnd Whether to clamp the interpolated value to the second known value. Defaults to false.
     * @returns The interpolated value corresponding to the specified key.
     */
    static lerp(x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        if (x0 !== x1 && y0 !== y1) {
            const fraction = MathUtils.clamp((x - x0) / (x1 - x0), clampStart ? 0 : -Infinity, clampEnd ? 1 : Infinity);
            return fraction * (y1 - y0) + y0;
        }
        else {
            return y0;
        }
    }
    /**
     * Linearly interpolates a keyed vector along one dimension. If the known vectors and the result vector have unequal
     * lengths, then only the components shared by all vectors are interpolated in the result.
     * @param out The object to which to write the result.
     * @param x The key of the vector to interpolate.
     * @param x0 The key of the first known vector.
     * @param x1 The key of the second known vector.
     * @param y0 The first known vector.
     * @param y1 The second known vector.
     * @param clampStart Whether to clamp the components of the interpolated vector to those of the first known vector.
     * Defaults to false.
     * @param clampEnd Whether to clamp the components of the interpolated vector to those of the second known vector.
     * Defaults to false.
     * @returns The interpolated vector corresponding to the specified key.
     */
    static lerpVector(out, x, x0, x1, y0, y1, clampStart = false, clampEnd = false) {
        const length = Math.min(y0.length, y1.length, out.length);
        for (let i = 0; i < length; i++) {
            out[i] = MathUtils.lerp(x, x0, x1, y0[i], y1[i], clampStart, clampEnd);
        }
        return out;
    }
}
/** Twice the value of pi. */
MathUtils.TWO_PI = Math.PI * 2;
/** Half the value of pi. */
MathUtils.HALF_PI = Math.PI / 2;
/** Square root of 3. */
MathUtils.SQRT3 = Math.sqrt(3);
/** Square root of 1/3. */
MathUtils.SQRT1_3 = 1 / Math.sqrt(3);

/**
 * Applies time-weighted exponential smoothing (i.e. an exponential moving average) to a sequence of raw values and
 * optionally uses smoothed estimates of velocity and acceleration to adjust the smooth value to compensate for trends
 * in the raw input values.
 *
 * When a new raw value is added to the sequence, it and the last smoothed value, with optional adjustments derived
 * from estimated velocity and acceleration, are weighted according to the time elapsed since the last smoothed value
 * was calculated (i.e. since the last raw value was added) and averaged. The calculation of the weighting is such that
 * the weight of each raw value in the sequence decays exponentially with the "age" (i.e. time elapsed between when
 * that value was added to the sequence and when the latest value was added to the sequence) of the value. Estimates of
 * velocity and acceleration are also smoothed in the same manner.
 */
class MultiExpSmoother {
    /**
     * Creates a new instance of MultiExpSmoother.
     * @param tau This smoother's time constant. The larger the constant, the greater the smoothing effect. A value less
     * than or equal to 0 is equivalent to no smoothing.
     * @param tauVelocity This smoother's time constant for estimated velocity. The larger the constant, the greater the
     * smoothing effect applied to the estimated velocity. A value less than or equal to 0 is equivalent to no smoothing.
     * If not defined, then this smoother will not estimate velocity.
     * @param tauAccel This smoother's time constant for estimated acceleration. The larger the constant, the greater the
     * smoothing effect applied to the estimated acceleration. A value less than or equal to 0 is equivalent to no
     * smoothing. If this value or {@linkcode tauVelocity} is not defined, then this smoother will not estimate
     * acceleration.
     * @param initial The initial smoothed value of the smoother. Defaults to `null`.
     * @param initialVelocity The initial smoothed velocity estimate of the smoother. Ignored if {@linkcode tauVelocity}
     * is not defined. Defaults to `null`.
     * @param initialAccel The initial smoothed acceleration estimate of the smoother. Ignored if {@linkcode tauVelocity}
     * or {@linkcode tauAccel} is not defined. Defaults to `null`.
     * @param dtThreshold The elapsed time threshold, in seconds, above which this smoother will not smooth a new raw
     * value. Defaults to infinity.
     */
    constructor(tau, tauVelocity, tauAccel, initial = null, initialVelocity = null, initialAccel = null, dtThreshold = Infinity) {
        this.tau = tau;
        this.tauVelocity = tauVelocity;
        this.tauAccel = tauAccel;
        this.dtThreshold = dtThreshold;
        this.lastValue = this.lastRawValue = initial;
        this.lastVel = this.lastRawVel = initialVelocity;
        this.lastAccel = initialAccel;
    }
    /**
     * Gets the last smoothed value.
     * @returns The last smoothed value, or `null` if none exists.
     */
    last() {
        return this.lastValue;
    }
    /**
     * Gets the last smoothed velocity.
     * @returns The last smoothed velocity, or `null` if none exists.
     */
    lastVelocity() {
        return this.lastVel;
    }
    /**
     * Gets the last smoothed acceleration.
     * @returns The last smoothed acceleration, or `null` if none exists.
     */
    lastAcceleration() {
        return this.lastAccel;
    }
    /**
     * Adds a new raw value and gets the next smoothed value. If the new raw value is the first to be added since this
     * smoother was created or reset with no initial smoothed value, the returned smoothed value will be equal to the
     * raw value.
     * @param raw The new raw value.
     * @param dt The elapsed time since the last raw value was added.
     * @returns The next smoothed value.
     */
    next(raw, dt) {
        if (this.tau > 0 && this.lastValue !== null && this.lastRawValue !== null && dt <= this.dtThreshold) {
            const alpha = Math.exp(-dt / this.tau);
            const next = MultiExpSmoother.smooth(raw, this.lastValue + (this.lastVel === null ? 0 : this.lastVel * dt) + (this.lastAccel === null ? 0 : this.lastAccel * 0.5 * dt * dt), alpha);
            if (dt !== 0 && this.tauVelocity !== undefined) {
                let nextVelocity;
                const velocity = (raw - this.lastRawValue) / dt;
                if (this.tauVelocity > 0 && this.lastVel !== null && this.lastRawVel !== null) {
                    const beta = Math.exp(-dt / this.tauVelocity);
                    nextVelocity = MultiExpSmoother.smooth(velocity, this.lastVel + (this.lastAccel === null ? 0 : this.lastAccel * dt), beta);
                    if (this.tauAccel !== undefined) {
                        const acceleration = (velocity - this.lastRawVel) / dt;
                        if (this.tauAccel > 0 && this.lastAccel !== null) {
                            const gamma = Math.exp(-dt / this.tauAccel);
                            this.lastAccel = MultiExpSmoother.smooth(acceleration, this.lastAccel, gamma);
                        }
                        else {
                            this.lastAccel = acceleration;
                        }
                    }
                }
                else {
                    nextVelocity = velocity;
                }
                this.lastRawVel = velocity;
                this.lastVel = nextVelocity;
            }
            this.lastRawValue = raw;
            this.lastValue = next;
            return next;
        }
        else {
            return this.reset(raw);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    reset(value = null, velocity = null, accel = null) {
        this.lastVel = this.lastRawVel = velocity;
        this.lastAccel = accel;
        return this.lastValue = this.lastRawValue = value;
    }
    /**
     * Forecasts the smoothed value into the future based on the most recently calculated smoothed parameters (value,
     * velocity, and acceleration). If velocity or acceleration has not been calculated (or is not part of this
     * smoother's internal model), each will be treated as zero.
     * @param t The time in the future (relative to the last calculated smoothed value) at which to get the
     * forecasted value.
     * @returns The forecast smoothed value at the specified time, or `null` if a smoothed value has not yet been
     * calculated.
     */
    forecast(t) {
        if (this.lastValue === null) {
            return null;
        }
        else {
            return this.lastValue + (this.lastVel === null ? 0 : this.lastVel * t) + (this.lastAccel === null ? 0 : this.lastAccel * 0.5 * t * t);
        }
    }
    /**
     * Applies exponential smoothing.
     * @param value The value to smooth.
     * @param last The last smoothed value.
     * @param factor The smoothing factor.
     * @returns A smoothed value.
     */
    static smooth(value, last, factor) {
        return value * (1 - factor) + last * factor;
    }
}

/**
 * A {@link Subscription} which executes a handler function every time it receives a notification.
 */
class HandlerSubscription {
    /**
     * Constructor.
     * @param handler This subscription's handler. The handler will be called each time this subscription receives a
     * notification from its source.
     * @param initialNotifyFunc A function which sends initial notifications to this subscription. If not defined, this
     * subscription will not support initial notifications.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(handler, initialNotifyFunc, onDestroy) {
        this.handler = handler;
        this.initialNotifyFunc = initialNotifyFunc;
        this.onDestroy = onDestroy;
        this._isAlive = true;
        this._isPaused = false;
        this.canInitialNotify = initialNotifyFunc !== undefined;
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Sends an initial notification to this subscription.
     * @throws Error if this subscription is not alive.
     */
    initialNotify() {
        if (!this._isAlive) {
            throw new Error('HandlerSubscription: cannot notify a dead Subscription.');
        }
        this.initialNotifyFunc && this.initialNotifyFunc(this);
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot pause a dead Subscription.');
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        if (!this._isAlive) {
            throw new Error('Subscription: cannot resume a dead Subscription.');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        if (initialNotify) {
            this.initialNotify();
        }
        return this;
    }
    /** @inheritdoc */
    destroy() {
        if (!this._isAlive) {
            return;
        }
        this._isAlive = false;
        this.onDestroy && this.onDestroy(this);
    }
}

/**
 * A pipe from an input subscribable to an output mutable subscribable. Each notification received by the pipe is used
 * to change the state of the output subscribable.
 */
class SubscribablePipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let onDestroy;
        if (typeof arg4 === 'function') {
            handler = (fromVal) => {
                to.set(arg3(fromVal, to.get()));
            };
            onDestroy = arg4;
        }
        else {
            handler = (fromVal) => {
                to.set(fromVal);
            };
            onDestroy = arg3;
        }
        super(handler, (sub) => { sub.handler(from.get()); }, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribable {
    constructor() {
        this.isSubscribable = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this subscribable.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subscribable's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.notifySubscription(this.singletonSub);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribable: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        this.notifySubscription(sub);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribable: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this subscribable's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.get());
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        return new MappedSubscribableClass(this, fn, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc, initialVal);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}
/**
 * Checks if two values are equal using the strict equality operator.
 * @param a The first value.
 * @param b The second value.
 * @returns whether a and b are equal.
 */
AbstractSubscribable.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;
/**
 * An implementation of {@link MappedSubscribable}.
 */
class MappedSubscribableClass extends AbstractSubscribable {
    /**
     * Constructor.
     * @param input This subscribable's input.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     */
    constructor(input, mapFunc, equalityFunc, mutateFunc, initialVal) {
        super();
        this.input = input;
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.input.get()));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.input.get());
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSub = this.input.sub(inputValue => {
            this.updateValue(inputValue);
        }, true);
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     * @param inputValue The input value.
     */
    updateValue(inputValue) {
        const value = this.mapFunc(inputValue, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot pause a dead subscribable');
        }
        if (this._isPaused) {
            return this;
        }
        this.inputSub.pause();
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubscribable: cannot resume a dead subscribable');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        this.inputSub.resume(true);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        this.inputSub.destroy();
    }
}

/**
 * A subscribable subject whose value can be freely manipulated.
 */
class Subject extends AbstractSubscribable {
    /**
     * Constructs an observable Subject.
     * @param value The initial value.
     * @param equalityFunc The function to use to check for equality.
     * @param mutateFunc The function to use to mutate the subject's value.
     */
    constructor(value, equalityFunc, mutateFunc) {
        super();
        this.value = value;
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.isMutableSubscribable = true;
    }
    /**
     * Creates and returns a new Subject.
     * @param v The initial value of the subject.
     * @param equalityFunc The function to use to check for equality between subject values. Defaults to the strict
     * equality comparison (`===`).
     * @param mutateFunc The function to use to change the subject's value. If not defined, new values will replace
     * old values by variable assignment.
     * @returns A Subject instance.
     */
    static create(v, equalityFunc, mutateFunc) {
        return new Subject(v, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : Subject.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /** @inheritdoc */
    notifySub(sub) {
        sub(this.value);
    }
    /**
     * Sets the value of this subject and notifies subscribers if the value changed.
     * @param value The new value.
     */
    set(value) {
        if (!this.equalityFunc(value, this.value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Applies a partial set of properties to this subject's value and notifies subscribers if the value changed as a
     * result.
     * @param value The properties to apply.
     */
    apply(value) {
        let changed = false;
        for (const prop in value) {
            changed = value[prop] !== this.value[prop];
            if (changed) {
                break;
            }
        }
        Object.assign(this.value, value);
        changed && this.notify();
    }
    /** @inheritdoc */
    notify() {
        super.notify();
    }
    /**
     * Gets the value of this subject.
     * @returns The value of this subject.
     */
    get() {
        return this.value;
    }
}

/**
 * Utility methods for working with Subscribables.
 */
class SubscribableUtils {
    /**
     * Checks if a query is a subscribable.
     * @param query A query.
     * @returns Whether the query is a subscribable.
     */
    static isSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isSubscribable === true;
    }
    /**
     * Checks if a query is a mutable subscribable.
     * @param query A query.
     * @returns Whether the query is a mutable subscribable.
     */
    static isMutableSubscribable(query) {
        return typeof query === 'object' && query !== null && query.isMutableSubscribable === true;
    }
    /**
     * Converts a value to a subscribable.
     *
     * If the `excludeSubscribables` argument is `true` and the value is already a subscribable, then the value is
     * returned unchanged. Otherwise, a new subscribable whose state is always equal to the value will be created and
     * returned.
     * @param value The value to convert to a subscribable.
     * @param excludeSubscribables Whether to return subscribable values as-is instead of wrapping them in another
     * subscribable.
     * @returns A subscribable.
     */
    static toSubscribable(value, excludeSubscribables) {
        if (excludeSubscribables && SubscribableUtils.isSubscribable(value)) {
            return value;
        }
        else {
            return Subject.create(value);
        }
    }
}
/**
 * A numeric equality function which returns `true` if and only if two numbers are strictly equal or if they are both
 * `NaN`.
 * @param a The first number to compare.
 * @param b The second number to compare.
 * @returns Whether the two numbers are strictly equal or both `NaN`.
 */
SubscribableUtils.NUMERIC_NAN_EQUALITY = (a, b) => a === b || (isNaN(a) && isNaN(b));

/**
 * Utility class for generating common functions for mapping subscribables.
 */
class SubscribableMapFunctions {
    /**
     * Generates a function which maps an input to itself.
     * @returns A function which maps an input to itself.
     */
    static identity() {
        return (input) => input;
    }
    /**
     * Generates a function which maps an input boolean to its negation.
     * @returns A function which maps an input boolean to its negation.
     */
    static not() {
        return (input) => !input;
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if at least one tuple member is `true` and to
     * `false` otherwise.
     */
    static or() {
        return (input) => input.length > 0 && input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if no tuple member is `true` and to
     * `false` otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if no tuple member is `true` or there are no
     * tuple members, and to `false` otherwise.
     */
    static nor() {
        return (input) => !input.includes(true);
    }
    /**
     * Generates a function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `false`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static and() {
        return (input) => input.length > 0 && !input.includes(false);
    }
    /**
     * Generates a function which maps an input boolean tuple to `false` if all tuple members are `true` and to `false`
     * otherwise. A zero-length tuple is mapped to `true`.
     * @returns A function which maps an input boolean tuple to `true` if all tuple members are `true` and to `false`
     * otherwise.
     */
    static nand() {
        return (input) => input.length < 1 || input.includes(false);
    }
    /**
     * Generates a function which maps an input number to its negation.
     * @returns A function which maps an input number to its negation.
     */
    static negate() {
        return (input) => -input;
    }
    /**
     * Generates a function which maps an input number to its absolute value.
     * @returns A function which maps an input number to its absolute value.
     */
    static abs() {
        return Math.abs;
    }
    /**
     * Generates a function which maps an input number to a rounded version of itself at a certain precision.
     * @param precision The precision to which to round the input.
     * @returns A function which maps an input number to a rounded version of itself at the specified precision.
     */
    static withPrecision(precision) {
        return SubscribableUtils.isSubscribable(precision)
            ? (input) => {
                const precisionVal = precision.get();
                return Math.round(input / precisionVal) * precisionVal;
            }
            : (input) => {
                return Math.round(input / precision) * precision;
            };
    }
    /**
     * Generates a function which maps an input number to itself if and only if it differs from the previous mapped value
     * by a certain amount, and to the previous mapped value otherwise.
     * @param threshold The minimum difference between the input and the previous mapped value required to map the input
     * to itself.
     * @returns A function which maps an input number to itself if and only if it differs from the previous mapped value
     * by the specified amount, and to the previous mapped value otherwise.
     */
    static changedBy(threshold) {
        return SubscribableUtils.isSubscribable(threshold)
            ? (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold.get() ? input : currentVal
            : (input, currentVal) => currentVal === undefined || Math.abs(input - currentVal) >= threshold ? input : currentVal;
    }
    /**
     * Generates a function which maps an input number to itself up to a maximum frequency, and to the previous mapped
     * value otherwise.
     * @param freq The maximum frequency at which to map the input to itself, in hertz.
     * @param timeFunc A function which gets the current time in milliseconds. Defaults to `Date.now()`.
     * @returns A function which maps an input number to itself up to the specified maximum frequency, and to the
     * previous mapped value otherwise.
     */
    static atFrequency(freq, timeFunc = Date.now) {
        let t0;
        let timeRemaining = 0;
        if (SubscribableUtils.isSubscribable(freq)) {
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    const period = 1000 / freq.get();
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
        else {
            const period = 1000 / freq;
            return (input, currentVal) => {
                let returnValue = currentVal !== null && currentVal !== void 0 ? currentVal : input;
                const currentTime = timeFunc();
                const dt = currentTime - (t0 !== null && t0 !== void 0 ? t0 : (t0 = currentTime));
                t0 = currentTime;
                timeRemaining -= dt;
                if (timeRemaining <= 0) {
                    timeRemaining = period + timeRemaining % period;
                    returnValue = input;
                }
                return returnValue;
            };
        }
    }
}

/**
 * A subscribable subject that is a mapped stream from one or more input subscribables.
 */
class MappedSubject extends AbstractSubscribable {
    /**
     * Creates a new MappedSubject.
     * @param mapFunc The function which maps this subject's inputs to a value.
     * @param equalityFunc The function which this subject uses to check for equality between values.
     * @param mutateFunc The function which this subject uses to change its value.
     * @param initialVal The initial value of this subject.
     * @param inputs The subscribables which provide the inputs to this subject.
     */
    constructor(mapFunc, equalityFunc, mutateFunc, initialVal, ...inputs) {
        super();
        this.mapFunc = mapFunc;
        this.equalityFunc = equalityFunc;
        this.isSubscribable = true;
        this._isAlive = true;
        this._isPaused = false;
        this.inputs = inputs;
        this.inputValues = inputs.map(input => input.get());
        if (initialVal && mutateFunc) {
            this.value = initialVal;
            mutateFunc(this.value, this.mapFunc(this.inputValues, undefined));
            this.mutateFunc = (newVal) => { mutateFunc(this.value, newVal); };
        }
        else {
            this.value = this.mapFunc(this.inputValues, undefined);
            this.mutateFunc = (newVal) => { this.value = newVal; };
        }
        this.inputSubs = this.inputs.map((input, index) => input.sub(inputValue => {
            this.inputValues[index] = inputValue;
            this.updateValue();
        }));
    }
    /** @inheritdoc */
    get isAlive() {
        return this._isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(...args) {
        let mapFunc, equalityFunc, mutateFunc, initialVal;
        if (typeof args[0] === 'function') {
            // Mapping function was supplied.
            mapFunc = args.shift();
            if (typeof args[0] === 'function') {
                equalityFunc = args.shift();
            }
            else {
                equalityFunc = AbstractSubscribable.DEFAULT_EQUALITY_FUNC;
            }
            if (typeof args[0] === 'function') {
                mutateFunc = args.shift();
                initialVal = args.shift();
            }
        }
        else {
            mapFunc = MappedSubject.IDENTITY_MAP;
            equalityFunc = MappedSubject.NEVER_EQUALS;
        }
        return new MappedSubject(mapFunc, equalityFunc, mutateFunc, initialVal, ...args);
    }
    /**
     * Re-maps this subject's value from its input, and notifies subscribers if this results in a change to the mapped
     * value according to this subject's equality function.
     */
    updateValue() {
        const value = this.mapFunc(this.inputValues, this.value);
        if (!this.equalityFunc(this.value, value)) {
            this.mutateFunc(value);
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /** @inheritdoc */
    pause() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot pause a dead subject');
        }
        if (this._isPaused) {
            return this;
        }
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].pause();
        }
        this._isPaused = true;
        return this;
    }
    /** @inheritdoc */
    resume() {
        if (!this._isAlive) {
            throw new Error('MappedSubject: cannot resume a dead subject');
        }
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputValues[i] = this.inputs[i].get();
            this.inputSubs[i].resume();
        }
        this.updateValue();
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this._isAlive = false;
        for (let i = 0; i < this.inputSubs.length; i++) {
            this.inputSubs[i].destroy();
        }
    }
}
MappedSubject.IDENTITY_MAP = SubscribableMapFunctions.identity();
MappedSubject.NEVER_EQUALS = () => false;

/**
 * A Subject which provides a {@link NumberUnitInterface} value.
 */
class NumberUnitSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     */
    static create(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /**
     * Creates a NumberUnitSubject.
     * @param initialVal The initial value.
     * @returns A NumberUnitSubject.
     * @deprecated Use `NumberUnitSubject.create()` instead.
     */
    static createFromNumberUnit(initialVal) {
        return new NumberUnitSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2) : this.value.equals(arg1);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
    /**
     * Returns a number {@link Subscribable} of this `NumberUnit` converted according to a unit or unit `Subscribable`
     *
     * @param unit the unit to subscribe to
     *
     * @returns a `MappedSubscribable<number>`
     */
    asUnit(unit) {
        return MappedSubject.create(([numberUnit, toUnit]) => numberUnit.asUnit(toUnit), this, SubscribableUtils.toSubscribable(unit, true));
    }
}

/**
 * A utitlity class for calculating a numerical average of a selected number of samples.
 */
class SimpleMovingAverage {
    /**
     * Class to return a numerical average from a specified number of inputs.
     * @param samples is the number of samples.
     */
    constructor(samples) {
        this.samples = samples;
        this._values = [];
    }
    /**
     * Returns a numerical average of the inputs.
     * @param input is the input number.
     * @returns The numerical average.
     */
    getAverage(input) {
        if (this._values.length === this.samples) {
            this._values.splice(0, 1);
        }
        this._values.push(input);
        let sum = 0;
        this._values.forEach((v) => {
            sum += v;
        });
        return sum / this._values.length;
    }
    /**
     * Resets the average.
     */
    reset() {
        this._values = [];
    }
}

/**
 * 2D vector mathematical operations.
 */
class Vec2Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y) {
        const vec = new Float64Array(2);
        if (x !== undefined && y !== undefined) {
            vec[0] = x;
            vec[1] = y;
        }
        return vec;
    }
    /**
     * Gets the polar angle theta of a vector in radians.
     * @param vec - a vector.
     * @returns the polar angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x - the new x-component.
     * @param y - the new y-component.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static set(x, y, vec) {
        vec[0] = x;
        vec[1] = y;
        return vec;
    }
    /**
     * Sets the polar components of a vector.
     * @param r - the new length (magnitude).
     * @param theta - the new polar angle theta, in radians.
     * @param vec - the vector to change.
     * @returns the vector after it has been changed.
     */
    static setFromPolar(r, theta, vec) {
        vec[0] = r * Math.cos(theta);
        vec[1] = r * Math.sin(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1];
    }
    /**
     * Gets the determinant of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The determinant of the vectors.
     */
    static det(v1, v2) {
        return v1[0] * v2[1] - v1[1] * v2[0];
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec2Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        return out;
    }
    /**
     * Gets the normal of the supplied vector.
     * @param v1 The vector to get the normal for.
     * @param out The vector to write the results to.
     * @param counterClockwise Whether or not to get the counterclockwise normal.
     * @returns the normal vector.
     */
    static normal(v1, out, counterClockwise = false) {
        const x = v1[0];
        const y = v1[1];
        if (!counterClockwise) {
            out[0] = y;
            out[1] = -x;
        }
        else {
            out[0] = -y;
            out[1] = x;
        }
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[1]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     */
    static copy(from, to) {
        return Vec2Math.set(from[0], from[1], to);
    }
    /**
     * Checks if a point is within a polygon.
     * @param polygon The polygon to check against.
     * @param point The point to test.
     * @returns True if the point is within or on the polygon, false otherwise.
     * @throws An error if first and last points in a polygon are not the same.
     */
    static pointWithinPolygon(polygon, point) {
        //Adapted from https://github.com/rowanwins/point-in-polygon-hao
        let k = 0;
        let f = 0;
        let u1 = 0;
        let v1 = 0;
        let u2 = 0;
        let v2 = 0;
        let currentP = null;
        let nextP = null;
        const x = point[0];
        const y = point[1];
        const contourLen = polygon.length - 1;
        currentP = polygon[0];
        if (currentP[0] !== polygon[contourLen][0] &&
            currentP[1] !== polygon[contourLen][1]) {
            throw new Error('First and last coordinates in a ring must be the same');
        }
        u1 = currentP[0] - x;
        v1 = currentP[1] - y;
        for (let i = 0; i < polygon.length - 1; i++) {
            nextP = polygon[i + 1];
            v2 = nextP[1] - y;
            if ((v1 < 0 && v2 < 0) || (v1 > 0 && v2 > 0)) {
                currentP = nextP;
                v1 = v2;
                u1 = currentP[0] - x;
                continue;
            }
            u2 = nextP[0] - point[0];
            if (v2 > 0 && v1 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f > 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 > 0 && v2 <= 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f < 0) {
                    k = k + 1;
                }
                else if (f === 0) {
                    return undefined;
                }
            }
            else if (v2 === 0 && v1 < 0) {
                f = (u1 * v2) - (u2 * v1);
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 < 0) {
                f = u1 * v2 - u2 * v1;
                if (f === 0) {
                    return undefined;
                }
            }
            else if (v1 === 0 && v2 === 0) {
                if (u2 <= 0 && u1 >= 0) {
                    return undefined;
                }
                else if (u1 <= 0 && u2 >= 0) {
                    return undefined;
                }
            }
            currentP = nextP;
            v1 = v2;
            u1 = u2;
        }
        if (k % 2 === 0) {
            return false;
        }
        return true;
    }
}
/**
 * 3D vector mathematical operations.
 */
class Vec3Math {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(x, y, z) {
        const vec = new Float64Array(3);
        if (x !== undefined && y !== undefined && z !== undefined) {
            vec[0] = x;
            vec[1] = y;
            vec[2] = z;
        }
        return vec;
    }
    /**
     * Gets the spherical angle theta (polar angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle theta of the vector.
     */
    static theta(vec) {
        return Math.atan2(Math.hypot(vec[0], vec[1]), vec[2]);
    }
    /**
     * Gets the spherical angle phi (azimuthal angle) of a vector in radians.
     * @param vec A vector.
     * @returns The spherical angle phi of the vector.
     */
    static phi(vec) {
        return Math.atan2(vec[1], vec[0]);
    }
    /**
     * Sets the components of a vector.
     * @param x The new x-component.
     * @param y The new y-component.
     * @param z The new z-component.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static set(x, y, z, vec) {
        vec[0] = x;
        vec[1] = y;
        vec[2] = z;
        return vec;
    }
    /**
     * Sets the spherical components of a vector.
     * @param r The new length (magnitude).
     * @param theta The new spherical angle theta (polar angle), in radians.
     * @param phi The new spherical angle phi (azimuthal angle), in radians.
     * @param vec The vector to change.
     * @returns The vector after it has been changed.
     */
    static setFromSpherical(r, theta, phi, vec) {
        const sinTheta = Math.sin(theta);
        vec[0] = r * sinTheta * Math.cos(phi);
        vec[1] = r * sinTheta * Math.sin(phi);
        vec[2] = r * Math.cos(theta);
        return vec;
    }
    /**
     * Add one vector to another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector sum.
     */
    static add(v1, v2, out) {
        out[0] = v1[0] + v2[0];
        out[1] = v1[1] + v2[1];
        out[2] = v1[2] + v2[2];
        return out;
    }
    /**
     * Subtracts one vector from another.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @param out The vector to write the results to.
     * @returns the vector difference.
     */
    static sub(v1, v2, out) {
        out[0] = v1[0] - v2[0];
        out[1] = v1[1] - v2[1];
        out[2] = v1[2] - v2[2];
        return out;
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     */
    static dot(v1, v2) {
        return v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
    }
    /**
     * Gets the cross product of two vectors.
     * @param v1 - the first vector.
     * @param v2 - the second vector.
     * @param out - the vector to which to write the result.
     * @returns the cross product.
     */
    static cross(v1, v2, out) {
        const x1 = v1[0];
        const y1 = v1[1];
        const z1 = v1[2];
        const x2 = v2[0];
        const y2 = v2[1];
        const z2 = v2[2];
        out[0] = y1 * z2 - z1 * y2;
        out[1] = z1 * x2 - x1 * z2;
        out[2] = x1 * y2 - y1 * x2;
        return out;
    }
    /**
     * Multiplies a vector by a scalar.
     * @param v1 The vector to multiply.
     * @param scalar The scalar to apply.
     * @param out The vector to write the results to.
     * @returns The scaled vector.
     */
    static multScalar(v1, scalar, out) {
        out[0] = v1[0] * scalar;
        out[1] = v1[1] * scalar;
        out[2] = v1[2] * scalar;
        return out;
    }
    /**
     * Gets the magnitude of a vector.
     * @param v1 The vector to get the magnitude for.
     * @returns the vector's magnitude.
     */
    static abs(v1) {
        return Math.hypot(v1[0], v1[1], v1[2]);
    }
    /**
     * Normalizes the vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns the normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        out[0] = v1[0] / mag;
        out[1] = v1[1] / mag;
        out[2] = v1[2] / mag;
        return out;
    }
    /**
     * Gets the Euclidean distance between two vectors.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns the Euclidean distance between the two vectors.
     */
    static distance(vec1, vec2) {
        return Math.hypot(vec2[0] - vec1[0], vec2[1] - vec1[0], vec2[2] - vec1[2]);
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        return vec1[0] === vec2[0] && vec1[1] === vec2[1] && vec1[2] === vec2[2];
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        return isFinite(vec[0]) && isFinite(vec[1]) && isFinite(vec[2]);
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns the changed vector.
     */
    static copy(from, to) {
        return Vec3Math.set(from[0], from[1], from[2], to);
    }
}
/**
 * N-dimensional vector mathematical operations.
 */
class VecNMath {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(length, ...components) {
        const vec = new Float64Array(length);
        for (let i = 0; i < length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Sets the components of a vector.
     * @param vec The vector to change.
     * @param components The new components.
     * @returns The vector after it has been changed.
     */
    static set(vec, ...components) {
        for (let i = 0; i < vec.length && components.length; i++) {
            vec[i] = components[i];
        }
        return vec;
    }
    /**
     * Gets the magnitude of a vector.
     * @param vec The vector to get the magnitude for.
     * @returns The vector's magnitude.
     */
    static abs(vec) {
        return Math.hypot(...vec);
    }
    /**
     * Gets the dot product of two vectors.
     * @param v1 The first vector.
     * @param v2 The second vector.
     * @returns The dot product of the vectors.
     * @throws Error if the two vectors are of unequal lengths.
     */
    static dot(v1, v2) {
        if (v1.length !== v2.length) {
            throw new Error(`VecNMath: cannot compute dot product of two vectors of unequal length (${v1.length} and ${v2.length})`);
        }
        let dot = 0;
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            dot += v1[i] * v2[i];
        }
        return dot;
    }
    /**
     * Normalizes a vector to a unit vector.
     * @param v1 The vector to normalize.
     * @param out The vector to write the results to.
     * @returns The normalized vector.
     */
    static normalize(v1, out) {
        const mag = Vec3Math.abs(v1);
        const len = v1.length;
        for (let i = 0; i < len; i++) {
            out[i] = v1[i] / mag;
        }
        return out;
    }
    /**
     * Checks if two vectors are equal.
     * @param vec1 The first vector.
     * @param vec2 The second vector.
     * @returns Whether the two vectors are equal.
     */
    static equals(vec1, vec2) {
        if (vec1.length !== vec2.length) {
            return false;
        }
        for (let i = 0; i < vec1.length; i++) {
            if (vec1[i] !== vec2[i]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Checks if a vector is finite. A vector is considered finite if all of its components are finite.
     * @param vec The vector to check.
     * @returns Whether the specified vector is finite.
     */
    static isFinite(vec) {
        for (let i = 0; i < vec.length; i++) {
            if (!isFinite(vec[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Copies one vector to another.
     * @param from The vector from which to copy.
     * @param to The vector to which to copy.
     * @returns The changed vector.
     * @throws Error if the vectors are of unequal lengths.
     */
    static copy(from, to) {
        if (from.length !== to.length) {
            throw new Error(`VecNMath: cannot copy a vector of length ${from.length} to a vector of length ${to.length}`);
        }
        to.set(from);
        return to;
    }
}

/**
 * A Subject which allows a 2D vector to be observed.
 */
class Vec2Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     */
    static create(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /**
     * Creates a Vec2Subject.
     * @param initialVal The initial value.
     * @returns A Vec2Subject.
     * @deprecated Use `Vec2Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec2Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let x, y;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
        }
        else {
            x = arg1[0];
            y = arg1[1];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0]) && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1]);
        if (!equals) {
            Vec2Math.set(x, y, this.value);
            this.notify();
        }
    }
}
/**
 * A Subject which allows a 3D vector to be observed.
 */
class Vec3Subject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     */
    constructor(value) {
        super();
        this.value = value;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     */
    static create(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /**
     * Creates a Vec3Subject.
     * @param initialVal The initial value.
     * @returns A Vec3Subject.
     * @deprecated Use `Vec3Subject.create()` instead.
     */
    static createFromVector(initialVal) {
        return new Vec3Subject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2, arg3) {
        let x, y, z;
        if (typeof arg1 === 'number') {
            x = arg1;
            y = arg2;
            z = arg3;
        }
        else {
            x = arg1[0];
            y = arg1[1];
            z = arg1[2];
        }
        const equals = SubscribableUtils.NUMERIC_NAN_EQUALITY(x, this.value[0])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(y, this.value[1])
            && SubscribableUtils.NUMERIC_NAN_EQUALITY(z, this.value[2]);
        if (!equals) {
            Vec3Math.set(x, y, z, this.value);
            this.notify();
        }
    }
}

/**
 * A read-only wrapper for a GeoPoint.
 */
class GeoPointReadOnly {
    /**
     * Constructor.
     * @param source - the source of the new read-only point.
     */
    constructor(source) {
        this.source = source;
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this.source.lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this.source.lon;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distance(arg1, arg2);
        }
        else {
            return this.source.distance(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.distanceRhumb(arg1, arg2);
        }
        else {
            return this.source.distanceRhumb(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingTo(arg1, arg2);
        }
        else {
            return this.source.bearingTo(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingFrom(arg1, arg2);
        }
        else {
            return this.source.bearingFrom(arg1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return this.source.bearingRhumb(arg1, arg2);
        }
        else {
            return this.source.bearingRhumb(arg1);
        }
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offset(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offset(bearing, distance, out);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. If not supplied, a new GeoPoint object is created.
     * @returns The offset point.
     * @throws Error if argument `out` is undefined.
     */
    offsetRhumb(bearing, distance, out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.offsetRhumb(bearing, distance, out);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint ot which to write the result.
     * @returns The antipode of this point.
     * @throws Error if argument `out` is undefined.
     */
    antipode(out) {
        if (!out) {
            throw new Error('Cannot mutate a read-only GeoPoint.');
        }
        return this.source.antipode(out);
    }
    /**
     * Calculates the cartesian (x, y, z) representation of this point, in units of great-arc radians. By convention,
     * in the cartesian coordinate system the origin is at the center of the Earth, the positive x-axis passes through
     * 0 degrees N, 0 degrees E, and the positive z-axis passes through the north pole.
     * @param out The vector array to which to write the result.
     * @returns The cartesian representation of this point.
     */
    toCartesian(out) {
        return this.source.toCartesian(out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return this.source.equals(arg1, arg2, arg3);
        }
        else {
            return this.source.equals(arg1, arg2);
        }
    }
    /** @inheritdoc */
    copy(to) {
        return this.source.copy(to);
    }
}
/**
 * A point on Earth's surface. This class uses a spherical Earth model.
 */
class GeoPoint {
    /**
     * Constructor.
     * @param lat The latitude, in degrees.
     * @param lon The longitude, in degrees.
     */
    constructor(lat, lon) {
        this._lat = 0;
        this._lon = 0;
        this.set(lat, lon);
        this.readonly = new GeoPointReadOnly(this);
    }
    /**
     * The latitude of this point, in degrees.
     * @returns the latitude of this point.
     */
    get lat() {
        return this._lat;
    }
    /**
     * The longitude of this point, in degrees.
     * @returns the longitude of this point.
     */
    get lon() {
        return this._lon;
    }
    /**
     * Converts an argument list consisting of either a LatLonInterface or lat/lon coordinates into an equivalent
     * LatLonInterface.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @returns A LatLonInterface.
     */
    static asLatLonInterface(arg1, arg2) {
        if (typeof arg1 === 'number') {
            return GeoPoint.tempGeoPoint.set(arg1, arg2);
        }
        else {
            return arg1;
        }
    }
    /**
     * Converts an argument list consisting of either a 3D vector or x, y, z components into an equivalent 3D vector.
     * @param arg1 Argument 1.
     * @param arg2 Argument 2.
     * @param arg3 Argument 3.
     * @returns A 3D vector.
     */
    static asVec3(arg1, arg2, arg3) {
        if (typeof arg1 === 'number') {
            return Vec3Math.set(arg1, arg2, arg3, GeoPoint.tempVec3);
        }
        else {
            return arg1;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        lat = GeoPoint.toPlusMinus180(lat);
        lon = GeoPoint.toPlusMinus180(lon);
        if (Math.abs(lat) > 90) {
            lat = 180 - lat;
            lat = GeoPoint.toPlusMinus180(lat);
            lon += 180;
            lon = GeoPoint.toPlusMinus180(lon);
        }
        this._lat = lat;
        this._lon = lon;
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setFromCartesian(arg1, arg2, arg3) {
        const vec = GeoPoint.asVec3(arg1, arg2, arg3);
        const theta = Vec3Math.theta(vec);
        const phi = Vec3Math.phi(vec);
        return this.set(90 - theta * Avionics.Utils.RAD2DEG, phi * Avionics.Utils.RAD2DEG);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distance(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distance(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    distanceRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.distanceRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingTo(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.initialBearing(this.lat, this.lon, other.lat, other.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingFrom(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.finalBearing(other.lat, other.lon, this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    bearingRhumb(arg1, arg2) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        return GeoPoint.bearingRhumb(this.lat, this.lon, other.lat, other.lon);
    }
    /**
     * Offsets this point by an initial bearing and distance along a great circle.
     * @param bearing The initial true bearing (forward azimuth), in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offset(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(latRad);
        const cosLat = Math.cos(latRad);
        const sinBearing = Math.sin(bearing * Avionics.Utils.DEG2RAD);
        const cosBearing = Math.cos(bearing * Avionics.Utils.DEG2RAD);
        const angularDistance = distance;
        const sinAngularDistance = Math.sin(angularDistance);
        const cosAngularDistance = Math.cos(angularDistance);
        const offsetLatRad = Math.asin(sinLat * cosAngularDistance + cosLat * sinAngularDistance * cosBearing);
        const offsetLonDeltaRad = Math.atan2(sinBearing * sinAngularDistance * cosLat, cosAngularDistance - sinLat * Math.sin(offsetLatRad));
        const offsetLat = offsetLatRad * Avionics.Utils.RAD2DEG;
        const offsetLon = (lonRad + offsetLonDeltaRad) * Avionics.Utils.RAD2DEG;
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Offsets this point by a constant bearing and distance along a rhumb line.
     * @param bearing The true bearing, in degrees, by which to offset.
     * @param distance The distance, in great-arc radians, by which to offset.
     * @param out The GeoPoint to which to write the result. By default this point.
     * @returns The offset point.
     */
    offsetRhumb(bearing, distance, out) {
        const latRad = this.lat * Avionics.Utils.DEG2RAD;
        const lonRad = this.lon * Avionics.Utils.DEG2RAD;
        const bearingRad = bearing * Avionics.Utils.DEG2RAD;
        const deltaLat = distance * Math.cos(bearingRad);
        let offsetLat = latRad + deltaLat;
        let offsetLon;
        if (Math.abs(offsetLat) >= Math.PI / 2) {
            // you can't technically go past the poles along a rhumb line, so we will simply terminate the path at the pole
            offsetLat = Math.sign(offsetLat) * 90;
            offsetLon = 0; // since longitude is meaningless at the poles, we'll arbitrarily pick a longitude of 0 degrees.
        }
        else {
            const deltaPsi = GeoPoint.deltaPsi(latRad, offsetLat);
            const correction = GeoPoint.rhumbCorrection(deltaPsi, latRad, offsetLat);
            const deltaLon = distance * Math.sin(bearingRad) / correction;
            offsetLon = lonRad + deltaLon;
            offsetLat *= Avionics.Utils.RAD2DEG;
            offsetLon *= Avionics.Utils.RAD2DEG;
        }
        return (out !== null && out !== void 0 ? out : this).set(offsetLat, offsetLon);
    }
    /**
     * Gets the antipode of this point.
     * @param out The GeoPoint to which to write the results. By default this point.
     * @returns The antipode of this point.
     */
    antipode(out) {
        return (out !== null && out !== void 0 ? out : this).set(-this._lat, this._lon + 180);
    }
    /** @inheritdoc */
    toCartesian(out) {
        return GeoPoint.sphericalToCartesian(this, out);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    equals(arg1, arg2, arg3) {
        const other = GeoPoint.asLatLonInterface(arg1, arg2);
        if (other) {
            if (isNaN(this._lat) && isNaN(this._lon) && isNaN(other.lat) && isNaN(other.lon)) {
                return true;
            }
            const tolerance = typeof arg1 === 'number' ? arg3 : arg2;
            const distance = this.distance(other);
            return !isNaN(distance) && distance <= (tolerance !== null && tolerance !== void 0 ? tolerance : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return false;
        }
    }
    /** @inheritdoc */
    copy(to) {
        return to ? to.set(this.lat, this.lon) : new GeoPoint(this.lat, this.lon);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static sphericalToCartesian(arg1, arg2, arg3) {
        const point = GeoPoint.asLatLonInterface(arg1, arg2);
        const theta = (90 - point.lat) * Avionics.Utils.DEG2RAD;
        const phi = point.lon * Avionics.Utils.DEG2RAD;
        return Vec3Math.setFromSpherical(1, theta, phi, arg3 !== null && arg3 !== void 0 ? arg3 : arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static equals(arg1, arg2, arg3, arg4, arg5) {
        if (arg1 instanceof Float64Array) {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else if (typeof arg1 === 'number') {
            return GeoPoint.distance(arg1, arg2, arg3, arg4) <= (arg5 !== null && arg5 !== void 0 ? arg5 : GeoPoint.EQUALITY_TOLERANCE);
        }
        else {
            return GeoPoint.distance(arg1, arg2) <= (arg3 !== null && arg3 !== void 0 ? arg3 : GeoPoint.EQUALITY_TOLERANCE);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distance(arg1, arg2, arg3, arg4) {
        if (arg1 instanceof Float64Array) {
            return Math.acos(Utils.Clamp(Vec3Math.dot(arg1, arg2), -1, 1));
        }
        else {
            let lat1, lon1, lat2, lon2;
            if (typeof arg1 === 'number') {
                lat1 = arg1;
                lon1 = arg2;
                lat2 = arg3;
                lon2 = arg4;
            }
            else {
                lat1 = arg1.lat;
                lon1 = arg1.lon;
                lat2 = arg2.lat;
                lon2 = arg2.lon;
            }
            lat1 *= Avionics.Utils.DEG2RAD;
            lon1 *= Avionics.Utils.DEG2RAD;
            lat2 *= Avionics.Utils.DEG2RAD;
            lon2 *= Avionics.Utils.DEG2RAD;
            // haversine formula
            const sinHalfDeltaLat = Math.sin((lat2 - lat1) / 2);
            const sinHalfDeltaLon = Math.sin((lon2 - lon1) / 2);
            const a = sinHalfDeltaLat * sinHalfDeltaLat + Math.cos(lat1) * Math.cos(lat2) * sinHalfDeltaLon * sinHalfDeltaLon;
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static distanceRhumb(arg1, arg2, arg3, arg4) {
        let lat1, lon1, lat2, lon2;
        if (typeof arg1 === 'number') {
            lat1 = arg1 * Avionics.Utils.DEG2RAD;
            lon1 = arg2 * Avionics.Utils.DEG2RAD;
            lat2 = arg3 * Avionics.Utils.DEG2RAD;
            lon2 = arg4 * Avionics.Utils.DEG2RAD;
        }
        else if (arg1 instanceof Float64Array) {
            const point1 = GeoPoint.tempGeoPoint.setFromCartesian(arg1);
            lat1 = point1.lat;
            lon1 = point1.lon;
            const point2 = GeoPoint.tempGeoPoint.setFromCartesian(arg2);
            lat2 = point2.lat;
            lon2 = point2.lon;
        }
        else {
            lat1 = arg1.lat;
            lon1 = arg1.lon;
            lat2 = arg2.lat;
            lon2 = arg2.lon;
        }
        const deltaLat = lat2 - lat1;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        const correction = GeoPoint.rhumbCorrection(deltaPsi, lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.sqrt(deltaLat * deltaLat + correction * correction * deltaLon * deltaLon);
    }
    /**
     * Calculates the initial true bearing (forward azimuth) from one point to another along the great circle connecting
     * the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The initial true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static initialBearing(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        const cosLat2 = Math.cos(lat2);
        const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * cosLat2 * Math.cos(lon2 - lon1);
        const y = Math.sin(lon2 - lon1) * cosLat2;
        const bearing = Math.atan2(y, x) * Avionics.Utils.RAD2DEG;
        return (bearing + 360) % 360; // enforce range [0, 360)
    }
    /**
     * Calculates the final true bearing from one point to another along the great circle connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The final true bearing, in degrees, from the initial point to the final point along the great circle
     * connecting the two.
     */
    static finalBearing(lat1, lon1, lat2, lon2) {
        return (GeoPoint.initialBearing(lat2, lon2, lat1, lon1) + 180) % 360;
    }
    /**
     * Calculates the constant true bearing from one point to another along the rhumb line connecting the two.
     * @param lat1 The latitude of the initial point, in degrees.
     * @param lon1 The longitude of the initial point, in degrees.
     * @param lat2 The latitude of the final point, in degrees.
     * @param lon2 The longitude of the final point, in degrees.
     * @returns The constant true bearing, in degrees, from the initial point to the final point along the rhumb line
     * connecting the two.
     */
    static bearingRhumb(lat1, lon1, lat2, lon2) {
        lat1 *= Avionics.Utils.DEG2RAD;
        lat2 *= Avionics.Utils.DEG2RAD;
        lon1 *= Avionics.Utils.DEG2RAD;
        lon2 *= Avionics.Utils.DEG2RAD;
        let deltaLon = lon2 - lon1;
        const deltaPsi = GeoPoint.deltaPsi(lat1, lat2);
        if (Math.abs(deltaLon) > Math.PI) {
            deltaLon += -Math.sign(deltaLon) * 2 * Math.PI;
        }
        return Math.atan2(deltaLon, deltaPsi) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Converts an angle, in degrees, to an equivalent value in the range [-180, 180).
     * @param angle An angle in degrees.
     * @returns The angle's equivalent in the range [-180, 180).
     */
    static toPlusMinus180(angle) {
        return ((angle % 360) + 540) % 360 - 180;
    }
    /**
     * Calculates the difference in isometric latitude from a pair of geodetic (geocentric) latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The difference in isometric latitude from latitude 1 to latitude 2, in radians.
     */
    static deltaPsi(latRad1, latRad2) {
        return Math.log(Math.tan(latRad2 / 2 + Math.PI / 4) / Math.tan(latRad1 / 2 + Math.PI / 4));
    }
    /**
     * Calculates the rhumb correction factor between two latitudes.
     * @param deltaPsi The difference in isometric latitude beween the two latitudes.
     * @param latRad1 Geodetic latitude 1, in radians.
     * @param latRad2 Geodetic latitude 2, in radians.
     * @returns The rhumb correction factor between the two latitudes.
     */
    static rhumbCorrection(deltaPsi, latRad1, latRad2) {
        return Math.abs(deltaPsi) > 1e-12 ? ((latRad2 - latRad1) / deltaPsi) : Math.cos(latRad1);
    }
}
/**
 * The default equality tolerance, defined as the maximum allowed distance between two equal points in great-arc
 * radians.
 */
GeoPoint.EQUALITY_TOLERANCE = 1e-7; // ~61 cm
GeoPoint.tempVec3 = new Float64Array(3);
GeoPoint.tempGeoPoint = new GeoPoint(0, 0);

/**
 * A circle on Earth's surface, defined as the set of points on the Earth's surface equidistant (as measured
 * geodetically) from a central point.
 */
class GeoCircle {
    /**
     * Constructor.
     * @param center The center of the new small circle, represented as a position vector in the standard geographic
     * cartesian reference system.
     * @param radius The radius of the new small circle in great-arc radians.
     */
    constructor(center, radius) {
        this._center = new Float64Array(3);
        this._radius = 0;
        this._sinRadius = 0;
        this.set(center, radius);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The center of this circle.
     */
    get center() {
        return this._center;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The radius of this circle, in great-arc radians.
     */
    get radius() {
        return this._radius;
    }
    /**
     * Checks whether this circle is a great circle, or equivalently, whether its radius is equal to pi / 2 great-arc
     * radians.
     * @returns Whether this circle is a great circle.
     */
    isGreatCircle() {
        return this._radius === Math.PI / 2;
    }
    /**
     * Calculates the length of an arc along this circle subtended by a central angle.
     * @param angle A central angle, in radians.
     * @returns The length of the arc subtended by the angle, in great-arc radians.
     */
    arcLength(angle) {
        return this._sinRadius * angle;
    }
    /**
     * Calculates the central angle which subtends an arc along this circle of given length.
     * @param length An arc length, in great-arc radians.
     * @returns The central angle which subtends an arc along this circle of the given length, in radians.
     */
    angularWidth(length) {
        return length / this._sinRadius;
    }
    /**
     * Sets the center and radius of this circle.
     * @param center The new center.
     * @param radius The new radius in great-arc radians.
     * @returns this circle, after it has been changed.
     */
    set(center, radius) {
        if (center instanceof Float64Array) {
            if (Vec3Math.abs(center) === 0) {
                // if center has no direction, arbitrarily set the center to 0 N, 0 E.
                Vec3Math.set(1, 0, 0, this._center);
            }
            else {
                Vec3Math.normalize(center, this._center);
            }
        }
        else {
            GeoPoint.sphericalToCartesian(center, this._center);
        }
        this._radius = Math.abs(radius) % Math.PI;
        this._sinRadius = Math.sin(this._radius);
        return this;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setAsGreatCircle(arg1, arg2) {
        this.set(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
        return this;
    }
    /**
     * Reverses the direction of this circle. This sets the center of the circle to its antipode and the radius to its
     * complement with `Math.PI`.
     * @returns This circle, after it has been reversed.
     */
    reverse() {
        Vec3Math.multScalar(this._center, -1, this._center);
        this._radius = Math.PI - this._radius;
        return this;
    }
    /**
     * Gets the distance from a point to the center of this circle, in great-arc radians.
     * @param point The point to which to measure the distance.
     * @returns the distance from the point to the center of this circle.
     */
    distanceToCenter(point) {
        if (point instanceof Float64Array) {
            point = Vec3Math.normalize(point, GeoCircle.vec3Cache[0]);
        }
        else {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const dot = Vec3Math.dot(point, this._center);
        return Math.acos(Utils.Clamp(dot, -1, 1));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    closest(point, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]);
        }
        const offset = Vec3Math.multScalar(this._center, Math.cos(this._radius), GeoCircle.vec3Cache[1]);
        const dot = Vec3Math.dot(Vec3Math.sub(point, offset, GeoCircle.vec3Cache[2]), this._center);
        const planeProjected = Vec3Math.sub(point, Vec3Math.multScalar(this._center, dot, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        if (Vec3Math.dot(planeProjected, planeProjected) === 0 || Math.abs(Vec3Math.dot(planeProjected, this._center)) === 1) {
            // the point is equidistant from all points on this circle
            return out instanceof GeoPoint ? out.set(NaN, NaN) : Vec3Math.set(NaN, NaN, NaN, out);
        }
        const displacement = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.sub(planeProjected, offset, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]), Math.sin(this._radius), GeoCircle.vec3Cache[2]);
        const closest = Vec3Math.add(offset, displacement, GeoCircle.vec3Cache[2]);
        return out instanceof Float64Array ? Vec3Math.normalize(closest, out) : out.setFromCartesian(closest);
    }
    /**
     * Calculates and returns the great-circle distance from a specified point to the closest point that lies on this
     * circle. In other words, calculates the shortest distance from a point to this circle. The distance is signed, with
     * positive distances representing deviation away from the center of the circle, and negative distances representing
     * deviation toward the center of the circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @returns the great circle distance, in great-arc radians, from the point to the closest point on this circle.
     */
    distance(point) {
        const distanceToCenter = this.distanceToCenter(point);
        return distanceToCenter - this._radius;
    }
    /**
     * Checks whether a point lies on this circle.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies on this circle.
     */
    includes(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return Math.abs(distance) < tolerance;
    }
    /**
     * Checks whether a point lies within the boundary defined by this circle. This is equivalent to checking whether
     * the distance of the point from the center of this circle is less than or equal to this circle's radius.
     * @param point A point, represented as either a position vector or lat/long coordinates.
     * @param inclusive Whether points that lie on this circle should pass the check. True by default.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns whether the point lies within the boundary defined by this circle.
     */
    encircles(point, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const distance = this.distance(point);
        return inclusive
            ? distance <= tolerance
            : distance < -tolerance;
    }
    /**
     * Gets the angular distance along an arc between two points that lie on this circle. The arc extends from the first
     * point to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The angular tolerance for considering the start and end points to be equal, in radians.
     * If the absolute (direction-agnostic) angular distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the angular width of the arc between the two points, in radians.
     * @throws Error if either point does not lie on this circle.
     */
    angleAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, GeoCircle.vec3Cache[1]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, GeoCircle.vec3Cache[2]);
        }
        if (!this.includes(start, tolerance) || !this.includes(end, tolerance)) {
            throw new Error(`GeoCircle: at least one of the two specified arc end points does not lie on this circle (start point distance of ${this.distance(start)}, end point distance of ${this.distance(end)}, vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return 0;
        }
        const startRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, start, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        const endRadialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, end, GeoCircle.vec3Cache[4]), GeoCircle.vec3Cache[4]);
        const angularDistance = Math.acos(Utils.Clamp(Vec3Math.dot(startRadialNormal, endRadialNormal), -1, 1));
        const isArcGreaterThanSemi = Vec3Math.dot(startRadialNormal, end) < 0;
        const angle = isArcGreaterThanSemi ? MathUtils.TWO_PI - angularDistance : angularDistance;
        return angle >= MathUtils.TWO_PI - equalityTolerance || angle <= equalityTolerance ? 0 : angle;
    }
    /**
     * Gets the distance along an arc between two points that lie on this circle. The arc extends from the first point
     * to the second in a counterclockwise direction when viewed from above the center of the circle.
     * @param start A point on this circle which marks the beginning of an arc.
     * @param end A point on this circle which marks the end of an arc.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `end` lie on this circle.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @param equalityTolerance The tolerance for considering the start and end points to be equal, in great-arc radians.
     * If the absolute (direction-agnostic) along-arc distance between the start and end points is less than or equal to
     * this value, then the zero will be returned. Defaults to `0`.
     * @returns the length of the arc between the two points, in great-arc radians.
     * @throws Error if either point does not lie on this circle.
     */
    distanceAlong(start, end, tolerance = GeoCircle.ANGULAR_TOLERANCE, equalityTolerance = 0) {
        return this.arcLength(this.angleAlong(start, end, tolerance, this.angularWidth(equalityTolerance)));
    }
    /**
     * Calculates the true bearing along this circle at a point on the circle.
     * @param point A point on this circle.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the bearing along this circle at the point.
     * @throws Error if the point does not lie on this circle.
     */
    bearingAt(point, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[1]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this._radius <= GeoCircle.ANGULAR_TOLERANCE || 1 - Math.abs(Vec3Math.dot(point, GeoCircle.NORTH_POLE)) <= GeoCircle.ANGULAR_TOLERANCE) {
            // Meaningful bearings cannot be defined along a circle with 0 radius (effectively a point) and at the north and south poles.
            return NaN;
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(this._center, point, GeoCircle.vec3Cache[2]), GeoCircle.vec3Cache[2]);
        const northNormal = Vec3Math.normalize(Vec3Math.cross(point, GeoCircle.NORTH_POLE, GeoCircle.vec3Cache[3]), GeoCircle.vec3Cache[3]);
        return (Math.acos(Utils.Clamp(Vec3Math.dot(radialNormal, northNormal), -1, 1)) * (radialNormal[2] >= 0 ? 1 : -1) * Avionics.Utils.RAD2DEG - 90 + 360) % 360;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetDistanceAlong(point, distance, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angle = distance / Math.sin(this.radius);
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        return this._offsetAngleAlong(point, angle, out, tolerance);
    }
    /**
     * Offsets a point on this circle by a specified angular distance. The direction of the offset for positive distances
     * is counterclockwise when viewed from above the center of this circle.
     * @param point The point to offset.
     * @param angle The angular distance by which to offset, in radians.
     * @param out A Float64Array or GeoPoint object to which to write the result.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `point` lies on this circle. Defaults
     * to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The offset point.
     * @throws Error if the point does not lie on this circle.
     */
    _offsetAngleAlong(point, angle, out, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[3]);
        }
        if (!this.includes(point, tolerance)) {
            throw new Error(`GeoCircle: the specified point does not lie on this circle (distance of ${Math.abs(this.distance(point))} vs tolerance of ${tolerance}).`);
        }
        if (this.radius === 0) {
            return out instanceof GeoPoint ? out.setFromCartesian(point) : Vec3Math.copy(point, out);
        }
        // Since point may not lie exactly on this circle due to error tolerance, project point onto this circle to ensure
        // the offset point lies exactly on this circle.
        point = this.closest(point, GeoCircle.vec3Cache[3]);
        const sin = Math.sin(angle / 2);
        const q0 = Math.cos(angle / 2);
        const q1 = sin * this._center[0];
        const q2 = sin * this._center[1];
        const q3 = sin * this._center[2];
        const q0Sq = q0 * q0;
        const q1Sq = q1 * q1;
        const q2Sq = q2 * q2;
        const q3Sq = q3 * q3;
        const q01 = q0 * q1;
        const q02 = q0 * q2;
        const q03 = q0 * q3;
        const q12 = q1 * q2;
        const q13 = q1 * q3;
        const q23 = q2 * q3;
        const rot_11 = q0Sq + q1Sq - q2Sq - q3Sq;
        const rot_12 = 2 * (q12 - q03);
        const rot_13 = 2 * (q13 + q02);
        const rot_21 = 2 * (q12 + q03);
        const rot_22 = q0Sq - q1Sq + q2Sq - q3Sq;
        const rot_23 = 2 * (q23 - q01);
        const rot_31 = 2 * (q13 - q02);
        const rot_32 = 2 * (q23 + q01);
        const rot_33 = (q0Sq - q1Sq - q2Sq + q3Sq);
        const x = point[0];
        const y = point[1];
        const z = point[2];
        const rotX = rot_11 * x + rot_12 * y + rot_13 * z;
        const rotY = rot_21 * x + rot_22 * y + rot_23 * z;
        const rotZ = rot_31 * x + rot_32 * y + rot_33 * z;
        return out instanceof Float64Array
            ? Vec3Math.set(rotX, rotY, rotZ, out)
            : out.setFromCartesian(Vec3Math.set(rotX, rotY, rotZ, GeoCircle.vec3Cache[2]));
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of position vectors.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new Float64Array objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersection(other, out) {
        const center1 = this._center;
        const center2 = other._center;
        const radius1 = this._radius;
        const radius2 = other._radius;
        /**
         * Theory: We can model geo circles as the intersection between a sphere and the unit sphere (Earth's surface).
         * Therefore, the intersection of two geo circles is the intersection between two spheres AND the unit sphere.
         * First, we find the intersection of the two non-Earth spheres (which can either be a sphere, a circle, or a
         * point), then we find the intersection of that geometry with the unit sphere.
         */
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; either there are zero solutions or infinite solutions; either way we don't
            // write any solutions to the array.
            return 0;
        }
        // find the position vector to the center of the circle which defines the intersection of the two geo circle
        // spheres.
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[0]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            // the two geo circle spheres do not intersect.
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            // this technically can't happen (since we already check if center1 dot center2 === +/-1 above, but just in
            // case...)
            return 0;
        }
        const offset = Math.sqrt((1 - intersectionLengthSquared) / crossLengthSquared);
        let solutionCount = 1;
        if (!out[0]) {
            out[0] = new Float64Array(3);
        }
        out[0].set(cross);
        Vec3Math.multScalar(out[0], offset, out[0]);
        Vec3Math.add(out[0], intersection, out[0]);
        if (offset > 0) {
            if (!out[1]) {
                out[1] = new Float64Array(3);
            }
            out[1].set(cross);
            Vec3Math.multScalar(out[1], -offset, out[1]);
            Vec3Math.add(out[1], intersection, out[1]);
            solutionCount++;
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the set of intersection points between this circle and another one, and writes the results
     * to an array of GeoPoint objects.
     * @param other The other circle to test for intersections.
     * @param out An array in which to store the results. The results will be stored at indexes 0 and 1. If these indexes
     * are empty, then new GeoPoint objects will be created and inserted into the array.
     * @returns The number of solutions written to the out array. Either 0, 1, or 2.
     */
    intersectionGeoPoint(other, out) {
        const solutionCount = this.intersection(other, GeoCircle.intersectionCache);
        for (let i = 0; i < solutionCount; i++) {
            if (!out[i]) {
                out[i] = new GeoPoint(0, 0);
            }
            out[i].setFromCartesian(GeoCircle.intersectionCache[i]);
        }
        return solutionCount;
    }
    /**
     * Calculates and returns the number of intersection points between this circle and another one. Returns NaN if there
     * are an infinite number of intersection points.
     * @param other The other circle to test for intersections.
     * @param tolerance The error tolerance, in great-arc radians, of this operation. Defaults to
     * `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns the number of intersection points between this circle and the other one.
     */
    numIntersectionPoints(other, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const center1 = this.center;
        const center2 = other.center;
        const radius1 = this.radius;
        const radius2 = other.radius;
        const dot = Vec3Math.dot(center1, center2);
        const dotSquared = dot * dot;
        if (dotSquared === 1) {
            // the two circles are concentric; if they are the same circle there are an infinite number of intersections,
            // otherwise there are none.
            if (dot === 1) {
                // centers are the same
                return (Math.abs(this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
            else {
                // centers are antipodal
                return (Math.abs(Math.PI - this.radius - other.radius) <= tolerance) ? NaN : 0;
            }
        }
        const a = (Math.cos(radius1) - dot * Math.cos(radius2)) / (1 - dotSquared);
        const b = (Math.cos(radius2) - dot * Math.cos(radius1)) / (1 - dotSquared);
        const intersection = Vec3Math.add(Vec3Math.multScalar(center1, a, GeoCircle.vec3Cache[0]), Vec3Math.multScalar(center2, b, GeoCircle.vec3Cache[1]), GeoCircle.vec3Cache[1]);
        const intersectionLengthSquared = Vec3Math.dot(intersection, intersection);
        if (intersectionLengthSquared > 1) {
            return 0;
        }
        const cross = Vec3Math.cross(center1, center2, GeoCircle.vec3Cache[1]);
        const crossLengthSquared = Vec3Math.dot(cross, cross);
        if (crossLengthSquared === 0) {
            return 0;
        }
        const sinTol = Math.sin(tolerance);
        return ((1 - intersectionLengthSquared) / crossLengthSquared > sinTol * sinTol) ? 2 : 1;
    }
    /**
     * Creates a new small circle from a lat/long coordinate pair and radius.
     * @param point The center of the new small circle.
     * @param radius The radius of the new small circle, in great-arc radians.
     * @returns a small circle.
     */
    static createFromPoint(point, radius) {
        return new GeoCircle(GeoPoint.sphericalToCartesian(point, GeoCircle.vec3Cache[0]), radius);
    }
    static createGreatCircle(arg1, arg2) {
        return new GeoCircle(GeoCircle._getGreatCircleNormal(arg1, arg2, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Creates a new great circle defined by one point and a bearing offset. The new great circle will be equivalent to
     * the path projected from the point with the specified initial bearing (forward azimuth).
     * @param point A point that lies on the new great circle.
     * @param bearing The initial bearing from the point.
     * @returns a great circle.
     */
    static createGreatCircleFromPointBearing(point, bearing) {
        return new GeoCircle(GeoCircle.getGreatCircleNormalFromPointBearing(point, bearing, GeoCircle.vec3Cache[0]), Math.PI / 2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getGreatCircleNormal(arg1, arg2, out) {
        return GeoCircle._getGreatCircleNormal(arg1, arg2, out);
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the circle, or a point and initial bearing.
     * @param arg1 A point that lies on the great circle.
     * @param arg2 A second point that lies on the great circle, or an initial bearing from the first point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static _getGreatCircleNormal(arg1, arg2, out) {
        if (typeof arg2 === 'number') {
            return GeoCircle.getGreatCircleNormalFromPointBearing(arg1, arg2, out);
        }
        else {
            return GeoCircle.getGreatCircleNormalFromPoints(arg1, arg2, out);
        }
    }
    /**
     * Calculates a normal vector for a great circle given two points which lie on the cirlce.
     * @param point1 The first point that lies on the great circle.
     * @param point2 The second point that lies on the great circle.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPoints(point1, point2, out) {
        if (!(point1 instanceof Float64Array)) {
            point1 = GeoPoint.sphericalToCartesian(point1, GeoCircle.vec3Cache[0]);
        }
        if (!(point2 instanceof Float64Array)) {
            point2 = GeoPoint.sphericalToCartesian(point2, GeoCircle.vec3Cache[1]);
        }
        return Vec3Math.normalize(Vec3Math.cross(point1, point2, out), out);
    }
    /**
     * Calculates a normal vector for a great circle given a point and initial bearing.
     * @param point A point that lies on the great circle.
     * @param bearing The initial bearing from the point.
     * @param out The vector to which to write the result.
     * @returns the normal vector for the great circle.
     */
    static getGreatCircleNormalFromPointBearing(point, bearing, out) {
        if (point instanceof Float64Array) {
            point = GeoCircle.tempGeoPoint.setFromCartesian(point);
        }
        const lat = point.lat * Avionics.Utils.DEG2RAD;
        const long = point.lon * Avionics.Utils.DEG2RAD;
        bearing *= Avionics.Utils.DEG2RAD;
        const sinLat = Math.sin(lat);
        const sinLon = Math.sin(long);
        const cosLon = Math.cos(long);
        const sinBearing = Math.sin(bearing);
        const cosBearing = Math.cos(bearing);
        const x = sinLon * cosBearing - sinLat * cosLon * sinBearing;
        const y = -cosLon * cosBearing - sinLat * sinLon * sinBearing;
        const z = Math.cos(lat) * sinBearing;
        return Vec3Math.set(x, y, z, out);
    }
}
GeoCircle.ANGULAR_TOLERANCE = 1e-7; // ~61cm
GeoCircle.NORTH_POLE = new Float64Array([0, 0, 1]);
GeoCircle.tempGeoPoint = new GeoPoint(0, 0);
GeoCircle.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
GeoCircle.intersectionCache = [new Float64Array(3), new Float64Array(3)];

/**
 * Navigational mathematics functions.
 */
class NavMath {
    /**
     * Clamps a value to a min and max.
     * @param val The value to clamp.
     * @param min The minimum value to clamp to.
     * @param max The maximum value to clamp to.
     * @returns The clamped value.
     */
    static clamp(val, min, max) {
        return Math.min(Math.max(val, min), max);
    }
    /**
     * Normalizes a heading to a 0-360 range.
     * @param heading The heading to normalize.
     * @returns The normalized heading.
     */
    static normalizeHeading(heading) {
        if (isFinite(heading)) {
            return (heading % 360 + 360) % 360;
        }
        else {
            console.error(`normalizeHeading: Invalid heading: ${heading}`);
            return NaN;
        }
    }
    /**
     * Inverts a heading value by adding 180 and normalizing.
     * @param heading The heading to invert/reciprocate.
     * @returns The inverted/reciprocated heading.
     * */
    static reciprocateHeading(heading) {
        return NavMath.normalizeHeading(heading + 180);
    }
    /**
     * Gets the turn radius for a given true airspeed.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param bankAngle The bank angle of the plane, in degrees.
     * @returns The airplane turn radius, in meters.
     */
    static turnRadius(airspeedTrue, bankAngle) {
        return (Math.pow(airspeedTrue, 2) / (11.26 * Math.tan(bankAngle * Avionics.Utils.DEG2RAD)))
            / 3.2808399;
    }
    /**
     * Gets the required bank angle for a given true airspeed and turn radius.
     * @param airspeedTrue The true airspeed of the plane, in knots.
     * @param radius The airplane turn radius, in meters.
     * @returns The required bank angle, in degrees.
     */
    static bankAngle(airspeedTrue, radius) {
        const airspeedMS = airspeedTrue * 0.51444444;
        return Math.atan(Math.pow(airspeedMS, 2) / (radius * 9.80665)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the turn direction for a given course change.
     * @param startCourse The start course.
     * @param endCourse The end course.
     * @returns The turn direction for the course change.
     */
    static getTurnDirection(startCourse, endCourse) {
        return NavMath.normalizeHeading(endCourse - startCourse) > 180 ? 'left' : 'right';
    }
    /**
     * Converts polar radians to degrees north.
     * @param radians The radians to convert.
     * @returns The angle, in degrees north.
     */
    static polarToDegreesNorth(radians) {
        return NavMath.normalizeHeading((180 / Math.PI) * (Math.PI / 2 - radians));
    }
    /**
     * Converts degrees north to polar radians.
     * @param degrees The degrees to convert.
     * @returns The angle radians, in polar.
     */
    static degreesNorthToPolar(degrees) {
        return NavMath.normalizeHeading(degrees - 90) / (180 / Math.PI);
    }
    /**
     * Calculates the distance along an arc on Earth's surface. The arc begins at the intersection of the great circle
     * passing through the center of a circle of radius `radius` meters in the direction of 'startBearing', and ends at
     * the intersection of the great circle passing through the center of the circle in the direction of 'endBearing',
     * proceeding clockwise (as viewed from above).
     * @param startBearing The degrees of the start of the arc.
     * @param endBearing The degrees of the end of the arc.
     * @param radius The radius of the arc, in meters.
     * @returns The arc distance.
     */
    static calculateArcDistance(startBearing, endBearing, radius) {
        const angularWidth = ((endBearing - startBearing + 360) % 360) * Avionics.Utils.DEG2RAD;
        const conversion = UnitType.GA_RADIAN.convertTo(1, UnitType.METER);
        return angularWidth * Math.sin(radius / conversion) * conversion;
    }
    /**
     * Calculates the intersection of a line and a circle.
     * @param x1 The start x of the line.
     * @param y1 The start y of the line.
     * @param x2 The end x of the line.
     * @param y2 The end y of the line.
     * @param cx The circle center x.
     * @param cy The circle center y.
     * @param r The radius of the circle.
     * @param sRef The reference to the solution object to write the solution to.
     * @returns The number of solutions (0, 1 or 2).
     */
    static circleIntersection(x1, y1, x2, y2, cx, cy, r, sRef) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const a = dx * dx + dy * dy;
        const b = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
        const c = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - r * r;
        const det = b * b - 4 * a * c;
        if (a < 0.0000001 || det < 0) {
            sRef.x1 = NaN;
            sRef.x2 = NaN;
            sRef.y1 = NaN;
            sRef.y2 = NaN;
            return 0;
        }
        else if (det == 0) {
            const t = -b / (2 * a);
            sRef.x1 = x1 + t * dx;
            sRef.y1 = y1 + t * dy;
            sRef.x2 = NaN;
            sRef.y2 = NaN;
            return 1;
        }
        else {
            const t1 = ((-b + Math.sqrt(det)) / (2 * a));
            sRef.x1 = x1 + t1 * dx;
            sRef.y1 = y1 + t1 * dy;
            const t2 = ((-b - Math.sqrt(det)) / (2 * a));
            sRef.x2 = x1 + t2 * dx;
            sRef.y2 = y1 + t2 * dy;
            return 2;
        }
    }
    /**
     * Gets the degrees north that a point lies on a circle.
     * @param cx The x point of the center of the circle.
     * @param cy The y point of the center of the circle.
     * @param x The x point to get the bearing for.
     * @param y The y point to get the bearing for.
     * @returns The angle in degrees north that the point is relative to the center.
     */
    static northAngle(cx, cy, x, y) {
        return NavMath.polarToDegreesNorth(Math.atan2(y - cy, x - cx));
    }
    /**
     * Checks if a degrees north bearing is between two other degrees north bearings.
     * @param bearing The bearing in degrees north to check.
     * @param start The start bearing in degrees north.
     * @param end The end bearing, in degrees north.
     * @returns True if the bearing is between the two provided bearings, false otherwise.
     */
    static bearingIsBetween(bearing, start, end) {
        const range = this.normalizeHeading(end - start);
        const relativeBearing = this.normalizeHeading(bearing - start);
        return relativeBearing >= 0 && relativeBearing <= range;
    }
    /**
     * Converts a degrees north heading to a degrees north turn circle angle.
     * @param heading The heading to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north turn circle angle.
     */
    static headingToAngle(heading, turnDirection) {
        return NavMath.normalizeHeading(heading + (turnDirection === 'left' ? 90 : -90));
    }
    /**
     * Converts a degrees north turn circle angle to a degrees north heading.
     * @param angle The turn circle angle to convert.
     * @param turnDirection The direction of the turn.
     * @returns A degrees north heading.
     */
    static angleToHeading(angle, turnDirection) {
        return NavMath.normalizeHeading(angle + (turnDirection === 'left' ? -90 : 90));
    }
    /**
     * Calculates the wind correction angle.
     * @param course The current plane true course.
     * @param airspeedTrue The current plane true airspeed.
     * @param windDirection The direction of the wind, in degrees true.
     * @param windSpeed The current speed of the wind.
     * @returns The calculated wind correction angle.
     */
    static windCorrectionAngle(course, airspeedTrue, windDirection, windSpeed) {
        const currCrosswind = windSpeed * (Math.sin((course * Math.PI / 180) - (windDirection * Math.PI / 180)));
        const windCorrection = 180 * Math.asin(currCrosswind / airspeedTrue) / Math.PI;
        return windCorrection;
    }
    /**
     * Calculates the cross track deviation from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The amount of cross track deviation, in nautical miles.
     */
    static crossTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return UnitType.GA_RADIAN.convertTo(path.distance(pos), UnitType.NMILE);
    }
    /**
     * Calculates the along-track distance from a starting point to another point along a great-circle track running
     * through the starting point.
     * @param start The start of the great-circle track.
     * @param end The end of the great-circle track.
     * @param pos The point for which to calculate the along-track distance.
     * @returns The along-track distance, in nautical miles.
     */
    static alongTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        const distance = path.distanceAlong(start, path.closest(pos, NavMath.vec3Cache[0]));
        return UnitType.GA_RADIAN.convertTo((distance + Math.PI) % (2 * Math.PI) - Math.PI, UnitType.NMILE);
    }
    /**
     * Calculates the desired track from the provided leg fixes.
     * @param start The location of the starting fix of the leg.
     * @param end The location of the ending fix of the leg.
     * @param pos The current plane location coordinates.
     * @returns The desired track, in degrees true.
     */
    static desiredTrack(start, end, pos) {
        const path = NavMath.geoCircleCache[0].setAsGreatCircle(start, end);
        if (isNaN(path.center[0])) {
            return NaN;
        }
        return path.bearingAt(path.closest(pos, NavMath.vec3Cache[0]));
    }
    /**
     * Gets the desired track for a given arc.
     * @param center The center of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The desired track.
     */
    static desiredTrackArc(center, turnDirection, pos) {
        const northAngle = NavMath.geoPointCache[0].set(pos).bearingFrom(center);
        //TODO: Clamp the arc angle to the start and end angles
        return NavMath.angleToHeading(northAngle, turnDirection);
    }
    /**
     * Gets the percentage along the arc path that the plane currently is.
     * @param start The start of the arc, in degrees north.
     * @param end The end of the arc, in degrees north.
     * @param center The center location of the arc.
     * @param turnDirection The direction of the turn.
     * @param pos The current plane position.
     * @returns The percentage along the arc the plane is.
     */
    static percentAlongTrackArc(start, end, center, turnDirection, pos) {
        const bearingFromCenter = NavMath.geoPointCache[0].set(center).bearingTo(pos);
        const sign = turnDirection === 'right' ? 1 : -1;
        const alpha = ((end - start) * sign + 360) % 360;
        const mid = (start + alpha / 2 * sign + 360) % 360;
        const rotBearing = ((bearingFromCenter - mid) + 540) % 360 - 180;
        const frac = rotBearing * sign / alpha + 0.5;
        return frac;
    }
    /**
     * Gets a position given an arc and a distance from the arc start.
     * @param start The start bearing of the arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc.
     * @param turnDirection The turn direction for the arc.
     * @param distance The distance along the arc to get the position for.
     * @param out The position to write to.
     * @returns The position along the arc that was written to.
     */
    static positionAlongArc(start, center, radius, turnDirection, distance, out) {
        const convertedRadius = UnitType.GA_RADIAN.convertTo(Math.sin(UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)), UnitType.METER);
        const theta = UnitType.RADIAN.convertTo(distance / convertedRadius, UnitType.DEGREE);
        const bearing = turnDirection === 'right' ? start + theta : start - theta;
        center.offset(NavMath.normalizeHeading(bearing), UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), out);
        return out;
    }
    /**
     * Gets the cross track distance for a given arc.
     * @param center The center of the arc.
     * @param radius The radius of the arc, in meters.
     * @param pos The current plane position.
     * @returns The cross track distance, in NM.
     */
    static crossTrackArc(center, radius, pos) {
        return UnitType.METER.convertTo(radius, UnitType.NMILE) - UnitType.GA_RADIAN.convertTo(NavMath.geoPointCache[0].set(pos).distance(center), UnitType.NMILE);
    }
    /**
     * Gets the total difference in degrees between two angles.
     * @param a The first angle.
     * @param b The second angle.
     * @returns The difference between the two angles, in degrees.
     */
    static diffAngle(a, b) {
        let diff = b - a;
        while (diff > 180) {
            diff -= 360;
        }
        while (diff <= -180) {
            diff += 360;
        }
        return diff;
    }
    /**
     * Finds side a given sides b, c, and angles beta, gamma.
     * @param b The length of side b, as a trigonometric ratio.
     * @param c The length of side c, as a trigonometric ratio.
     * @param beta The angle, in radians, of the opposite of side b.
     * @param gamma The angle, in radians, of the opposite of side c
     * @returns The length of side a, as a trigonometric ratio.
     */
    static napierSide(b, c, beta, gamma) {
        return 2 * Math.atan(Math.tan(0.5 * (b - c))
            * (Math.sin(0.5 * (beta + gamma)) / Math.sin(0.5 * (beta - gamma))));
    }
    /**
     * Calculates a normal vector to a provided course in degrees north.
     * @param course The course in degrees north.
     * @param turnDirection The direction of the turn to orient the normal.
     * @param outVector The normal vector for the provided course.
     */
    static normal(course, turnDirection, outVector) {
        const normalCourse = NavMath.headingToAngle(course, turnDirection);
        const polarCourse = NavMath.degreesNorthToPolar(normalCourse);
        outVector[0] = Math.cos(polarCourse);
        outVector[1] = Math.sin(polarCourse);
    }
}
NavMath.vec3Cache = [new Float64Array(3)];
NavMath.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
NavMath.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/// <reference types="@microsoft/msfs-types/coherent/facilities" />
/**
 * A utility class for working with magnetic variation (magnetic declination).
 */
class MagVar {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static get(arg1, arg2) {
        return MagVar.getMagVar(arg1, arg2);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static magneticToTrue(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing + (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static trueToMagnetic(bearing, arg1, arg2) {
        return NavMath.normalizeHeading(bearing - (typeof arg1 === 'number' && arg2 === undefined ? arg1 : MagVar.getMagVar(arg1, arg2)));
    }
    /**
     * Gets the magnetic variation (magnetic declination) at a specific point on Earth.
     * @param arg1 The query point, or the latitude of the query point.
     * @param arg2 The longitude of the query point.
     * @returns The magnetic variation (magnetic declination) at the point.
     */
    static getMagVar(arg1, arg2) {
        if (typeof Facilities === 'undefined') {
            // In case this code is executed before the Facilities class is created.
            return 0;
        }
        let lat, lon;
        if (typeof arg1 === 'number') {
            lat = arg1;
            lon = arg2;
        }
        else {
            lat = arg1.lat;
            lon = arg1.lon;
        }
        return Facilities.getMagVar(lat, lon);
    }
}

/**
 * A Subject which provides a {@link GeoPointInterface} value.
 */
class GeoPointSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param value The value of this subject.
     * @param tolerance The tolerance of this subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     */
    constructor(value, tolerance) {
        super();
        this.value = value;
        this.tolerance = tolerance;
        /** @inheritdoc */
        this.isMutableSubscribable = true;
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @param tolerance The tolerance of the subject's equality check, defined as the maximum allowed great-circle
     * distance between two equal points in great-arc radians. Defaults to {@link GeoPoint.EQUALITY_TOLERANCE}.
     * @returns A GeoPointSubject.
     */
    static create(initialVal, tolerance) {
        return new GeoPointSubject(initialVal, tolerance);
    }
    /**
     * Creates a GeoPointSubject.
     * @param initialVal The initial value.
     * @returns A GeoPointSubject.
     * @deprecated Use `GeoPointSubject.create()` instead.
     */
    static createFromGeoPoint(initialVal) {
        return new GeoPointSubject(initialVal);
    }
    /** @inheritdoc */
    get() {
        return this.value.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, arg2) {
        const isArg1Number = typeof arg1 === 'number';
        const equals = isArg1Number ? this.value.equals(arg1, arg2, this.tolerance) : this.value.equals(arg1, this.tolerance);
        if (!equals) {
            isArg1Number ? this.value.set(arg1, arg2) : this.value.set(arg1);
            this.notify();
        }
    }
}

/**
 * A publisher for AHRS information.
 */
class AhrsPublisher extends SimVarPublisher {
    /**
     * Creates an AhrsPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        var _a;
        const simvars = new Map([
            ['pitch_deg', { name: 'ATTITUDE INDICATOR PITCH DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['roll_deg', { name: 'ATTITUDE INDICATOR BANK DEGREES:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['hdg_deg_true', { name: 'HEADING INDICATOR:#index#', type: SimVarValueType.Degree, map: (heading) => MagVar.magneticToTrue(heading, this.magVar), indexed: true }],
            ['delta_heading_rate', { name: 'DELTA HEADING RATE:#index#', type: SimVarValueType.Degree, indexed: true }],
            ['turn_coordinator_ball', { name: 'TURN COORDINATOR BALL', type: SimVarValueType.Number }],
            ['actual_hdg_deg', { name: 'PLANE HEADING DEGREES MAGNETIC', type: SimVarValueType.Degree }],
            ['actual_hdg_deg_true', { name: 'PLANE HEADING DEGREES TRUE', type: SimVarValueType.Degree }],
            ['actual_pitch_deg', { name: 'PLANE PITCH DEGREES', type: SimVarValueType.Degree }],
            ['actual_roll_deg', { name: 'PLANE BANK DEGREES', type: SimVarValueType.Degree }],
        ]);
        super(simvars, bus, pacer);
        this.magVar = 0;
        (_a = this.needUpdateMagVar) !== null && _a !== void 0 ? _a : (this.needUpdateMagVar = false);
    }
    /** @inheritdoc */
    onTopicSubscribed(topic) {
        super.onTopicSubscribed(topic);
        if (topic.startsWith('hdg_deg_true')) {
            this.needUpdateMagVar = true;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needUpdateMagVar) {
            this.magVar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
        }
        super.onUpdate();
    }
}

/**
 * Ambient precipitation states.
 */
var AmbientPrecipState;
(function (AmbientPrecipState) {
    AmbientPrecipState[AmbientPrecipState["None"] = 2] = "None";
    AmbientPrecipState[AmbientPrecipState["Rain"] = 4] = "Rain";
    AmbientPrecipState[AmbientPrecipState["Snow"] = 8] = "Snow";
})(AmbientPrecipState || (AmbientPrecipState = {}));
/**
 * A publisher for ambient environment information.
 */
class AmbientPublisher extends SimVarPublisher {
    /**
     * Creates an AmbientPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['ambient_precip_state', { name: 'AMBIENT PRECIP STATE', type: SimVarValueType.Number }],
            ['ambient_precip_rate', { name: 'AMBIENT PRECIP RATE', type: SimVarValueType.MillimetersWater }],
            ['ambient_visibility', { name: 'AMBIENT VISIBILITY', type: SimVarValueType.Meters }],
            ['ambient_in_cloud', { name: 'AMBIENT IN CLOUD', type: SimVarValueType.Bool }],
            ['ambient_qnh_inhg', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.InHG }],
            ['ambient_qnh_mb', { name: 'SEA LEVEL PRESSURE', type: SimVarValueType.MB }],
        ]);
        super(simvars, bus, pacer);
    }
}

/**
 * A basic implementation of {@link Consumer}.
 */
class BasicConsumer {
    /**
     * Creates an instance of a Consumer.
     * @param subscribe A function which subscribes a handler to the source of this consumer's events.
     * @param state The state for the consumer to track.
     * @param currentHandler The current build filter handler stack, if any.
     */
    constructor(subscribe, state = {}, currentHandler) {
        this.subscribe = subscribe;
        this.state = state;
        this.currentHandler = currentHandler;
        /** @inheritdoc */
        this.isConsumer = true;
        this.activeSubs = new Map();
    }
    /** @inheritdoc */
    handle(handler, paused = false) {
        let activeHandler;
        if (this.currentHandler !== undefined) {
            /**
             * The handler reference to store.
             * @param data The input data to the handler.
             */
            activeHandler = (data) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.currentHandler(data, this.state, handler);
            };
        }
        else {
            activeHandler = handler;
        }
        let activeSubArray = this.activeSubs.get(handler);
        if (!activeSubArray) {
            activeSubArray = [];
            this.activeSubs.set(handler, activeSubArray);
        }
        const onDestroyed = (destroyed) => {
            const activeSubsArray = this.activeSubs.get(handler);
            if (activeSubsArray) {
                activeSubsArray.splice(activeSubsArray.indexOf(destroyed), 1);
                if (activeSubsArray.length === 0) {
                    this.activeSubs.delete(handler);
                }
            }
        };
        const sub = new ConsumerSubscription(this.subscribe(activeHandler, paused), onDestroyed);
        // Need to handle the case where the subscription is destroyed immediately
        if (sub.isAlive) {
            activeSubArray.push(sub);
        }
        else if (activeSubArray.length === 0) {
            this.activeSubs.delete(handler);
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        var _a;
        const activeSubArray = this.activeSubs.get(handler);
        if (activeSubArray) {
            (_a = activeSubArray.shift()) === null || _a === void 0 ? void 0 : _a.destroy();
            if (activeSubArray.length === 0) {
                this.activeSubs.delete(handler);
            }
        }
    }
    /** @inheritdoc */
    atFrequency(frequency, immediateFirstPublish = true) {
        const initialState = {
            previousTime: Date.now(),
            firstRun: immediateFirstPublish
        };
        return new BasicConsumer(this.subscribe, initialState, this.getAtFrequencyHandler(frequency));
    }
    /**
     * Gets a handler function for a 'atFrequency' filter.
     * @param frequency The frequency, in Hz, to cap to.
     * @returns A handler function for a 'atFrequency' filter.
     */
    getAtFrequencyHandler(frequency) {
        const deltaTimeTrigger = 1000 / frequency;
        return (data, state, next) => {
            const currentTime = Date.now();
            const deltaTime = currentTime - state.previousTime;
            if (deltaTimeTrigger <= deltaTime || state.firstRun) {
                while ((state.previousTime + deltaTimeTrigger) < currentTime) {
                    state.previousTime += deltaTimeTrigger;
                }
                if (state.firstRun) {
                    state.firstRun = false;
                }
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    withPrecision(precision) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWithPrecisionHandler(precision));
    }
    /**
     * Gets a handler function for a 'withPrecision' filter.
     * @param precision The decimal precision to snap to.
     * @returns A handler function for a 'withPrecision' filter.
     */
    getWithPrecisionHandler(precision) {
        return (data, state, next) => {
            const dataValue = data;
            const multiplier = Math.pow(10, precision);
            const currentValueAtPrecision = Math.round(dataValue * multiplier) / multiplier;
            if (!state.hasLastValue || currentValueAtPrecision !== state.lastValue) {
                state.hasLastValue = true;
                state.lastValue = currentValueAtPrecision;
                this.with(currentValueAtPrecision, next);
            }
        };
    }
    /** @inheritdoc */
    whenChangedBy(amount) {
        return new BasicConsumer(this.subscribe, { lastValue: 0, hasLastValue: false }, this.getWhenChangedByHandler(amount));
    }
    /**
     * Gets a handler function for a 'whenChangedBy' filter.
     * @param amount The minimum amount threshold below which the consumer will not consume.
     * @returns A handler function for a 'whenChangedBy' filter.
     */
    getWhenChangedByHandler(amount) {
        return (data, state, next) => {
            const dataValue = data;
            const diff = Math.abs(dataValue - state.lastValue);
            if (!state.hasLastValue || diff >= amount) {
                state.hasLastValue = true;
                state.lastValue = dataValue;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    whenChanged() {
        return new BasicConsumer(this.subscribe, { lastValue: '', hasLastValue: false }, this.getWhenChangedHandler());
    }
    /**
     * Gets a handler function for a 'whenChanged' filter.
     * @returns A handler function for a 'whenChanged' filter.
     */
    getWhenChangedHandler() {
        return (data, state, next) => {
            if (!state.hasLastValue || state.lastValue !== data) {
                state.hasLastValue = true;
                state.lastValue = data;
                this.with(data, next);
            }
        };
    }
    /** @inheritdoc */
    onlyAfter(deltaTime) {
        return new BasicConsumer(this.subscribe, { previousTime: Date.now() }, this.getOnlyAfterHandler(deltaTime));
    }
    /**
     * Gets a handler function for an 'onlyAfter' filter.
     * @param deltaTime The minimum delta time between events.
     * @returns A handler function for an 'onlyAfter' filter.
     */
    getOnlyAfterHandler(deltaTime) {
        return (data, state, next) => {
            const currentTime = Date.now();
            const timeDiff = currentTime - state.previousTime;
            if (timeDiff > deltaTime) {
                state.previousTime += deltaTime;
                this.with(data, next);
            }
        };
    }
    /**
     * Builds a handler stack from the current handler.
     * @param data The data to send in to the handler.
     * @param handler The handler to use for processing.
     */
    with(data, handler) {
        if (this.currentHandler !== undefined) {
            this.currentHandler(data, this.state, handler);
        }
        else {
            handler(data);
        }
    }
}
/**
 * A {@link Subscription} for a {@link BasicConsumer}.
 */
class ConsumerSubscription {
    /**
     * Constructor.
     * @param sub The event bus subscription backing this subscription.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(sub, onDestroy) {
        this.sub = sub;
        this.onDestroy = onDestroy;
    }
    /** @inheritdoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    /** @inheritdoc */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritdoc */
    get canInitialNotify() {
        return this.sub.canInitialNotify;
    }
    /** @inheritdoc */
    pause() {
        this.sub.pause();
        return this;
    }
    /** @inheritdoc */
    resume(initialNotify = false) {
        this.sub.resume(initialNotify);
        return this;
    }
    /** @inheritdoc */
    destroy() {
        this.sub.destroy();
        this.onDestroy(this);
    }
}

/**
 * A typed container for subscribers interacting with the Event Bus.
 */
class EventSubscriber {
    /**
     * Creates an instance of an EventSubscriber.
     * @param bus The EventBus that is the parent of this instance.
     */
    constructor(bus) {
        this.bus = bus;
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @returns A consumer to bind the event handler to.
     */
    on(topic) {
        return new BasicConsumer((handler, paused) => {
            return this.bus.on(topic, handler, paused);
        });
    }
}

var APLockType;
(function (APLockType) {
    APLockType[APLockType["Heading"] = 0] = "Heading";
    APLockType[APLockType["Nav"] = 1] = "Nav";
    APLockType[APLockType["Alt"] = 2] = "Alt";
    APLockType[APLockType["Bank"] = 3] = "Bank";
    APLockType[APLockType["WingLevel"] = 4] = "WingLevel";
    APLockType[APLockType["Vs"] = 5] = "Vs";
    APLockType[APLockType["Flc"] = 6] = "Flc";
    APLockType[APLockType["Pitch"] = 7] = "Pitch";
    APLockType[APLockType["Approach"] = 8] = "Approach";
    APLockType[APLockType["Backcourse"] = 9] = "Backcourse";
    APLockType[APLockType["Glideslope"] = 10] = "Glideslope";
    APLockType[APLockType["VNav"] = 11] = "VNav";
})(APLockType || (APLockType = {}));
/** base publisher for simvars */
class APSimVarPublisher extends SimVarPublisher {
    /**
     * Create an APSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(APSimVarPublisher.simvars, bus, pacer);
    }
}
APSimVarPublisher.simvars = new Map([
    ['ap_master_status', { name: 'AUTOPILOT MASTER', type: SimVarValueType.Bool }],
    ['ap_yd_status', { name: 'AUTOPILOT YAW DAMPER', type: SimVarValueType.Bool }],
    ['ap_disengage_status', { name: 'AUTOPILOT DISENGAGED', type: SimVarValueType.Bool }],
    ['ap_heading_hold', { name: 'AUTOPILOT HEADING LOCK', type: SimVarValueType.Bool }],
    ['ap_nav_hold', { name: 'AUTOPILOT NAV1 LOCK', type: SimVarValueType.Bool }],
    ['ap_bank_hold', { name: 'AUTOPILOT BANK HOLD', type: SimVarValueType.Bool }],
    ['ap_max_bank_id', { name: 'AUTOPILOT MAX BANK ID', type: SimVarValueType.Number }],
    ['ap_max_bank_value', { name: 'AUTOPILOT MAX BANK', type: SimVarValueType.Degree }],
    ['ap_wing_lvl_hold', { name: 'AUTOPILOT WING LEVELER', type: SimVarValueType.Bool }],
    ['ap_approach_hold', { name: 'AUTOPILOT APPROACH HOLD', type: SimVarValueType.Bool }],
    ['ap_backcourse_hold', { name: 'AUTOPILOT BACKCOURSE HOLD', type: SimVarValueType.Bool }],
    ['ap_vs_hold', { name: 'AUTOPILOT VERTICAL HOLD', type: SimVarValueType.Bool }],
    ['ap_flc_hold', { name: 'AUTOPILOT FLIGHT LEVEL CHANGE', type: SimVarValueType.Bool }],
    ['ap_alt_hold', { name: 'AUTOPILOT ALTITUDE LOCK', type: SimVarValueType.Bool }],
    ['ap_glideslope_hold', { name: 'AUTOPILOT GLIDESLOPE HOLD', type: SimVarValueType.Bool }],
    ['ap_pitch_hold', { name: 'AUTOPILOT PITCH HOLD', type: SimVarValueType.Bool }],
    ['ap_toga_hold', { name: 'AUTOPILOT TAKEOFF POWER ACTIVE', type: SimVarValueType.Bool }],
    ['ap_heading_selected', { name: 'AUTOPILOT HEADING LOCK DIR:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_altitude_selected', { name: 'AUTOPILOT ALTITUDE LOCK VAR:#index#', type: SimVarValueType.Feet, indexed: true }],
    ['ap_pitch_selected', { name: 'AUTOPILOT PITCH HOLD REF', type: SimVarValueType.Degree }],
    ['ap_vs_selected', { name: 'AUTOPILOT VERTICAL HOLD VAR:#index#', type: SimVarValueType.FPM, indexed: true }],
    ['ap_fpa_selected', { name: 'L:WT_AP_FPA_Target:#index#', type: SimVarValueType.Degree, indexed: true }],
    ['ap_ias_selected', { name: 'AUTOPILOT AIRSPEED HOLD VAR:#index#', type: SimVarValueType.Knots, indexed: true }],
    ['ap_mach_selected', { name: 'AUTOPILOT MACH HOLD VAR:#index#', type: SimVarValueType.Number, indexed: true }],
    ['ap_selected_speed_is_mach', { name: 'AUTOPILOT MANAGED SPEED IN MACH', type: SimVarValueType.Bool }],
    ['ap_selected_speed_is_manual', { name: 'L:XMLVAR_SpeedIsManuallySet', type: SimVarValueType.Bool }],
    ['flight_director_bank', { name: 'AUTOPILOT FLIGHT DIRECTOR BANK', type: SimVarValueType.Degree }],
    ['flight_director_pitch', { name: 'AUTOPILOT FLIGHT DIRECTOR PITCH', type: SimVarValueType.Degree }],
    ['flight_director_is_active_1', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', type: SimVarValueType.Bool }],
    ['flight_director_is_active_2', { name: 'AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', type: SimVarValueType.Bool }],
    ['vnav_active', { name: 'L:XMLVAR_VNAVButtonValue', type: SimVarValueType.Bool }]
]);
/**
 * Publishes autopilot data
 */
class AutopilotPublisher extends BasePublisher {
    /**
     * Creates an AutopilotPublisher
     * @param bus The event bus to publish to.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
    }
    /**
     * Publish an AP master engage event
     */
    publishMasterEngage() {
        this.publish('ap_master_on', true);
    }
    /**
     * Publish an AP master disengage event
     */
    publishMasterDisengage() {
        this.publish('ap_master_off', true);
    }
    /**
     * Publish a YD engage event
     */
    publishYdEngage() {
        this.publish('ap_yd_on', true);
    }
    /**
     * Publish a YD disengage event
     */
    publishYdDisengage() {
        this.publish('ap_yd_off', true);
    }
    /**
     * Publish a lock set event
     * @param lock The lock/hold set
     */
    publishLockSet(lock) {
        this.publish('ap_lock_set', lock);
    }
    /**
     * Publish a lock release event
     * @param lock The lock/hold released
     */
    publishLockRelease(lock) {
        this.publish('ap_lock_release', lock);
    }
}
/**
 * Manages an autopilot system
 */
class AutopilotInstrument {
    /**
     * Create an AutopilotInstrument
     * @param bus The event bus to publish to
     */
    constructor(bus) {
        this.bus = bus;
        // this.hEvents = this.bus.getSubscriber<HEvent>();
        this.publisher = new AutopilotPublisher(bus);
        this.simVarPublisher = new APSimVarPublisher(bus);
        this.simVarSubscriber = new EventSubscriber(bus);
    }
    /**
     * Initialize the instrument
     */
    init() {
        this.publisher.startPublish();
        this.simVarPublisher.startPublish();
        // console.log('initting autopilot');
        this.simVarSubscriber.on('ap_master_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishMasterEngage();
            }
            else {
                this.publisher.publishMasterDisengage();
            }
        });
        this.simVarSubscriber.on('ap_yd_status').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishYdEngage();
            }
            else {
                this.publisher.publishYdDisengage();
            }
        });
        this.simVarSubscriber.on('ap_alt_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Alt);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Alt);
            }
        });
        this.simVarSubscriber.on('ap_pitch_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Pitch);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Pitch);
            }
        });
        this.simVarSubscriber.on('ap_heading_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Heading);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Heading);
            }
        });
        this.simVarSubscriber.on('ap_nav_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Nav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Nav);
            }
        });
        this.simVarSubscriber.on('ap_approach_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Approach);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Approach);
            }
        });
        this.simVarSubscriber.on('ap_backcourse_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Backcourse);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Backcourse);
            }
        });
        this.simVarSubscriber.on('ap_bank_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Bank);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Bank);
            }
        });
        this.simVarSubscriber.on('ap_wing_lvl_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.WingLevel);
            }
            else {
                this.publisher.publishLockRelease(APLockType.WingLevel);
            }
        });
        this.simVarSubscriber.on('ap_flc_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Flc);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Flc);
            }
        });
        this.simVarSubscriber.on('ap_vs_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Vs);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Vs);
            }
        });
        this.simVarSubscriber.on('ap_glideslope_hold').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.Glideslope);
            }
            else {
                this.publisher.publishLockRelease(APLockType.Glideslope);
            }
        });
        this.simVarSubscriber.on('vnav_active').whenChangedBy(1).handle((engaged) => {
            if (engaged) {
                this.publisher.publishLockSet(APLockType.VNav);
            }
            else {
                this.publisher.publishLockRelease(APLockType.VNav);
            }
        });
    }
    /** update our publishers */
    onUpdate() {
        this.simVarPublisher.onUpdate();
    }
}

/**
 * Utility functions for working with arrays.
 */
class ArrayUtils {
    /**
     * Creates a new array with initialized values.
     * @param length The length of the new array.
     * @param init A function which generates initial values for the new array at each index.
     * @returns A new array of the specified length with initialized values.
     */
    static create(length, init) {
        const newArray = [];
        for (let i = 0; i < length; i++) {
            newArray[i] = init(i);
        }
        return newArray;
    }
    /**
     * Gets the element at a specific index in an array.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array.
     * @throws RangeError if the index is out of bounds.
     */
    static at(array, index) {
        if (index < 0) {
            index += array.length;
        }
        if (index < 0 || index >= array.length) {
            throw new RangeError();
        }
        return array[index];
    }
    /**
     * Gets the element at a specific index in an array, or `undefined` if the index is out of bounds.
     * @param array An array.
     * @param index The index to access. Negative indexes are supported and access elements starting from the end of the
     * array (`-1` accesses the last element, `-2` the second to last element, etc).
     * @returns The element at the specified index in the array, or `undefined` if the index is out of bounds.
     */
    static peekAt(array, index) {
        if (index < 0) {
            index += array.length;
        }
        return array[index];
    }
    /**
     * Gets the first element of an array.
     * @param array An array.
     * @returns The first element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static first(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[0];
    }
    /**
     * Gets the first element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The first element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekFirst(array) {
        return array[0];
    }
    /**
     * Gets the last element of an array.
     * @param array An array.
     * @returns The last element of the specified array.
     * @throws RangeError if the array is empty.
     */
    static last(array) {
        if (array.length === 0) {
            throw new RangeError();
        }
        return array[array.length - 1];
    }
    /**
     * Gets the last element of an array if it is not empty, or `undefined` otherwise.
     * @param array An array.
     * @returns The last element of an array if it is not empty, or `undefined` otherwise.
     */
    static peekLast(array) {
        return array[array.length - 1];
    }
    /**
     * Checks if a certain element is included in an array.
     * @param array An array.
     * @param searchElement The element to search for.
     * @param fromIndex The position in this array at which to begin searching for `searchElement`.
     * @returns Whether the search element is included in the specified array.
     */
    static includes(array, searchElement, fromIndex) {
        return array.includes(searchElement, fromIndex);
    }
    /**
     * Checks if two arrays are equal to each other. This method considers two arrays `a` and `b` if their lengths are
     * equal and `a[i]` equals `b[i]` for every valid index `i`. All empty arrays are considered equal to one another.
     * @param a The first array.
     * @param b The second array.
     * @param equalsFunc The function to use to determine whether two array elements are equal to each other. Defaults
     * to a function which uses the strict equality operator (`===`).
     * @returns Whether the two specified arrays are equal.
     */
    static equals(a, b, equalsFunc = ArrayUtils.STRICT_EQUALS) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            if (!equalsFunc(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Creates a new array by mapping each element of an existing array using a mapping function, then flattening the
     * mapped elements to a maximum depth of one, leaving the original array intact.
     * @param array An array.
     * @param map A function which is called once on each element of the original array to map it to an arbitrary value.
     * @returns A new array which was created by mapping each element of the specified array, then flattening the mapped
     * elements to a maximum depth of one.
     */
    static flatMap(array, map) {
        const out = [];
        for (let i = 0; i < array.length; i++) {
            const mapped = map(array[i], i, array);
            if (Array.isArray(mapped)) {
                for (let j = 0; j < mapped.length; j++) {
                    out[out.length] = mapped[j];
                }
            }
            else {
                out[out.length] = mapped;
            }
        }
        return out;
    }
    /**
     * Creates a new array by flattening an existing array to a maximum depth, leaving the original array intact. The
     * process of flattening replaces each element in the array that is itself an array with the sequence of elements
     * found in the sub-array, recursively up to the maximum depth.
     * @param array An array.
     * @param depth The maximum depth to which to flatten. Values less than or equal to zero will result in no flattening
     * (in other words, a shallow copy of the original array will be returned). Defaults to `1`.
     * @returns A new array which was created by flattening the specified array to the specified maximum depth.
     */
    static flat(array, depth = 1) {
        const out = [];
        this.flatHelper(array, depth, 0, out);
        return out;
    }
    /**
     * Recursively flattens an array and writes the flattened sequence of elements into another array.
     * @param array The array to flatten.
     * @param maxDepth The maximum depth to which to flatten.
     * @param depth The current flattening depth.
     * @param out The array to which to write the flattened sequence of elements.
     */
    static flatHelper(array, maxDepth, depth, out) {
        for (let i = 0; i < array.length; i++) {
            const element = array[i];
            if (Array.isArray(element) && depth < maxDepth) {
                this.flatHelper(element, maxDepth, depth + 1, out);
            }
            else {
                out[out.length] = element;
            }
        }
    }
    /**
     * Performs a shallow copy of an array. After the operation is complete, the target array will have the same
     * length and the same elements in the same order as the source array.
     * @param source The array to copy.
     * @param target The array to copy into. If not defined, a new array will be created.
     * @returns The target array, after the source array has been copied into it.
     */
    static shallowCopy(source, target = []) {
        target.length = source.length;
        for (let i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        return target;
    }
    /**
     * Performs a binary search on a sorted array to find the index of the first or last element in the array whose
     * sorting order is equal to a query element. If no such element in the array exists, `-(index + 1)` is returned,
     * where `index` is the index at which the query element would be found if it were contained in the sorted array.
     * @param array An array.
     * @param element The element to search for.
     * @param comparator A function which determines the sorting order of elements in the array. The function should
     * return a negative number if the first element is to be sorted before the second, a positive number if the first
     * element is to be sorted after the second, or zero if both elements are to be sorted equivalently.
     * @param first If `true`, this method will find the first (lowest) matching index if there are multiple matching
     * indexes, otherwise this method will find the last (highest) matching index. Defaults to `true`.
     * @returns The index of the first (if `first` is `true`) or last (if `first` is `false`) element in the specified
     * array whose sorting order is equal to the query element, or `-(index + 1)`, where `index` is the index at which
     * the query element would be found if it were contained in the sorted array, if no element in the array has a
     * sorting order equal to the query.
     */
    static binarySearch(array, element, comparator, first = true) {
        let min = 0;
        let max = array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = comparator(element, array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < array.length && comparator(element, array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Gets the length of the longest string in the array.
     * @param array The array to search in.
     * @returns length of the longest string
     */
    static getMaxStringLength(array) {
        return array.reduce((accum, curr) => curr.length > accum ? curr.length : accum, 0);
    }
}
ArrayUtils.STRICT_EQUALS = (a, b) => a === b;

/** A collection of helper functions dealing with radios and frequencies. */
class RadioUtils {
    /**
     * Checks whether a frequency is a NAV frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a NAV frequency.
     */
    static isNavFrequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 108e3 || freqKhz > 117950) {
            return false;
        }
        return freqKhz % 50 === 0;
    }
    /**
     * Checks if frequency is a localizer frequency based on the number.
     * @param freq The frequency to check, in megahertz.
     * @returns True if frequency is between 108.1 and 111.95 MHz (inclusive) and the tenths place is odd.
     */
    static isLocalizerFrequency(freq) {
        return freq >= 108.1 && freq <= 111.95 && (Math.trunc(freq * 10) % 2 === 1);
    }
    /**
     * Checks whether a frequency is a 8.33 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 8.33 kHz-spacing COM frequency.
     */
    static isCom833Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136990) {
            return false;
        }
        return RadioUtils.COM_833_ENDINGS.includes(freqKhz % 50);
    }
    /**
     * Checks whether a frequency is a 25 kHz-spacing COM frequency.
     * @param freq The frequency to check, in megahertz.
     * @returns Whether the specified frequency is a 25 kHz-spacing COM frequency.
     */
    static isCom25Frequency(freq) {
        const freqKhz = Math.round(freq * 1000);
        if (freqKhz < 118e3 || freqKhz > 136975) {
            return false;
        }
        return freqKhz % 25 === 0;
    }
    /**
     * Checks whether a frequency is an ADF frequency.
     * @param freq The frequency to check, in kilohertz.
     * @returns Whether the specified frequency is an ADF frequency.
     */
    static isAdfFrequency(freq) {
        const freqHz = Math.round(freq * 1000);
        if (freqHz < 190e3 || freqHz > 1799500) {
            return false;
        }
        return freqHz % 500 === 0;
    }
}
RadioUtils.COM_833_ENDINGS = [5, 10, 15, 30, 35, 40];

/**
 * VOR signal to/from flags.
 */
var VorToFrom;
(function (VorToFrom) {
    VorToFrom[VorToFrom["OFF"] = 0] = "OFF";
    VorToFrom[VorToFrom["TO"] = 1] = "TO";
    VorToFrom[VorToFrom["FROM"] = 2] = "FROM";
})(VorToFrom || (VorToFrom = {}));
/** Marker beacon signal state. */
var MarkerBeaconState;
(function (MarkerBeaconState) {
    MarkerBeaconState[MarkerBeaconState["Inactive"] = 0] = "Inactive";
    MarkerBeaconState[MarkerBeaconState["Outer"] = 1] = "Outer";
    MarkerBeaconState[MarkerBeaconState["Middle"] = 2] = "Middle";
    MarkerBeaconState[MarkerBeaconState["Inner"] = 3] = "Inner";
})(MarkerBeaconState || (MarkerBeaconState = {}));
/**
 * A publisher of NAV, COM, ADF radio and marker beacon tuning-related sim var events.
 */
class NavComSimVarPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of NavComSimVarPublisher.
     * @param bus The event bus to which to publish.
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ...NavComSimVarPublisher.createNavRadioDefinitions(),
            ...NavComSimVarPublisher.createComRadioDefinitions(),
            ...NavComSimVarPublisher.createAdfRadioDefinitions(),
            ...NavComSimVarPublisher.createMarkerBeaconDefinitions(),
            ...NavComSimVarPublisher.createGpsDefinitions()
        ]);
        super(simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions.
     * @returns An array of nav radio sim var event definitions.
     */
    static createNavRadioDefinitions() {
        return [
            ['nav_active_frequency', { name: 'NAV ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_standby_frequency', { name: 'NAV STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_signal', { name: 'NAV SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_sound', { name: 'NAV SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_ident', { name: 'NAV IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_volume', { name: 'NAV VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_obs', { name: 'NAV OBS:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_dme', { name: 'NAV HAS DME:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_has_nav', { name: 'NAV HAS NAV:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_cdi', { name: 'NAV CDI:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme', { name: 'NAV DME:#index#', type: SimVarValueType.NM, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial', { name: 'NAV RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_radial_error', { name: 'NAV RADIAL ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_to_from', { name: 'NAV TOFROM:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer', { name: 'NAV HAS LOCALIZER:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_localizer_crs', { name: 'NAV LOCALIZER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_airport_ident', { name: 'NAV LOC AIRPORT IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_designator', { name: 'NAV LOC RUNWAY DESIGNATOR:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_loc_runway_number', { name: 'NAV LOC RUNWAY NUMBER:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_glideslope', { name: 'NAV HAS GLIDE SLOPE:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_error', { name: 'NAV GLIDE SLOPE ERROR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_raw_gs', { name: 'NAV RAW GLIDE SLOPE:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_lla', { name: 'NAV VOR LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_dme_lla', { name: 'NAV DME LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_gs_lla', { name: 'NAV GS LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['nav_magvar', { name: 'NAV MAGVAR:#index#', type: SimVarValueType.Degree, indexed: [1, 2, 3, 4], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of com radio sim var event definitions.
     * @returns An array of com radio sim var event definitions.
     */
    static createComRadioDefinitions() {
        return [
            ['com_active_frequency', { name: 'COM ACTIVE FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_standby_frequency', { name: 'COM STANDBY FREQUENCY:#index#', type: SimVarValueType.MHz, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_name', { name: 'COM ACTIVE FREQ NAME:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_type', { name: 'COM ACTIVE FREQ TYPE:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_active_facility_ident', { name: 'COM ACTIVE FREQ IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2, 3], defaultIndex: null }],
            // Note: 'COM RECEIVE' is whether the radio is receiving OR transmitting,
            // whereas 'COM RECEIVE EX1' is exclusively its receiving state.
            ['com_receive', { name: 'COM RECEIVE EX1:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_status', { name: 'COM STATUS:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_transmit', { name: 'COM TRANSMIT:#index#', type: SimVarValueType.Bool, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_spacing_mode', { name: 'COM SPACING MODE:#index#', type: SimVarValueType.Enum, indexed: [1, 2, 3], defaultIndex: null }],
            ['com_volume', { name: 'COM VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2, 3], defaultIndex: null }],
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions.
     * @returns An array of ADF radio sim var event definitions.
     */
    static createAdfRadioDefinitions() {
        return [
            ['adf_active_frequency', { name: 'ADF ACTIVE FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_standby_frequency', { name: 'ADF STANDBY FREQUENCY:#index#', type: SimVarValueType.KHz, indexed: [1, 2], defaultIndex: null }],
            ['adf_sound', { name: 'ADF SOUND:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['adf_volume', { name: 'ADF VOLUME:#index#', type: SimVarValueType.Percent, indexed: [1, 2], defaultIndex: null }],
            ['adf_ident', { name: 'ADF IDENT:#index#', type: SimVarValueType.String, indexed: [1, 2], defaultIndex: null }],
            ['adf_signal', { name: 'ADF SIGNAL:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['adf_bearing', { name: 'ADF RADIAL:#index#', type: SimVarValueType.Degree, indexed: [1, 2], defaultIndex: null }],
            ['adf_lla', { name: 'ADF LATLONALT:#index#', type: SimVarValueType.LLA, indexed: [1, 2], defaultIndex: null }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createMarkerBeaconDefinitions() {
        return [
            ['marker_beacon_hisense_on', { name: 'MARKER BEACON SENSITIVITY HIGH', type: SimVarValueType.Bool }],
            ['marker_beacon_sound', { name: 'MARKER SOUND', type: SimVarValueType.Bool }],
            ['marker_beacon_state', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
            ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }]
        ];
    }
    /**
     * Creates an array of GPS sim var event definitions.
     * @returns An array of GPS sim var event definitions.
     */
    static createGpsDefinitions() {
        return [
            ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
            ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
            ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
            ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
            ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
            ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
            ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
        ];
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher of nav radio, ADF radio, GPS, and marker beacon-related sim var events.
 *
 * @deprecated Please use `NavComSimVarPublisher` instead.
 */
class NavProcSimVarPublisher extends SimVarPublisher {
    /**
     * Create a NavProcSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(NavProcSimVarPublisher.simvars, bus, pacer);
    }
    /**
     * Creates an array of nav radio sim var event definitions for an indexed nav radio.
     * @param index The index of the nav radio.
     * @returns An array of nav radio sim var event definitions for the specified nav radio.
     */
    static createNavRadioDefinitions(index) {
        return [
            [`nav_signal_${index}`, { name: `NAV SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`nav_obs_${index}`, { name: `NAV OBS:${index}`, type: SimVarValueType.Degree }],
            [`nav_has_dme_${index}`, { name: `NAV HAS DME:${index}`, type: SimVarValueType.Bool }],
            [`nav_has_nav_${index}`, { name: `NAV HAS NAV:${index}`, type: SimVarValueType.Bool }],
            [`nav_cdi_${index}`, { name: `NAV CDI:${index}`, type: SimVarValueType.Number }],
            [`nav_dme_${index}`, { name: `NAV DME:${index}`, type: SimVarValueType.NM }],
            [`nav_radial_${index}`, { name: `NAV RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`nav_radial_error_${index}`, { name: `NAV RADIAL ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_ident_${index}`, { name: `NAV IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_to_from_${index}`, { name: `NAV TOFROM:${index}`, type: SimVarValueType.Enum }],
            [`nav_localizer_${index}`, { name: `NAV HAS LOCALIZER:${index}`, type: SimVarValueType.Bool }],
            [`nav_localizer_crs_${index}`, { name: `NAV LOCALIZER:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_airport_ident_${index}`, { name: `NAV LOC AIRPORT IDENT:${index}`, type: SimVarValueType.String }],
            [`nav_loc_runway_designator_${index}`, { name: `NAV LOC RUNWAY DESIGNATOR:${index}`, type: SimVarValueType.Number }],
            [`nav_loc_runway_number_${index}`, { name: `NAV LOC RUNWAY NUMBER:${index}`, type: SimVarValueType.Number }],
            [`nav_glideslope_${index}`, { name: `NAV HAS GLIDE SLOPE:${index}`, type: SimVarValueType.Bool }],
            [`nav_gs_error_${index}`, { name: `NAV GLIDE SLOPE ERROR:${index}`, type: SimVarValueType.Degree }],
            [`nav_raw_gs_${index}`, { name: `NAV RAW GLIDE SLOPE:${index}`, type: SimVarValueType.Degree }],
            [`nav_lla_${index}`, { name: `NAV VOR LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_dme_lla_${index}`, { name: `NAV DME LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_gs_lla_${index}`, { name: `NAV GS LATLONALT:${index}`, type: SimVarValueType.LLA }],
            [`nav_magvar_${index}`, { name: `NAV MAGVAR:${index}`, type: SimVarValueType.Degree }]
        ];
    }
    /**
     * Creates an array of ADF radio sim var event definitions for an indexed ADF radio.
     * @param index The index of the ADF radio.
     * @returns An array of ADF radio sim var event definitions for the specified ADF radio.
     */
    static createAdfRadioDefinitions(index) {
        return [
            [`adf_signal_${index}`, { name: `ADF SIGNAL:${index}`, type: SimVarValueType.Number }],
            [`adf_bearing_${index}`, { name: `ADF RADIAL:${index}`, type: SimVarValueType.Degree }],
            [`adf_lla_${index}`, { name: `ADF LATLONALT:${index}`, type: SimVarValueType.LLA }]
        ];
    }
}
NavProcSimVarPublisher.simvars = new Map([
    ...NavProcSimVarPublisher.createNavRadioDefinitions(1),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(2),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(3),
    ...NavProcSimVarPublisher.createNavRadioDefinitions(4),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(1),
    ...NavProcSimVarPublisher.createAdfRadioDefinitions(2),
    ['gps_dtk', { name: 'GPS WP DESIRED TRACK', type: SimVarValueType.Degree }],
    ['gps_xtk', { name: 'GPS WP CROSS TRK', type: SimVarValueType.NM }],
    ['gps_wp', { name: 'GPS WP NEXT ID', type: SimVarValueType.NM }],
    ['gps_wp_bearing', { name: 'GPS WP BEARING', type: SimVarValueType.Degree }],
    ['gps_wp_distance', { name: 'GPS WP DISTANCE', type: SimVarValueType.NM }],
    ['mkr_bcn_state_simvar', { name: 'MARKER BEACON STATE', type: SimVarValueType.Number }],
    ['gps_obs_active_simvar', { name: 'GPS OBS ACTIVE', type: SimVarValueType.Bool }],
    ['gps_obs_value_simvar', { name: 'GPS OBS VALUE', type: SimVarValueType.Degree }]
]);
//
// Navigation event configurations
//
var NavSourceType;
(function (NavSourceType) {
    NavSourceType[NavSourceType["Nav"] = 0] = "Nav";
    NavSourceType[NavSourceType["Gps"] = 1] = "Gps";
    NavSourceType[NavSourceType["Adf"] = 2] = "Adf";
})(NavSourceType || (NavSourceType = {}));

/**
 * An instrument that gathers localizer and glideslope information for use by
 * the AP systems.
 *
 * Requires that the topics defined in {@link NavComEvents} are published to the event bus.
 */
class APRadioNavInstrument {
    /**
     * Creates an instance of the APRadioNavInstrument.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.bus = bus;
        this.navRadioData = ArrayUtils.create(5, index => {
            index = Math.max(1, index);
            return {
                gsLocation: new LatLongAlt(0, 0),
                navLocation: new LatLongAlt(0, 0),
                glideslope: this.createEmptyGlideslope({ index, type: NavSourceType.Nav }),
                localizer: this.createEmptyLocalizer({ index, type: NavSourceType.Nav }),
                cdi: this.createEmptyCdi({ index, type: NavSourceType.Nav }),
                obs: this.createEmptyObs({ index, type: NavSourceType.Nav }),
                radialError: 0,
                magVar: 0
            };
        });
        this.currentCdiIndex = 1;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    init() {
        const navComSubscriber = this.bus.getSubscriber();
        for (let i = 1; i < 5; i++) {
            navComSubscriber.on(`nav_glideslope_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_gs_lla_${i}`).handle(this.setGlideslopePosition.bind(this, i));
            navComSubscriber.on(`nav_gs_error_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_raw_gs_${i}`).whenChanged().handle(this.setGlideslopeValue.bind(this, i, 'gsAngle'));
            navComSubscriber.on(`nav_localizer_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'isValid'));
            navComSubscriber.on(`nav_localizer_crs_${i}`).whenChanged().handle(this.setLocalizerValue.bind(this, i, 'course'));
            navComSubscriber.on(`nav_cdi_${i}`).whenChanged().handle(this.setCDIValue.bind(this, i, 'deviation'));
            navComSubscriber.on(`nav_has_nav_${i}`).whenChanged().handle(hasNav => !hasNav && this.setCDIValue(i, 'deviation', null));
            navComSubscriber.on(`nav_obs_${i}`).whenChanged().handle(this.setOBSValue.bind(this, i, 'heading'));
            navComSubscriber.on(`nav_lla_${i}`).handle(this.setNavPosition.bind(this, i));
            navComSubscriber.on(`nav_radial_error_${i}`).whenChanged().handle(this.setRadialError.bind(this, i));
            navComSubscriber.on(`nav_magvar_${i}`).whenChanged().handle(this.setMagVar.bind(this, i));
        }
        const navEvents = this.bus.getSubscriber();
        navEvents.on('cdi_select').handle(source => {
            const oldIndex = this.currentCdiIndex;
            this.currentCdiIndex = source.type === NavSourceType.Nav ? source.index : 0;
            if (oldIndex !== this.currentCdiIndex) {
                const data = this.navRadioData[this.currentCdiIndex];
                this.publisher.pub('nav_radio_active_gs_location', data.gsLocation);
                this.publisher.pub('nav_radio_active_nav_location', data.navLocation);
                this.publisher.pub('nav_radio_active_glideslope', data.glideslope);
                this.publisher.pub('nav_radio_active_localizer', data.localizer);
                this.publisher.pub('nav_radio_active_cdi_deviation', data.cdi);
                this.publisher.pub('nav_radio_active_obs_setting', data.obs);
                this.publisher.pub('nav_radio_active_radial_error', data.radialError);
                this.publisher.pub('nav_radio_active_magvar', data.magVar);
            }
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // noop
    }
    /**
     * Sets a value in a nav radio glideslope.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setGlideslopeValue(index, field, value) {
        this.navRadioData[index].glideslope[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_glideslope', this.navRadioData[index].glideslope);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_glideslope_1', this.navRadioData[index].glideslope);
                break;
            case 2:
                this.publisher.pub('nav_radio_glideslope_2', this.navRadioData[index].glideslope);
                break;
            case 3:
                this.publisher.pub('nav_radio_glideslope_3', this.navRadioData[index].glideslope);
                break;
            case 4:
                this.publisher.pub('nav_radio_glideslope_4', this.navRadioData[index].glideslope);
                break;
        }
    }
    /**
     * Sends the current glideslope's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setGlideslopePosition(index, lla) {
        this.navRadioData[index].gsLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_gs_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_gs_location_1', this.navRadioData[index].gsLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_gs_location_2', this.navRadioData[index].gsLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_gs_location_3', this.navRadioData[index].gsLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_gs_location_4', this.navRadioData[index].gsLocation);
                break;
        }
    }
    /**
     * Sends the current nav's LLA position.
     * @param index The index of the nav radio.
     * @param lla The LLA to send.
     */
    setNavPosition(index, lla) {
        this.navRadioData[index].navLocation = lla;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_nav_location', lla);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_nav_location_1', this.navRadioData[index].navLocation);
                break;
            case 2:
                this.publisher.pub('nav_radio_nav_location_2', this.navRadioData[index].navLocation);
                break;
            case 3:
                this.publisher.pub('nav_radio_nav_location_3', this.navRadioData[index].navLocation);
                break;
            case 4:
                this.publisher.pub('nav_radio_nav_location_4', this.navRadioData[index].navLocation);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setLocalizerValue(index, field, value) {
        this.navRadioData[index].localizer[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_localizer', this.navRadioData[index].localizer);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_localizer_1', this.navRadioData[index].localizer);
                break;
            case 2:
                this.publisher.pub('nav_radio_localizer_2', this.navRadioData[index].localizer);
                break;
            case 3:
                this.publisher.pub('nav_radio_localizer_3', this.navRadioData[index].localizer);
                break;
            case 4:
                this.publisher.pub('nav_radio_localizer_4', this.navRadioData[index].localizer);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setCDIValue(index, field, value) {
        this.navRadioData[index].cdi[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_cdi_deviation', this.navRadioData[index].cdi);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_cdi_1', this.navRadioData[index].cdi);
                break;
            case 2:
                this.publisher.pub('nav_radio_cdi_2', this.navRadioData[index].cdi);
                break;
            case 3:
                this.publisher.pub('nav_radio_cdi_3', this.navRadioData[index].cdi);
                break;
            case 4:
                this.publisher.pub('nav_radio_cdi_4', this.navRadioData[index].cdi);
                break;
        }
    }
    /**
     * Sets a value in a nav radio localizer.
     * @param index The index of the nav radio.
     * @param field The field to set.
     * @param value The value to set the field to.
     */
    setOBSValue(index, field, value) {
        this.navRadioData[index].obs[field] = value;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_obs_setting', this.navRadioData[index].obs);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_obs_1', this.navRadioData[index].obs);
                break;
            case 2:
                this.publisher.pub('nav_radio_obs_2', this.navRadioData[index].obs);
                break;
            case 3:
                this.publisher.pub('nav_radio_obs_3', this.navRadioData[index].obs);
                break;
            case 4:
                this.publisher.pub('nav_radio_obs_4', this.navRadioData[index].obs);
                break;
        }
    }
    /**
     * Sets the radial error of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param radialError The radial error to set.
     */
    setRadialError(index, radialError) {
        this.navRadioData[index].radialError = radialError;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_radial_error', radialError);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_radial_error_1', this.navRadioData[index].radialError);
                break;
            case 2:
                this.publisher.pub('nav_radio_radial_error_2', this.navRadioData[index].radialError);
                break;
            case 3:
                this.publisher.pub('nav_radio_radial_error_3', this.navRadioData[index].radialError);
                break;
            case 4:
                this.publisher.pub('nav_radio_radial_error_4', this.navRadioData[index].radialError);
                break;
        }
    }
    /**
     * Sets the magnetic variation of a nav radio signal source.
     * @param index The index of the nav radio.
     * @param magVar The magvar to set.
     */
    setMagVar(index, magVar) {
        magVar = NavMath.normalizeHeading(-magVar + 180) % 360 - 180;
        this.navRadioData[index].magVar = magVar;
        if (this.currentCdiIndex === index) {
            this.publisher.pub('nav_radio_active_magvar', magVar);
        }
        switch (index) {
            case 1:
                this.publisher.pub('nav_radio_magvar_1', this.navRadioData[index].magVar);
                break;
            case 2:
                this.publisher.pub('nav_radio_magvar_2', this.navRadioData[index].magVar);
                break;
            case 3:
                this.publisher.pub('nav_radio_magvar_3', this.navRadioData[index].magVar);
                break;
            case 4:
                this.publisher.pub('nav_radio_magvar_4', this.navRadioData[index].magVar);
                break;
        }
    }
    /**
     * Creates an empty localizer data.
     * @param id The nav source ID.
     * @returns New empty localizer data.
     */
    createEmptyLocalizer(id) {
        return {
            isValid: false,
            course: 0,
            source: id
        };
    }
    /**
     * Creates an empty glideslope data.
     * @param id The nav source ID.
     * @returns New empty glideslope data.
     */
    createEmptyGlideslope(id) {
        return {
            isValid: false,
            gsAngle: 0,
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty CDI data.
     * @param id The nav source ID.
     * @returns New empty CDI data.
     */
    createEmptyCdi(id) {
        return {
            deviation: 0,
            source: id
        };
    }
    /**
     * Creates an empty OBS data.
     * @param id The nav source ID.
     * @returns New empty OBS data.
     */
    createEmptyObs(id) {
        return {
            heading: 0,
            source: id
        };
    }
}

/**
 * InstrumentBackplane provides a common control point for aggregating and
 * managing any number of publishers.  This can be used as an "update loop"
 * corral", amongst other things.
 */
class InstrumentBackplane {
    /**
     * Create an InstrumentBackplane
     */
    constructor() {
        this.publishers = new Map();
        this.instruments = new Map();
    }
    /**
     * Initialize all the things. This is initially just a proxy for the
     * private initPublishers() and initInstruments() methods.
     *
     * This should be simplified.
     */
    init() {
        this.initPublishers();
        this.initInstruments();
    }
    /**
     * Update all the things.  This is initially just a proxy for the private
     * updatePublishers() and updateInstruments() methods.
     *
     * This should be simplified.
     */
    onUpdate() {
        this.updatePublishers();
        this.updateInstruments();
    }
    /**
     * Add a publisher to this backplane.
     * @param name A symbolic name for the publisher for reference.
     * @param publisher The publisher to add.
     * @param override Whether to override any existing publishers added to this backplane under the same name. If
     * `true`, any existing publisher with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new publisher will not be added if this backplane already has a publisher with the same
     * name or a publisher of the same type. Defaults to `false`.
     */
    addPublisher(name, publisher, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, publisher, this.publishers)) {
            this.publishers.set(name, publisher);
        }
    }
    /**
     * Add an instrument to this backplane.
     * @param name A symbolic name for the instrument for reference.
     * @param instrument The instrument to add.
     * @param override Whether to override any existing instruments added to this backplane under the same name. If
     * `true`, any existing instrument with the same name will removed from this backplane and the new one added in its
     * place. If `false`, the new instrument will not be added if this backplane already has an instrument with the same
     * name or an instrument of the same type. Defaults to `false`.
     */
    addInstrument(name, instrument, override = false) {
        if (override || !InstrumentBackplane.checkAlreadyExists(name, instrument, this.instruments)) {
            this.instruments.set(name, instrument);
        }
    }
    /**
     * Gets a publisher from this backplane.
     * @param name The name of the publisher to get.
     * @returns The publisher in this backplane with the specified name, or `undefined` if there is no such publisher.
     */
    getPublisher(name) {
        return this.publishers.get(name);
    }
    /**
     * Gets an instrument from this backplane.
     * @param name The name of the instrument to get.
     * @returns The instrument in this backplane with the specified name, or `undefined` if there is no such instrument.
     */
    getInstrument(name) {
        return this.instruments.get(name);
    }
    /**
     * Checks for duplicate publishers or instruments of the same name or type.
     * @param name the name of the publisher or instrument
     * @param objToCheck the object to check
     * @param map the map to check
     * @returns true if the object is already in the map
     */
    static checkAlreadyExists(name, objToCheck, map) {
        if (map.has(name)) {
            console.warn(`${name} already exists in backplane.`);
            return true;
        }
        // check if there already is a publisher with the same type
        for (const p of map.values()) {
            if (p.constructor === objToCheck.constructor) {
                console.warn(`${name} already exists in backplane.`);
                return true;
            }
        }
        return false;
    }
    /**
     * Initialize all of the publishers that you hold.
     */
    initPublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.startPublish();
        }
    }
    /**
     * Initialize all of the instruments that you hold.
     */
    initInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.init();
        }
    }
    /**
     * Update all of the publishers that you hold.
     */
    updatePublishers() {
        for (const publisher of this.publishers.values()) {
            publisher.onUpdate();
        }
    }
    /**
     * Update all of the instruments that you hold.
     */
    updateInstruments() {
        for (const instrument of this.instruments.values()) {
            instrument.onUpdate();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Brake information.
 */
class BrakeSimvarPublisher extends SimVarPublisher {
    /**
     * Create a BrakePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['brake_position_left', { name: 'BRAKE LEFT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_right', { name: 'BRAKE RIGHT POSITION', type: SimVarValueType.Percent }],
            ['brake_position_left_raw', { name: 'BRAKE LEFT POSITION EX1', type: SimVarValueType.Percent }],
            ['brake_position_right_raw', { name: 'BRAKE RIGHT POSITION EX1', type: SimVarValueType.Percent }],
            ['left_wheel_rpm', { name: 'LEFT WHEEL RPM', type: SimVarValueType.RPM }],
            ['right_wheel_rpm', { name: 'RIGHT WHEEL RPM', type: SimVarValueType.RPM }],
            ['parking_brake_set', { name: 'BRAKE PARKING POSITION', type: SimVarValueType.Bool }],
            ['autobrake_switch_pos', { name: 'AUTO BRAKE SWITCH CB', type: SimVarValueType.Number }],
            ['autobrake_active', { name: 'AUTOBRAKES ACTIVE', type: SimVarValueType.Bool }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * A publisher of clock events.
 */
class ClockPublisher extends BasePublisher {
    /**
     * Creates a new instance of ClockPublisher.
     * @param bus The event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(bus, pacer) {
        super(bus, pacer);
        this.needPublishRealTime = false;
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['simTime', { name: 'E:ABSOLUTE TIME', type: SimVarValueType.Seconds, map: ClockPublisher.absoluteTimeToUNIXTime }],
            ['simRate', { name: 'E:SIMULATION RATE', type: SimVarValueType.Number }]
        ]), bus, pacer);
        if (this.bus.getTopicSubscriberCount('realTime') > 0) {
            this.needPublishRealTime = true;
        }
        else {
            const sub = this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
                if (topic === 'realTime') {
                    this.needPublishRealTime = true;
                    sub.destroy();
                }
            }, true);
            sub.resume();
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
        if (this.hiFreqInterval === undefined) {
            this.hiFreqInterval = setInterval(() => this.publish('simTimeHiFreq', ClockPublisher.absoluteTimeToUNIXTime(SimVar.GetSimVarValue('E:ABSOLUTE TIME', 'seconds'))), 0);
        }
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
        if (this.hiFreqInterval !== undefined) {
            clearInterval(this.hiFreqInterval);
            this.hiFreqInterval = undefined;
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.needPublishRealTime) {
            this.publish('realTime', Date.now());
        }
        this.simVarPublisher.onUpdate();
    }
    /**
     * Converts the sim's absolute time to a UNIX timestamp. The sim's absolute time value is equivalent to a .NET
     * DateTime.Ticks value (epoch = 00:00:00 01 Jan 0001).
     * @param absoluteTime an absolute time value, in units of seconds.
     * @returns the UNIX timestamp corresponding to the absolute time value.
     */
    static absoluteTimeToUNIXTime(absoluteTime) {
        return (absoluteTime - 62135596800) * 1000;
    }
}
/**
 * A clock which keeps track of real-world and sim time.
 */
class Clock {
    /**
     * Constructor.
     * @param bus The event bus to use to publish events from this clock.
     */
    constructor(bus) {
        this.publisher = new ClockPublisher(bus);
    }
    /**
     * Initializes this clock.
     */
    init() {
        this.publisher.startPublish();
    }
    /**
     * Updates this clock.
     */
    onUpdate() {
        this.publisher.onUpdate();
    }
}

/**
 * A publisher for control surfaces information.
 */
class ControlSurfacesPublisher extends SimVarPublisher {
    /**
     * Create an ControlSurfacesPublisher.
     * @param bus The EventBus to publish to.
     * @param gearCount The number of landing gear to support.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, gearCount, pacer) {
        const nonIndexedSimVars = [
            ['flaps_handle_index', { name: 'FLAPS HANDLE INDEX', type: SimVarValueType.Number }],
            ['flaps_left_angle', { name: 'TRAILING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_right_angle', { name: 'TRAILING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['flaps_left_percent', { name: 'TRAILING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['flaps_right_percent', { name: 'TRAILING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['slats_left_angle', { name: 'LEADING EDGE FLAPS LEFT ANGLE', type: SimVarValueType.Degree }],
            ['slats_right_angle', { name: 'LEADING EDGE FLAPS RIGHT ANGLE', type: SimVarValueType.Degree }],
            ['slats_left_percent', { name: 'LEADING EDGE FLAPS LEFT PERCENT', type: SimVarValueType.Percent }],
            ['slats_right_percent', { name: 'LEADING EDGE FLAPS RIGHT PERCENT', type: SimVarValueType.Percent }],
            ['spoilers_left_percent', { name: 'SPOILERS LEFT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_right_percent', { name: 'SPOILERS RIGHT POSITION', type: SimVarValueType.Percent }],
            ['spoilers_without_spoilerons_left_percent', { name: 'SPOILERS WITHOUT SPOILERONS LEFT POSITION', type: SimVarValueType.Percent }],
            ['elevator_trim_angle', { name: 'ELEVATOR TRIM POSITION', type: SimVarValueType.Degree }],
            ['elevator_trim_pct', { name: 'ELEVATOR TRIM PCT', type: SimVarValueType.Percent }],
            ['elevator_trim_neutral_pct', { name: 'AIRCRAFT ELEVATOR TRIM NEUTRAL', type: SimVarValueType.Percent }],
            ['aileron_trim_angle', { name: 'AILERON TRIM', type: SimVarValueType.Degree }],
            ['aileron_trim_pct', { name: 'AILERON TRIM PCT', type: SimVarValueType.Percent }],
            ['rudder_trim_angle', { name: 'RUDDER TRIM', type: SimVarValueType.Degree }],
            ['rudder_trim_pct', { name: 'RUDDER TRIM PCT', type: SimVarValueType.Percent }],
            ['aileron_left_percent', { name: 'AILERON LEFT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['aileron_right_percent', { name: 'AILERON RIGHT DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['elevator_percent', { name: 'ELEVATOR DEFLECTION PCT', type: SimVarValueType.Percent }],
            ['rudder_percent', { name: 'RUDDER DEFLECTION PCT', type: SimVarValueType.Percent }]
        ];
        const gearIndexedSimVars = [
            ['gear_position', { name: 'GEAR POSITION', type: SimVarValueType.Number }],
            ['gear_is_on_ground', { name: 'GEAR IS ON GROUND', type: SimVarValueType.Bool }]
        ];
        const simvars = new Map(nonIndexedSimVars);
        // set un-indexed simvar topics to pull from index 0
        for (const [topic, simvar] of [...gearIndexedSimVars]) {
            simvars.set(`${topic}`, {
                name: `${simvar.name}:0`,
                type: simvar.type,
                map: simvar.map
            });
        }
        // add landing gear indexed simvar topics
        // HINT: for some reason index 0 is nose. not 1-based.
        gearCount = Math.max(gearCount, 1);
        for (let i = 0; i < gearCount; i++) {
            for (const [topic, simvar] of gearIndexedSimVars) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * An event bus that can be used to publish data from backend
 * components and devices to consumers.
 */
class EventBus {
    /**
     * Creates an instance of an EventBus.
     * @param useAlternativeEventSync Whether or not to use generic listener event sync (default false).
     * If true, FlowEventSync will only work for gauges.
     * @param shouldResync Whether the eventbus should ask for a resync of all previously cached events (default true)
     */
    constructor(useAlternativeEventSync = false, shouldResync = true) {
        this._topicSubsMap = new Map();
        this._wildcardSubs = new Array();
        this._notifyDepthMap = new Map();
        this._wildcardNotifyDepth = 0;
        this._eventCache = new Map();
        this.onWildcardSubDestroyedFunc = this.onWildcardSubDestroyed.bind(this);
        this._busId = Math.floor(Math.random() * 2147483647);
        // fallback to flowevent when genericdatalistener not avail (su9)
        useAlternativeEventSync = (typeof RegisterGenericDataListener === 'undefined');
        const syncFunc = useAlternativeEventSync ? EventBusFlowEventSync : EventBusListenerSync;
        this._busSync = new syncFunc(this.pub.bind(this), this._busId);
        if (shouldResync === true) {
            this.syncEvent('event_bus', 'resync_request', false);
            this.on('event_bus', (data) => {
                if (data == 'resync_request') {
                    this.resyncEvents();
                }
            });
        }
    }
    /**
     * Subscribes to a topic on the bus.
     * @param topic The topic to subscribe to.
     * @param handler The handler to be called when an event happens.
     * @param paused Whether the new subscription should be initialized as paused. Defaults to `false`.
     * @returns The new subscription.
     */
    on(topic, handler, paused = false) {
        let subs = this._topicSubsMap.get(topic);
        if (subs === undefined) {
            this._topicSubsMap.set(topic, subs = []);
            this.pub('event_bus_topic_first_sub', topic, false, false);
        }
        const initialNotifyFunc = (sub) => {
            const lastState = this._eventCache.get(topic);
            if (lastState !== undefined) {
                sub.handler(lastState.data);
            }
        };
        const onDestroyFunc = (sub) => {
            var _a;
            // If we are not in the middle of a notify operation, remove the subscription.
            // Otherwise, do nothing and let the post-notify clean-up code handle it.
            if (((_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0) === 0) {
                const subsToSplice = this._topicSubsMap.get(topic);
                if (subsToSplice) {
                    subsToSplice.splice(subsToSplice.indexOf(sub), 1);
                }
            }
        };
        const sub = new HandlerSubscription(handler, initialNotifyFunc, onDestroyFunc);
        subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
    /**
     * Unsubscribes a handler from the topic's events.
     * @param topic The topic to unsubscribe from.
     * @param handler The handler to unsubscribe from topic.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by `.on()`
     * to manage subscriptions.
     */
    off(topic, handler) {
        const handlers = this._topicSubsMap.get(topic);
        const toDestroy = handlers === null || handlers === void 0 ? void 0 : handlers.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Subscribes to all topics.
     * @param handler The handler to subscribe to all events.
     * @returns The new subscription.
     */
    onAll(handler) {
        const sub = new HandlerSubscription(handler, undefined, this.onWildcardSubDestroyedFunc);
        this._wildcardSubs.push(sub);
        return sub;
    }
    /**
     * Unsubscribe the handler from all topics.
     * @param handler The handler to unsubscribe from all events.
     * @deprecated This method has been deprecated in favor of using the {@link Subscription} object returned by
     * `.onAll()` to manage subscriptions.
     */
    offAll(handler) {
        const toDestroy = this._wildcardSubs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Publishes an event to the topic on the bus.
     * @param topic The topic to publish to.
     * @param data The data portion of the event.
     * @param sync Whether or not this message needs to be synced on local stoage.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    pub(topic, data, sync = false, isCached = true) {
        var _a;
        if (isCached) {
            this._eventCache.set(topic, { data: data, synced: sync });
        }
        const subs = this._topicSubsMap.get(topic);
        if (subs !== undefined) {
            let needCleanUpSubs = false;
            const notifyDepth = (_a = this._notifyDepthMap.get(topic)) !== null && _a !== void 0 ? _a : 0;
            this._notifyDepthMap.set(topic, notifyDepth + 1);
            const len = subs.length;
            for (let i = 0; i < len; i++) {
                try {
                    const sub = subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(data);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`EventBus: error in handler: ${error}. topic: ${topic}. data: ${data}. sync: ${sync}. isCached: ${isCached}`, { error, topic, data, sync, isCached, subs });
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
            this._notifyDepthMap.set(topic, notifyDepth);
            if (needCleanUpSubs && notifyDepth === 0) {
                const filteredSubs = subs.filter(sub => sub.isAlive);
                this._topicSubsMap.set(topic, filteredSubs);
            }
        }
        // We don't know if anything is subscribed on busses in other instruments,
        // so we'll unconditionally sync if sync is true and trust that the
        // publisher knows what it's doing.
        if (sync) {
            this.syncEvent(topic, data, isCached);
        }
        // always push to wildcard handlers
        let needCleanUpSubs = false;
        this._wildcardNotifyDepth++;
        const wcLen = this._wildcardSubs.length;
        for (let i = 0; i < wcLen; i++) {
            const sub = this._wildcardSubs[i];
            if (sub.isAlive && !sub.isPaused) {
                sub.handler(topic, data);
            }
            needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
        }
        this._wildcardNotifyDepth--;
        if (needCleanUpSubs && this._wildcardNotifyDepth === 0) {
            this._wildcardSubs = this._wildcardSubs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a wildcard subscription is destroyed.
     * @param sub The destroyed subscription.
     */
    onWildcardSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this._wildcardNotifyDepth === 0) {
            this._wildcardSubs.splice(this._wildcardSubs.indexOf(sub), 1);
        }
    }
    /**
     * Re-sync all synced events
     */
    resyncEvents() {
        for (const [topic, event] of this._eventCache) {
            if (event.synced) {
                this.syncEvent(topic, event.data, true);
            }
        }
    }
    /**
     * Publish an event to the sync bus.
     * @param topic The topic to publish to.
     * @param data The data to publish.
     * @param isCached Whether or not this message will be resync'd across the bus on load.
     */
    syncEvent(topic, data, isCached) {
        this._busSync.sendEvent(topic, data, isCached);
    }
    /**
     * Gets a typed publisher from the event bus..
     * @returns The typed publisher.
     */
    getPublisher() {
        return this;
    }
    /**
     * Gets a typed subscriber from the event bus.
     * @returns The typed subscriber.
     */
    getSubscriber() {
        return new EventSubscriber(this);
    }
    /**
     * Get the number of subscribes for a given topic.
     * @param topic The name of the topic.
     * @returns The number of subscribers.
     **/
    getTopicSubscriberCount(topic) {
        var _a, _b;
        return (_b = (_a = this._topicSubsMap.get(topic)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
    /**
     * Executes a function once for each topic with at least one subscriber.
     * @param fn The function to execute.
     */
    forEachSubscribedTopic(fn) {
        this._topicSubsMap.forEach((subs, topic) => { subs.length > 0 && fn(topic, subs.length); });
    }
}
/**
 * An abstract class for bus sync implementations.
 */
class EventBusSyncBase {
    /**
     * Creates an instance of EventBusFlowEventSync.
     * @param recvEventCb A callback to execute when an event is received on the bus.
     * @param busId The ID of the bus.
     */
    constructor(recvEventCb, busId) {
        this.isPaused = false;
        this.lastEventSynced = -1;
        this.dataPackageQueue = [];
        this.recvEventCb = recvEventCb;
        this.busId = busId;
        this.hookReceiveEvent();
        /** Sends the queued up data packages */
        const sendFn = () => {
            if (!this.isPaused && this.dataPackageQueue.length > 0) {
                // console.log(`Sending ${this.dataPackageQueue.length} packages`);
                const syncDataPackage = {
                    busId: this.busId,
                    packagedId: Math.floor(Math.random() * 1000000000),
                    data: this.dataPackageQueue
                };
                if (this.executeSync(syncDataPackage)) {
                    this.dataPackageQueue.length = 0;
                }
                else {
                    console.warn('Failed to send sync data package');
                }
            }
            requestAnimationFrame(sendFn);
        };
        requestAnimationFrame(sendFn);
    }
    /**
     * Processes events received and sends them onto the local bus.
     * @param syncData The data package to process.
     */
    processEventsReceived(syncData) {
        if (this.busId !== syncData.busId) {
            // HINT: coherent events are still received twice, so check for this
            if (this.lastEventSynced !== syncData.packagedId) {
                this.lastEventSynced = syncData.packagedId;
                syncData.data.forEach((data) => {
                    try {
                        this.recvEventCb(data.topic, data.data !== undefined ? data.data : undefined, false, data.isCached);
                    }
                    catch (e) {
                        console.error(e);
                        if (e instanceof Error) {
                            console.error(e.stack);
                        }
                    }
                });
            }
        }
    }
    /**
     * Sends an event via flow events.
     * @param topic The topic to send data on.
     * @param data The data to send.
     * @param isCached Whether or not this event is cached.
     */
    sendEvent(topic, data, isCached) {
        // stringify data
        const dataObj = data;
        // build a data package
        const dataPackage = {
            topic: topic,
            data: dataObj,
            isCached: isCached
        };
        // queue data package
        this.dataPackageQueue.push(dataPackage);
    }
}
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 * DON'T USE this, it has bad performance implications.
 * @deprecated
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars
class EventBusCoherentSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // HINT: Stringifying the data again to circumvent the bad perf on Coherent interop
        try {
            this.listener.triggerToAllSubscribers(EventBusCoherentSync.EB_KEY, JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        this.listener = RegisterViewListener(EventBusCoherentSync.EB_LISTENER_KEY, undefined, true);
        this.listener.on(EventBusCoherentSync.EB_KEY, (e) => {
            try {
                const evt = JSON.parse(e);
                this.processEventsReceived(evt);
            }
            catch (error) {
                console.error(error);
            }
        });
    }
}
EventBusCoherentSync.EB_KEY = 'eb.evt';
EventBusCoherentSync.EB_LISTENER_KEY = 'JS_LISTENER_SIMVARS';
/**
 * A class that manages event bus synchronization via Flow Event Triggers.
 */
class EventBusFlowEventSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        // console.log('Sending sync package: ' + syncDataPackage.packagedId);
        try {
            LaunchFlowEvent('ON_MOUSERECT_HTMLEVENT', EventBusFlowEventSync.EB_LISTENER_KEY, this.busId.toString(), JSON.stringify(syncDataPackage));
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        Coherent.on('OnInteractionEvent', (target, args) => {
            // identify if its a busevent
            if (args.length === 0 || args[0] !== EventBusFlowEventSync.EB_LISTENER_KEY || !args[2]) {
                return;
            }
            this.processEventsReceived(JSON.parse(args[2]));
        });
    }
}
EventBusFlowEventSync.EB_LISTENER_KEY = 'EB_EVENTS';
//// END GLOBALS DECLARATION
/**
 * A class that manages event bus synchronization via the Generic Data Listener.
 */
class EventBusListenerSync extends EventBusSyncBase {
    /** @inheritdoc */
    executeSync(syncDataPackage) {
        try {
            this.listener.send(EventBusListenerSync.EB_KEY, syncDataPackage);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /** @inheritdoc */
    hookReceiveEvent() {
        // pause the sync until the listener is ready
        this.isPaused = true;
        this.listener = RegisterGenericDataListener(() => {
            this.listener.onDataReceived(EventBusListenerSync.EB_KEY, (data) => {
                try {
                    this.processEventsReceived(data);
                }
                catch (error) {
                    console.error(error);
                }
            });
            this.isPaused = false;
        });
    }
}
EventBusListenerSync.EB_KEY = 'wt.eb.evt';
EventBusListenerSync.EB_LISTENER_KEY = 'JS_LISTENER_GENERICDATA';

/**
 * Captures the state of a value from a consumer.
 */
class ConsumerValue {
    /**
     * Creates an instance of a ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     */
    constructor(consumer, initialValue) {
        this.consumerHandler = (v) => { this.value = v; };
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialValue;
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused. While paused, this object's value will not update.
     */
    get isPaused() {
        return this._isPaused;
    }
    /**
     * Gets the current value.
     * @returns The current value.
     */
    get() {
        return this.value;
    }
    /**
     * Sets the consumer from which this object derives its value. If the consumer is null, this object's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This object, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.sub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this object. Once paused, this object's value will not be updated.
     * @returns This object, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this object. Once resumed, this object's value will be updated from consumed
     * events.
     * @returns This object, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /**
     * Destroys this object. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        this.isDestroyed = true;
        (_a = this.sub) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    /**
     * Creates a new ConsumerValue.
     * @param consumer The consumer to track.
     * @param initialValue The initial value.
     * @returns The created ConsumerValue.
     */
    static create(consumer, initialValue) {
        return new ConsumerValue(consumer, initialValue);
    }
}

/**
 * A publisher for publishing H:Events on the bus.
 */
class HEventPublisher extends BasePublisher {
    /**
     * Dispatches an H:Event to the event bus.
     * @param hEvent The H:Event to dispatch.
     * @param sync Whether this event should be synced (optional, default false)
     */
    dispatchHEvent(hEvent, sync = false) {
        // console.log(`dispaching hevent:  ${hEvent}`);
        this.publish('hEvent', hEvent, sync, false);
    }
}

/**
 * A subscribable subject which derives its value from an event consumer.
 */
class ConsumerSubject extends AbstractSubscribable {
    /**
     * Constructor.
     * @param consumer The event consumer from which this subject obtains its value. If null, this subject's value will
     * not be updated until its consumer is set to a non-null value.
     * @param initialVal This subject's initial value.
     * @param equalityFunc The function this subject uses check for equality between values.
     * @param mutateFunc The function this subject uses to change its value. If not defined, variable assignment is used
     * instead.
     */
    constructor(consumer, initialVal, equalityFunc, mutateFunc) {
        super();
        this.equalityFunc = equalityFunc;
        this.mutateFunc = mutateFunc;
        this.consumerHandler = this.onEventConsumed.bind(this);
        this._isPaused = false;
        this.isDestroyed = false;
        this.value = initialVal;
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether event consumption is currently paused for this subject. While paused, this subject's value will not
     * update.
     */
    get isPaused() {
        return this._isPaused;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static create(consumer, initialVal, equalityFunc, mutateFunc) {
        return new ConsumerSubject(consumer, initialVal, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, mutateFunc);
    }
    /**
     * Consumes an event.
     * @param value The value of the event.
     */
    onEventConsumed(value) {
        if (!this.equalityFunc(this.value, value)) {
            if (this.mutateFunc) {
                this.mutateFunc(this.value, value);
            }
            else {
                this.value = value;
            }
            this.notify();
        }
    }
    /**
     * Sets the consumer from which this subject derives its value. If the consumer is null, this subject's value will
     * not be updated until a non-null consumer is set.
     * @param consumer An event consumer.
     * @returns This subject, after its consumer has been set.
     */
    setConsumer(consumer) {
        var _a;
        if (this.isDestroyed) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.consumerSub = consumer === null || consumer === void 0 ? void 0 : consumer.handle(this.consumerHandler, this._isPaused);
        return this;
    }
    /**
     * Pauses consuming events for this subject. Once paused, this subject's value will not be updated.
     * @returns This subject, after it has been paused.
     */
    pause() {
        var _a;
        if (this._isPaused) {
            return this;
        }
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.pause();
        this._isPaused = true;
        return this;
    }
    /**
     * Resumes consuming events for this subject. Once resumed, this subject's value will be updated from consumed
     * events.
     * @returns This subject, after it has been resumed.
     */
    resume() {
        var _a;
        if (!this._isPaused) {
            return this;
        }
        this._isPaused = false;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        return this;
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Destroys this subject. Once destroyed, it will no longer consume events to update its value.
     */
    destroy() {
        var _a;
        (_a = this.consumerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.isDestroyed = true;
    }
}

/**
 * A utility class which provides the current game state.
 */
class GameStateProvider {
    /**
     * Constructor.
     */
    constructor() {
        this.gameState = Subject.create(undefined);
        window.document.addEventListener('OnVCockpitPanelAttributesChanged', this.onAttributesChanged.bind(this));
        this.onAttributesChanged();
    }
    /**
     * Responds to changes in document attributes.
     */
    onAttributesChanged() {
        var _a;
        if ((_a = window.parent) === null || _a === void 0 ? void 0 : _a.document.body.hasAttribute('gamestate')) {
            const attribute = window.parent.document.body.getAttribute('gamestate');
            if (attribute !== null) {
                const state = GameState[attribute];
                // The game state is set briefly to ingame after loading is finished before changing to briefing. In order to
                // not notify subscribers of this erroneous ingame state, we will debounce any state changes into ingame by two
                // frames.
                if (state === GameState.ingame && this.gameState.get() !== GameState.ingame) {
                    setTimeout(() => {
                        setTimeout(() => {
                            const newAttribute = window.parent.document.body.getAttribute('gamestate');
                            if (newAttribute !== null) {
                                this.gameState.set(GameState[newAttribute]);
                            }
                        });
                    });
                }
                else {
                    this.gameState.set(state);
                }
                return;
            }
        }
        this.gameState.set(undefined);
    }
    /**
     * Gets a subscribable which provides the current game state.
     * @returns A subscribable which provides the current game state.
     */
    static get() {
        var _a;
        return ((_a = GameStateProvider.INSTANCE) !== null && _a !== void 0 ? _a : (GameStateProvider.INSTANCE = new GameStateProvider())).gameState;
    }
}

/**
 * A manager for key events. Allows key events to be triggered and intercepted, and also publishes intercepted key
 * events on the event bus.
 */
class KeyEventManager {
    /**
     * Constructor.
     * @param keyListener The Coherent key intercept view listener.
     * @param bus The event bus.
     */
    constructor(keyListener, bus) {
        this.keyListener = keyListener;
        this.bus = bus;
        Coherent.on('keyIntercepted', this.onKeyIntercepted.bind(this));
    }
    /**
     * Responds to key intercept events.
     * @param key The key that was intercepted.
     * @param value1 The second data value of the key event.
     * @param value0 The first data value of the key event.
     * @param value2 The third data value of the key event.
     */
    onKeyIntercepted(key, value1, value0, value2) {
        // Even though values are uint32, we will do what the sim does and pretend they're actually sint32
        if (value0 !== undefined && value0 >= 2147483648) {
            value0 -= 4294967296;
        }
        this.bus.pub('key_intercept', { key, value0, value1, value2 }, false, false);
    }
    /**
     * Triggers a key event.
     * @param key The key to trigger.
     * @param bypass Whether the event should bypass intercepts.
     * @param value0 The first data value of the key event. Defaults to `0`.
     * @param value1 The second data value of the key event. Defaults to `0`.
     * @param value2 The third data value of the key event. Defaults to `0`.
     * @returns A Promise which is fulfilled after the key event has been triggered.
     */
    triggerKey(key, bypass, value0 = 0, value1 = 0, value2 = 0) {
        return Coherent.call('TRIGGER_KEY_EVENT', key, bypass, value0, value1, value2);
    }
    /**
     * Enables interception for a key.
     * @param key The key to intercept.
     * @param passThrough Whether to pass the event through to the sim after it has been intercepted.
     */
    interceptKey(key, passThrough) {
        Coherent.call('INTERCEPT_KEY_EVENT', key, passThrough ? 0 : 1);
    }
    /**
     * Gets an instance of KeyEventManager. If an instance does not already exist, a new one will be created.
     * @param bus The event bus.
     * @returns A Promise which will be fulfilled with an instance of KeyEventManager.
     */
    static getManager(bus) {
        if (KeyEventManager.INSTANCE) {
            return Promise.resolve(KeyEventManager.INSTANCE);
        }
        if (!KeyEventManager.isCreatingInstance) {
            KeyEventManager.createInstance(bus);
        }
        return new Promise(resolve => {
            KeyEventManager.pendingPromiseResolves.push(resolve);
        });
    }
    /**
     * Creates an instance of KeyEventManager and fulfills all pending Promises to get the manager instance once
     * the instance is created.
     * @param bus The event bus.
     */
    static async createInstance(bus) {
        KeyEventManager.isCreatingInstance = true;
        KeyEventManager.INSTANCE = await KeyEventManager.create(bus);
        KeyEventManager.isCreatingInstance = false;
        for (let i = 0; i < KeyEventManager.pendingPromiseResolves.length; i++) {
            KeyEventManager.pendingPromiseResolves[i](KeyEventManager.INSTANCE);
        }
    }
    /**
     * Creates an instance of KeyEventManager.
     * @param bus The event bus.
     * @returns A Promise which is fulfilled with a new instance of KeyEventManager after it has been created.
     */
    static create(bus) {
        return new Promise((resolve, reject) => {
            const gameState = GameStateProvider.get();
            const sub = gameState.sub(state => {
                if (window['IsDestroying']) {
                    sub.destroy();
                    reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                    return;
                }
                if (state === GameState.briefing || state === GameState.ingame) {
                    sub.destroy();
                    const keyListener = RegisterViewListener('JS_LISTENER_KEYEVENT', () => {
                        if (window['IsDestroying']) {
                            reject('KeyEventManager: cannot create a key intercept manager after the Coherent JS view has been destroyed');
                            return;
                        }
                        resolve(new KeyEventManager(keyListener, bus));
                    });
                }
            }, false, true);
            sub.resume(true);
        });
    }
}
KeyEventManager.isCreatingInstance = false;
KeyEventManager.pendingPromiseResolves = [];

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * The available facility frequency types.
 */
var FacilityFrequencyType;
(function (FacilityFrequencyType) {
    FacilityFrequencyType[FacilityFrequencyType["None"] = 0] = "None";
    FacilityFrequencyType[FacilityFrequencyType["ATIS"] = 1] = "ATIS";
    FacilityFrequencyType[FacilityFrequencyType["Multicom"] = 2] = "Multicom";
    FacilityFrequencyType[FacilityFrequencyType["Unicom"] = 3] = "Unicom";
    FacilityFrequencyType[FacilityFrequencyType["CTAF"] = 4] = "CTAF";
    FacilityFrequencyType[FacilityFrequencyType["Ground"] = 5] = "Ground";
    FacilityFrequencyType[FacilityFrequencyType["Tower"] = 6] = "Tower";
    FacilityFrequencyType[FacilityFrequencyType["Clearance"] = 7] = "Clearance";
    FacilityFrequencyType[FacilityFrequencyType["Approach"] = 8] = "Approach";
    FacilityFrequencyType[FacilityFrequencyType["Departure"] = 9] = "Departure";
    FacilityFrequencyType[FacilityFrequencyType["Center"] = 10] = "Center";
    FacilityFrequencyType[FacilityFrequencyType["FSS"] = 11] = "FSS";
    FacilityFrequencyType[FacilityFrequencyType["AWOS"] = 12] = "AWOS";
    FacilityFrequencyType[FacilityFrequencyType["ASOS"] = 13] = "ASOS";
    /** Clearance Pre-Taxi*/
    FacilityFrequencyType[FacilityFrequencyType["CPT"] = 14] = "CPT";
    /** Remote Clearance Delivery */
    FacilityFrequencyType[FacilityFrequencyType["GCO"] = 15] = "GCO";
})(FacilityFrequencyType || (FacilityFrequencyType = {}));
/** Additional Approach Types (additive to those defined in simplane). */
var AdditionalApproachType;
(function (AdditionalApproachType) {
    AdditionalApproachType[AdditionalApproachType["APPROACH_TYPE_VISUAL"] = 99] = "APPROACH_TYPE_VISUAL";
})(AdditionalApproachType || (AdditionalApproachType = {}));
/**
 * Flags indicating the approach fix type.
 */
var FixTypeFlags;
(function (FixTypeFlags) {
    FixTypeFlags[FixTypeFlags["None"] = 0] = "None";
    FixTypeFlags[FixTypeFlags["IAF"] = 1] = "IAF";
    FixTypeFlags[FixTypeFlags["IF"] = 2] = "IF";
    FixTypeFlags[FixTypeFlags["MAP"] = 4] = "MAP";
    FixTypeFlags[FixTypeFlags["FAF"] = 8] = "FAF";
    FixTypeFlags[FixTypeFlags["MAHP"] = 16] = "MAHP";
})(FixTypeFlags || (FixTypeFlags = {}));
/**
 * Flags indicating the rnav approach type.
 */
var RnavTypeFlags;
(function (RnavTypeFlags) {
    RnavTypeFlags[RnavTypeFlags["None"] = 0] = "None";
    RnavTypeFlags[RnavTypeFlags["LNAV"] = 1] = "LNAV";
    RnavTypeFlags[RnavTypeFlags["LNAVVNAV"] = 2] = "LNAVVNAV";
    RnavTypeFlags[RnavTypeFlags["LP"] = 4] = "LP";
    RnavTypeFlags[RnavTypeFlags["LPV"] = 8] = "LPV";
})(RnavTypeFlags || (RnavTypeFlags = {}));
/**
 * The class of airport facility.
 */
var AirportClass;
(function (AirportClass) {
    /** No other airport class could be identified. */
    AirportClass[AirportClass["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClass[AirportClass["HardSurface"] = 1] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClass[AirportClass["SoftSurface"] = 2] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClass[AirportClass["AllWater"] = 3] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClass[AirportClass["HeliportOnly"] = 4] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClass[AirportClass["Private"] = 5] = "Private";
})(AirportClass || (AirportClass = {}));
/**
 * The class of an airport facility, expressed as a mask for nearest airport search session filtering.
 */
var AirportClassMask;
(function (AirportClassMask) {
    /** No other airport class could be identified. */
    AirportClassMask[AirportClassMask["None"] = 0] = "None";
    /** The airport has at least one hard surface runway. */
    AirportClassMask[AirportClassMask["HardSurface"] = 2] = "HardSurface";
    /** The airport has no hard surface runways. */
    AirportClassMask[AirportClassMask["SoftSurface"] = 4] = "SoftSurface";
    /** The airport has only water surface runways. */
    AirportClassMask[AirportClassMask["AllWater"] = 8] = "AllWater";
    /** The airport has no runways, but does contain helipads. */
    AirportClassMask[AirportClassMask["HeliportOnly"] = 16] = "HeliportOnly";
    /** The airport is a non-public use airport. */
    AirportClassMask[AirportClassMask["Private"] = 32] = "Private";
})(AirportClassMask || (AirportClassMask = {}));
/**
 * An enumeration of possible intersection types.
 */
var IntersectionType;
(function (IntersectionType) {
    IntersectionType[IntersectionType["None"] = 0] = "None";
    IntersectionType[IntersectionType["Named"] = 1] = "Named";
    IntersectionType[IntersectionType["Unnamed"] = 2] = "Unnamed";
    IntersectionType[IntersectionType["Vor"] = 3] = "Vor";
    IntersectionType[IntersectionType["NDB"] = 4] = "NDB";
    IntersectionType[IntersectionType["Offroute"] = 5] = "Offroute";
    IntersectionType[IntersectionType["IAF"] = 6] = "IAF";
    IntersectionType[IntersectionType["FAF"] = 7] = "FAF";
    IntersectionType[IntersectionType["RNAV"] = 8] = "RNAV";
    IntersectionType[IntersectionType["VFR"] = 9] = "VFR";
})(IntersectionType || (IntersectionType = {}));
var UserFacilityType;
(function (UserFacilityType) {
    UserFacilityType[UserFacilityType["RADIAL_RADIAL"] = 0] = "RADIAL_RADIAL";
    UserFacilityType[UserFacilityType["RADIAL_DISTANCE"] = 1] = "RADIAL_DISTANCE";
    UserFacilityType[UserFacilityType["LAT_LONG"] = 2] = "LAT_LONG";
})(UserFacilityType || (UserFacilityType = {}));
/**
 * ARINC 424 Leg Types
 */
var LegType;
(function (LegType) {
    /** An unknown leg type. */
    LegType[LegType["Unknown"] = 0] = "Unknown";
    /** An arc-to-fix leg. This indicates a DME arc leg to a specified fix.*/
    LegType[LegType["AF"] = 1] = "AF";
    /** A course-to-altitude leg. */
    LegType[LegType["CA"] = 2] = "CA";
    /**
     * A course-to-DME-distance leg. This leg is flown on a wind corrected course
     * to a specific DME distance from another fix.
     */
    LegType[LegType["CD"] = 3] = "CD";
    /** A course-to-fix leg.*/
    LegType[LegType["CF"] = 4] = "CF";
    /** A course-to-intercept leg. */
    LegType[LegType["CI"] = 5] = "CI";
    /** A course-to-radial intercept leg. */
    LegType[LegType["CR"] = 6] = "CR";
    /** A direct-to-fix leg, from an unspecified starting position. */
    LegType[LegType["DF"] = 7] = "DF";
    /**
     * A fix-to-altitude leg. A FA leg is flown on a track from a fix to a
     * specified altitude.
     */
    LegType[LegType["FA"] = 8] = "FA";
    /**
     * A fix-to-distance leg. This leg is flown on a track from a fix to a
     * specific distance from the fix.
     */
    LegType[LegType["FC"] = 9] = "FC";
    /**
     * A fix to DME distance leg. This leg is flown on a track from a fix to
     * a specific DME distance from another fix.
     */
    LegType[LegType["FD"] = 10] = "FD";
    /** A course-to-manual-termination leg. */
    LegType[LegType["FM"] = 11] = "FM";
    /** A hold-to-altitude leg. The hold is flown until a specified altitude is reached. */
    LegType[LegType["HA"] = 12] = "HA";
    /**
     * A hold-to-fix leg. This indicates one time around the hold circuit and
     * then an exit.
     */
    LegType[LegType["HF"] = 13] = "HF";
    /** A hold-to-manual-termination leg. */
    LegType[LegType["HM"] = 14] = "HM";
    /** Initial procedure fix. */
    LegType[LegType["IF"] = 15] = "IF";
    /** A procedure turn leg. */
    LegType[LegType["PI"] = 16] = "PI";
    /** A radius-to-fix leg, with endpoint fixes, a center fix, and a radius. */
    LegType[LegType["RF"] = 17] = "RF";
    /** A track-to-fix leg, from the previous fix to the terminator. */
    LegType[LegType["TF"] = 18] = "TF";
    /** A heading-to-altitude leg. */
    LegType[LegType["VA"] = 19] = "VA";
    /** A heading-to-DME-distance leg. */
    LegType[LegType["VD"] = 20] = "VD";
    /** A heading-to-intercept leg. */
    LegType[LegType["VI"] = 21] = "VI";
    /** A heading-to-manual-termination leg. */
    LegType[LegType["VM"] = 22] = "VM";
    /** A heading-to-radial intercept leg. */
    LegType[LegType["VR"] = 23] = "VR";
    /** A leg representing a lateral and vertical discontinuity in the flight plan. */
    LegType[LegType["Discontinuity"] = 99] = "Discontinuity";
    /** A leg representing a lateral and vertical discontinuity in the flight plan that does not prevent sequencing. */
    LegType[LegType["ThruDiscontinuity"] = 100] = "ThruDiscontinuity";
})(LegType || (LegType = {}));
/**
 * Types of altitude restrictions on procedure legs.
 */
var AltitudeRestrictionType;
(function (AltitudeRestrictionType) {
    AltitudeRestrictionType[AltitudeRestrictionType["Unused"] = 0] = "Unused";
    AltitudeRestrictionType[AltitudeRestrictionType["At"] = 1] = "At";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    AltitudeRestrictionType[AltitudeRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    AltitudeRestrictionType[AltitudeRestrictionType["Between"] = 4] = "Between";
})(AltitudeRestrictionType || (AltitudeRestrictionType = {}));
var LegTurnDirection;
(function (LegTurnDirection) {
    LegTurnDirection[LegTurnDirection["None"] = 0] = "None";
    LegTurnDirection[LegTurnDirection["Left"] = 1] = "Left";
    LegTurnDirection[LegTurnDirection["Right"] = 2] = "Right";
    LegTurnDirection[LegTurnDirection["Either"] = 3] = "Either";
})(LegTurnDirection || (LegTurnDirection = {}));
var AirwayType;
(function (AirwayType) {
    AirwayType[AirwayType["None"] = 0] = "None";
    AirwayType[AirwayType["Victor"] = 1] = "Victor";
    AirwayType[AirwayType["Jet"] = 2] = "Jet";
    AirwayType[AirwayType["Both"] = 3] = "Both";
})(AirwayType || (AirwayType = {}));
var NdbType;
(function (NdbType) {
    NdbType[NdbType["CompassPoint"] = 0] = "CompassPoint";
    NdbType[NdbType["MH"] = 1] = "MH";
    NdbType[NdbType["H"] = 2] = "H";
    NdbType[NdbType["HH"] = 3] = "HH";
})(NdbType || (NdbType = {}));
var VorType;
(function (VorType) {
    VorType[VorType["Unknown"] = 0] = "Unknown";
    VorType[VorType["VOR"] = 1] = "VOR";
    VorType[VorType["VORDME"] = 2] = "VORDME";
    VorType[VorType["DME"] = 3] = "DME";
    VorType[VorType["TACAN"] = 4] = "TACAN";
    VorType[VorType["VORTAC"] = 5] = "VORTAC";
    VorType[VorType["ILS"] = 6] = "ILS";
    VorType[VorType["VOT"] = 7] = "VOT";
})(VorType || (VorType = {}));
var RunwaySurfaceType;
(function (RunwaySurfaceType) {
    RunwaySurfaceType[RunwaySurfaceType["Concrete"] = 0] = "Concrete";
    RunwaySurfaceType[RunwaySurfaceType["Grass"] = 1] = "Grass";
    RunwaySurfaceType[RunwaySurfaceType["WaterFSX"] = 2] = "WaterFSX";
    RunwaySurfaceType[RunwaySurfaceType["GrassBumpy"] = 3] = "GrassBumpy";
    RunwaySurfaceType[RunwaySurfaceType["Asphalt"] = 4] = "Asphalt";
    RunwaySurfaceType[RunwaySurfaceType["ShortGrass"] = 5] = "ShortGrass";
    RunwaySurfaceType[RunwaySurfaceType["LongGrass"] = 6] = "LongGrass";
    RunwaySurfaceType[RunwaySurfaceType["HardTurf"] = 7] = "HardTurf";
    RunwaySurfaceType[RunwaySurfaceType["Snow"] = 8] = "Snow";
    RunwaySurfaceType[RunwaySurfaceType["Ice"] = 9] = "Ice";
    RunwaySurfaceType[RunwaySurfaceType["Urban"] = 10] = "Urban";
    RunwaySurfaceType[RunwaySurfaceType["Forest"] = 11] = "Forest";
    RunwaySurfaceType[RunwaySurfaceType["Dirt"] = 12] = "Dirt";
    RunwaySurfaceType[RunwaySurfaceType["Coral"] = 13] = "Coral";
    RunwaySurfaceType[RunwaySurfaceType["Gravel"] = 14] = "Gravel";
    RunwaySurfaceType[RunwaySurfaceType["OilTreated"] = 15] = "OilTreated";
    RunwaySurfaceType[RunwaySurfaceType["SteelMats"] = 16] = "SteelMats";
    RunwaySurfaceType[RunwaySurfaceType["Bituminous"] = 17] = "Bituminous";
    RunwaySurfaceType[RunwaySurfaceType["Brick"] = 18] = "Brick";
    RunwaySurfaceType[RunwaySurfaceType["Macadam"] = 19] = "Macadam";
    RunwaySurfaceType[RunwaySurfaceType["Planks"] = 20] = "Planks";
    RunwaySurfaceType[RunwaySurfaceType["Sand"] = 21] = "Sand";
    RunwaySurfaceType[RunwaySurfaceType["Shale"] = 22] = "Shale";
    RunwaySurfaceType[RunwaySurfaceType["Tarmac"] = 23] = "Tarmac";
    RunwaySurfaceType[RunwaySurfaceType["WrightFlyerTrack"] = 24] = "WrightFlyerTrack";
    //SURFACE_TYPE_LAST_FSX
    RunwaySurfaceType[RunwaySurfaceType["Ocean"] = 26] = "Ocean";
    RunwaySurfaceType[RunwaySurfaceType["Water"] = 27] = "Water";
    RunwaySurfaceType[RunwaySurfaceType["Pond"] = 28] = "Pond";
    RunwaySurfaceType[RunwaySurfaceType["Lake"] = 29] = "Lake";
    RunwaySurfaceType[RunwaySurfaceType["River"] = 30] = "River";
    RunwaySurfaceType[RunwaySurfaceType["WasteWater"] = 31] = "WasteWater";
    RunwaySurfaceType[RunwaySurfaceType["Paint"] = 32] = "Paint";
    // UNUSED
    // SURFACE_TYPE_ERASE_GRASS
})(RunwaySurfaceType || (RunwaySurfaceType = {}));
var RunwayLightingType;
(function (RunwayLightingType) {
    RunwayLightingType[RunwayLightingType["Unknown"] = 0] = "Unknown";
    RunwayLightingType[RunwayLightingType["None"] = 1] = "None";
    RunwayLightingType[RunwayLightingType["PartTime"] = 2] = "PartTime";
    RunwayLightingType[RunwayLightingType["FullTime"] = 3] = "FullTime";
    RunwayLightingType[RunwayLightingType["Frequency"] = 4] = "Frequency";
})(RunwayLightingType || (RunwayLightingType = {}));
var AirportPrivateType;
(function (AirportPrivateType) {
    AirportPrivateType[AirportPrivateType["Uknown"] = 0] = "Uknown";
    AirportPrivateType[AirportPrivateType["Public"] = 1] = "Public";
    AirportPrivateType[AirportPrivateType["Military"] = 2] = "Military";
    AirportPrivateType[AirportPrivateType["Private"] = 3] = "Private";
})(AirportPrivateType || (AirportPrivateType = {}));
var GpsBoolean;
(function (GpsBoolean) {
    GpsBoolean[GpsBoolean["Unknown"] = 0] = "Unknown";
    GpsBoolean[GpsBoolean["No"] = 1] = "No";
    GpsBoolean[GpsBoolean["Yes"] = 2] = "Yes";
})(GpsBoolean || (GpsBoolean = {}));
var VorClass;
(function (VorClass) {
    VorClass[VorClass["Unknown"] = 0] = "Unknown";
    VorClass[VorClass["Terminal"] = 1] = "Terminal";
    VorClass[VorClass["LowAlt"] = 2] = "LowAlt";
    VorClass[VorClass["HighAlt"] = 3] = "HighAlt";
    VorClass[VorClass["ILS"] = 4] = "ILS";
    VorClass[VorClass["VOT"] = 5] = "VOT";
})(VorClass || (VorClass = {}));
var FacilityType;
(function (FacilityType) {
    FacilityType["Airport"] = "LOAD_AIRPORT";
    FacilityType["Intersection"] = "LOAD_INTERSECTION";
    FacilityType["VOR"] = "LOAD_VOR";
    FacilityType["NDB"] = "LOAD_NDB";
    FacilityType["USR"] = "USR";
    FacilityType["RWY"] = "RWY";
    FacilityType["VIS"] = "VIS";
})(FacilityType || (FacilityType = {}));
var FacilitySearchType;
(function (FacilitySearchType) {
    FacilitySearchType[FacilitySearchType["All"] = 0] = "All";
    FacilitySearchType[FacilitySearchType["Airport"] = 1] = "Airport";
    FacilitySearchType[FacilitySearchType["Intersection"] = 2] = "Intersection";
    FacilitySearchType[FacilitySearchType["Vor"] = 3] = "Vor";
    FacilitySearchType[FacilitySearchType["Ndb"] = 4] = "Ndb";
    FacilitySearchType[FacilitySearchType["Boundary"] = 5] = "Boundary";
    FacilitySearchType[FacilitySearchType["User"] = 6] = "User";
    FacilitySearchType[FacilitySearchType["Visual"] = 7] = "Visual";
    FacilitySearchType[FacilitySearchType["AllExceptVisual"] = 8] = "AllExceptVisual";
})(FacilitySearchType || (FacilitySearchType = {}));
/**
 * A type of airspace boundary.
 */
var BoundaryType;
(function (BoundaryType) {
    BoundaryType[BoundaryType["None"] = 0] = "None";
    BoundaryType[BoundaryType["Center"] = 1] = "Center";
    BoundaryType[BoundaryType["ClassA"] = 2] = "ClassA";
    BoundaryType[BoundaryType["ClassB"] = 3] = "ClassB";
    BoundaryType[BoundaryType["ClassC"] = 4] = "ClassC";
    BoundaryType[BoundaryType["ClassD"] = 5] = "ClassD";
    BoundaryType[BoundaryType["ClassE"] = 6] = "ClassE";
    BoundaryType[BoundaryType["ClassF"] = 7] = "ClassF";
    BoundaryType[BoundaryType["ClassG"] = 8] = "ClassG";
    BoundaryType[BoundaryType["Tower"] = 9] = "Tower";
    BoundaryType[BoundaryType["Clearance"] = 10] = "Clearance";
    BoundaryType[BoundaryType["Ground"] = 11] = "Ground";
    BoundaryType[BoundaryType["Departure"] = 12] = "Departure";
    BoundaryType[BoundaryType["Approach"] = 13] = "Approach";
    BoundaryType[BoundaryType["MOA"] = 14] = "MOA";
    BoundaryType[BoundaryType["Restricted"] = 15] = "Restricted";
    BoundaryType[BoundaryType["Prohibited"] = 16] = "Prohibited";
    BoundaryType[BoundaryType["Warning"] = 17] = "Warning";
    BoundaryType[BoundaryType["Alert"] = 18] = "Alert";
    BoundaryType[BoundaryType["Danger"] = 19] = "Danger";
    BoundaryType[BoundaryType["NationalPark"] = 20] = "NationalPark";
    BoundaryType[BoundaryType["ModeC"] = 21] = "ModeC";
    BoundaryType[BoundaryType["Radar"] = 22] = "Radar";
    BoundaryType[BoundaryType["Training"] = 23] = "Training";
})(BoundaryType || (BoundaryType = {}));
/**
 * A type of airspace boundary altitude maxima.
 */
var BoundaryAltitudeType;
(function (BoundaryAltitudeType) {
    BoundaryAltitudeType[BoundaryAltitudeType["Unknown"] = 0] = "Unknown";
    BoundaryAltitudeType[BoundaryAltitudeType["MSL"] = 1] = "MSL";
    BoundaryAltitudeType[BoundaryAltitudeType["AGL"] = 2] = "AGL";
    BoundaryAltitudeType[BoundaryAltitudeType["Unlimited"] = 3] = "Unlimited";
})(BoundaryAltitudeType || (BoundaryAltitudeType = {}));
/**
 * A type of boundary geometry vector.
 */
var BoundaryVectorType;
(function (BoundaryVectorType) {
    BoundaryVectorType[BoundaryVectorType["None"] = 0] = "None";
    BoundaryVectorType[BoundaryVectorType["Start"] = 1] = "Start";
    BoundaryVectorType[BoundaryVectorType["Line"] = 2] = "Line";
    BoundaryVectorType[BoundaryVectorType["Origin"] = 3] = "Origin";
    BoundaryVectorType[BoundaryVectorType["ArcCW"] = 4] = "ArcCW";
    BoundaryVectorType[BoundaryVectorType["ArcCCW"] = 5] = "ArcCCW";
    BoundaryVectorType[BoundaryVectorType["Circle"] = 6] = "Circle";
})(BoundaryVectorType || (BoundaryVectorType = {}));
/**
 * Wind speed units used by METAR.
 */
var MetarWindSpeedUnits;
(function (MetarWindSpeedUnits) {
    MetarWindSpeedUnits[MetarWindSpeedUnits["Knot"] = 0] = "Knot";
    MetarWindSpeedUnits[MetarWindSpeedUnits["MeterPerSecond"] = 1] = "MeterPerSecond";
    MetarWindSpeedUnits[MetarWindSpeedUnits["KilometerPerHour"] = 2] = "KilometerPerHour";
})(MetarWindSpeedUnits || (MetarWindSpeedUnits = {}));
/** Visibility distance units used by METAR. */
var MetarVisibilityUnits;
(function (MetarVisibilityUnits) {
    MetarVisibilityUnits[MetarVisibilityUnits["Meter"] = 0] = "Meter";
    MetarVisibilityUnits[MetarVisibilityUnits["StatuteMile"] = 1] = "StatuteMile";
})(MetarVisibilityUnits || (MetarVisibilityUnits = {}));
/**
 * METAR cloud layer coverage/sky condition.
 */
var MetarCloudLayerCoverage;
(function (MetarCloudLayerCoverage) {
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["SkyClear"] = 0] = "SkyClear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Clear"] = 1] = "Clear";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["NoSignificant"] = 2] = "NoSignificant";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Few"] = 3] = "Few";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Scattered"] = 4] = "Scattered";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Broken"] = 5] = "Broken";
    MetarCloudLayerCoverage[MetarCloudLayerCoverage["Overcast"] = 6] = "Overcast";
})(MetarCloudLayerCoverage || (MetarCloudLayerCoverage = {}));
/**
 * METAR significant cloud types.
 */
var MetarCloudLayerType;
(function (MetarCloudLayerType) {
    MetarCloudLayerType[MetarCloudLayerType["Unspecified"] = -1] = "Unspecified";
    MetarCloudLayerType[MetarCloudLayerType["ToweringCumulus"] = 0] = "ToweringCumulus";
    MetarCloudLayerType[MetarCloudLayerType["Cumulonimbus"] = 1] = "Cumulonimbus";
    MetarCloudLayerType[MetarCloudLayerType["AltocumulusCastellanus"] = 2] = "AltocumulusCastellanus";
})(MetarCloudLayerType || (MetarCloudLayerType = {}));
/** METAR phenomenon types. */
var MetarPhenomenonType;
(function (MetarPhenomenonType) {
    MetarPhenomenonType[MetarPhenomenonType["None"] = 0] = "None";
    MetarPhenomenonType[MetarPhenomenonType["Mist"] = 1] = "Mist";
    MetarPhenomenonType[MetarPhenomenonType["Duststorm"] = 2] = "Duststorm";
    MetarPhenomenonType[MetarPhenomenonType["Dust"] = 3] = "Dust";
    MetarPhenomenonType[MetarPhenomenonType["Drizzle"] = 4] = "Drizzle";
    MetarPhenomenonType[MetarPhenomenonType["FunnelCloud"] = 5] = "FunnelCloud";
    MetarPhenomenonType[MetarPhenomenonType["Fog"] = 6] = "Fog";
    MetarPhenomenonType[MetarPhenomenonType["Smoke"] = 7] = "Smoke";
    MetarPhenomenonType[MetarPhenomenonType["Hail"] = 8] = "Hail";
    MetarPhenomenonType[MetarPhenomenonType["SmallHail"] = 9] = "SmallHail";
    MetarPhenomenonType[MetarPhenomenonType["Haze"] = 10] = "Haze";
    MetarPhenomenonType[MetarPhenomenonType["IceCrystals"] = 11] = "IceCrystals";
    MetarPhenomenonType[MetarPhenomenonType["IcePellets"] = 12] = "IcePellets";
    MetarPhenomenonType[MetarPhenomenonType["DustSandWhorls"] = 13] = "DustSandWhorls";
    MetarPhenomenonType[MetarPhenomenonType["Spray"] = 14] = "Spray";
    MetarPhenomenonType[MetarPhenomenonType["Rain"] = 15] = "Rain";
    MetarPhenomenonType[MetarPhenomenonType["Sand"] = 16] = "Sand";
    MetarPhenomenonType[MetarPhenomenonType["SnowGrains"] = 17] = "SnowGrains";
    MetarPhenomenonType[MetarPhenomenonType["Shower"] = 18] = "Shower";
    MetarPhenomenonType[MetarPhenomenonType["Snow"] = 19] = "Snow";
    MetarPhenomenonType[MetarPhenomenonType["Squalls"] = 20] = "Squalls";
    MetarPhenomenonType[MetarPhenomenonType["Sandstorm"] = 21] = "Sandstorm";
    MetarPhenomenonType[MetarPhenomenonType["UnknownPrecip"] = 22] = "UnknownPrecip";
    MetarPhenomenonType[MetarPhenomenonType["VolcanicAsh"] = 23] = "VolcanicAsh";
})(MetarPhenomenonType || (MetarPhenomenonType = {}));
/** METAR phenomenon intensities. */
var MetarPhenomenonIntensity;
(function (MetarPhenomenonIntensity) {
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Light"] = -1] = "Light";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Normal"] = 0] = "Normal";
    MetarPhenomenonIntensity[MetarPhenomenonIntensity["Heavy"] = 1] = "Heavy";
})(MetarPhenomenonIntensity || (MetarPhenomenonIntensity = {}));
/**
 * Methods for working with FS ICAO strings.
 */
class ICAO {
    /**
     * Gets the facility type from an ICAO.
     * @param icao The icao to get the facility type for.
     * @returns The ICAO facility type.
     * @throws An error if the facility type cannot be determined.
     */
    static getFacilityType(icao) {
        switch (icao[0]) {
            case 'A':
                return FacilityType.Airport;
            case 'W':
                return FacilityType.Intersection;
            case 'V':
                return FacilityType.VOR;
            case 'N':
                return FacilityType.NDB;
            case 'U':
                return FacilityType.USR;
            case 'R':
                return FacilityType.RWY;
            case 'S':
                return FacilityType.VIS;
            default:
                throw new Error(`ICAO ${icao} has unknown type: ${icao[0]}`);
        }
    }
    /**
     * Returns the ident of the icao's associated airport. (ex. for terminal waypoints)
     * @param icao The icao to get the airport ident for.
     * @returns The airport ident.
     */
    static getAssociatedAirportIdent(icao) {
        return icao.substr(3, 4).trim();
    }
    /**
     * Checks whether an ICAO string defines a facility (optionally of a specific type).
     * @param icao An ICAO string.
     * @param type The specific facility type to check against. If not defined, this method will return `true` as long as
     * the ICAO string defines any valid facility type.
     * @returns Whether the given ICAO string defines a facility of the specified type.
     */
    static isFacility(icao, type) {
        switch (icao[0]) {
            case 'A':
                return type === undefined || type === FacilityType.Airport;
            case 'W':
                return type === undefined || type === FacilityType.Intersection;
            case 'V':
                return type === undefined || type === FacilityType.VOR;
            case 'N':
                return type === undefined || type === FacilityType.NDB;
            case 'U':
                return type === undefined || type === FacilityType.USR;
            case 'R':
                return type === undefined || type === FacilityType.RWY;
            case 'S':
                return type === undefined || type === FacilityType.VIS;
            default:
                return false;
        }
    }
    /**
     * Gets the ident for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The ICAO ident.
     */
    static getIdent(icao) {
        return icao.substr(7).trim();
    }
    /**
     * Gets the region code for a given ICAO string.
     * @param icao The FS ICAO to get the ident for.
     * @returns The two letter region code.
     */
    static getRegionCode(icao) {
        return icao.substr(1, 2).trim();
    }
}
/**
 * An empty ICAO.
 */
ICAO.emptyIcao = '            ';
/**
 * Utility functions for working with facilities.
 */
class FacilityUtils {
    /**
     * Checks whether a facility is of a given type.
     * @param facility The facility to check.
     * @param type The facility type to check against.
     * @returns Whether the facility is of the specified type.
     */
    static isFacilityType(facility, type) {
        // Need to check for the intersection version of VOR/NDB facilities - these facilities have identical ICAOs
        // to their VOR/NDB counterparts, so we need to manually check the __Type property on the facility object.
        if (facility['__Type'] === 'JS_FacilityIntersection') {
            return type === FacilityType.Intersection;
        }
        return ICAO.isFacility(facility.icao, type);
    }
    /**
     * Gets the magnetic variation at a facility, in degrees. If the facility is a VOR, the magnetic variation defined
     * by the VOR is returned. For all other facilities, the modeled magnetic variation at the location of the facility
     * is returned.
     * @param facility A facility.
     * @returns The magnetic variation at the specified facility, in degrees.
     */
    static getMagVar(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            return -facility.magneticVariation; // VOR facility magvar is positive west instead of the standard positive east
        }
        else {
            return MagVar.get(facility.lat, facility.lon);
        }
    }
    /**
     * Gets latitude/longitude coordinates corresponding to a radial and distance from a reference facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees.
     * @param distance The distance, in nautical miles.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the specified radial and distance from the reference
     * facility.
     */
    static getLatLonFromRadialDistance(reference, radial, distance, out) {
        return FacilityUtils.geoPointCache[0].set(reference).offset(MagVar.magneticToTrue(radial, FacilityUtils.getMagVar(reference)), UnitType.NMILE.convertTo(distance, UnitType.GA_RADIAN), out);
    }
    /**
     * Gets latitude/longitude coordinates corresponding to the intersection of two facility radials.
     * @param reference1 The first reference facility.
     * @param radial1 The first magnetic radial, in degrees.
     * @param reference2 The second reference facility.
     * @param radial2 The second magnetic radial, in degrees.
     * @param out The GeoPoint object to which to write the result.
     * @returns The latitude/longitude coordinates corresponding to the intersection of the two specified radials. If
     * the specified radials do not intersect at a unique point, `NaN` is written to both `lat` and `lon`.
     */
    static getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, out) {
        const magVar1 = FacilityUtils.getMagVar(reference1);
        const magVar2 = FacilityUtils.getMagVar(reference2);
        const radialCircle1 = FacilityUtils.geoCircleCache[0].setAsGreatCircle(reference1, MagVar.magneticToTrue(radial1, magVar1));
        const radialCircle2 = FacilityUtils.geoCircleCache[1].setAsGreatCircle(reference2, MagVar.magneticToTrue(radial2, magVar2));
        const radial1IncludesRef2 = radialCircle1.includes(reference2);
        const radial2IncludesRef1 = radialCircle2.includes(reference1);
        if (radial1IncludesRef2 && radial2IncludesRef1) {
            // Radials are parallel or antiparallel, and therefore do not have a unique intersection point.
            return out.set(NaN, NaN);
        }
        else if (radial1IncludesRef2) {
            // Reference 2 lies along the great circle of radial 1. The intersection point therefore is either reference 2
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle1.angleAlong(reference1, reference2, Math.PI) < Math.PI ? out.set(reference2) : out.set(reference2).antipode();
        }
        else if (radial2IncludesRef1) {
            // Reference 1 lies along the great circle of radial 2. The intersection point therefore is either reference 1
            // or its antipode. One of the two lies on the radial, and the other lies on the anti-radial.
            return radialCircle2.angleAlong(reference2, reference1, Math.PI) < Math.PI ? out.set(reference1) : out.set(reference1).antipode();
        }
        // Radials, unlike great circles, do not circumscribe the globe. Therefore, we choose the order of the intersection
        // operation carefully to ensure that the first solution (if it exists) is the "correct" intersection.
        const numIntersections = radialCircle1.encircles(reference2)
            ? radialCircle2.intersectionGeoPoint(radialCircle1, FacilityUtils.intersectionCache)
            : radialCircle1.intersectionGeoPoint(radialCircle2, FacilityUtils.intersectionCache);
        if (numIntersections === 0) {
            return out.set(NaN, NaN);
        }
        return out.set(FacilityUtils.intersectionCache[0]);
    }
}
FacilityUtils.geoPointCache = [new GeoPoint(0, 0)];
FacilityUtils.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
FacilityUtils.intersectionCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Utility functions for working with intersection facilities.
 */
class IntersectionFacilityUtils {
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isTerminal(arg) {
        const icao = typeof arg === 'string' ? arg : arg.icao;
        if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
            throw new Error(`Facility with ICAO ${icao} is not an intersection`);
        }
        return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao);
    }
    /**
     * Gets the non-terminal version of an intersection ICAO. If the ICAO is already a non-terminal intersection ICAO,
     * then an identical string will be returned.
     * @param icao An intersection ICAO.
     * @returns The non-terminal version of the specified intersection ICAO.
     * @throws Error if the specified ICAO is not an intersection ICAO.
     */
    static getNonTerminalICAO(icao) {
        if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
            throw new Error(`Facility with ICAO ${icao} is not an intersection`);
        }
        return IntersectionFacilityUtils.TERMINAL_REGEX.test(icao) ? `${icao.substring(0, 3)}    ${icao.substring(7)}` : icao;
    }
    /**
     * Gets an ICAO string from itself.
     * @param icao An ICAO string.
     * @returns The specified ICAO string.
     */
    static getIcaoIdentity(icao) {
        return icao;
    }
    /**
     * Gets an ICAO string from a facility.
     * @param facility A facility.
     * @returns The specified facility's ICAO string.
     */
    static getIcaoFacility(facility) {
        return facility.icao;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static filterDuplicates(array, arg2, arg3) {
        if (array.length === 0) {
            return [];
        }
        let getIcao;
        let retainTerminal;
        if (typeof arg2 === 'function') {
            getIcao = arg2;
            retainTerminal = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            retainTerminal = arg2 !== null && arg2 !== void 0 ? arg2 : false;
            if (typeof array[0] === 'string') {
                getIcao = IntersectionFacilityUtils.getIcaoIdentity;
            }
            else {
                getIcao = IntersectionFacilityUtils.getIcaoFacility;
            }
        }
        // Build the set of ICAOs to filter.
        IntersectionFacilityUtils.filterDuplicatesSet.clear();
        for (let i = 0; i < array.length; i++) {
            const icao = getIcao(array[i]);
            if (ICAO.isFacility(icao, FacilityType.Intersection) && IntersectionFacilityUtils.isTerminal(icao) === retainTerminal) {
                IntersectionFacilityUtils.filterDuplicatesSet.add(IntersectionFacilityUtils.getNonTerminalICAO(icao));
            }
        }
        // If there are no ICAOs to filter, then just return a copy of the original array.
        if (IntersectionFacilityUtils.filterDuplicatesSet.size === 0) {
            return array.slice();
        }
        const filtered = array.filter(icao => {
            return IntersectionFacilityUtils.filterDuplicatesHelper(icao, getIcao, retainTerminal, IntersectionFacilityUtils.filterDuplicatesSet);
        });
        IntersectionFacilityUtils.filterDuplicatesSet.clear();
        return filtered;
    }
    /**
     * Checks whether an element should be filtered out from an array such that the filtered array does not contain any
     * elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     * @param element The element to check.
     * @param getIcao A function which maps elements to ICAOs.
     * @param retainTerminal Whether to retain the terminal version of a duplicate pair in the filtered array.
     * @param nonTerminalIcaosToFilter A set of non-terminal ICAOs to filter out of the array.
     * @returns Whether the specified element should be filtered out from an array such that the filtered array does not
     * contain any elements that are mapped to duplicate terminal/non-terminal intersection pairs.
     */
    static filterDuplicatesHelper(element, getIcao, retainTerminal, nonTerminalIcaosToFilter) {
        const icao = getIcao(element);
        if (!ICAO.isFacility(icao, FacilityType.Intersection)) {
            return true;
        }
        const isTerminal = IntersectionFacilityUtils.isTerminal(icao);
        if (isTerminal === retainTerminal) {
            return true;
        }
        if (isTerminal) {
            return !nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao));
        }
        else {
            return !nonTerminalIcaosToFilter.has(icao);
        }
    }
}
IntersectionFacilityUtils.TERMINAL_REGEX = /^...[a-zA-Z\d]/;
IntersectionFacilityUtils.filterDuplicatesSet = new Set();
/**
 * Utility functions for working with user facilities.
 */
class UserFacilityUtils {
    /**
     * Creates a user facility from latitude/longitude coordinates.
     * @param icao The ICAO string of the new facility.
     * @param lat The latitude of the new facility.
     * @param lon The longitude of the new facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromLatLon(icao, lat, lon, isTemporary = false, name) {
        const fac = {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat,
            lon,
            userFacilityType: UserFacilityType.LAT_LONG,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(lat, lon)
        };
        return fac;
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference The reference facility.
     * @param radial The magnetic radial, in degrees, of the reference facility on which the new facility lies.
     * @param distance The distance, in nautical miles, from the reference facility.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility.
     */
    static createFromRadialDistance(icao, reference, radial, distance, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialDistance(reference, radial, distance, UserFacilityUtils.geoPointCache[0]);
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_DISTANCE,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference.icao,
            reference1Radial: radial,
            reference1MagVar: FacilityUtils.getMagVar(reference),
            reference1Distance: distance
        };
    }
    /**
     * Creates a user facility from a radial and distance relative to a reference facility.
     * @param icao The ICAO string of the new facility.
     * @param reference1 The first reference facility.
     * @param radial1 The magnetic radial, in degrees, of the first reference facility on which the new facility lies.
     * @param reference2 The second reference facility.
     * @param radial2 The magnetic radial, in degrees, of the second reference facility on which the new facility lies.
     * @param isTemporary Whether the new facility is temporary.
     * @param name The name of the new facility.
     * @returns A new user facility, or `undefined` if the specified radials do not intersect at a unique point.
     */
    static createFromRadialRadial(icao, reference1, radial1, reference2, radial2, isTemporary = false, name) {
        const location = FacilityUtils.getLatLonFromRadialRadial(reference1, radial1, reference2, radial2, UserFacilityUtils.geoPointCache[0]);
        if (isNaN(location.lat) || isNaN(location.lon)) {
            return undefined;
        }
        return {
            icao,
            name: name !== null && name !== void 0 ? name : '',
            lat: location.lat,
            lon: location.lon,
            userFacilityType: UserFacilityType.RADIAL_RADIAL,
            isTemporary,
            region: '',
            city: '',
            magvar: MagVar.get(location),
            reference1Icao: reference1.icao,
            reference1Radial: radial1,
            reference1MagVar: FacilityUtils.getMagVar(reference1),
            reference2Icao: reference2.icao,
            reference2Radial: radial2,
            reference2MagVar: FacilityUtils.getMagVar(reference2)
        };
    }
}
UserFacilityUtils.geoPointCache = [new GeoPoint(0, 0)];

var RunwaySurfaceCategory;
(function (RunwaySurfaceCategory) {
    RunwaySurfaceCategory[RunwaySurfaceCategory["Unknown"] = 1] = "Unknown";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Hard"] = 2] = "Hard";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Soft"] = 4] = "Soft";
    RunwaySurfaceCategory[RunwaySurfaceCategory["Water"] = 8] = "Water";
})(RunwaySurfaceCategory || (RunwaySurfaceCategory = {}));
/**
 * Methods for working with Runways and Runway Designations.
 */
class RunwayUtils {
    /**
     * Gets the letter for a runway designator.
     * @param designator A runway designator.
     * @param lowerCase Whether the letter should be lower case. False by default.
     * @returns The letter for the specified runway designator.
     */
    static getDesignatorLetter(designator, lowerCase = false) {
        const letter = RunwayUtils.RUNWAY_DESIGNATOR_LETTERS[designator];
        return lowerCase
            ? letter.toLowerCase()
            : letter;
    }
    /**
     * Creates an empty one-way runway.
     * @returns an empty one-way runway.
     */
    static createEmptyOneWayRunway() {
        return {
            parentRunwayIndex: -1,
            designation: '',
            direction: 36,
            runwayDesignator: RunwayDesignator.RUNWAY_DESIGNATOR_NONE,
            course: 0,
            elevation: 0,
            elevationEnd: 0,
            gradient: 0,
            latitude: 0,
            longitude: 0,
            length: 0,
            width: 0,
            startThresholdLength: 0,
            endThresholdLength: 0,
            surface: RunwaySurfaceType.Concrete,
            lighting: RunwayLightingType.Unknown
        };
    }
    /**
     * Utility method to return all of the one-way runways from a single airport facility
     * @param airport is the Airport Facility to evaluate
     * @returns all of the one-way runways in the airport facility, sorted.
     */
    static getOneWayRunwaysFromAirport(airport) {
        const runways = [];
        airport.runways.map((r, i) => RunwayUtils.getOneWayRunways(r, i)).forEach(d => {
            runways.push(d[0]);
            runways.push(d[1]);
        });
        runways.sort(RunwayUtils.sortRunways);
        return runways;
    }
    /**
     * Utility method to return two one-way runways from a single runway facility
     * @param runway is the AirportRunway object to evaluate
     * @param index is the index of the AirportRunway in the Facility
     * @returns splitRunways array of OneWayRunway objects
     */
    static getOneWayRunways(runway, index) {
        const splitRunways = [];
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let designator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
            let course = 0;
            let thresholdDistanceFromCenter = 0;
            let thresholdElevation = 0;
            let endThresholdElevation = 0;
            let ilsFrequency;
            let startThresholdLength = 0, endThresholdLength = 0;
            if (i === 0) {
                designator = runway.designatorCharPrimary;
                course = runway.direction;
                thresholdDistanceFromCenter = (runway.length / 2) - runway.primaryThresholdLength;
                thresholdElevation = runway.primaryElevation;
                endThresholdElevation = runway.secondaryElevation;
                ilsFrequency = runway.primaryILSFrequency.freqMHz === 0 ? undefined : runway.primaryILSFrequency;
                startThresholdLength = runway.primaryThresholdLength;
                endThresholdLength = runway.secondaryThresholdLength;
            }
            else if (i === 1) {
                designator = runway.designatorCharSecondary;
                course = NavMath.normalizeHeading(runway.direction + 180);
                thresholdDistanceFromCenter = (runway.length / 2) - runway.secondaryThresholdLength;
                thresholdElevation = runway.secondaryElevation;
                endThresholdElevation = runway.primaryElevation;
                ilsFrequency = runway.secondaryILSFrequency.freqMHz === 0 ? undefined : runway.secondaryILSFrequency;
                startThresholdLength = runway.secondaryThresholdLength;
                endThresholdLength = runway.primaryThresholdLength;
            }
            const designation = RunwayUtils.getRunwayNameString(runwayNumber, designator);
            const coordinates = RunwayUtils.tempGeoPoint
                .set(runway.latitude, runway.longitude)
                .offset(course - 180, UnitType.METER.convertTo(thresholdDistanceFromCenter, UnitType.GA_RADIAN));
            splitRunways.push({
                parentRunwayIndex: index,
                designation,
                direction: runwayNumber,
                runwayDesignator: designator,
                course,
                elevation: thresholdElevation,
                elevationEnd: endThresholdElevation,
                gradient: (endThresholdElevation - thresholdElevation) / (runway.length - startThresholdLength - endThresholdLength) * 100,
                latitude: coordinates.lat,
                longitude: coordinates.lon,
                ilsFrequency,
                length: runway.length,
                width: runway.width,
                startThresholdLength,
                endThresholdLength,
                surface: runway.surface,
                lighting: runway.lighting
            });
        }
        return splitRunways;
    }
    /**
     * Gets a name for a paired runway. Names are formatted as dash-separated pairs of directional (one-way) runway
     * designations, with optional leading zero padding of the runway numbers. If the specified runway is not paired,
     * then the name will be the designation of the primary runway only.
     * @param runway A paired runway.
     * @param padded Whether the runway numbers should be padded with leading zeroes. Defaults to `true`.
     * @returns The name for the specified paired runway.
     */
    static getRunwayPairNameString(runway, padded = true) {
        const pad = padded ? 2 : 0;
        const dashIndex = runway.designation.search('-');
        const primary = `${(dashIndex < 0 ? runway.designation : runway.designation.substring(0, dashIndex)).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharPrimary)}`;
        const secondary = dashIndex < 0 ? '' : `-${runway.designation.substring(dashIndex + 1).padStart(pad)}${RunwayUtils.getDesignatorLetter(runway.designatorCharSecondary)}`;
        return primary + secondary;
    }
    /**
     * Utility method to return the runway name from the number and designator (L/R/C/W)
     * @param runwayNumber is the integer part of a runway name (18, 26, 27, etc)
     * @param designator is the RunwayDesignator enum for the runway
     * @param padded Whether single-char runways should be 0-padded.
     * @param prefix A prefix to put before the runway name.
     * @returns the runway name string
     */
    static getRunwayNameString(runwayNumber, designator, padded = true, prefix = '') {
        let numberText = `${runwayNumber}`;
        if (padded) {
            numberText = numberText.padStart(2, '0');
        }
        return prefix + numberText + RunwayUtils.getDesignatorLetter(designator);
    }
    /**
     * Gets the primary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The primary runway number for the specified runway.
     */
    static getRunwayNumberPrimary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return parseInt(runway.designation);
        }
        else {
            return parseInt(runway.designation.substring(0, dashIndex));
        }
    }
    /**
     * Gets the secondary runway number for a paired runway.
     * @param runway A paired runway.
     * @returns The secondary runway number for the specified runway, or `undefined` if the runway has no secondary
     * runway.
     */
    static getRunwayNumberSecondary(runway) {
        const dashIndex = runway.designation.search('-');
        if (dashIndex < 0) {
            return undefined;
        }
        else {
            return parseInt(runway.designation.substring(dashIndex + 1));
        }
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation by number and designator.
     * @param airport The airport facility in which to search for the match.
     * @param runwayNumber A runway number to match.
     * @param runwayDesignator A runway designator to match.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const length = airport.runways.length;
        for (let r = 0; r < length; r++) {
            const runway = airport.runways[r];
            const designation = runway.designation;
            const primaryRunwayNumber = parseInt(designation.split('-')[0]);
            const secondaryRunwayNumber = parseInt(designation.split('-')[1]);
            if (primaryRunwayNumber === runwayNumber && runway.designatorCharPrimary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[0];
            }
            else if (secondaryRunwayNumber === runwayNumber && runway.designatorCharSecondary === runwayDesignator) {
                const oneWayRunways = RunwayUtils.getOneWayRunways(runway, r);
                return oneWayRunways[1];
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway designation string.
     * @param airport The airport facility in which to search for the match.
     * @param designation A runway designation.
     * @returns The one-way runway which matches the designation, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromDesignation(airport, designation) {
        const length = airport.runways.length;
        for (let i = 0; i < length; i++) {
            const match = RunwayUtils.getOneWayRunways(airport.runways[i], i).find((r) => {
                return (r.designation === designation);
            });
            if (match) {
                return match;
            }
        }
        return undefined;
    }
    /**
     * Gets a one-way runway from an airport that matches a runway ident.
     * @param airport The airport facility in which to search for the match.
     * @param ident A runway ident.
     * @returns The one-way runway which matches the ident, or undefined if no match could be found.
     */
    static matchOneWayRunwayFromIdent(airport, ident) {
        return RunwayUtils.matchOneWayRunwayFromDesignation(airport, ident.substr(2).trim());
    }
    /**
     * Utility method to return the procedures for a given runway.
     * @param procedures The procedures for the airport.
     * @param runway The given runway to find procedures for.
     * @returns A list of approach procedures for the given runway.
     */
    static getProceduresForRunway(procedures, runway) {
        const oneways = new Array();
        // TODO Make the designation splitting logic a common routine too.
        const designations = runway.designation.split('-');
        for (let i = 0; i < designations.length; i++) {
            const runwayNumber = parseInt(designations[i]);
            let runwayName;
            if (i === 0) {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharPrimary, false, '');
            }
            else {
                runwayName = RunwayUtils.getRunwayNameString(runwayNumber, runway.designatorCharSecondary, false, '');
            }
            oneways.push(runwayName);
        }
        const found = new Array();
        for (const procedure of procedures) {
            if (oneways.includes(procedure.runway.trim())) {
                found.push(procedure);
            }
            else if (procedure.runwayNumber === 0) {
                found.push(procedure);
            }
        }
        return found;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getLocFrequency(airport, arg1, arg2) {
        let runway;
        if (typeof arg1 === 'string') {
            const matchedRunway = RunwayUtils.matchOneWayRunwayFromDesignation(airport, arg1);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else if (typeof arg1 === 'number') {
            const matchedRunway = RunwayUtils.matchOneWayRunway(airport, arg1, arg2);
            if (!matchedRunway) {
                return undefined;
            }
            runway = matchedRunway;
        }
        else {
            runway = arg1;
        }
        const runwayDesignation = runway.designation;
        if (runway.ilsFrequency) {
            return runway.ilsFrequency;
        }
        for (let i = 0; i < airport.frequencies.length; i++) {
            // Note: drop the leading zero in the runway designation for the search because some third-party sceneries
            // format the frequency names without the leading zero.
            const match = airport.frequencies[i].name.search(runwayDesignation.replace(/^0/, ''));
            if (match > -1) {
                return airport.frequencies[i];
            }
        }
        return undefined;
    }
    /**
     * Gets the back course frequency for a runway.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The bc frequency for the query runway, or undefined if one could not be found.
     */
    static getBcFrequency(airport, runwayNumber, runwayDesignator) {
        const matchedRunway = RunwayUtils.getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator);
        if (!matchedRunway) {
            return undefined;
        }
        return RunwayUtils.getLocFrequency(airport, matchedRunway);
    }
    /**
     * Get the opposite one way runway from a runway number and designator.
     * @param airport The airport to which the query runway belongs.
     * @param runwayNumber The number of the query runway.
     * @param runwayDesignator The designator of the query runway.
     * @returns The opposite one way runway for the query runway, or undefined if one could not be found.
     */
    static getOppositeOneWayRunway(airport, runwayNumber, runwayDesignator) {
        const oppositeRunwayNumber = Math.round(NavMath.normalizeHeading(10 * (runwayNumber + 18)) / 10);
        let oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_NONE;
        switch (runwayDesignator) {
            case RunwayDesignator.RUNWAY_DESIGNATOR_LEFT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT;
                break;
            case RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT:
                oppositeRunwayDesignator = RunwayDesignator.RUNWAY_DESIGNATOR_LEFT;
                break;
            default:
                oppositeRunwayDesignator = runwayDesignator;
                break;
        }
        return RunwayUtils.matchOneWayRunway(airport, oppositeRunwayNumber, oppositeRunwayDesignator);
    }
    /**
     * A comparer for sorting runways by number, and then by L, C, and R.
     * @param r1 The first runway to compare.
     * @param r2 The second runway to compare.
     * @returns -1 if the first is before, 0 if equal, 1 if the first is after.
     */
    static sortRunways(r1, r2) {
        if (r1.direction === r2.direction) {
            let v1 = 0;
            if (r1.designation.indexOf('L') != -1) {
                v1 = 1;
            }
            else if (r1.designation.indexOf('C') != -1) {
                v1 = 2;
            }
            else if (r1.designation.indexOf('R') != -1) {
                v1 = 3;
            }
            let v2 = 0;
            if (r2.designation.indexOf('L') != -1) {
                v2 = 1;
            }
            else if (r2.designation.indexOf('C') != -1) {
                v2 = 2;
            }
            else if (r2.designation.indexOf('R') != -1) {
                v2 = 3;
            }
            return v1 - v2;
        }
        return r1.direction - r2.direction;
    }
    /**
     * Gets the ICAO string for the runway facility associated with a one-way runway.
     * @param airport The runway's parent airport, or the ICAO of the airport.
     * @param runway A one-way runway.
     * @returns the ICAO string for the runway facility associated with the one-way runway.
     */
    static getRunwayFacilityIcao(airport, runway) {
        const icao = typeof airport === 'string' ? airport : airport.icao;
        return `R  ${icao.substring(7, 11)}RW${runway.designation.padEnd(3, ' ')}`;
    }
    /**
     * Creates a runway waypoint facility from a runway.
     * @param airport The runway's parent airport.
     * @param runway A one-way runway.
     * @returns A runway waypoint facility corresponding to the runway.
     */
    static createRunwayFacility(airport, runway) {
        return {
            icao: RunwayUtils.getRunwayFacilityIcao(airport, runway),
            name: `Runway ${runway.designation}`,
            region: airport.region,
            city: airport.city,
            lat: runway.latitude,
            lon: runway.longitude,
            magvar: airport.magvar,
            runway
        };
    }
    /**
     * Gets an alpha code from a runway number.
     * @param number is the runway number.
     * @returns a letter.
     */
    static getRunwayCode(number) {
        const n = Math.round(number);
        return String.fromCharCode(48 + n + (n > 9 ? 7 : 0));
    }
    /**
     * Gets the runway surface category from a runway or runway surface type.
     * @param runway A runway or runway surface type.
     * @returns The surface category of the specified runway or runway surface type.
     */
    static getSurfaceCategory(runway) {
        const surface = typeof runway === 'object' ? runway.surface : runway;
        if (this.SURFACES_HARD.includes(surface)) {
            return RunwaySurfaceCategory.Hard;
        }
        else if (this.SURFACES_SOFT.includes(surface)) {
            return RunwaySurfaceCategory.Soft;
        }
        else if (this.SURFACES_WATER.includes(surface)) {
            return RunwaySurfaceCategory.Water;
        }
        else {
            return RunwaySurfaceCategory.Unknown;
        }
    }
}
RunwayUtils.RUNWAY_DESIGNATOR_LETTERS = {
    [RunwayDesignator.RUNWAY_DESIGNATOR_NONE]: '',
    [RunwayDesignator.RUNWAY_DESIGNATOR_LEFT]: 'L',
    [RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT]: 'R',
    [RunwayDesignator.RUNWAY_DESIGNATOR_CENTER]: 'C',
    [RunwayDesignator.RUNWAY_DESIGNATOR_WATER]: 'W',
    [RunwayDesignator.RUNWAY_DESIGNATOR_A]: 'A',
    [RunwayDesignator.RUNWAY_DESIGNATOR_B]: 'B',
};
RunwayUtils.SURFACES_HARD = [
    RunwaySurfaceType.Asphalt,
    RunwaySurfaceType.Bituminous,
    RunwaySurfaceType.Brick,
    RunwaySurfaceType.Concrete,
    RunwaySurfaceType.Ice,
    RunwaySurfaceType.Macadam,
    RunwaySurfaceType.Paint,
    RunwaySurfaceType.Planks,
    RunwaySurfaceType.SteelMats,
    RunwaySurfaceType.Tarmac,
    RunwaySurfaceType.Urban,
];
RunwayUtils.SURFACES_SOFT = [
    RunwaySurfaceType.Coral,
    RunwaySurfaceType.Dirt,
    RunwaySurfaceType.Forest,
    RunwaySurfaceType.Grass,
    RunwaySurfaceType.GrassBumpy,
    RunwaySurfaceType.Gravel,
    RunwaySurfaceType.HardTurf,
    RunwaySurfaceType.LongGrass,
    RunwaySurfaceType.OilTreated,
    RunwaySurfaceType.Sand,
    RunwaySurfaceType.Shale,
    RunwaySurfaceType.ShortGrass,
    RunwaySurfaceType.Snow,
    RunwaySurfaceType.WrightFlyerTrack
];
RunwayUtils.SURFACES_WATER = [
    RunwaySurfaceType.WaterFSX,
    RunwaySurfaceType.Lake,
    RunwaySurfaceType.Ocean,
    RunwaySurfaceType.Pond,
    RunwaySurfaceType.River,
    RunwaySurfaceType.WasteWater,
    RunwaySurfaceType.Water
];
RunwayUtils.tempGeoPoint = new GeoPoint(0, 0);

/**
 * Utility functions for working with airport data.
 */
class AirportUtils {
    /**
     * Attempts to get the region code of an airport.
     * @param facility The facility record for the airport.
     * @returns The region code of an airport, or `undefined` if one could not be found.
     */
    static tryGetRegionCode(facility) {
        // Airports don't have region codes in their ICAO strings, so we will try a series of increasingly ugly hacks to
        // deduce the region code
        // First, we will look for any non-circling approach and see if we can find a runway fix and grab its region code,
        // which should always be the same code as the airport
        for (let i = 0; i < facility.approaches.length; i++) {
            const approach = facility.approaches[i];
            if (approach.runway.length === 0 || approach.finalLegs.length === 0) {
                continue;
            }
            const fixIcao = approach.finalLegs[approach.finalLegs.length - 1].fixIcao;
            if (ICAO.isFacility(fixIcao, FacilityType.RWY)) {
                const region = ICAO.getRegionCode(fixIcao);
                if (AirportUtils.REGION_CODES.has(region)) {
                    return region;
                }
            }
        }
        // Next, we will grab region codes from final approach fixes. If they all match, then it's a good bet the airport
        // region code is the same.
        if (facility.approaches.length > 1) {
            let region = undefined;
            let regionCount = 0;
            for (let i = 0; i < facility.approaches.length; i++) {
                const approach = facility.approaches[i];
                for (let j = 0; j < approach.finalLegs.length; j++) {
                    const leg = approach.finalLegs[j];
                    if (leg.fixTypeFlags === FixTypeFlags.FAF && ICAO.isFacility(leg.fixIcao)) {
                        const fafRegion = ICAO.getRegionCode(leg.fixIcao);
                        if (AirportUtils.REGION_CODES.has(fafRegion)) {
                            region !== null && region !== void 0 ? region : (region = fafRegion);
                            if (region !== fafRegion) {
                                region = undefined;
                            }
                            regionCount++;
                            break;
                        }
                    }
                }
                if (region === undefined && regionCount > 0) {
                    break;
                }
            }
            if (region !== undefined && regionCount > 1) {
                return region;
            }
        }
        // Next, we will grab the first two letters of the airport ident if the ident is exactly four letters and does not
        // contain any numerals.
        const ident = ICAO.getIdent(facility.icao);
        if (ident.length === 4 && ident.search(AirportUtils.NUMERAL_REGEX) < 0) {
            const region = ident.substring(0, 2);
            if (AirportUtils.REGION_CODES.has(region)) {
                return region;
            }
        }
        // Finally, we will search every procedure (excluding enroute transitions) at the airport for terminal intersections.
        // The region codes of these intersections should be the same as that of the airport.
        // Departures
        for (let i = 0; i < facility.departures.length; i++) {
            const departure = facility.departures[i];
            for (let j = 0; j < departure.commonLegs.length; j++) {
                const leg = departure.commonLegs[j];
                if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                    const region = ICAO.getRegionCode(leg.fixIcao);
                    if (AirportUtils.REGION_CODES.has(region)) {
                        return region;
                    }
                }
            }
            for (let j = 0; j < departure.runwayTransitions.length; j++) {
                const transition = departure.runwayTransitions[j];
                for (let k = 0; k < transition.legs.length; k++) {
                    const leg = transition.legs[k];
                    if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                        const region = ICAO.getRegionCode(leg.fixIcao);
                        if (AirportUtils.REGION_CODES.has(region)) {
                            return region;
                        }
                    }
                }
            }
        }
        // Arrivals
        for (let i = 0; i < facility.arrivals.length; i++) {
            const arrival = facility.arrivals[i];
            for (let j = 0; j < arrival.commonLegs.length; j++) {
                const leg = arrival.commonLegs[j];
                if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                    const region = ICAO.getRegionCode(leg.fixIcao);
                    if (AirportUtils.REGION_CODES.has(region)) {
                        return region;
                    }
                }
            }
            for (let j = 0; j < arrival.runwayTransitions.length; j++) {
                const transition = arrival.runwayTransitions[j];
                for (let k = 0; k < transition.legs.length; k++) {
                    const leg = transition.legs[k];
                    if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                        const region = ICAO.getRegionCode(leg.fixIcao);
                        if (AirportUtils.REGION_CODES.has(region)) {
                            return region;
                        }
                    }
                }
            }
        }
        // Approaches
        for (let i = 0; i < facility.approaches.length; i++) {
            const approach = facility.approaches[i];
            for (let j = 0; j < approach.finalLegs.length; j++) {
                const leg = approach.finalLegs[j];
                if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                    const region = ICAO.getRegionCode(leg.fixIcao);
                    if (AirportUtils.REGION_CODES.has(region)) {
                        return region;
                    }
                }
            }
            for (let j = 0; j < approach.transitions.length; j++) {
                const transition = approach.transitions[j];
                for (let k = 0; k < transition.legs.length; k++) {
                    const leg = transition.legs[k];
                    if (ICAO.isFacility(leg.fixIcao) && ICAO.getAssociatedAirportIdent(leg.fixIcao) === ident) {
                        const region = ICAO.getRegionCode(leg.fixIcao);
                        if (AirportUtils.REGION_CODES.has(region)) {
                            return region;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the elevation of an airport, in meters. The elevation is estimated as the average elevation of the airport's
     * runways. If the airport has no runways, an elevation cannot be estimated and `undefined` is returned instead.
     * @param facility The facility record for the airport.
     * @returns The elevation of the specified airport, in meters, or `undefined` if the elevation could not be
     * determined.
     */
    static getElevation(facility) {
        if (facility.runways.length === 0) {
            return undefined;
        }
        return facility.runways.reduce((sum, runway) => sum + runway.elevation, 0) / facility.runways.length;
    }
    /**
     * Gets the longest runway of an airport.
     * @param facility The facility record for the airport.
     * @returns The longest runway as an AirportRunway, or null.
     */
    static getLongestRunway(facility) {
        let longestRunway = null;
        for (const runway of facility.runways) {
            if (longestRunway === null || runway.length > longestRunway.length) {
                longestRunway = runway;
            }
        }
        return longestRunway;
    }
    /**
     * Get a list of runways at an airport matching specific criteria.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A list of matching runways.
     */
    static getFilteredRunways(facility, minLength, surfaceTypes) {
        minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
        const result = [];
        for (const runway of facility.runways) {
            if (runway.length >= minLength) {
                if (surfaceTypes === undefined ||
                    BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
                    result.push(runway);
                }
            }
        }
        return result;
    }
    /**
     * Checks to see whether an airport has a runway matching specific criteria.   This is a
     * lighter version of getFilteredRunways that doesn't do any extra assignments.
     * @param facility The facility record for the airport.
     * @param minLength The minimum length of the runway, in feet.
     * @param surfaceTypes An optional bitfield of RunwaySurfaceCategory values to allow.
     * @returns A boolean if a matching runway exists.
     */
    static hasMatchingRunway(facility, minLength, surfaceTypes) {
        minLength = UnitType.METER.convertFrom(minLength, UnitType.FOOT);
        for (const runway of facility.runways) {
            if (runway.length >= minLength) {
                if (surfaceTypes === undefined ||
                    BitFlags.isAny(RunwayUtils.getSurfaceCategory(runway), surfaceTypes)) {
                    return true;
                }
            }
        }
        return false;
    }
}
AirportUtils.REGION_CODES = new Set([
    'AG', 'AN', 'AY', 'BG', 'BI', 'BK', 'CY', 'DA', 'DB', 'DF', 'DG', 'DI', 'DN', 'DR', 'DT', 'DX', 'EB', 'ED', 'EE',
    'EF', 'EG', 'EH', 'EI', 'EK', 'EL', 'EN', 'EP', 'ES', 'ET', 'EV', 'EY', 'FA', 'FB', 'FC', 'FD', 'FE', 'FG', 'FH',
    'FI', 'FJ', 'FK', 'FL', 'FM', 'FN', 'FO', 'FP', 'FQ', 'FS', 'FT', 'FV', 'FW', 'FX', 'FY', 'FZ', 'GA', 'GB', 'GC',
    'GE', 'GF', 'GG', 'GL', 'GM', 'GO', 'GQ', 'GS', 'GU', 'GV', 'HA', 'HB', 'HD', 'HE', 'HH', 'HK', 'HL', 'HR', 'HS',
    'HT', 'HU', 'K1', 'K2', 'K3', 'K4', 'K5', 'K6', 'K7', 'LA', 'LB', 'LC', 'LD', 'LE', 'LF', 'LG', 'LH', 'LI', 'LJ',
    'LK', 'LL', 'LM', 'LO', 'LP', 'LQ', 'LR', 'LS', 'LT', 'LU', 'LV', 'LW', 'LX', 'LY', 'LZ', 'MB', 'MD', 'MG', 'MH',
    'MK', 'MM', 'MN', 'MP', 'MR', 'MS', 'MT', 'MU', 'MW', 'MY', 'MZ', 'NC', 'NF', 'NG', 'NI', 'NL', 'NS', 'NT', 'NV',
    'NW', 'NZ', 'OA', 'OB', 'OE', 'OI', 'OJ', 'OK', 'OL', 'OM', 'OO', 'OP', 'OR', 'OS', 'OT', 'OY', 'PA', 'PG', 'PH',
    'PJ', 'PK', 'PL', 'PM', 'PO', 'PP', 'PT', 'PW', 'RC', 'RJ', 'RK', 'RO', 'RP', 'SA', 'SB', 'SC', 'SD', 'SE', 'SG',
    'SI', 'SJ', 'SK', 'SL', 'SM', 'SO', 'SP', 'SS', 'SU', 'SV', 'SW', 'SY', 'TA', 'TB', 'TD', 'TF', 'TG', 'TI', 'TJ',
    'TK', 'TL', 'TN', 'TQ', 'TT', 'TU', 'TV', 'TX', 'UA', 'UB', 'UC', 'UD', 'UE', 'UG', 'UH', 'UI', 'UK', 'UL', 'UM',
    'UN', 'UO', 'UR', 'US', 'UT', 'UU', 'UW', 'VA', 'VC', 'VD', 'VE', 'VG', 'VH', 'VI', 'VL', 'VM', 'VN', 'VO', 'VR',
    'VT', 'VV', 'VY', 'WA', 'WB', 'WI', 'WM', 'WR', 'WS', 'YB', 'YM', 'ZB', 'ZG', 'ZH', 'ZK', 'ZL', 'ZM', 'ZP', 'ZS',
    'ZU', 'ZW', 'ZY'
]);
AirportUtils.NUMERAL_REGEX = /\d/;

/**
 * A utility class for working with approach procedures.
 */
class ApproachUtils {
    /**
     * Gets the best RNAV minimum type available for a given approach.
     * @param query The approach to check, or its RNAV type flags.
     * @returns The best RNAV minimum type available for the specified approach.
     */
    static getBestRnavType(query) {
        const rnavTypeFlags = typeof query === 'number' ? query : query.rnavTypeFlags;
        if (rnavTypeFlags & RnavTypeFlags.LPV) {
            return RnavTypeFlags.LPV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAVVNAV) {
            return RnavTypeFlags.LNAVVNAV;
        }
        if (rnavTypeFlags & RnavTypeFlags.LP) {
            return RnavTypeFlags.LP;
        }
        if (rnavTypeFlags & RnavTypeFlags.LNAV) {
            return RnavTypeFlags.LNAV;
        }
        return RnavTypeFlags.None;
    }
    /**
     * Checks whether an approach procedure is an RNP (AR) approach.
     * @param approach The approach procedure to check.
     * @returns Whether the approach procedure is an RNP (AR) approach.
     */
    static isRnpAr(approach) {
        return approach.approachType === ApproachType.APPROACH_TYPE_RNAV
            && approach.rnavTypeFlags === RnavTypeFlags.None
            && approach.runwayNumber !== 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static getFrequencyFromAirport(facility, approach) {
        if (typeof approach === 'number') {
            approach = facility.approaches[approach];
        }
        if (approach) {
            switch (approach.approachType) {
                case ApproachType.APPROACH_TYPE_ILS:
                case ApproachType.APPROACH_TYPE_LOCALIZER:
                case ApproachType.APPROACH_TYPE_LDA:
                case ApproachType.APPROACH_TYPE_SDF:
                    return RunwayUtils.getLocFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
                case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                    return RunwayUtils.getBcFrequency(facility, approach.runwayNumber, approach.runwayDesignator);
            }
        }
        return undefined;
    }
    /**
     * Gets the reference facility for an approach. Only ILS, LOC (BC), LDA, SDF, VOR(DME), and NDB(DME) approaches can
     * have reference facilities.
     * @param approach The approach for which to get a reference facility.
     * @param facLoader The facility loader.
     * @returns A Promise which is fulfilled with the reference facility for the specified approach, or `undefined` if
     * one could not be found.
     */
    static async getReferenceFacility(approach, facLoader) {
        let facilityType;
        let isLoc = false;
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
                isLoc = true;
            // eslint-disable-next-line no-fallthrough
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                facilityType = FacilityType.VOR;
                break;
            case ApproachType.APPROACH_TYPE_NDB:
            case ApproachType.APPROACH_TYPE_NDBDME:
                facilityType = FacilityType.NDB;
                break;
            default:
                return undefined;
        }
        const finalLegs = approach.finalLegs;
        // Find the faf
        let fafLeg = undefined;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = finalLegs[i];
            if (BitFlags.isAll(leg.fixTypeFlags, FixTypeFlags.FAF)) {
                fafLeg = leg;
                break;
            }
        }
        if (!fafLeg) {
            return undefined;
        }
        if (!ICAO.isFacility(fafLeg.originIcao, facilityType)) {
            return undefined;
        }
        try {
            const facility = await facLoader.getFacility(facilityType, fafLeg.originIcao);
            if (isLoc && facility.type !== VorType.ILS) {
                return undefined;
            }
            else {
                return facility;
            }
        }
        catch (_a) {
            return undefined;
        }
    }
}

/**
 * A viewlistener that gets autopilot mode information.
 */
var MSFSAPStates;
(function (MSFSAPStates) {
    MSFSAPStates[MSFSAPStates["LogicOn"] = 1] = "LogicOn";
    MSFSAPStates[MSFSAPStates["APOn"] = 2] = "APOn";
    MSFSAPStates[MSFSAPStates["FDOn"] = 4] = "FDOn";
    MSFSAPStates[MSFSAPStates["FLC"] = 8] = "FLC";
    MSFSAPStates[MSFSAPStates["Alt"] = 16] = "Alt";
    MSFSAPStates[MSFSAPStates["AltArm"] = 32] = "AltArm";
    MSFSAPStates[MSFSAPStates["GS"] = 64] = "GS";
    MSFSAPStates[MSFSAPStates["GSArm"] = 128] = "GSArm";
    MSFSAPStates[MSFSAPStates["Pitch"] = 256] = "Pitch";
    MSFSAPStates[MSFSAPStates["VS"] = 512] = "VS";
    MSFSAPStates[MSFSAPStates["Heading"] = 1024] = "Heading";
    MSFSAPStates[MSFSAPStates["Nav"] = 2048] = "Nav";
    MSFSAPStates[MSFSAPStates["NavArm"] = 4096] = "NavArm";
    MSFSAPStates[MSFSAPStates["WingLevel"] = 8192] = "WingLevel";
    MSFSAPStates[MSFSAPStates["Attitude"] = 16384] = "Attitude";
    MSFSAPStates[MSFSAPStates["ThrottleSpd"] = 32768] = "ThrottleSpd";
    MSFSAPStates[MSFSAPStates["ThrottleMach"] = 65536] = "ThrottleMach";
    MSFSAPStates[MSFSAPStates["ATArm"] = 131072] = "ATArm";
    MSFSAPStates[MSFSAPStates["YD"] = 262144] = "YD";
    MSFSAPStates[MSFSAPStates["EngineRPM"] = 524288] = "EngineRPM";
    MSFSAPStates[MSFSAPStates["TOGAPower"] = 1048576] = "TOGAPower";
    MSFSAPStates[MSFSAPStates["Autoland"] = 2097152] = "Autoland";
    MSFSAPStates[MSFSAPStates["TOGAPitch"] = 4194304] = "TOGAPitch";
    MSFSAPStates[MSFSAPStates["Bank"] = 8388608] = "Bank";
    MSFSAPStates[MSFSAPStates["FBW"] = 16777216] = "FBW";
    MSFSAPStates[MSFSAPStates["AvionicsManaged"] = 33554432] = "AvionicsManaged";
    MSFSAPStates[MSFSAPStates["None"] = -2147483648] = "None";
})(MSFSAPStates || (MSFSAPStates = {}));

/// <reference types="@microsoft/msfs-types/js/common" />
const airportIcaoRegionPattern = new RegExp(/^A../);
/**
 * A type map of facility type to facility search type.
 */
({
    /** Airport facility type. */
    [FacilityType.Airport]: FacilitySearchType.Airport,
    /** Intersection facility type. */
    [FacilityType.Intersection]: FacilitySearchType.Intersection,
    /** NDB facility type. */
    [FacilityType.NDB]: FacilitySearchType.Ndb,
    /** VOR facility type. */
    [FacilityType.VOR]: FacilitySearchType.Vor,
    /** USR facility type. */
    [FacilityType.USR]: FacilitySearchType.User,
    /** Visual facility type. */
    [FacilityType.VIS]: FacilitySearchType.Visual
});
/**
 * A class that handles loading facility data from the simulator.
 */
class FacilityLoader {
    /**
     * Creates an instance of the FacilityLoader.
     * @param facilityRepo A local facility repository.
     * @param onInitialized A callback to call when the facility loader has completed initialization.
     */
    constructor(facilityRepo, onInitialized = () => { }) {
        this.facilityRepo = facilityRepo;
        this.onInitialized = onInitialized;
        if (FacilityLoader.facilityListener === undefined) {
            FacilityLoader.facilityListener = RegisterViewListener('JS_LISTENER_FACILITY', () => {
                FacilityLoader.facilityListener.on('SendAirport', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendIntersection', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendVor', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('SendNdb', FacilityLoader.onFacilityReceived);
                FacilityLoader.facilityListener.on('NearestSearchCompleted', FacilityLoader.onNearestSearchCompleted);
                setTimeout(() => FacilityLoader.init(), 2000);
            }, true);
        }
        this.awaitInitialization().then(() => this.onInitialized());
    }
    /**
     * Initializes this facility loader.
     */
    static init() {
        FacilityLoader.isInitialized = true;
        for (const resolve of this.initPromiseResolveQueue) {
            resolve();
        }
        this.initPromiseResolveQueue.length = 0;
    }
    /**
     * Waits until this facility loader is initialized.
     * @returns A Promise which is fulfilled when this facility loader is initialized.
     */
    awaitInitialization() {
        if (FacilityLoader.isInitialized) {
            return Promise.resolve();
        }
        else {
            return new Promise(resolve => {
                FacilityLoader.initPromiseResolveQueue.push(resolve);
            });
        }
    }
    /**
     * Retrieves a facility.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    getFacility(type, icao) {
        switch (type) {
            case FacilityType.USR:
            case FacilityType.RWY:
            case FacilityType.VIS:
                return this.getFacilityFromRepo(type, icao);
            default:
                return this.getFacilityFromCoherent(type, icao);
        }
    }
    // eslint-disable-next-line jsdoc/require-throws
    /**
     * Retrieves a facility from the local facility repository.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromRepo(type, icao) {
        const fac = this.facilityRepo.get(icao);
        if (fac) {
            return fac;
        }
        else if (type === FacilityType.RWY) {
            try {
                const airport = await this.getFacility(FacilityType.Airport, `A      ${icao.substr(3, 4)} `);
                const runway = RunwayUtils.matchOneWayRunwayFromIdent(airport, ICAO.getIdent(icao));
                if (runway) {
                    const runwayFac = RunwayUtils.createRunwayFacility(airport, runway);
                    this.facilityRepo.add(runwayFac);
                    return runwayFac;
                }
            }
            catch (e) {
                // noop
            }
        }
        throw `Facility ${icao} could not be found.`;
    }
    /**
     * Retrieves a facility from Coherent.
     * @param type The type of facility to retrieve.
     * @param icao The ICAO of the facility to retrieve.
     * @returns A Promise which will be fulfilled with the requested facility, or rejected if the facility could not be
     * retrieved.
     */
    async getFacilityFromCoherent(type, icao) {
        const isMismatch = ICAO.getFacilityType(icao) !== type;
        // Remove the region code from the icao
        if (type === FacilityType.Airport) {
            icao = icao.replace(airportIcaoRegionPattern, 'A  ');
        }
        let queue = FacilityLoader.requestQueue;
        let cache = FacilityLoader.facCache;
        if (isMismatch) {
            queue = FacilityLoader.mismatchRequestQueue;
            cache = FacilityLoader.typeMismatchFacCache;
        }
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const cachedFac = cache.get(icao);
        if (cachedFac !== undefined) {
            return Promise.resolve(cachedFac);
        }
        const currentTime = Date.now();
        let request = queue.get(icao);
        if (request === undefined || currentTime - request.timeStamp > 10000) {
            if (request !== undefined) {
                request.reject(`Facility request for ${icao} has timed out.`);
            }
            let resolve = undefined;
            let reject = undefined;
            const promise = new Promise((resolution, rejection) => {
                resolve = resolution;
                reject = rejection;
                Coherent.call(type, icao).then((isValid) => {
                    if (!isValid) {
                        rejection(`Facility ${icao} could not be found.`);
                        queue.delete(icao);
                    }
                });
            });
            request = { promise, timeStamp: currentTime, resolve: resolve, reject: reject };
            queue.set(icao, request);
        }
        return request.promise;
    }
    /**
     * Gets airway data from the sim.
     * @param airwayName The airway name.
     * @param airwayType The airway type.
     * @param icao The 12 character FS ICAO of at least one intersection in the airway.
     * @returns The retrieved airway.
     * @throws an error if no airway is returned
     */
    async getAirway(airwayName, airwayType, icao) {
        if (FacilityLoader.airwayCache.has(airwayName)) {
            const cachedAirway = FacilityLoader.airwayCache.get(airwayName);
            const match = cachedAirway === null || cachedAirway === void 0 ? void 0 : cachedAirway.waypoints.find((w) => {
                w.icao === icao;
            });
            if (match !== undefined && cachedAirway !== undefined) {
                return cachedAirway;
            }
        }
        const fac = await this.getFacility(FacilityType.Intersection, icao);
        const route = fac.routes.find((r) => r.name === airwayName);
        if (route !== undefined) {
            const airwayBuilder = new AirwayBuilder(fac, route, this);
            const status = await airwayBuilder.startBuild();
            if (status === AirwayStatus.COMPLETE) {
                const waypoints = airwayBuilder.waypoints;
                if (waypoints !== null) {
                    const airway = new AirwayObject(airwayName, airwayType);
                    airway.waypoints = [...waypoints];
                    FacilityLoader.addToAirwayCache(airway);
                    return airway;
                }
            }
        }
        throw new Error('Airway could not be found.');
    }
    /**
     * Starts a nearest facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startNearestSearchSession(type) {
        switch (type) {
            case FacilitySearchType.User:
            case FacilitySearchType.Visual:
                return this.startRepoNearestSearchSession(type);
            case FacilitySearchType.AllExceptVisual:
                return this.startCoherentNearestSearchSession(FacilitySearchType.All);
            default:
                return this.startCoherentNearestSearchSession(type);
        }
    }
    /**
     * Starts a sim-side nearest facilities search session through Coherent.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     */
    async startCoherentNearestSearchSession(type) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const sessionId = await Coherent.call('START_NEAREST_SEARCH_SESSION', type);
        let session;
        switch (type) {
            case FacilitySearchType.Airport:
                session = new NearestAirportSearchSession(sessionId);
                break;
            case FacilitySearchType.Intersection:
                session = new NearestIntersectionSearchSession(sessionId);
                break;
            case FacilitySearchType.Vor:
                session = new NearestVorSearchSession(sessionId);
                break;
            case FacilitySearchType.Boundary:
                session = new NearestBoundarySearchSession(sessionId);
                break;
            default:
                session = new CoherentNearestSearchSession(sessionId);
                break;
        }
        FacilityLoader.searchSessions.set(sessionId, session);
        return session;
    }
    /**
     * Starts a repository facilities search session.
     * @param type The type of facilities for which to search.
     * @returns A Promise which will be fulfilled with the new nearest search session.
     * @throws Error if the search type is not supported.
     */
    startRepoNearestSearchSession(type) {
        // Session ID doesn't really matter for these, so in order to not conflict with IDs from Coherent, we will set
        // them all to negative numbers
        const sessionId = FacilityLoader.repoSearchSessionId--;
        switch (type) {
            case FacilitySearchType.User:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            case FacilitySearchType.Visual:
                return new NearestRepoFacilitySearchSession(this.facilityRepo, sessionId);
            default:
                throw new Error();
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    async getMetar(arg) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const ident = typeof arg === 'string' ? arg : ICAO.getIdent(arg.icao);
        const metar = await Coherent.call('GET_METAR_BY_IDENT', ident);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Searches for the METAR issued for the closest airport to a given location.
     * @param lat The latitude of the center of the search, in degrees.
     * @param lon The longitude of the center of the search, in degrees.
     * @returns The METAR issued for the closest airport to the given location, or undefined if none could be found.
     */
    async searchMetar(lat, lon) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        const metar = await Coherent.call('GET_METAR_BY_LATLON', lat, lon);
        return FacilityLoader.cleanMetar(metar);
    }
    /**
     * Cleans up a raw METAR object.
     * @param raw A raw METAR object.
     * @returns A cleaned version of the raw METAR object, or undefined if the raw METAR is empty.
     */
    static cleanMetar(raw) {
        if (raw.icao === '') {
            return undefined;
        }
        raw.gust < 0 && delete raw.gust;
        raw.vertVis < 0 && delete raw.vertVis;
        isNaN(raw.altimeterA) && delete raw.altimeterA;
        raw.altimeterQ < 0 && delete raw.altimeterQ;
        isNaN(raw.slp) && delete raw.slp;
        return raw;
    }
    /**
     * Searches for ICAOs by their ident portion only.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs.
     * @param ident The partial or complete ident to search for.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matched ICAOs. Exact matches are sorted before partial matches.
     */
    async searchByIdent(filter, ident, maxItems = 40) {
        if (!FacilityLoader.isInitialized) {
            await this.awaitInitialization();
        }
        let results;
        if (filter !== FacilitySearchType.User && filter !== FacilitySearchType.Visual) {
            const coherentFilter = filter === FacilitySearchType.AllExceptVisual ? FacilitySearchType.All : filter;
            results = await Coherent.call('SEARCH_BY_IDENT', ident, coherentFilter, maxItems);
        }
        else {
            results = [];
        }
        const facRepositorySearchTypes = FacilityLoader.facRepositorySearchTypes[filter];
        if (facRepositorySearchTypes) {
            this.facilityRepo.forEach(fac => {
                const facIdent = ICAO.getIdent(fac.icao);
                if (facIdent === ident) {
                    results.unshift(fac.icao);
                }
                else if (facIdent.startsWith(ident)) {
                    results.push(fac.icao);
                }
            }, facRepositorySearchTypes);
        }
        return results;
    }
    /**
     * Searches for facilities matching a given ident, and returns the matching facilities, with nearest at the beginning of the array.
     * @param filter The type of facility to filter by. Selecting ALL will search all facility type ICAOs, except for boundary facilities.
     * @param ident The exact ident to search for. (ex: DEN, KDEN, ITADO)
     * @param lat The latitude to find facilities nearest to.
     * @param lon The longitude to find facilities nearest to.
     * @param maxItems The maximum number of matches to return. Defaults to 40.
     * @returns An array of matching facilities, sorted by distance to the given lat/lon, with nearest at the beginning of the array.
     */
    async findNearestFacilitiesByIdent(filter, ident, lat, lon, maxItems = 40) {
        const results = await this.searchByIdent(filter, ident, maxItems);
        if (!results) {
            return [];
        }
        const promises = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i];
            const facIdent = ICAO.getIdent(icao);
            if (facIdent === ident) {
                const facType = ICAO.getFacilityType(icao);
                promises.push(this.getFacility(facType, icao));
            }
        }
        const foundFacilities = await Promise.all(promises);
        if (foundFacilities.length > 1) {
            foundFacilities.sort((a, b) => GeoPoint.distance(lat, lon, a.lat, a.lon) - GeoPoint.distance(lat, lon, b.lat, b.lon));
            return foundFacilities;
        }
        else if (foundFacilities.length === 1) {
            return foundFacilities;
        }
        else {
            return [];
        }
    }
    /**
     * A callback called when a facility is received from the simulator.
     * @param facility The received facility.
     */
    static onFacilityReceived(facility) {
        const isMismatch = facility['__Type'] === 'JS_FacilityIntersection' && facility.icao[0] !== 'W';
        const queue = isMismatch ? FacilityLoader.mismatchRequestQueue : FacilityLoader.requestQueue;
        const request = queue.get(facility.icao);
        if (request !== undefined) {
            request.resolve(facility);
            FacilityLoader.addToFacilityCache(facility, isMismatch);
            queue.delete(facility.icao);
        }
    }
    /**
     * A callback called when a search completes.
     * @param results The results of the search.
     */
    static onNearestSearchCompleted(results) {
        const session = FacilityLoader.searchSessions.get(results.sessionId);
        if (session instanceof CoherentNearestSearchSession) {
            session.onSearchCompleted(results);
        }
    }
    /**
     * Adds a facility to the cache.
     * @param fac The facility to add.
     * @param isTypeMismatch Whether to add the facility to the type mismatch cache.
     */
    static addToFacilityCache(fac, isTypeMismatch) {
        const cache = isTypeMismatch ? FacilityLoader.typeMismatchFacCache : FacilityLoader.facCache;
        cache.set(fac.icao, fac);
        if (cache.size > FacilityLoader.MAX_FACILITY_CACHE_ITEMS) {
            cache.delete(cache.keys().next().value);
        }
    }
    /**
     * Adds an airway to the airway cache.
     * @param airway The airway to add.
     */
    static addToAirwayCache(airway) {
        FacilityLoader.airwayCache.set(airway.name, airway);
        if (FacilityLoader.airwayCache.size > FacilityLoader.MAX_AIRWAY_CACHE_ITEMS) {
            FacilityLoader.airwayCache.delete(FacilityLoader.airwayCache.keys().next().value);
        }
    }
}
FacilityLoader.MAX_FACILITY_CACHE_ITEMS = 1000;
FacilityLoader.MAX_AIRWAY_CACHE_ITEMS = 1000;
FacilityLoader.requestQueue = new Map();
FacilityLoader.mismatchRequestQueue = new Map();
FacilityLoader.facCache = new Map();
FacilityLoader.typeMismatchFacCache = new Map();
FacilityLoader.airwayCache = new Map();
FacilityLoader.searchSessions = new Map();
FacilityLoader.facRepositorySearchTypes = {
    [FacilitySearchType.All]: [FacilityType.USR, FacilityType.VIS],
    [FacilitySearchType.User]: [FacilityType.USR],
    [FacilitySearchType.Visual]: [FacilityType.VIS],
    [FacilitySearchType.AllExceptVisual]: [FacilityType.USR]
};
FacilityLoader.repoSearchSessionId = -1;
FacilityLoader.isInitialized = false;
FacilityLoader.initPromiseResolveQueue = [];
/**
 * A session for searching for nearest facilities through Coherent.
 */
class CoherentNearestSearchSession {
    /**
     * Creates an instance of a CoherentNearestSearchSession.
     * @param sessionId The ID of the session.
     */
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.searchQueue = new Map();
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const promise = new Promise((resolve) => {
            Coherent.call('SEARCH_NEAREST', this.sessionId, lat, lon, radius, maxItems)
                .then((searchId) => {
                this.searchQueue.set(searchId, { promise, resolve });
            });
        });
        return promise;
    }
    /**
     * A callback called by the facility loader when a nearest search has completed.
     * @param results The search results.
     */
    onSearchCompleted(results) {
        const request = this.searchQueue.get(results.searchId);
        if (request !== undefined) {
            request.resolve(results);
            this.searchQueue.delete(results.searchId);
        }
    }
}
/**
 * A session for searching for nearest airports.
 */
class NearestAirportSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the airport nearest search.
     * @param showClosed Whether or not to show closed airports.
     * @param classMask A bitmask to determine which JS airport classes to show.
     */
    setAirportFilter(showClosed, classMask) {
        Coherent.call('SET_NEAREST_AIRPORT_FILTER', this.sessionId, showClosed ? 1 : 0, classMask);
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        Coherent.call('SET_NEAREST_EXTENDED_AIRPORT_FILTERS', this.sessionId, surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
    }
}
/**
 * Default filters for the nearest airports search session.
 */
NearestAirportSearchSession.Defaults = {
    ShowClosed: false,
    ClassMask: BitFlags.union(BitFlags.createFlag(AirportClass.HardSurface), BitFlags.createFlag(AirportClass.SoftSurface), BitFlags.createFlag(AirportClass.AllWater), BitFlags.createFlag(AirportClass.HeliportOnly), BitFlags.createFlag(AirportClass.Private)),
    SurfaceTypeMask: 2147483647,
    ApproachTypeMask: 2147483647,
    MinimumRunwayLength: 0,
    ToweredMask: 3
};
/**
 * A session for searching for nearest intersections.
 */
class NearestIntersectionSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the intersection nearest search.
     * @param typeMask A bitmask to determine which JS intersection types to show.
     * @param showTerminalWaypoints Whether or not to show terminal waypoints. Defaults to true.
     */
    setIntersectionFilter(typeMask, showTerminalWaypoints = true) {
        Coherent.call('SET_NEAREST_INTERSECTION_FILTER', this.sessionId, typeMask, showTerminalWaypoints ? 1 : 0);
    }
}
/**
 * Default filters for the nearest intersections search session.
 */
NearestIntersectionSearchSession.Defaults = {
    TypeMask: BitFlags.union(BitFlags.createFlag(IntersectionType.Named), BitFlags.createFlag(IntersectionType.Unnamed), BitFlags.createFlag(IntersectionType.Offroute), BitFlags.createFlag(IntersectionType.IAF), BitFlags.createFlag(IntersectionType.FAF))
};
/**
 * A session for searching for nearest VORs.
 */
class NearestVorSearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the VOR nearest search.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        Coherent.call('SET_NEAREST_VOR_FILTER', this.sessionId, classMask, typeMask);
    }
}
/**
 * Default filters for the nearest VORs search session.
 */
NearestVorSearchSession.Defaults = {
    ClassMask: BitFlags.union(BitFlags.createFlag(VorClass.Terminal), BitFlags.createFlag(VorClass.HighAlt), BitFlags.createFlag(VorClass.LowAlt)),
    TypeMask: BitFlags.union(BitFlags.createFlag(VorType.VOR), BitFlags.createFlag(VorType.DME), BitFlags.createFlag(VorType.VORDME), BitFlags.createFlag(VorType.VORTAC), BitFlags.createFlag(VorType.TACAN))
};
/**
 * A session for searching for nearest airspace boundaries.
 */
class NearestBoundarySearchSession extends CoherentNearestSearchSession {
    /**
     * Sets the filter for the boundary nearest search.
     * @param classMask A bitmask to determine which boundary classes to show.
     */
    setBoundaryFilter(classMask) {
        Coherent.call('SET_NEAREST_BOUNDARY_FILTER', this.sessionId, classMask);
    }
}
/**
 * A session for searching for nearest facilities that uses the facility repository.
 */
class NearestRepoFacilitySearchSession {
    /**
     * Creates an instance of a NearestUserSearchSession.
     * @param repo The facility repository in which to search.
     * @param sessionId The ID of the session.
     */
    constructor(repo, sessionId) {
        this.repo = repo;
        this.sessionId = sessionId;
        this.filter = undefined;
        this.cachedResults = new Set();
        this.searchId = 0;
    }
    /** @inheritdoc */
    searchNearest(lat, lon, radius, maxItems) {
        const radiusGAR = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const results = this.repo.search(FacilityType.USR, lat, lon, radiusGAR, maxItems, [], this.filter);
        const added = [];
        for (let i = 0; i < results.length; i++) {
            const icao = results[i].icao;
            if (this.cachedResults.has(icao)) {
                this.cachedResults.delete(icao);
            }
            else {
                added.push(icao);
            }
        }
        const removed = Array.from(this.cachedResults);
        this.cachedResults.clear();
        for (let i = 0; i < results.length; i++) {
            this.cachedResults.add(results[i].icao);
        }
        return Promise.resolve({
            sessionId: this.sessionId,
            searchId: this.searchId++,
            added,
            removed
        });
    }
    /**
     * Sets the filter for this search session.
     * @param filter A function to filter the search results.
     */
    setUserFacilityFilter(filter) {
        this.filter = filter;
    }
}
/**
 * An airway.
 */
class AirwayObject {
    /** Builds a Airway
     * @param name - the name of the new airway.
     * @param type - the type of the new airway.
     */
    constructor(name, type) {
        this._waypoints = [];
        this._name = name;
        this._type = type;
    }
    /**
     * Gets the name of the airway
     * @returns the airway name
     */
    get name() {
        return this._name;
    }
    /**
     * Gets the type of the airway
     * @returns the airway type
     */
    get type() {
        return this._type;
    }
    /**
     * Gets the waypoints of this airway.
     * @returns the waypoints of this airway.
     */
    get waypoints() {
        return this._waypoints;
    }
    /**
     * Sets the waypoints of this airway.
     * @param waypoints is the array of waypoints.
     */
    set waypoints(waypoints) {
        this._waypoints = waypoints;
    }
}
/**
 * WT Airway Status Enum
 */
var AirwayStatus;
(function (AirwayStatus) {
    /**
     * @readonly
     * @property {number} INCOMPLETE - indicates waypoints have not been loaded yet.
     */
    AirwayStatus[AirwayStatus["INCOMPLETE"] = 0] = "INCOMPLETE";
    /**
     * @readonly
     * @property {number} COMPLETE - indicates all waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["COMPLETE"] = 1] = "COMPLETE";
    /**
     * @readonly
     * @property {number} PARTIAL - indicates some, but not all, waypoints have been successfully loaded.
     */
    AirwayStatus[AirwayStatus["PARTIAL"] = 2] = "PARTIAL";
})(AirwayStatus || (AirwayStatus = {}));
/**
 * The Airway Builder.
 */
class AirwayBuilder {
    /** Creates an instance of the AirwayBuilder
     * @param _initialWaypoint is the initial intersection facility
     * @param _initialData is the intersection route to build from
     * @param facilityLoader is an instance of the facility loader
     */
    constructor(_initialWaypoint, _initialData, facilityLoader) {
        this._initialWaypoint = _initialWaypoint;
        this._initialData = _initialData;
        this.facilityLoader = facilityLoader;
        this._waypointsArray = [];
        this._hasStarted = false;
        this._isDone = false;
    }
    // constructor(private _initialWaypoint: IntersectionFacility, private _requestEntry: (entry: string) => Promise<IntersectionFacility>) {
    // }
    /**
     * Get whether this builder has started loading waypoints
     * @returns whether this builder has started
     */
    get hasStarted() {
        return this._hasStarted;
    }
    /**
     * Get whether this builder is done loading waypoints
     * @returns whether this builder is done loading waypoints
     */
    get isDone() {
        return this._isDone;
    }
    /**
     * Get the airway waypoints
     * @returns the airway waypoints, or null
     */
    get waypoints() {
        return this._waypointsArray;
    }
    /** Steps through the airway waypoints
     * @param stepForward is the direction to step; true = forward, false = backward
     * @param arrayInsertFunc is the arrayInsertFunc
     */
    async _step(stepForward, arrayInsertFunc) {
        let isDone = false;
        let current = this._initialData;
        while (!isDone && current) {
            const nextICAO = stepForward ? current.nextIcao : current.prevIcao;
            if (nextICAO && nextICAO.length > 0 && nextICAO[0] != ' ' && this._waypointsArray !== null
                && !this._waypointsArray.find(waypoint => waypoint.icao === nextICAO)) {
                const fac = await this.facilityLoader.getFacility(FacilityType.Intersection, nextICAO);
                arrayInsertFunc(fac);
                const next = fac.routes.find((route) => route.name === current.name);
                if (next !== undefined) {
                    current = next;
                }
                else {
                    isDone = true;
                }
            }
            else {
                isDone = true;
            }
        }
    }
    /** Steps Forward through the airway waypoints
     * @returns the step forward function
     */
    async _stepForward() {
        if (this._waypointsArray !== null) {
            return this._step(true, this._waypointsArray.push.bind(this._waypointsArray));
        }
    }
    /** Steps Backward through the airway waypoints
     * @returns the step backward function
     */
    async _stepBackward() {
        if (this._waypointsArray !== null) {
            return this._step(false, this._waypointsArray.unshift.bind(this._waypointsArray));
        }
    }
    /**
     * Sets the array into which this builder will load waypoints.
     * @param array is the array into which the builder will load waypoints
     */
    setWaypointsArray(array) {
        this._waypointsArray = array;
    }
    /**
     * Begins loading waypoints for this builder's parent airway.
     * @returns a Promise to return a status code corresponding to Airway.Status when this builder has
     * finished loading waypoints.
     */
    startBuild() {
        if (this.hasStarted) {
            return Promise.reject(new Error('Airway builder has already started building.'));
        }
        return new Promise(resolve => {
            this._hasStarted = true;
            if (this._waypointsArray !== null) {
                this._waypointsArray.push(this._initialWaypoint);
                Promise.all([
                    this._stepForward(),
                    this._stepBackward()
                ]).then(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.COMPLETE);
                }).catch(() => {
                    this._isDone = true;
                    resolve(AirwayStatus.PARTIAL);
                });
            }
        });
    }
}

/**
 * A binary min-heap. Each element added to the heap is ordered according to the value of an assigned key relative
 * to the keys of the other elements in the heap. The relative values of element keys are defined by a supplied
 * comparator function. Retrieval of the element with the smallest key (minimum element) is performed in constant time.
 * Removal of the minimum element and insertions are performed in logarithmic time. Additionally, this type of heap
 * supports combined insertion and removal operations (in either order) which are slightly more efficient than chaining
 * the two operations separately.
 */
class BinaryHeap {
    /**
     * Constructor.
     * @param comparator The function that this heap uses to compare the keys of its elements. The function returns 0 if
     * `a` and `b` share the same key, a negative number if `a` has a lower key than `b`, and a positive number if `a`
     * has a greater key than `b`.
     */
    constructor(comparator) {
        this.comparator = comparator;
        this.tree = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements contained in this heap. */
    get size() {
        return this.tree.length;
    }
    /**
     * Finds the element in this heap with the smallest key.
     * @returns The element in this heap with the smallest key, or undefined if this heap is empty.
     */
    findMin() {
        return this.tree[0];
    }
    /**
     * Removes and returns the element in this heap with the smallest key.
     * @returns The removed element, or undefined if this heap is empty.
     */
    removeMin() {
        if (this.tree.length === 0) {
            return undefined;
        }
        const min = this.tree[0];
        this.swap(0, this.tree.length - 1);
        this.tree.length--;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Inserts an element into this heap.
     * @param element The element to insert.
     * @returns This heap, after the element has been inserted.
     */
    insert(element) {
        this.tree.push(element);
        this.heapifyUp(this.tree.length - 1);
        return this;
    }
    /**
     * Inserts an element into this heap, then removes the element with the smallest key.
     * @param element The element to insert.
     * @returns The removed element.
     */
    insertAndRemoveMin(element) {
        if (this.tree.length === 0 || this.comparator(element, this.tree[0]) <= 0) {
            return element;
        }
        return this.removeMinAndInsert(element);
    }
    /**
     * Removes the element in this heap with the smallest key, then inserts a new element.
     * @param element The element to insert.
     * @returns The removed element, or undefined if this heap was empty before the new element was inserted.
     */
    removeMinAndInsert(element) {
        const min = this.tree[0];
        this.tree[0] = element;
        this.heapifyDown(0);
        return min;
    }
    /**
     * Removes all elements from this heap.
     * @returns This heap, after it has been cleared.
     */
    clear() {
        this.tree.length = 0;
        return this;
    }
    /**
     * Restores the heap property for this heap upwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyUp(index) {
        let parent = BinaryHeap.parent(index);
        while (parent >= 0 && this.comparator(this.tree[index], this.tree[parent]) < 0) {
            this.swap(parent, index);
            index = parent;
            parent = BinaryHeap.parent(index);
        }
    }
    /**
     * Restores the heap property for this heap downwards from a node which potentially violates the property.
     * @param index The index of the node at which to begin the operation.
     */
    heapifyDown(index) {
        const len = this.tree.length;
        while (index < len) {
            const left = BinaryHeap.left(index);
            const right = BinaryHeap.right(index);
            let needSwapFlags = 0;
            if (left < len && this.comparator(this.tree[index], this.tree[left]) > 0) {
                needSwapFlags |= 1;
            }
            if (right < len && this.comparator(this.tree[index], this.tree[right]) > 0) {
                needSwapFlags |= 2;
            }
            if (needSwapFlags === 3) {
                needSwapFlags = this.comparator(this.tree[left], this.tree[right]) <= 0 ? 1 : 2;
            }
            if (needSwapFlags === 0) {
                break;
            }
            const swapChild = needSwapFlags === 1 ? left : right;
            this.swap(index, swapChild);
            index = swapChild;
        }
    }
    /**
     * Swaps two nodes in this heap.
     * @param index1 The index of the first node.
     * @param index2 The index of the second node.
     */
    swap(index1, index2) {
        const old1 = this.tree[index1];
        this.tree[index1] = this.tree[index2];
        this.tree[index2] = old1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's left child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's left child.
     */
    static left(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's right child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's right child.
     */
    static right(index) {
        return index * 2 + 2;
    }
}

/**
 * A sorted array.
 */
class SortedArray {
    /**
     * Constructor.
     * @param comparatorFunc A function which defines the relative sorting priority of two elements. The function should
     * return 0 if its arguments are to be sorted identically, a negative number if the first argument is to be sorted
     * before the second argument, and a positive number if the first argument is to be sorted after the second argument.
     * @param equalityFunc A function which checks if two elements are equal. Defaults to the strict equality comparison
     * (`===`) if not defined.
     */
    constructor(comparatorFunc, equalityFunc = SortedArray.DEFAULT_EQUALITY_FUNC) {
        this.comparatorFunc = comparatorFunc;
        this.equalityFunc = equalityFunc;
        this._array = [];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** A read-only version of the array object backing this sorted array. */
    get array() {
        return this._array;
    }
    /**
     * The number of elements in this array.
     * @returns The number of elements in the array.
     */
    get length() {
        return this._array.length;
    }
    /**
     * Finds the index of the first or last element in this array whose sorting priority is equal to a query element. If
     * no such element in this array exists, `-(index + 1)` is returned, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param element The query element.
     * @param first Whether to find the first index.
     * @returns The index of the first or last element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    findIndex(element, first = true) {
        let min = 0;
        let max = this._array.length;
        let index = Math.floor((min + max) / 2);
        while (min < max) {
            const compare = this.comparatorFunc(element, this._array[index]);
            if (compare < 0) {
                max = index;
            }
            else if (compare > 0) {
                min = index + 1;
            }
            else {
                const delta = first ? -1 : 1;
                while (index + delta >= 0 && index + delta < this._array.length && this.comparatorFunc(element, this._array[index + delta]) === 0) {
                    index += delta;
                }
                return index;
            }
            index = Math.floor((min + max) / 2);
        }
        return -(index + 1);
    }
    /**
     * Finds the index of the first element in this array which equals a query element, starting at a specified index.
     * The search proceeds toward the end of the array, ending at the first index containing an element whose sorting
     * priority does not equal the query, or the end of the array, whichever comes first. If no such element in this
     * array exists, -1 is returned instead.
     * @param element The query element.
     * @param startIndex The index at which to start the search.
     * @returns The index of the first element in this array which equals the query element, or -1 if no such element
     * exists.
     */
    searchEquals(element, startIndex) {
        let index = startIndex;
        while (index >= 0 && index < this._array.length && this.comparatorFunc(element, this._array[index]) === 0) {
            if (this.equalityFunc(element, this._array[index])) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the element at a specified index.
     * @param index An index.
     * @returns The element at the specified index.
     * @throws RangeError if index is out of bounds.
     */
    get(index) {
        if (index < 0 || index >= this._array.length) {
            throw new RangeError();
        }
        return this._array[index];
    }
    /**
     * Gets the element at a specified index, if it exists.
     * @param index An index.
     * @returns The element at the specified index, or undefined if the index is out of bounds.
     */
    peek(index) {
        return this._array[index];
    }
    /**
     * Gets the first element in this array.
     * @returns The first element in this array.
     * @throws RangeError if this array is empty.
     */
    first() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[0];
    }
    /**
     * Gets the first element in this array, if it exists.
     * @returns The first element in this array, or undefined if this array is empty.
     */
    peekFirst() {
        return this._array[0];
    }
    /**
     * Gets the last element in this array.
     * @returns The last element in this array.
     * @throws RangeError if this array is empty.
     */
    last() {
        if (this._array.length === 0) {
            throw new RangeError();
        }
        return this._array[this._array.length - 1];
    }
    /**
     * Gets the last element in this array, if it exists.
     * @returns The last element in this array, or undefined if this array is empty.
     */
    peekLast() {
        return this._array[this._array.length - 1];
    }
    /**
     * Checks whether this array contains an element. Returns true if and only if there is at least one element in this
     * array which is equal to the specified element according to this array's equality function.
     * @param element The element to check.
     * @returns Whether this array contains the element.
     */
    has(element) {
        return this.searchEquals(element, this.findIndex(element)) >= 0;
    }
    /**
     * Inserts an element into this array. The element will be inserted at the greatest index such that it is located
     * before all the existing elements in the array sorted after it according to this array's sorting function. All
     * existing elements located at indexes greater than or equal to the index at which the element was inserted are
     * shifted to the right.
     * @param element The element to insert.
     * @returns The index at which the element was placed.
     */
    insert(element) {
        let index = this.findIndex(element, false);
        if (index < 0) {
            index = -index - 1;
        }
        this._array.splice(index, 0, element);
        return index;
    }
    /**
     * Inserts all elements in an Iterable into this array. Each element is inserted according to the same behavior used
     * by the `insert()` method. If an element appears more than once in the iterable, one instance of that element will
     * be inserted into this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to insert.
     * @returns The number of elements inserted.
     */
    insertAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let toInsertIndex = 0;
        let toInsert = sorted[toInsertIndex];
        const len = this._array.length;
        const insertLen = sorted.length;
        for (let i = 0; i < len && toInsertIndex < insertLen; i++) {
            if (this.comparatorFunc(toInsert, this._array[i]) > 0) {
                this._array.splice(i, 0, toInsert);
                toInsert = sorted[++toInsertIndex];
            }
        }
        for (; toInsertIndex < insertLen; toInsertIndex++) {
            this._array.push(sorted[toInsertIndex]);
        }
        return sorted.length;
    }
    /**
     * Removes the first occurrence of an element from this array. This array is searched for the first element which
     * is equal to the specified element according to this array's equality function, the matching element is removed,
     * and all elements after it are shifted to the left.
     * @param element The element to remove.
     * @returns The (former) index of the removed element, or -1 if no element was removed.
     */
    remove(element) {
        const index = this.searchEquals(element, this.findIndex(element));
        if (index >= 0) {
            this._array.splice(index, 1);
        }
        return index;
    }
    /**
     * Removes all elements in an Iterable from this array. Each element is removed according to the behavior used by the
     * `remove()` method. If an element appears more than once in the iterable, one instance of that element will be
     * removed from this array for each time the element appears in the iterable.
     * @param elements An iterable of elements to remove.
     * @returns The number of elements removed.
     */
    removeAll(elements) {
        const sorted = Array.from(elements).sort(this.comparatorFunc);
        let numRemoved = 0;
        let toRemoveIndex = 0;
        let toRemove = sorted[toRemoveIndex];
        const len = this._array.length;
        const removeLen = sorted.length;
        for (let i = 0; i < len && toRemoveIndex < removeLen; i++) {
            if (this.equalityFunc(toRemove, this._array[i])) {
                this._array.splice(i--, 1);
                toRemove = sorted[++toRemoveIndex];
                numRemoved++;
            }
        }
        return numRemoved;
    }
    /**
     * Removes an element at a specific index from this array and returns it.
     * @param index The index of the element to remove.
     * @returns The removed element, or `undefined` if no element was removed.
     */
    removeAt(index) {
        if (index < 0 || index >= this._array.length) {
            return undefined;
        }
        return this._array.splice(index, 1)[0];
    }
    /**
     * Removes the last element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    pop() {
        return this._array.pop();
    }
    /**
     * Removes the first element from this array and returns it.
     * @returns The removed element, or `undefined` if the array was empty.
     */
    shift() {
        return this._array.shift();
    }
    /**
     * Re-sorts this array using its sorting function.
     */
    resort() {
        this._array.sort(this.comparatorFunc);
    }
    /**
     * Finds the index of the first occurrence of an element in this array. This array is searched for the first element
     * which is equal to the specified element according to this array's equality function, and its index is returned.
     * @param element The element for which to search.
     * @returns The index of the first occurrence of the specified element, or -1 if no such element was found.
     */
    indexOf(element) {
        return this.searchEquals(element, this.findIndex(element));
    }
    /**
     * Searches this array for the first element whose sorting priority is equal to a query element. If no such element
     * is found, then undefined is returned instead.
     * @param query The query element.
     * @returns The first element in the array with the same sorting priority as the query, or undefined if no such
     * element exists.
     */
    match(query) {
        const index = this.matchIndex(query);
        return this._array[index];
    }
    /**
     * Searches this array for the index of the first element whose sorting priority is equal to a query element. If no
     * such element is found, then `-(index + 1)` is returned instead, where `index` is the index at which the query
     * element would be found if it were contained in the array.
     * @param query The query element.
     * @returns The index of the first element in this array with the same sorting priority as the query, or
     * `-(index + 1)` if no such element exists, where `index` is the index at which the query element would be found if
     * it were contained in the array.
     */
    matchIndex(query) {
        return this.findIndex(query);
    }
    /**
     * Removes all elements from this array.
     */
    clear() {
        this._array.length = 0;
    }
    /**
     * Gets an IterableIterator over all elements in this array.
     * @returns An IterableIterator over all elements in this array.
     */
    values() {
        return this._array.values();
    }
    /** @inheritdoc */
    [Symbol.iterator]() {
        return this._array.values();
    }
}
SortedArray.DEFAULT_EQUALITY_FUNC = (a, b) => a === b;

/**
 * A linearly interpolated N-dimensional lookup table.
 */
class LerpLookupTable {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg) {
        this.table = new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg === 'number') {
            this._dimensionCount = isNaN(arg) ? 0 : Math.max(0, arg);
            return;
        }
        const leastDimension = arg.reduce((accum, current) => (current.length < accum.length) ? current : accum);
        this._dimensionCount = Math.max(0, leastDimension ? (leastDimension.length - 1) : 0);
        if (this._dimensionCount === 0) {
            return;
        }
        for (let i = 0; i < arg.length; i++) {
            this.insertBreakpoint(arg[i]);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, or the breakpoint has fewer dimensions than this table.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a value in this table using a specified key. The returned value will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The value corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a value could
     * not be retrieved.
     */
    get(...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table);
        if (value === undefined) {
            throw new Error(`LerpLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray) {
        const dimensionKey = key[dimension];
        const query = LerpLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        if (startValue === endValue) {
            return startValue;
        }
        return MathUtils.lerp(dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpLookupTable.tempBreakpoint = { key: 0 };

/**
 * A linearly interpolated N-dimensional lookup table of vectors.
 */
class LerpVectorLookupTable {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(arg1, arg2) {
        var _a, _b;
        this.table = new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR);
        if (typeof arg1 === 'number') {
            this._dimensionCount = isFinite(arg1) ? 0 : Math.max(0, arg1);
            this._vectorLength = isFinite(arg2) ? 0 : Math.max(0, arg2);
        }
        else {
            let leastBreakpointDimension = Infinity;
            let leastVectorLength = Infinity;
            for (let i = 0; i < arg1.length; i++) {
                leastBreakpointDimension = Math.min(leastBreakpointDimension, Math.max(arg1[i].length - 1, 0));
                leastVectorLength = Math.min(leastVectorLength, (_b = (_a = arg1[i][0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
            }
            this._dimensionCount = isFinite(leastBreakpointDimension) ? leastBreakpointDimension : 0;
            this._vectorLength = isFinite(leastVectorLength) ? leastVectorLength : 0;
            if (this._dimensionCount > 0) {
                for (let i = 0; i < arg1.length; i++) {
                    this.insertBreakpoint(arg1[i]);
                }
            }
        }
        // Create temporary working vectors: we need 2 per dimension.
        this.tempVectors = ArrayUtils.create(this._dimensionCount * 2, () => new Float64Array(this._vectorLength));
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of dimensions in this table. */
    get dimensionCount() {
        return this._dimensionCount;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of the vectors in this table. */
    get vectorLength() {
        return this._vectorLength;
    }
    /**
     * Inserts a breakpoint into this table. If the breakpoint has more dimensions than this table, only the first `N`
     * keys of the breakpoint will be used, where `N` is the dimension count of this table.
     * @param breakpoint A breakpoint, as a number array with the value at index 0 followed by the keys for each
     * dimension.
     * @returns This table, after the breakpoint has been inserted.
     * @throws Error if this table has zero dimensions, the breakpoint has fewer dimensions than this table, or the
     * the length of the breakpoint vector is less than this table's vector length property.
     */
    insertBreakpoint(breakpoint) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpVectorLookupTable: cannot insert a breakpoint into a 0-dimensional table');
        }
        if (breakpoint.length - 1 < this._dimensionCount) {
            throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint.length - 1}-dimensional breakpoint into a ${this._dimensionCount}-dimensional table`);
        }
        if (breakpoint[0].length < this._vectorLength) {
            throw new Error(`LerpVectorLookupTable: cannot insert a ${breakpoint[0].length}-length vector into a table with vectors of length ${this._vectorLength}`);
        }
        this.insertBreakpointHelper(breakpoint, 0, this.table);
        return this;
    }
    /**
     * Helper method for inserting a breakpoint into this table.
     * @param breakpoint The breakpoint to insert.
     * @param dimension The current dimension being evaluated.
     * @param array The array of dimensional breakpoints into which the breakpoint should be inserted.
     */
    insertBreakpointHelper(breakpoint, dimension, array) {
        const dimensionKey = breakpoint[dimension + 1];
        const query = LerpVectorLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        if (dimension === this._dimensionCount - 1) {
            let match = array.match(query);
            if (!match) {
                match = { key: dimensionKey, value: breakpoint[0] };
                array.insert(match);
            }
        }
        else {
            let next = array.match(query);
            if (!next) {
                array.insert(next = { key: dimensionKey, array: new SortedArray(LerpVectorLookupTable.BREAKPOINT_COMPARATOR) });
            }
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.insertBreakpointHelper(breakpoint, dimension + 1, next.array);
        }
    }
    /**
     * Looks up a vector in this table using a specified key. The returned vector will be linearly interpolated from
     * surrounding breakpoints if the key is not an exact match for any of the table's breakpoints.
     * @param out The vector to which to write the result.
     * @param key The lookup key, as an ordered N-tuple of numbers.
     * @returns The vector corresponding to the specified key.
     * @throws Error if this table has zero dimensions, the key has fewer dimensions than this table, or a vector could
     * not be retrieved.
     */
    get(out, ...key) {
        if (this._dimensionCount === 0) {
            throw new Error('LerpVectorLookupTable: cannot look up a key in a 0-dimensional table');
        }
        if (key.length < this._dimensionCount) {
            throw new Error(`LerpVectorLookupTable: cannot look up a ${key.length}-dimensional key in a ${this._dimensionCount}-dimensional table`);
        }
        const value = this.lookupHelper(key, 0, this.table, out);
        if (value === undefined) {
            throw new Error(`LerpVectorLookupTable: could not retrieve value for key ${key}`);
        }
        return value;
    }
    /**
     * Helper method for looking up a key in this table.
     * @param key The key to look up.
     * @param dimension The current dimension being evaluated.
     * @param lookupArray The array containing breakpoints in the next lower dimension in which to search for the key.
     * @param out The vector to which to write the result.
     * @returns The interpolated value of the key at the specified dimension.
     */
    lookupHelper(key, dimension, lookupArray, out) {
        const dimensionKey = key[dimension];
        const query = LerpVectorLookupTable.tempBreakpoint;
        query.key = dimensionKey;
        const index = lookupArray.matchIndex(query);
        let start;
        let end;
        if (index >= 0) {
            start = lookupArray.peek(index);
            end = start;
        }
        else {
            start = lookupArray.peek(-index - 2);
            end = lookupArray.peek(-index - 1);
            if (!start) {
                start = end;
            }
            if (!end) {
                end = start;
            }
        }
        if (!start || !end) {
            return undefined;
        }
        let startValue;
        let endValue;
        if (dimension === this.dimensionCount - 1) {
            startValue = start.value;
            endValue = end.value;
        }
        else {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            startValue = this.lookupHelper(key, dimension + 1, start.array, this.tempVectors[dimension * 2]);
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            endValue = this.lookupHelper(key, dimension + 1, end.array, this.tempVectors[dimension * 2 + 1]);
        }
        if (startValue === undefined || endValue === undefined) {
            return undefined;
        }
        return MathUtils.lerpVector(out, dimensionKey, start.key, end.key, startValue, endValue);
    }
}
LerpVectorLookupTable.BREAKPOINT_COMPARATOR = (a, b) => a.key - b.key;
LerpVectorLookupTable.tempBreakpoint = { key: 0 };

/**
 * A k-dimensional search tree.
 */
class KdTree {
    /**
     * Constructor.
     * @param dimensionCount The number of dimensions supported by this tree. If this argument is not an integer, it will
     * be truncated to one.
     * @param keyFunc A function which generates keys from elements. Keys are an N-tuple of numbers, where N is equal to
     * the dimension count of this tree.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(dimensionCount, keyFunc) {
        this.keyFunc = keyFunc;
        this.elements = [];
        this.keys = [];
        this.nodes = [];
        this.minDepth = -1;
        this.maxDepth = -1;
        this.dimensionCount = Math.trunc(dimensionCount);
        if (this.dimensionCount < 2) {
            throw new Error(`KdTree: cannot create a tree with ${this.dimensionCount} dimensions.`);
        }
        this.indexArrays = Array.from({ length: this.dimensionCount + 1 }, () => []);
        this.indexSortFuncs = Array.from({ length: this.dimensionCount }, (v, index) => {
            return (a, b) => {
                const aKey = this.keys[a];
                const bKey = this.keys[b];
                for (let i = 0; i < this.dimensionCount; i++) {
                    const dimension = (i + index) % this.dimensionCount;
                    if (aKey[dimension] < bKey[dimension]) {
                        return -1;
                    }
                    else if (aKey[dimension] > bKey[dimension]) {
                        return 1;
                    }
                }
                return 0;
            };
        });
        this.keyCache = [
            new Float64Array(this.dimensionCount)
        ];
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The number of elements in this tree. */
    get size() {
        return this.elements.length;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    searchKey(key, radius, arg3, out, filter) {
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(undefined, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(undefined, key, radius, arg3);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(element, radius, arg3, out, filter) {
        const key = this.keyFunc(element, this.keyCache[0]);
        if (typeof arg3 === 'number') {
            return this.doResultsSearch(element, key, radius, arg3, out, filter);
        }
        else {
            this.doVisitorSearch(element, key, radius, arg3);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(element, key, radius, visitor) {
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            return visitor(elementInner, keyInner, distance, queryKey, queryElement);
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            return searchRadius + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(element, key, radius, maxResultCount, out, filter) {
        if (maxResultCount <= 0) {
            out.length = 0;
            return out;
        }
        const heap = new BinaryHeap((a, b) => KdTree.distance(key, this.keys[b], this.dimensionCount) - KdTree.distance(key, this.keys[a], this.dimensionCount));
        const resultHandler = (elementIndex, elementInner, keyInner, distance, queryKey, queryElement) => {
            if (!filter || filter(elementInner, keyInner, distance, queryKey, queryElement)) {
                if (heap.size === maxResultCount) {
                    heap.insertAndRemoveMin(elementIndex);
                }
                else {
                    heap.insert(elementIndex);
                }
            }
            return true;
        };
        const traversalHandler = (offsetFromPivot, searchRadius, child) => {
            let maxDist = searchRadius;
            if (heap.size === maxResultCount) {
                maxDist = Math.min(maxDist, KdTree.distance(key, this.keys[heap.findMin()], this.dimensionCount));
            }
            return maxDist + offsetFromPivot * child >= 0;
        };
        this.searchTree(element, key, radius, 0, 0, resultHandler, traversalHandler);
        out.length = heap.size;
        for (let i = out.length - 1; i >= 0; i--) {
            out[i] = this.elements[heap.removeMin()];
        }
        return out;
    }
    /**
     * Searches a subtree for elements whose keys are located near a query key.
     * @param element The query element, or undefined if none exists.
     * @param key The query key.
     * @param radius The search radius.
     * @param nodeIndex The index of the root of the subtree to search.
     * @param pivotDimension The dimension in which the root of the subtree is split.
     * @param resultHandler A function which will be called once per element found within the search radius. If the
     * function returns `true`, then the search will continue; if the function returns `false`, the search will
     * immediately halt.
     * @param traversalHandler A function which determines whether the search will proceed to a child node. If the
     * function returns `true`, the search will continue; if the function returns `false`, the search will skip the
     * child.
     * @returns `false` if the search was terminated prematurely by the `resultHandler` function, and `true` otherwise.
     */
    searchTree(element, key, radius, nodeIndex, pivotDimension, resultHandler, traversalHandler) {
        const elementIndex = this.nodes[nodeIndex];
        if (elementIndex === undefined) {
            return true;
        }
        const nodeKey = this.keys[elementIndex];
        const distanceFromNode = KdTree.distance(key, nodeKey, this.dimensionCount);
        if (distanceFromNode <= radius) {
            if (!resultHandler(elementIndex, this.elements[elementIndex], nodeKey, distanceFromNode, key, element)) {
                return false;
            }
        }
        const offsetFromPivot = key[pivotDimension] - nodeKey[pivotDimension];
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        const lesserNodeIndex = KdTree.lesser(nodeIndex);
        const greaterNodeIndex = KdTree.greater(nodeIndex);
        if (this.nodes[lesserNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, -1)) {
            if (!this.searchTree(element, key, radius, lesserNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        if (this.nodes[greaterNodeIndex] !== undefined && traversalHandler(offsetFromPivot, radius, 1)) {
            if (!this.searchTree(element, key, radius, greaterNodeIndex, nextPivotDimension, resultHandler, traversalHandler)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        const insertDepth = this.insertElementInTree(element) + 1;
        this.maxDepth = Math.max(this.maxDepth, insertDepth);
        if (insertDepth === this.minDepth + 1) {
            this.minDepth = KdTree.depth(this.nodes.indexOf(undefined, KdTree.leastIndexAtDepth(Math.max(0, this.minDepth))));
        }
        // Rebalance the tree if max depth is greater than twice the min depth.
        if (this.maxDepth + 1 > (this.minDepth + 1) * 2) {
            this.rebuild();
        }
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        for (const element of elements) {
            this.elements.push(element);
            this.keys.push(this.keyFunc(element, new Float64Array(this.dimensionCount)));
            const insertedIndex = this.elements.length - 1;
            for (let i = 0; i < this.dimensionCount; i++) {
                this.indexArrays[i].push(insertedIndex);
            }
        }
        this.rebuild();
    }
    /**
     * Inserts an element into this tree.
     * @param element The element to insert.
     * @returns The depth at which the element was inserted, with 0 being the depth of the root.
     */
    insertElementInTree(element) {
        const key = this.keyFunc(element, new Float64Array(this.dimensionCount));
        let index = 0;
        let depth = 0;
        let elementIndex;
        while ((elementIndex = this.nodes[index]) !== undefined) {
            const pivotDimension = depth % this.dimensionCount;
            const keyToCompare = key[pivotDimension];
            if (keyToCompare <= this.keys[elementIndex][pivotDimension]) {
                index = KdTree.lesser(index);
            }
            else {
                index = KdTree.greater(index);
            }
            depth++;
        }
        this.elements.push(element);
        this.keys.push(key);
        const insertedIndex = this.elements.length - 1;
        this.nodes[index] = insertedIndex;
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].push(insertedIndex);
        }
        return depth;
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        if (!this.removeElementFromArrays(element)) {
            return false;
        }
        this.resetIndexArrays();
        this.rebuild();
        return true;
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        let removed = false;
        for (const element of elements) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
            this.rebuild();
        }
        return removed;
    }
    /**
     * Removes an element and all references to it from this tree's arrays. This method does not change the structure
     * of this tree to reflect the removal of the element.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    removeElementFromArrays(element) {
        const index = this.elements.indexOf(element);
        if (index < 0) {
            return false;
        }
        const lastIndex = this.elements.length - 1;
        this.elements[index] = this.elements[lastIndex];
        this.keys[index] = this.keys[lastIndex];
        this.elements.length--;
        this.keys.length--;
        return true;
    }
    /**
     * Resets this tree's index arrays such that each array contains the indexes 0 to N-1 in order, where N is the
     * number of elements in the tree.
     */
    resetIndexArrays() {
        for (let i = 0; i < this.dimensionCount; i++) {
            const array = this.indexArrays[i];
            array.length = this.elements.length;
            for (let j = 0; j < array.length; j++) {
                array[j] = j;
            }
        }
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        let removed = false;
        for (const element of toRemove) {
            removed = this.removeElementFromArrays(element) || removed;
        }
        if (removed) {
            this.resetIndexArrays();
        }
        this.insertAll(toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        // clear the tree structure
        this.nodes.length = 0;
        if (this.size === 0) {
            return;
        }
        // sort index arrays
        for (let i = 0; i < this.dimensionCount; i++) {
            this.indexArrays[i].sort(this.indexSortFuncs[i]);
        }
        this.buildSubTree(0, 0, 0, this.indexArrays[0].length);
        const log = Math.log2(this.elements.length + 1);
        this.minDepth = Math.floor(log) - 1;
        this.maxDepth = Math.ceil(log) - 1;
    }
    /**
     * Builds a portion of this tree starting from a specified node using the element indexes stored in a specified
     * section of this tree's index arrays. The built subtree is guaranteed to be balanced. Before calling this method,
     * the index array at position 0 should contain keys sorted in the specified pivot dimension, the array at position
     * 1 should contain keys sorted in the dimension after the pivot dimension, etc (with the dimension wrapping back to
     * 0 when reaching `this.dimensionCount`).
     * @param nodeIndex The index of the tree node at which to start building the tree. The element associated with the
     * pivot key will be placed at this node.
     * @param pivotDimension The dimension in which to split the first level of the tree built by this method.
     * @param start The first index, inclusive, of the section of this tree's index arrays to use to build the tree.
     * @param end The last index, exclusive, of the section of this tree's index arrays to use to build the tree.
     */
    buildSubTree(nodeIndex, pivotDimension, start, end) {
        const tempArray = this.indexArrays[this.dimensionCount];
        const sortedArray = this.indexArrays[0];
        const medianIndex = Math.trunc((start + end) / 2);
        const medianKeyIndex = sortedArray[medianIndex];
        // Insert median into its position in the tree
        this.nodes[nodeIndex] = medianKeyIndex;
        if (end - start === 1) {
            return;
        }
        if (end - start <= 3) {
            const lesserIndex = medianIndex - 1;
            const greaterIndex = medianIndex + 1;
            if (lesserIndex >= start) {
                this.nodes[KdTree.lesser(nodeIndex)] = sortedArray[lesserIndex];
            }
            if (greaterIndex < end) {
                this.nodes[KdTree.greater(nodeIndex)] = sortedArray[greaterIndex];
            }
            return;
        }
        for (let i = start; i < end; i++) {
            tempArray[i] = sortedArray[i];
        }
        // Partition the index arrays not in the pivot dimension around the median key in the pivot dimension and at the
        // same time rotate the index arrays such that the index array sorted in the next pivot dimension is located at
        // index 0.
        for (let i = 1; i < this.dimensionCount; i++) {
            const targetArray = this.indexArrays[i - 1];
            const toPartitionArray = this.indexArrays[i];
            let lesserCount = 0;
            let greaterCount = 0;
            for (let j = start; j < end; j++) {
                const keyIndex = toPartitionArray[j];
                if (keyIndex === medianKeyIndex) {
                    targetArray[medianIndex] = keyIndex;
                }
                else {
                    const comparison = this.indexSortFuncs[pivotDimension](keyIndex, medianKeyIndex);
                    if (comparison <= 0) {
                        const index = start + (lesserCount++);
                        targetArray[index] = keyIndex;
                    }
                    else {
                        const index = medianIndex + 1 + (greaterCount++);
                        targetArray[index] = keyIndex;
                    }
                }
            }
        }
        // Copy the temporary array (now containing the sorted indexes in the pivot dimension) to the last index array.
        const newSortedArray = this.indexArrays[this.dimensionCount - 1];
        for (let i = start; i < end; i++) {
            newSortedArray[i] = tempArray[i];
        }
        const nextPivotDimension = (pivotDimension + 1) % this.dimensionCount;
        this.buildSubTree(KdTree.lesser(nodeIndex), nextPivotDimension, start, medianIndex);
        this.buildSubTree(KdTree.greater(nodeIndex), nextPivotDimension, medianIndex + 1, end);
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.elements.length = 0;
        this.keys.length = 0;
        this.nodes.length = 0;
        for (let i = 0; i < this.indexArrays.length; i++) {
            this.indexArrays[i].length = 0;
        }
        this.minDepth = -1;
        this.maxDepth = -1;
    }
    /**
     * Finds the index of a node's parent.
     * @param index the index of the node for which to find the parent.
     * @returns The index of the query node's parent.
     */
    static parent(index) {
        return (index - 1) >> 1;
    }
    /**
     * Finds the index of a node's lesser child.
     * @param index The index of the node for which to find the child.
     * @returns The index of the query node's lesser child.
     */
    static lesser(index) {
        return index * 2 + 1;
    }
    /**
     * Finds the index of a node's greater child.
     * @param index The index of the node for which to find the child.
     * @returns The idnex of the query node's greater child.
     */
    static greater(index) {
        return index * 2 + 2;
    }
    /**
     * Finds the least index of any node located at a given depth.
     * @param depth The depth for which to get the least index. The root of the tree lies at depth 0.
     * @returns The least index of any node located at the specified depth.
     */
    static leastIndexAtDepth(depth) {
        return 1 << depth - 1;
    }
    /**
     * Finds the depth at which a node lies.
     * @param index The index of the node for which to find the depth.
     * @returns The depth at which the node lies. The root of the tree lies at depth 0.
     */
    static depth(index) {
        return Math.trunc(Math.log2(index + 1));
    }
    /**
     * Calculates the Euclidean distance between two keys.
     * @param key1 The first key.
     * @param key2 The second key.
     * @param dimensionCount The number of dimensions in which to calculate the distance.
     * @returns The Euclidean distance between the two keys.
     */
    static distance(key1, key2, dimensionCount) {
        let sumSq = 0;
        for (let i = 0; i < dimensionCount; i++) {
            const diff = key1[i] - key2[i];
            sumSq += diff * diff;
        }
        return Math.sqrt(sumSq);
    }
}

/**
 * A spatial tree which is keyed on points on Earth's surface and allows searching for elements based on the great-
 * circle distances from their keys to a query point.
 */
class GeoKdTree {
    /**
     * Constructor.
     * @param keyFunc A function which generates keys from elements. Keys are cartesian representations of points on
     * Earth's surface.
     * @throws Error if the dimension count is less than 2.
     */
    constructor(keyFunc) {
        this.keyFunc = keyFunc;
        this.cartesianTree = new KdTree(3, (element, out) => {
            const vec = this.keyFunc(element, GeoKdTree.vec3Cache[0]);
            out[0] = vec[0];
            out[1] = vec[1];
            out[2] = vec[2];
            return out;
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(arg1, arg2, arg3, arg4, arg5, arg6) {
        let center, radius;
        let argA, argB, argC;
        if (typeof arg1 === 'number') {
            center = GeoPoint.sphericalToCartesian(arg1, arg2, GeoKdTree.vec3Cache[1]);
            radius = arg3;
            argA = arg4;
            argB = arg5;
            argC = arg6;
        }
        else if (!(arg1 instanceof Float64Array)) {
            center = GeoPoint.sphericalToCartesian(arg1, GeoKdTree.vec3Cache[1]);
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        else {
            center = arg1;
            radius = arg2;
            argA = arg3;
            argB = arg4;
            argC = arg5;
        }
        const radiusCartesian = Math.sqrt(2 * (1 - Math.cos(Utils.Clamp(radius, 0, Math.PI))));
        if (typeof argA === 'number') {
            return this.doResultsSearch(center, radiusCartesian, argA, argB, argC);
        }
        else {
            this.doVisitorSearch(center, radiusCartesian, argA);
        }
    }
    /**
     * Performs a tree search with a visitor function.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param visitor A visitor function. This function will be called once per element found within the search radius.
     * If the visitor returns `true`, then the search will continue; if the visitor returns `false`, the search will
     * immediately halt.
     */
    doVisitorSearch(center, radiusCartesian, visitor) {
        this.cartesianTree.searchKey(center, radiusCartesian, (element, key) => {
            const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
            const greatCircleDist = GeoPoint.distance(vec, center);
            return visitor(element, vec, greatCircleDist, center);
        });
    }
    /**
     * Performs a tree search and returns an array of search results.
     * @param center The query point.
     * @param radiusCartesian The query radius.
     * @param maxResultCount The maximum number of search results to return.
     * @param out An array in which to store the search results.
     * @param filter A function to filter the search results.
     * @returns An array containing the search results, in order of increasing distance from the query key.
     */
    doResultsSearch(center, radiusCartesian, maxResultCount, out, filter) {
        const cartesianFilter = filter
            ? (element, key) => {
                const vec = Vec3Math.set(key[0], key[1], key[2], GeoKdTree.vec3Cache[2]);
                const greatCircleDist = GeoPoint.distance(vec, center);
                return filter(element, vec, greatCircleDist, center);
            }
            : undefined;
        return this.cartesianTree.searchKey(center, radiusCartesian, maxResultCount, out, cartesianFilter);
    }
    /**
     * Inserts an element into this tree. This operation will trigger a rebalancing if, after the insertion, the length
     * of this tree's longest branch is more than twice the length of the shortest branch.
     * @param element The element to insert.
     */
    insert(element) {
        this.cartesianTree.insert(element);
    }
    /**
     * Inserts a batch of elements into this tree. This tree will be rebalanced after the elements are inserted.
     * @param elements An iterable of the elements to insert.
     */
    insertAll(elements) {
        this.cartesianTree.insertAll(elements);
    }
    /**
     * Removes an element from this tree. This tree will be rebalanced after the element is removed.
     * @param element The element to remove.
     * @returns Whether the element was removed.
     */
    remove(element) {
        return this.cartesianTree.remove(element);
    }
    /**
     * Removes a batch of elements from this tree. This tree will be rebalanced after the elements are removed.
     * @param elements An iterable of the elements to remove.
     * @returns Whether at least one element was removed.
     */
    removeAll(elements) {
        return this.cartesianTree.removeAll(elements);
    }
    /**
     * Removes elements from this tree, then inserts elements into this tree as a single operation. The tree will be
     * rebalanced at the end of the operation.
     *
     * Using this method is more efficient than calling `removeAll()` and `insertAll()` separately.
     * @param toRemove An iterable of the elements to remove.
     * @param toInsert An iterable of the elements to insert.
     */
    removeAndInsert(toRemove, toInsert) {
        this.cartesianTree.removeAndInsert(toRemove, toInsert);
    }
    /**
     * Rebuilds and balances this tree.
     */
    rebuild() {
        this.cartesianTree.rebuild();
    }
    /**
     * Removes all elements from this tree.
     */
    clear() {
        this.cartesianTree.clear();
    }
}
GeoKdTree.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];

/**
 * Types of subscribable array change event.
 */
var SubscribableArrayEventType;
(function (SubscribableArrayEventType) {
    /** An element was added. */
    SubscribableArrayEventType["Added"] = "Added";
    /** An element was removed. */
    SubscribableArrayEventType["Removed"] = "Removed";
    /** The array was cleared. */
    SubscribableArrayEventType["Cleared"] = "Cleared";
})(SubscribableArrayEventType || (SubscribableArrayEventType = {}));

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class AbstractSubscribableArray {
    constructor() {
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Adds a subscription to this array.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Gets an item from the array.
     * @param index Thex index of the item to get.
     * @returns An item.
     * @throws
     */
    get(index) {
        const array = this.getArray();
        if (index > array.length - 1) {
            throw new Error('Index out of range');
        }
        return array[index];
    }
    /**
     * Tries to get the value from the array.
     * @param index The index of the item to get.
     * @returns The value or undefined if not found.
     */
    tryGet(index) {
        return this.getArray()[index];
    }
    /**
     * Notifies subscriptions of a change in the array.
     * @param index The index that was changed.
     * @param type The type of subject event.
     * @param modifiedItem The item modified by the operation.
     */
    notify(index, type, modifiedItem) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(index, type, modifiedItem, this.getArray());
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(index, type, modifiedItem, this.getArray());
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableArray: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this array's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const array = this.getArray();
        sub.handler(0, SubscribableArrayEventType.Added, array, array);
    }
    /**
     * Responds to when a subscription to this array is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
}

/**
 * Types of facility repository sync events.
 */
var FacilityRepositorySyncType;
(function (FacilityRepositorySyncType) {
    FacilityRepositorySyncType["Add"] = "Add";
    FacilityRepositorySyncType["Remove"] = "Remove";
    FacilityRepositorySyncType["DumpRequest"] = "DumpRequest";
    FacilityRepositorySyncType["DumpResponse"] = "DumpResponse";
})(FacilityRepositorySyncType || (FacilityRepositorySyncType = {}));
/**
 * A repository of facilities.
 */
class FacilityRepository {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.repos = new Map();
        this.trees = {
            [FacilityType.USR]: new GeoKdTree(FacilityRepository.treeKeyFunc),
            [FacilityType.VIS]: new GeoKdTree(FacilityRepository.treeKeyFunc),
        };
        this.ignoreSync = false;
        bus.getSubscriber().on(FacilityRepository.SYNC_TOPIC).handle(this.onSyncEvent.bind(this));
        // Request a dump from any existing instances on other instruments to initialize the repository.
        this.pubSyncEvent({
            type: FacilityRepositorySyncType.DumpRequest, uid: this.lastDumpRequestUid = Math.random() * Number.MAX_SAFE_INTEGER
        });
    }
    /**
     * Gets the number of facilities stored in this repository.
     * @param types The types of facilities to count. Defaults to all facility types.
     * @returns The number of facilities stored in this repository.
     */
    size(types) {
        var _a, _b;
        let size = 0;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                size += repo.size;
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                size += (_b = (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0;
            }
        }
        return size;
    }
    /**
     * Retrieves a facility from this repository.
     * @param icao The ICAO of the facility to retrieve.
     * @returns The requested user facility, or undefined if it was not found in this repository.
     */
    get(icao) {
        var _a;
        if (!ICAO.isFacility(icao)) {
            return undefined;
        }
        return (_a = this.repos.get(ICAO.getFacilityType(icao))) === null || _a === void 0 ? void 0 : _a.get(icao);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    search(type, lat, lon, radius, arg5, out, filter) {
        if (type !== FacilityType.USR && type !== FacilityType.VIS) {
            throw new Error(`FacilityRepository: spatial searches are not supported for facility type ${type}`);
        }
        if (typeof arg5 === 'number') {
            return this.trees[type].search(lat, lon, radius, arg5, out, filter);
        }
        else {
            this.trees[type].search(lat, lon, radius, arg5);
        }
    }
    /**
     * Adds a facility to this repository and all other repositories synced with this one. If this repository already
     * contains a facility with the same ICAO as the facility to add, the existing facility will be replaced with the
     * new one.
     * @param fac The facility to add.
     * @throws Error if the facility has an invalid ICAO.
     */
    add(fac) {
        if (!ICAO.isFacility(fac.icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${fac.icao}`);
        }
        this.addToRepo(fac);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: [fac] });
    }
    /**
     * Adds multiple facilities from this repository and all other repositories synced with this one. For each added
     * facility, if this repository already contains a facility with the same ICAO, the existing facility will be
     * replaced with the new one.
     * @param facs The facilities to add.
     */
    addMultiple(facs) {
        this.addMultipleToRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Add, facs: Array.from(facs) });
    }
    /**
     * Removes a facility from this repository and all other repositories synced with this one.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     * @throws Error if the facility has an invalid ICAO.
     */
    remove(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        if (!ICAO.isFacility(icao)) {
            throw new Error(`FacilityRepository: invalid facility ICAO ${icao}`);
        }
        this.removeFromRepo(icao);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: [icao] });
    }
    /**
     * Removes multiple facilities from this repository and all other repositories synced with this one.
     * @param facs The facilities to remove, or the ICAOs of the facilties to remove.
     */
    removeMultiple(facs) {
        this.removeMultipleFromRepo(facs);
        this.pubSyncEvent({ type: FacilityRepositorySyncType.Remove, facs: facs.map(fac => typeof fac === 'object' ? fac.icao : fac) });
    }
    /**
     * Iterates over every facility in this respository with a visitor function.
     * @param fn A visitor function.
     * @param types The types of facilities over which to iterate. Defaults to all facility types.
     */
    forEach(fn, types) {
        var _a;
        if (types === undefined) {
            for (const repo of this.repos.values()) {
                repo.forEach(fn);
            }
        }
        else {
            for (let i = 0; i < types.length; i++) {
                (_a = this.repos.get(types[i])) === null || _a === void 0 ? void 0 : _a.forEach(fn);
            }
        }
    }
    /**
     * Adds a facility to this repository.
     * @param fac The facility to add.
     */
    addToRepo(fac) {
        const facilityType = ICAO.getFacilityType(fac.icao);
        let repo = this.repos.get(facilityType);
        if (repo === undefined) {
            this.repos.set(facilityType, repo = new Map());
        }
        const existing = repo.get(fac.icao);
        repo.set(fac.icao, fac);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            if (existing === undefined) {
                this.trees[facilityType].insert(fac);
            }
            else {
                this.trees[facilityType].removeAndInsert([existing], [fac]);
            }
        }
        if (existing === undefined) {
            this.publisher.pub('facility_added', fac, false, false);
        }
        else {
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Adds multiple facilities to this repository.
     * @param facs The facilities to add.
     */
    addMultipleToRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const addedFacilities = [];
        const changedFacilitiesRemoved = [];
        const changedFacilitiesAdded = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const facilityType = ICAO.getFacilityType(fac.icao);
            let repo = this.repos.get(facilityType);
            if (repo === undefined) {
                this.repos.set(facilityType, repo = new Map());
            }
            const existing = repo.get(fac.icao);
            repo.set(fac.icao, fac);
            if (existing === undefined) {
                addedFacilities.push(fac);
            }
            else {
                changedFacilitiesRemoved.push(existing);
                changedFacilitiesAdded.push(fac);
            }
        }
        const addedUserFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (addedUserFacilities.length > 0) {
            const removedUserFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
            this.trees[FacilityType.USR].removeAndInsert(removedUserFacilities, addedUserFacilities);
        }
        const addedVisFacilities = facs.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (addedVisFacilities.length > 0) {
            const removedVisFacilities = changedFacilitiesRemoved.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
            this.trees[FacilityType.VIS].removeAndInsert(removedVisFacilities, addedVisFacilities);
        }
        for (let i = 0; i < addedFacilities.length; i++) {
            const fac = addedFacilities[i];
            this.publisher.pub('facility_added', fac, false, false);
        }
        for (let i = 0; i < changedFacilitiesAdded.length; i++) {
            const fac = changedFacilitiesAdded[i];
            this.publisher.pub(`facility_changed_${fac.icao}`, fac, false, false);
            this.publisher.pub('facility_changed', fac, false, false);
        }
    }
    /**
     * Removes a facility from this repository.
     * @param fac The facility to remove, or the ICAO of the facility to remove.
     */
    removeFromRepo(fac) {
        const icao = typeof fac === 'string' ? fac : fac.icao;
        const facilityType = ICAO.getFacilityType(icao);
        const repo = this.repos.get(ICAO.getFacilityType(icao));
        if (repo === undefined) {
            return;
        }
        const facilityInRepo = repo.get(icao);
        if (facilityInRepo === undefined) {
            return;
        }
        repo.delete(icao);
        if (facilityType === FacilityType.USR || facilityType === FacilityType.VIS) {
            this.trees[facilityType].remove(facilityInRepo);
        }
        this.publisher.pub(`facility_removed_${icao}`, facilityInRepo, false, false);
        this.publisher.pub('facility_removed', facilityInRepo, false, false);
    }
    /**
     * Removes multiple facilities from this repository.
     * @param facs The facilities to remove, or the ICAOs of the facilities to remove.
     */
    removeMultipleFromRepo(facs) {
        if (facs.length === 0) {
            return;
        }
        const removedFacilities = [];
        for (let i = 0; i < facs.length; i++) {
            const fac = facs[i];
            const icao = typeof fac === 'string' ? fac : fac.icao;
            const repo = this.repos.get(ICAO.getFacilityType(icao));
            if (repo === undefined) {
                continue;
            }
            const facilityInRepo = repo.get(icao);
            if (facilityInRepo === undefined) {
                continue;
            }
            repo.delete(icao);
            removedFacilities.push(facilityInRepo);
        }
        const removedUserFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.USR));
        if (removedUserFacilities.length > 0) {
            this.trees[FacilityType.USR].removeAll(removedUserFacilities);
        }
        const removedVisFacilities = removedFacilities.filter(fac => FacilityUtils.isFacilityType(fac, FacilityType.VIS));
        if (removedVisFacilities.length > 0) {
            this.trees[FacilityType.VIS].removeAll(removedVisFacilities);
        }
        for (let i = 0; i < removedFacilities.length; i++) {
            const removedFac = removedFacilities[i];
            this.publisher.pub(`facility_removed_${removedFac.icao}`, removedFac, false, false);
            this.publisher.pub('facility_removed', removedFac, false, false);
        }
    }
    /**
     * Publishes a facility added or removed sync event over the event bus.
     * @param data The event data.
     */
    pubSyncEvent(data) {
        this.ignoreSync = true;
        this.publisher.pub(FacilityRepository.SYNC_TOPIC, data, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called when a sync event occurs.
     * @param data The event data.
     */
    onSyncEvent(data) {
        if (this.ignoreSync) {
            return;
        }
        switch (data.type) {
            case FacilityRepositorySyncType.DumpResponse:
                // Only accept responses to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    break;
                }
                else {
                    this.lastDumpRequestUid = undefined;
                }
            // eslint-disable-next-line no-fallthrough
            case FacilityRepositorySyncType.Add:
                if (data.facs.length === 1) {
                    this.addToRepo(data.facs[0]);
                }
                else {
                    this.addMultipleToRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.Remove:
                if (data.facs.length === 1) {
                    this.removeFromRepo(data.facs[0]);
                }
                else {
                    this.removeMultipleFromRepo(data.facs);
                }
                break;
            case FacilityRepositorySyncType.DumpRequest:
                // Don't respond to your own dump requests.
                if (data.uid !== this.lastDumpRequestUid) {
                    const facs = [];
                    this.forEach(fac => facs.push(fac));
                    this.pubSyncEvent({ type: FacilityRepositorySyncType.DumpResponse, uid: data.uid, facs });
                }
                break;
        }
    }
    /**
     * Gets an instance of FacilityRepository.
     * @param bus The event bus.
     * @returns an instance of FacilityRepository.
     */
    static getRepository(bus) {
        var _a;
        return (_a = FacilityRepository.INSTANCE) !== null && _a !== void 0 ? _a : (FacilityRepository.INSTANCE = new FacilityRepository(bus));
    }
}
FacilityRepository.SYNC_TOPIC = 'facilityrepo_sync';
FacilityRepository.treeKeyFunc = (fac, out) => {
    return GeoPoint.sphericalToCartesian(fac, out);
};

/**
 * Possible types of hold entries
 */
var HoldEntryType;
(function (HoldEntryType) {
    HoldEntryType[HoldEntryType["Direct"] = 0] = "Direct";
    HoldEntryType[HoldEntryType["Teardrop"] = 1] = "Teardrop";
    HoldEntryType[HoldEntryType["Parallel"] = 2] = "Parallel";
    HoldEntryType[HoldEntryType["None"] = 3] = "None";
})(HoldEntryType || (HoldEntryType = {}));
var HoldMaxSpeedRule;
(function (HoldMaxSpeedRule) {
    HoldMaxSpeedRule[HoldMaxSpeedRule["Faa"] = 0] = "Faa";
    HoldMaxSpeedRule[HoldMaxSpeedRule["Icao"] = 1] = "Icao";
})(HoldMaxSpeedRule || (HoldMaxSpeedRule = {}));
/**
 * Utilities for hold entries
 */
class HoldUtils {
    /**
     * Gets a hold direction UI string for a given inbound course.
     *
     * @param course The inbound course to get the string for.
     * @param short Whether to get the string in short form (single letter)
     *
     * @returns A UI human-readable course string.
     */
    static getDirectionString(course, short = false) {
        if (course >= 0 && course < 22.5) {
            return short ? 'S' : 'South';
        }
        else if (course >= 22.5 && course < 67.5) {
            return short ? 'SW' : 'Southwest';
        }
        else if (course >= 67.5 && course < 112.5) {
            return short ? 'W' : 'West';
        }
        else if (course >= 112.5 && course < 157.5) {
            return short ? 'NW' : 'Northwest';
        }
        else if (course >= 157.5 && course < 202.5) {
            return short ? 'N' : 'North';
        }
        else if (course >= 202.5 && course < 247.5) {
            return short ? 'NE' : 'Northeast';
        }
        else if (course >= 247.5 && course < 292.5) {
            return short ? 'E' : 'East';
        }
        else if (course >= 292.5 && course < 337.5) {
            return short ? 'SE' : 'Southeast';
        }
        else {
            return short ? 'S' : 'South';
        }
    }
    /**
     * Obtains hold speed (number and isMach) depending on altitude and speed rule (ICAO or FAA)
     *
     * @param altitude MSL altitude
     * @param rule     hold speed rule
     *
     * @returns hold speed and whether that number is in Mach
     */
    static getHoldSpeed(altitude, rule) {
        switch (rule) {
            case HoldMaxSpeedRule.Faa:
                if (altitude < 6000) {
                    return [200, false];
                }
                else if (altitude < 14000) {
                    return [230, false];
                }
                else {
                    return [265, false];
                }
            case HoldMaxSpeedRule.Icao:
                if (altitude < 14000) {
                    return [230, false];
                }
                else if (altitude < 20000) {
                    return [240, false];
                }
                else if (altitude < 34000) {
                    return [265, false];
                }
                else {
                    return [.83, true];
                }
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A type map of search type to concrete facility loader query type.
 */
const facilitySearchTypeMap = new Map([
    [FacilitySearchType.Airport, FacilityType.Airport],
    [FacilitySearchType.Intersection, FacilityType.Intersection],
    [FacilitySearchType.Vor, FacilityType.VOR],
    [FacilitySearchType.Ndb, FacilityType.NDB],
    [FacilitySearchType.User, FacilityType.USR]
]);
/**
 * A class for tracking a nearest facility session and making it available as a
 * subscribable array of facilities.
 */
class AbstractNearestSubscription extends AbstractSubscribableArray {
    /**
     * Creates an instance of a NearestSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     */
    constructor(facilityLoader, type) {
        super();
        this.facilityLoader = facilityLoader;
        this.type = type;
        this.facilities = [];
        this.facilityIndex = new Map();
        this.startPromiseResolves = [];
        this.updatePromiseResolves = [];
        this.hasRequestedSession = false;
        this.searchInProgress = false;
    }
    /** @inheritdoc */
    get length() {
        return this.facilities.length;
    }
    /**
     * Whether or not this subscription has been started.
     * @returns True if started, false otherwise.
     */
    get started() {
        return this.session !== undefined;
    }
    /** @inheritdoc */
    getArray() {
        return this.facilities;
    }
    /** @inheritdoc */
    awaitStart() {
        if (this.session !== undefined) {
            return Promise.resolve();
        }
        return new Promise(resolve => { this.startPromiseResolves.push(resolve); });
    }
    /** @inheritdoc */
    start() {
        if (this.session !== undefined) {
            return Promise.resolve();
        }
        if (this.hasRequestedSession) {
            return this.awaitStart();
        }
        return new Promise(resolve => {
            this.hasRequestedSession = true;
            this.startPromiseResolves.push(resolve);
            this.facilityLoader.startNearestSearchSession(this.type).then(session => {
                this.session = session;
                this.startPromiseResolves.forEach(queuedResolve => { queuedResolve(); });
                this.startPromiseResolves.length = 0;
            });
        });
    }
    /** @inheritdoc */
    update(lat, lon, radius, maxItems) {
        return new Promise(resolve => {
            this.updatePromiseResolves.push(resolve);
            if (this.searchInProgress) {
                return;
            }
            this.doUpdate(lat, lon, radius, maxItems);
        });
    }
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    async doUpdate(lat, lon, radius, maxItems) {
        this.searchInProgress = true;
        if (!this.started) {
            await this.start();
        }
        const results = await this.session.searchNearest(lat, lon, radius, maxItems);
        await this.onResults(results);
        this.searchInProgress = false;
        this.updatePromiseResolves.forEach(resolve => { resolve(); });
        this.updatePromiseResolves.length = 0;
    }
    /**
     * Adds a facility to the collection.
     * @param facility The facility to add.
     * @param key The key to track this facility by.
     */
    addFacility(facility, key) {
        if (this.facilityIndex.has(key)) {
            console.warn(`Facility ${key} is already in the collection.`);
        }
        this.facilities.push(facility);
        this.facilityIndex.set(key, facility);
        this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, facility);
    }
    /**
     * Removes a facility from the collection.
     * @param key The key of the facility to remove.
     */
    removeFacility(key) {
        const facility = this.facilityIndex.get(key);
        if (facility !== undefined) {
            const index = this.facilities.indexOf(facility);
            this.facilities.splice(index, 1);
            this.facilityIndex.delete(key);
            this.notify(index, SubscribableArrayEventType.Removed, facility);
        }
    }
}
/**
 * A nearest search subscription for waypoint facilites, including logic for further filtering
 * of results beyond what the sim search API gives us.
 */
class NearestWaypointSubscription extends AbstractNearestSubscription {
    /**
     * Creates a new NearestWaypointSubscription.
     * @param facilityLoader An instance of the facility loader to search with.
     * @param type The type of facility to search for.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader, type, filterCb) {
        super(facilityLoader, type);
        this.facilityCache = new Map();
        this.filterCb = filterCb;
    }
    /**
     * Sets this subscription's post-search session filter and refilters this subscription's latest results using the new
     * filter.
     * @param filter A function which filters results after they have been returned by this subscription's search
     * session, or `undefined` if no post-search session filtering is to be performed.
     */
    setFilterCb(filter) {
        this.filterCb = filter;
        this.refilter();
    }
    /**
     * Refilters the latest search results returned from this subscription's nearest search session.
     */
    refilter() {
        // Start the refresh of our data by iterating over the current entries and
        // removing any that no longer match the filter.
        if (this.filterCb) {
            for (const icao of this.facilityIndex.keys()) {
                if (!this.filterCb(this.facilityIndex.get(icao))) {
                    this.removeFacility(icao);
                }
            }
        }
        // Next go through our facility cache and add any existing entries that
        // hadn't previously matched but now do.
        for (const icao of this.facilityCache.keys()) {
            if (!this.facilityIndex.get(icao) && (this.filterCb === undefined || this.filterCb(this.facilityCache.get(icao)))) {
                this.addFacility(this.facilityCache.get(icao), icao);
            }
        }
    }
    /** @inheritdoc */
    async onResults(results) {
        const facilityType = facilitySearchTypeMap.get(this.type);
        if (facilityType !== undefined) {
            const added = await Promise.all(results.added.map(icao => this.facilityLoader.getFacility(facilityType, icao)));
            for (let i = 0; i < results.removed.length; i++) {
                this.facilityCache.delete(results.removed[i]);
                this.removeFacility(results.removed[i]);
            }
            for (let i = 0; i < added.length; i++) {
                this.facilityCache.set(added[i].icao, added[i]);
                if (this.filterCb === undefined || this.filterCb(added[i])) {
                    this.addFacility(added[i], added[i].icao);
                }
            }
        }
    }
}
/**
 * A nearest search subscription for airport facilites.
 */
class NearestAirportSubscription extends NearestWaypointSubscription {
    /**
     * Creates a new NearestAirportSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     */
    constructor(facilityLoader, filterCb) {
        super(facilityLoader, FacilitySearchType.Airport, filterCb);
    }
    /**
     * Sets the airport search filter.
     * @param showClosed Whether or not to return closed airports in the search.
     * @param classMask A bitmask representing the classes of airports to show.
     */
    setFilter(showClosed, classMask) {
        if (this.session !== undefined) {
            this.session.setAirportFilter(showClosed, classMask);
        }
    }
    /**
     * Sets the extended airport filters for the airport nearest search.
     * @param surfaceTypeMask A bitmask of allowable runway surface types.
     * @param approachTypeMask A bitmask of allowable approach types.
     * @param toweredMask A bitmask of untowered (1) or towered (2) bits.
     * @param minRunwayLength The minimum allowable runway length, in meters.
     */
    setExtendedFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength) {
        if (this.session !== undefined) {
            this.session.setExtendedAirportFilters(surfaceTypeMask, approachTypeMask, toweredMask, minRunwayLength);
        }
    }
}
/**
 * A nearest search subscription for intersection facilites.
 */
class NearestIntersectionSubscription extends NearestWaypointSubscription {
    /**
     * Creates a new NearestIntersectionSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     * @param filterCb A function which filters results after they have been returned by this subscription's search
     * session. If not defined, no post-search session filtering will be performed.
     * @param filterDupTerminal Whether to filter out terminal intersections if their non-terminal counterparts are
     * also present in the subscription's results. Defaults to `false`.
     */
    constructor(facilityLoader, filterCb, filterDupTerminal = false) {
        super(facilityLoader, FacilitySearchType.Intersection, filterCb);
        this.nonTerminalIcaosToFilter = new Set();
        this.filterDupTerminal = filterDupTerminal;
    }
    /**
     * Sets the intersection search filter.
     * @param typeMask A bitmask representing the types of intersections to include in the search.
     * @param showTerminalWaypoints Whether to include terminal intersections in the search.
     */
    setFilter(typeMask, showTerminalWaypoints = true) {
        if (this.session !== undefined) {
            this.session.setIntersectionFilter(typeMask, showTerminalWaypoints);
        }
    }
    /**
     * Sets whether to filter out terminal intersections if their non-terminal counterparts are also present in this
     * subscription's results and refilters this subscription's latest results accordingly.
     * @param filter Whether to filter out terminal intersections if their non-terminal counterparts are also present in
     * this subscription's results.
     */
    setFilterDupTerminal(filter) {
        if (filter === this.filterDupTerminal) {
            return;
        }
        this.filterDupTerminal = filter;
        this.refilter();
    }
    /** @inheritdoc */
    refilter() {
        // Rebuild non-terminal ICAO set
        this.nonTerminalIcaosToFilter.clear();
        if (this.filterDupTerminal) {
            for (const icao of this.facilityCache.keys()) {
                if (ICAO.isFacility(icao, FacilityType.Intersection)
                    && !IntersectionFacilityUtils.isTerminal(icao)
                    && (this.filterCb === undefined || this.filterCb(this.facilityCache.get(icao)))) {
                    this.nonTerminalIcaosToFilter.add(icao);
                }
            }
        }
        // Start the refresh of our data by iterating over the current entries and
        // removing any that no longer match the filter.
        if (this.filterCb || this.filterDupTerminal) {
            for (const icao of this.facilityIndex.keys()) {
                if ((this.filterCb && !this.filterCb(this.facilityIndex.get(icao)))
                    || (this.filterDupTerminal
                        && ICAO.isFacility(icao, FacilityType.Intersection)
                        && IntersectionFacilityUtils.isTerminal(icao)
                        && this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
                    this.removeFacility(icao);
                }
            }
        }
        // Next go through our facility cache and add any existing entries that
        // hadn't previously matched but now do.
        for (const icao of this.facilityCache.keys()) {
            if (!this.facilityIndex.get(icao)) {
                if ((this.filterCb === undefined || this.filterCb(this.facilityCache.get(icao)))
                    && (!this.filterDupTerminal
                        || !ICAO.isFacility(icao, FacilityType.Intersection)
                        || !IntersectionFacilityUtils.isTerminal(icao)
                        || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(icao)))) {
                    this.addFacility(this.facilityCache.get(icao), icao);
                }
            }
        }
    }
    /** @inheritdoc */
    async onResults(results) {
        const facilityType = facilitySearchTypeMap.get(this.type);
        if (facilityType !== undefined) {
            const added = await Promise.all(results.added.map(icao => this.facilityLoader.getFacility(facilityType, icao)));
            for (let i = 0; i < results.removed.length; i++) {
                this.nonTerminalIcaosToFilter.delete(results.removed[i]);
                this.facilityCache.delete(results.removed[i]);
                this.removeFacility(results.removed[i]);
            }
            for (let i = 0; i < added.length; i++) {
                const fac = added[i];
                this.facilityCache.set(fac.icao, fac);
                if (this.filterDupTerminal
                    && ICAO.isFacility(fac.icao, FacilityType.Intersection)
                    && !IntersectionFacilityUtils.isTerminal(fac)
                    && (this.filterCb === undefined || this.filterCb(fac))) {
                    this.nonTerminalIcaosToFilter.add(fac.icao);
                }
            }
            for (let i = 0; i < added.length; i++) {
                const fac = added[i];
                if ((this.filterCb === undefined || this.filterCb(fac))
                    && (!this.filterDupTerminal
                        || !ICAO.isFacility(fac.icao, FacilityType.Intersection)
                        || !IntersectionFacilityUtils.isTerminal(fac)
                        || !this.nonTerminalIcaosToFilter.has(IntersectionFacilityUtils.getNonTerminalICAO(fac.icao)))) {
                    this.addFacility(added[i], added[i].icao);
                }
            }
        }
    }
}
/**
 * A nearest search subscription for VOR facilites.
 */
class NearestVorSubscription extends NearestWaypointSubscription {
    /**
     * Creates a new NearestVorSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
        super(facilityLoader, FacilitySearchType.Vor);
    }
    /**
     * Sets the VOR search filter.
     * @param classMask A bitmask to determine which JS VOR classes to show.
     * @param typeMask A bitmask to determine which JS VOR types to show.
     */
    setVorFilter(classMask, typeMask) {
        if (this.session !== undefined) {
            this.session.setVorFilter(classMask, typeMask);
        }
    }
}
/**
 * A nearest search subscription for NDB facilites.
 */
class NearestNdbSubscription extends NearestWaypointSubscription {
    /**
     * Creates a new NearestNdbSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
        super(facilityLoader, FacilitySearchType.Ndb);
    }
}
/**
 * A nearest search subscription for USR facilites.
 */
class NearestUsrSubscription extends NearestWaypointSubscription {
    /**
     * Creates a new NearestUsrSubscription.
     * @param facilityLoader The facility loader to use with this instance.
     */
    constructor(facilityLoader) {
        super(facilityLoader, FacilitySearchType.User);
    }
}
/**
 * A wrapper for a {@link NearestSearchSession} that automatically adjusts the number of
 * search results requested from the sim to minimize search load while still attempting to
 * provide the total number of results needed by the user.
 */
class AdaptiveNearestSubscription extends AbstractSubscribableArray {
    /**
     * Creates an instance of AdaptiveNearestSubscription.
     * @param innerSubscription A {@link NearestSubscription} to use as our inner search.
     * @param absoluteMaxItems The maximum number of results to request in any search.
     */
    constructor(innerSubscription, absoluteMaxItems) {
        super();
        this.innerSubscription = innerSubscription;
        this.sortFunc = (a, b) => this.pos.distance(a) - this.pos.distance(b);
        /** The array that holds the results of our latest search. */
        this.facilities = [];
        /** The number of items we are requesting from the inner search to meet current demands. */
        this.derivedMaxItems = 0;
        /** Whether we have a search in progress already. */
        this.searchInProgress = false;
        /** A reusable GeoPoint for sorting by distance. */
        this.pos = new GeoPoint(0, 0);
        this.diffMap = new Map();
        this.updatePromiseResolves = [];
        this.absoluteMaxItems = SubscribableUtils.toSubscribable(absoluteMaxItems, true);
    }
    /** @inheritdoc */
    get length() {
        return this.facilities.length;
    }
    /** @inheritdoc */
    getArray() {
        return this.facilities;
    }
    /** @inheritdoc */
    get started() {
        return this.innerSubscription.started;
    }
    /** @inheritdoc */
    awaitStart() {
        return this.innerSubscription.awaitStart();
    }
    /** @inheritdoc */
    start() {
        return this.innerSubscription.start();
    }
    /** @inheritdoc */
    update(lat, lon, radius, maxItems) {
        return new Promise(resolve => {
            this.updatePromiseResolves.push(resolve);
            if (this.searchInProgress) {
                return;
            }
            this.doUpdate(lat, lon, radius, maxItems);
        });
    }
    /**
     * Executes an update of the nearest search subscription.
     * @param lat The latitude of the current search position.
     * @param lon The longitude of the current search position.
     * @param radius The radius of the search, in meters.
     * @param maxItems The maximum number of items to return in the search.
     */
    async doUpdate(lat, lon, radius, maxItems) {
        this.searchInProgress = true;
        this.pos.set(lat, lon);
        maxItems = Math.max(0, maxItems);
        if (maxItems > this.derivedMaxItems) {
            this.derivedMaxItems = maxItems;
        }
        // When the subscription updates, any changes from airports added or removed cause
        // onSourceChanged below to trigger.   That will update our facilites store, because
        // it means the airport is no longer in the raw search data.
        await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
        if (this.innerSubscription.length > maxItems) {
            // We have more returned facilities in our search than the user has asked for.
            // Begin a ramp-down of our search size. Ramp down is less aggressive than
            // ramp up to avoid flapping between the two states.
            this.derivedMaxItems = Math.max(Math.round(this.derivedMaxItems - (this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_DOWN_FACTOR)), maxItems);
        }
        else {
            // We have either exactly enough or too few facilities.  If we have too few, ramp
            // up our search size until we either have enough or hit the maximum allowed search
            // quantity.
            const absoluteMaxItems = this.absoluteMaxItems.get();
            while (this.innerSubscription.length < maxItems && this.derivedMaxItems < absoluteMaxItems) {
                this.derivedMaxItems = Math.min(Math.round(this.derivedMaxItems * AdaptiveNearestSubscription.RAMP_UP_FACTOR), absoluteMaxItems);
                await this.innerSubscription.update(lat, lon, radius, this.derivedMaxItems);
            }
        }
        if (this.innerSubscription.length > maxItems) {
            if (maxItems > 1) {
                // Filter out the farthest results until we have exactly as many results as the user has asked for.
                const sorted = Array.from(this.innerSubscription.getArray()).sort(this.sortFunc);
                sorted.length = maxItems;
                this.diffAndNotify(sorted);
            }
            else if (maxItems === 1) {
                this.diffAndNotify([this.findNearest(this.innerSubscription.getArray())]);
            }
            else {
                this.diffAndNotify(AdaptiveNearestSubscription.EMPTY_ARRAY);
            }
        }
        else {
            this.diffAndNotify(this.innerSubscription.getArray());
        }
        this.searchInProgress = false;
        this.updatePromiseResolves.forEach(resolve => { resolve(); });
        this.updatePromiseResolves.length = 0;
    }
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    findNearest(array) {
        let nearest = array[0];
        let nearestDistance = this.pos.distance(nearest);
        for (let i = 1; i < array.length; i++) {
            const fac = array[i];
            const distance = this.pos.distance(fac);
            if (distance < nearestDistance) {
                nearest = fac;
                nearestDistance = distance;
            }
        }
        return nearest;
    }
    /**
     * Diffs a new facility array against this subscription's current facility array, makes the necessary changes to
     * the current facility array so that it contains the same facilities as the new one, and notifies subscribers of the
     * changes.
     * @param newArray A new facility array.
     */
    diffAndNotify(newArray) {
        if (this.facilities.length === 0 && newArray.length === 0) {
            // Old and new arrays are both empty. Nothing to do.
            return;
        }
        if (newArray.length === 0) {
            // New array is empty. Clear the old array.
            this.facilities.length = 0;
            this.notify(0, SubscribableArrayEventType.Cleared);
            return;
        }
        if (this.facilities.length === 0) {
            // Old array is empty. Add every item from the new array in order.
            for (let i = 0; i < newArray.length; i++) {
                this.facilities[i] = newArray[i];
            }
            this.facilities.length = newArray.length;
            this.notify(0, SubscribableArrayEventType.Added, this.facilities);
            return;
        }
        // Remove every item from the old array that is not in the new array.
        for (let i = 0; i < newArray.length; i++) {
            this.diffMap.set(newArray[i].icao, newArray[i]);
        }
        for (let i = this.facilities.length - 1; i >= 0; i--) {
            const old = this.facilities[i];
            if (this.diffMap.has(old.icao)) {
                this.diffMap.delete(old.icao);
            }
            else {
                this.facilities.splice(i, 1);
                this.notify(i, SubscribableArrayEventType.Removed, old);
            }
        }
        // Add every item from the new array that is not in the old array (these items are now contained in diffMap).
        for (const toAdd of this.diffMap.values()) {
            this.facilities.push(toAdd);
            this.notify(this.facilities.length - 1, SubscribableArrayEventType.Added, toAdd);
        }
        this.diffMap.clear();
    }
}
AdaptiveNearestSubscription.RAMP_UP_FACTOR = 1.33;
AdaptiveNearestSubscription.RAMP_DOWN_FACTOR = 0.1;
AdaptiveNearestSubscription.EMPTY_ARRAY = [];

/**
 * The transition type to which a flight path vector belongs.
 */
var FlightPathVectorFlags;
(function (FlightPathVectorFlags) {
    FlightPathVectorFlags[FlightPathVectorFlags["None"] = 0] = "None";
    /** A turn to a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["TurnToCourse"] = 1] = "TurnToCourse";
    /** An arcing turn to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Arc"] = 2] = "Arc";
    /** A direct course to a specific point. */
    FlightPathVectorFlags[FlightPathVectorFlags["Direct"] = 4] = "Direct";
    /** A path to intercept a specific course. */
    FlightPathVectorFlags[FlightPathVectorFlags["InterceptCourse"] = 8] = "InterceptCourse";
    /** Inbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldInboundLeg"] = 16] = "HoldInboundLeg";
    /** Outbound leg of a hold. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldOutboundLeg"] = 32] = "HoldOutboundLeg";
    /** A direct hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldDirectEntry"] = 64] = "HoldDirectEntry";
    /** A teardrop hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldTeardropEntry"] = 128] = "HoldTeardropEntry";
    /** A parallel hold entry. */
    FlightPathVectorFlags[FlightPathVectorFlags["HoldParallelEntry"] = 256] = "HoldParallelEntry";
    /** A course reversal. */
    FlightPathVectorFlags[FlightPathVectorFlags["CourseReversal"] = 512] = "CourseReversal";
    /** A turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["LegToLegTurn"] = 1024] = "LegToLegTurn";
    /** An anticipated turn from one leg to another. */
    FlightPathVectorFlags[FlightPathVectorFlags["AnticipatedTurn"] = 2048] = "AnticipatedTurn";
    /** A fallback path. */
    FlightPathVectorFlags[FlightPathVectorFlags["Fallback"] = 4096] = "Fallback";
})(FlightPathVectorFlags || (FlightPathVectorFlags = {}));
/**
 * The details of procedures selected in the flight plan.
 */
class ProcedureDetails {
    constructor() {
        // *********************************************************************************************************
        // ******** When adding new fields, they MUST be initialized, even if it just gets set to undefined ********
        // ******** This is so that it can be used with Object.keys()                                       ********
        // *********************************************************************************************************
        /** The origin runway object, consisting of the index of the origin runway
         * in the origin runway information and the direction. */
        this.originRunway = undefined;
        /** The ICAO for the facility associated with the departure procedure. */
        this.departureFacilityIcao = undefined;
        /** The index of the departure in the origin airport information. */
        this.departureIndex = -1;
        /** The index of the departure transition in the origin airport departure information. */
        this.departureTransitionIndex = -1;
        /** The index of the selected runway in the original airport departure information. */
        this.departureRunwayIndex = -1;
        /** The ICAO for the facility associated with the arrival procedure. */
        this.arrivalFacilityIcao = undefined;
        /** The index of the arrival in the destination airport information. */
        this.arrivalIndex = -1;
        /** The index of the arrival transition in the destination airport arrival information. */
        this.arrivalTransitionIndex = -1;
        /** The index of the selected runway transition at the destination airport arrival information. */
        this.arrivalRunwayTransitionIndex = -1;
        /** The arrival runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.arrivalRunway = undefined;
        /** The ICAO for the facility associated with the approach procedure. */
        this.approachFacilityIcao = undefined;
        /** The index of the apporach in the destination airport information.*/
        this.approachIndex = -1;
        /** The index of the approach transition in the destination airport approach information.*/
        this.approachTransitionIndex = -1;
        /** The destination runway object, consisting of the index of the destination runway
         * in the destination runway information and the direction. */
        this.destinationRunway = undefined;
    }
}
/**
 * A prototype for signalling application-specific type metadata for plan segments.
 */
var FlightPlanSegmentType;
(function (FlightPlanSegmentType) {
    FlightPlanSegmentType["Origin"] = "Origin";
    FlightPlanSegmentType["Departure"] = "Departure";
    FlightPlanSegmentType["Enroute"] = "Enroute";
    FlightPlanSegmentType["Arrival"] = "Arrival";
    FlightPlanSegmentType["Approach"] = "Approach";
    FlightPlanSegmentType["Destination"] = "Destination";
    FlightPlanSegmentType["MissedApproach"] = "MissedApproach";
    FlightPlanSegmentType["RandomDirectTo"] = "RandomDirectTo";
})(FlightPlanSegmentType || (FlightPlanSegmentType = {}));
/**
 * A segment of a flight plan.
 */
class FlightPlanSegment {
    /**
     * Creates a new FlightPlanSegment.
     * @param segmentIndex The index of the segment within the flight plan.
     * @param offset The leg offset within the original flight plan that
     * the segment starts at.
     * @param legs The legs in the flight plan segment.
     * @param segmentType The type of segment this is.
     * @param airway The airway associated with this segment, if any.
     */
    constructor(segmentIndex, offset, legs, segmentType = FlightPlanSegmentType.Enroute, airway) {
        this.segmentIndex = segmentIndex;
        this.offset = offset;
        this.legs = legs;
        this.segmentType = segmentType;
        this.airway = airway;
    }
}
/** An empty flight plan segment. */
FlightPlanSegment.Empty = new FlightPlanSegment(-1, -1, []);
/**
 * Bitflags describing a leg definition.
 */
var LegDefinitionFlags;
(function (LegDefinitionFlags) {
    LegDefinitionFlags[LegDefinitionFlags["None"] = 0] = "None";
    LegDefinitionFlags[LegDefinitionFlags["DirectTo"] = 1] = "DirectTo";
    LegDefinitionFlags[LegDefinitionFlags["MissedApproach"] = 2] = "MissedApproach";
    LegDefinitionFlags[LegDefinitionFlags["Obs"] = 4] = "Obs";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinal"] = 8] = "VectorsToFinal";
    LegDefinitionFlags[LegDefinitionFlags["VectorsToFinalFaf"] = 16] = "VectorsToFinalFaf";
})(LegDefinitionFlags || (LegDefinitionFlags = {}));
/**
 * Vertical flight phase.
 */
var VerticalFlightPhase;
(function (VerticalFlightPhase) {
    VerticalFlightPhase["Climb"] = "Climb";
    VerticalFlightPhase["Descent"] = "Descent";
})(VerticalFlightPhase || (VerticalFlightPhase = {}));
var SpeedUnit;
(function (SpeedUnit) {
    SpeedUnit[SpeedUnit["IAS"] = 0] = "IAS";
    SpeedUnit[SpeedUnit["MACH"] = 1] = "MACH";
})(SpeedUnit || (SpeedUnit = {}));
/** Types of speed restrictions on legs. */
var SpeedRestrictionType;
(function (SpeedRestrictionType) {
    SpeedRestrictionType[SpeedRestrictionType["Unused"] = 0] = "Unused";
    SpeedRestrictionType[SpeedRestrictionType["At"] = 1] = "At";
    SpeedRestrictionType[SpeedRestrictionType["AtOrAbove"] = 2] = "AtOrAbove";
    SpeedRestrictionType[SpeedRestrictionType["AtOrBelow"] = 3] = "AtOrBelow";
    SpeedRestrictionType[SpeedRestrictionType["Between"] = 4] = "Between";
})(SpeedRestrictionType || (SpeedRestrictionType = {}));

/**
 * Utility class for working with flight path calculations.
 */
class FlightPathUtils {
    /**
     * Creates an empty arc vector.
     * @returns An empty arc vector.
     */
    static createEmptyCircleVector() {
        return {
            vectorType: 'circle',
            flags: FlightPathVectorFlags.None,
            radius: 0,
            centerX: 1,
            centerY: 0,
            centerZ: 0,
            startLat: 0,
            startLon: 0,
            endLat: 0,
            endLon: 0,
            distance: 0
        };
    }
    /**
     * Sets the parameters of a circle vector.
     * @param vector The circle vector to set.
     * @param circle The GeoCircle defining the vector's path.
     * @param start The start of the vector.
     * @param end The end of the vector.
     * @param flags The flags to set on the vector.
     * @returns The circle vector, after its parameters have been set.
     */
    static setCircleVector(vector, circle, start, end, flags) {
        vector.flags = flags;
        vector.radius = circle.radius;
        vector.centerX = circle.center[0];
        vector.centerY = circle.center[1];
        vector.centerZ = circle.center[2];
        vector.distance = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
        start instanceof Float64Array && (start = FlightPathUtils.geoPointCache[0].setFromCartesian(start));
        end instanceof Float64Array && (end = FlightPathUtils.geoPointCache[1].setFromCartesian(end));
        vector.startLat = start.lat;
        vector.startLon = start.lon;
        vector.endLat = end.lat;
        vector.endLon = end.lon;
        return vector;
    }
    /**
     * Checks whether a circle vector describes a great-circle path.
     * @param vector A flight path circle vector.
     * @returns Whether the vector describes a great-circle path.
     */
    static isVectorGreatCircle(vector) {
        return vector.radius === Math.PI / 2;
    }
    /**
     * Sets the parameters of a GeoCircle from a flight path circle vector.
     * @param vector A flight path circle vector.
     * @param out The GeoCircle to set.
     * @returns The GeoCircle, after its parameters have been set.
     */
    static setGeoCircleFromVector(vector, out) {
        return out.set(Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[0]), vector.radius);
    }
    /**
     * Gets the direction of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The direction of the turn described by the flight path circle vector.
     */
    static getVectorTurnDirection(vector) {
        return vector.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a flight path circle vector.
     * @param vector The flight path circle vector describing the turn.
     * @returns The radius of the turn described by the flight path circle vector, in great-arc radians.
     */
    static getVectorTurnRadius(vector) {
        return Math.min(vector.radius, Math.PI - vector.radius);
    }
    /**
     * Gets the initial true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The initial true course bearing of the vector, or undefined if one could not be calculated.
     */
    static getVectorInitialCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.startLat, vector.startLon), Math.PI);
    }
    /**
     * Gets the final true course bearing of a flight path vector.
     * @param vector A flight path vector.
     * @returns The final true course bearing of the vector, or `undefined` if one could not be calculated.
     */
    static getVectorFinalCourse(vector) {
        return FlightPathUtils.setGeoCircleFromVector(vector, FlightPathUtils.geoCircleCache[0]).bearingAt(FlightPathUtils.geoPointCache[0].set(vector.endLat, vector.endLon), Math.PI);
    }
    /**
     * Gets the true course for a flight plan leg.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation if `magVarFacility` is not defined.
     * @param magVarFacility The VOR facility which defines the magnetic variation used for the leg's course.
     * @returns The true course for the specified flight plan leg.
     */
    static getLegTrueCourse(leg, point, magVarFacility) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        const magVar = magVarFacility
            ? -magVarFacility.magneticVariation // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
            : Facilities.getMagVar(point.lat, point.lon);
        return NavMath.normalizeHeading(leg.course + magVar);
    }
    /**
     * Gets the final position of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @param out The GeoPoint object to which to write the result.
     * @returns The final position of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalPosition(legCalc, out) {
        if (legCalc.endLat !== undefined && legCalc.endLon !== undefined) {
            return out.set(legCalc.endLat, legCalc.endLon);
        }
        return undefined;
    }
    /**
     * Gets the final true course of a calculated leg.
     * @param legCalc A set of leg calculations.
     * @returns The final true course of the leg, or `undefined` if one could not be obtained.
     */
    static getLegFinalCourse(legCalc) {
        if (legCalc.flightPath.length > 0) {
            const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
            return this.getVectorFinalCourse(vector);
        }
        return undefined;
    }
    /**
     * Gets the circle describing the path of a turn.
     * @param center The center of the turn.
     * @param radius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the turn.
     */
    static getTurnCircle(center, radius, turnDirection, out) {
        out.set(center, radius);
        if (turnDirection === 'right') {
            out.reverse();
        }
        return out;
    }
    /**
     * Reverses the direction of a turn circle while keeping the turn center and turn radius constant.
     * @param circle The turn circle to reverse.
     * @param out A GeoCircle object to which to write the result.
     * @returns A turn circle which has the same turn center and turn radius, but the opposite direction as `circle`.
     */
    static reverseTurnCircle(circle, out) {
        return out.set(Vec3Math.multScalar(circle.center, -1, FlightPathUtils.vec3Cache[0]), Math.PI - circle.radius);
    }
    /**
     * Gets the direction of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The direction of the turn described by the circle.
     */
    static getTurnDirectionFromCircle(circle) {
        return circle.radius > MathUtils.HALF_PI ? 'right' : 'left';
    }
    /**
     * Gets the radius of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @returns The radius of the turn described by the circle, in great-arc radians.
     */
    static getTurnRadiusFromCircle(circle) {
        return Math.min(circle.radius, Math.PI - circle.radius);
    }
    /**
     * Gets the center of a turn described by a circle.
     * @param circle The geo circle describing the turn.
     * @param out A GeoPoint or 3D vector object to which to write the result.
     * @returns The center of a turn described by the circle.
     */
    static getTurnCenterFromCircle(circle, out) {
        return (circle.radius > MathUtils.HALF_PI
            ? out instanceof Float64Array
                ? Vec3Math.multScalar(circle.center, -1, out)
                : out.setFromCartesian(-circle.center[0], -circle.center[1], -circle.center[2])
            : out instanceof Float64Array
                ? Vec3Math.copy(circle.center, out)
                : out.setFromCartesian(circle.center));
    }
    /**
     * Gets the great circle tangent to a given path at a given tangent point. The tangent circle will contain the
     * tangent point and have the same direction as the path at the tangent point.
     * @param point The tangent point. If the point does not lie on the path, it will be projected onto the path.
     * @param path The geo circle describing the path.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified path at the specified point.
     */
    static getGreatCircleTangentToPath(point, path, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(path.center, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Gets the great circle tangent to a given flight path vector at a given tangent point. The tangent circle will
     * contain the tangent point and have the same direction as the vector at the tangent point.
     * @param point The tangent point. If the point does not lie on the vector, it will be projected onto the vector.
     * @param vector The flight path vector.
     * @param out A GeoCircle object to which to write the result.
     * @returns The great circle tangent to the specified flight path vector at the specified point.
     */
    static getGreatCircleTangentToVector(point, vector, out) {
        if (!(point instanceof Float64Array)) {
            point = GeoPoint.sphericalToCartesian(point, FlightPathUtils.vec3Cache[0]);
        }
        const centerVec = Vec3Math.set(vector.centerX, vector.centerY, vector.centerZ, FlightPathUtils.vec3Cache[1]);
        const radialNormal = Vec3Math.normalize(Vec3Math.cross(centerVec, point, FlightPathUtils.vec3Cache[1]), FlightPathUtils.vec3Cache[1]);
        return out.set(Vec3Math.cross(point, radialNormal, FlightPathUtils.vec3Cache[1]), MathUtils.HALF_PI);
    }
    /**
     * Calculates and returns a circle describing a turn starting from a path at a specified point.
     * @param start The starting point of the turn.
     * @param path The circle describing the path from which the turn starts.
     * @param turnRadius The radius of the turn, in great-arc radians.
     * @param turnDirection The direction of the turn.
     * @param out A GeoCircle object to which to write the result.
     * @returns The circle describing the path of the specified turn.
     */
    static getTurnCircleStartingFromPath(start, path, turnRadius, turnDirection, out) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, FlightPathUtils.vec3Cache[0]);
        }
        const radius = turnDirection === 'left'
            ? turnRadius
            : Math.PI - turnRadius;
        const turnStartToCenterNormal = Vec3Math.cross(start, path.center, FlightPathUtils.vec3Cache[1]);
        const turnStartToCenterPath = FlightPathUtils.geoCircleCache[0].set(turnStartToCenterNormal, MathUtils.HALF_PI);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radius, FlightPathUtils.vec3Cache[1], Math.PI);
        return out.set(turnCenter, radius);
    }
    /**
     * Gets the signed distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. A negative distance
     * indicates that the query point lies somewhere before the start of the arc but after the point on the arc's parent
     * circle that is diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The signed distance along the arc from the start point to the query point, in great-arc radians.
     */
    static getAlongArcSignedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        return circle.arcLength((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI + endAngularDistance / 2);
    }
    /**
     * Gets the normalized distance along an arc from a defined start point to a query point. The start, query, and end
     * points will be projected onto the arc's parent circle if they do not already lie on it. The distance is normalized
     * such that 1 equals the arc length from the start point to the end point. A negative distance indicates that the
     * query point lies somewhere before the start of the arc but after the point on the arc's parent circle that is
     * diametrically opposed to the midpoint of the arc.
     * @param circle The arc's parent circle.
     * @param start The start point of the arc.
     * @param end The end point of the arc.
     * @param pos The query point.
     * @param tolerance The error tolerance, in great-arc radians, when checking if `start` and `query` are equal.
     * Defaults to `GeoCircle.ANGULAR_TOLERANCE` if not specified.
     * @returns The normalized distance along the arc from the start point to the query point.
     */
    static getAlongArcNormalizedDistance(circle, start, end, pos, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const posAngularDistance = circle.angleAlong(start, pos, Math.PI);
        if (Math.min(posAngularDistance, MathUtils.TWO_PI - posAngularDistance) <= tolerance) {
            return 0;
        }
        const endAngularDistance = circle.angleAlong(start, end, Math.PI);
        if (Math.min(endAngularDistance, MathUtils.TWO_PI - endAngularDistance) <= tolerance) {
            return posAngularDistance >= Math.PI ? -Infinity : Infinity;
        }
        return ((posAngularDistance - (endAngularDistance / 2) + Math.PI) % MathUtils.TWO_PI - Math.PI) / endAngularDistance + 0.5;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static isPointAlongArc(circle, start, end, pos, inclusive = true, tolerance = GeoCircle.ANGULAR_TOLERANCE) {
        const angularTolerance = circle.angularWidth(tolerance);
        if (typeof end !== 'number') {
            end = circle.angleAlong(start, end, Math.PI, angularTolerance);
        }
        if (inclusive && Math.abs(end) >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const angle = circle.angleAlong(start, pos, Math.PI);
        if (inclusive && angle >= MathUtils.TWO_PI - angularTolerance) {
            return true;
        }
        const signedDiff = (angle - end) * (end >= 0 ? 1 : -1);
        return inclusive ? signedDiff <= angularTolerance : signedDiff < -angularTolerance;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    static projectVelocityToCircle(speed, position, direction, projectTo) {
        if (projectTo.radius <= GeoCircle.ANGULAR_TOLERANCE) {
            return NaN;
        }
        if (speed === 0) {
            return 0;
        }
        if (!(position instanceof Float64Array)) {
            position = GeoPoint.sphericalToCartesian(position, FlightPathUtils.vec3Cache[0]);
        }
        const velocityPath = typeof direction === 'number'
            ? FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, direction)
            : direction.isGreatCircle()
                ? direction
                : FlightPathUtils.geoCircleCache[0].setAsGreatCircle(position, FlightPathUtils.geoCircleCache[0].setAsGreatCircle(direction.center, position).center);
        const sign = velocityPath.encircles(projectTo.center) ? 1 : -1;
        const velocityPathNormal = Vec3Math.copy(velocityPath.center, FlightPathUtils.vec3Cache[1]);
        const projectedRadialNormal = FlightPathUtils.geoCircleCache[0].setAsGreatCircle(projectTo.center, position).center;
        const dot = Vec3Math.dot(projectedRadialNormal, velocityPathNormal);
        const sinTheta = Math.sqrt(1 - MathUtils.clamp(dot * dot, 0, 1));
        return speed * sinTheta * sign;
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan leg calculations. This operation will populate the
     * `ingressToEgress` array with a sequence of vectors connecting the ingress transition to the egress transition
     * while following the flight path defined by the vectors in the `flightPath` array.
     * @param legCalc A set of flight plan leg calculations.
     * @returns The flight plan leg calculations, after the ingress to egress vectors have been resolved.
     */
    static resolveIngressToEgress(legCalc) {
        var _a, _b, _c, _d, _e, _f;
        var _g, _h, _j, _k, _l, _m;
        const vectors = legCalc.ingressToEgress;
        let vectorIndex = 0;
        let flightPathVectorIndex = Math.max(0, legCalc.ingressJoinIndex);
        const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
        const ingressJoinVector = legCalc.flightPath[legCalc.ingressJoinIndex];
        const firstEgressVector = legCalc.egress[0];
        const egressJoinVector = legCalc.flightPath[legCalc.egressJoinIndex];
        if (lastIngressVector && ingressJoinVector) {
            // Check if the last ingress vector joins the base flight path before the end of a vector. If so, we need to
            // replace the base flight path vector the ingress joins with a shortened version starting where the ingress
            // ends.
            const ingressEnd = FlightPathUtils.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon);
            const ingressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(ingressJoinVector.startLat, ingressJoinVector.startLon);
            const ingressJoinVectorEnd = legCalc.ingressJoinIndex === legCalc.egressJoinIndex && firstEgressVector
                ? FlightPathUtils.geoPointCache[2].set(firstEgressVector.startLat, firstEgressVector.startLon)
                : FlightPathUtils.geoPointCache[2].set(ingressJoinVector.endLat, ingressJoinVector.endLon);
            const ingressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, FlightPathUtils.geoCircleCache[0]);
            const ingressEndAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(ingressJoinVectorCircle, ingressJoinVectorStart, ingressJoinVectorEnd, ingressEnd);
            const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(ingressJoinVector.distance, UnitType.GA_RADIAN);
            if (ingressEndAlongVectorDistance < 1 - normalizedTolerance) {
                // Ingress joins the base flight path before the end of the joined vector.
                if (ingressEndAlongVectorDistance > normalizedTolerance) {
                    // Ingress joins the base flight path after the start of the joined vector.
                    ingressJoinVectorCircle.closest(ingressEnd, ingressEnd);
                    FlightPathUtils.setCircleVector((_a = vectors[_g = vectorIndex++]) !== null && _a !== void 0 ? _a : (vectors[_g] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVectorCircle, ingressEnd, ingressJoinVectorEnd, ingressJoinVector.flags);
                }
                else {
                    // Ingress joins the base flight path at or before the start of the joined vector.
                    Object.assign((_b = vectors[_h = vectorIndex++]) !== null && _b !== void 0 ? _b : (vectors[_h] = FlightPathUtils.createEmptyCircleVector()), ingressJoinVector);
                }
            }
            flightPathVectorIndex++;
        }
        const end = Math.min(legCalc.flightPath.length, legCalc.egressJoinIndex < 0 ? Infinity : legCalc.egressJoinIndex);
        for (let i = flightPathVectorIndex; i < end; i++) {
            Object.assign((_c = vectors[_j = vectorIndex++]) !== null && _c !== void 0 ? _c : (vectors[_j] = FlightPathUtils.createEmptyCircleVector()), legCalc.flightPath[i]);
            flightPathVectorIndex++;
        }
        if (flightPathVectorIndex === legCalc.egressJoinIndex && egressJoinVector) {
            if (firstEgressVector) {
                // Check if the first egress vector joins the base flight path in after the start of a vector. If so, we need
                // to replace the base flight path vector the egress joins with a shortened version starting where the egress
                // starts.
                const egressStart = FlightPathUtils.geoPointCache[0].set(firstEgressVector.startLat, firstEgressVector.startLon);
                const egressJoinVectorStart = FlightPathUtils.geoPointCache[1].set(egressJoinVector.startLat, egressJoinVector.startLon);
                const egressJoinVectorEnd = FlightPathUtils.geoPointCache[2].set(egressJoinVector.endLat, egressJoinVector.endLon);
                const egressJoinVectorCircle = FlightPathUtils.setGeoCircleFromVector(egressJoinVector, FlightPathUtils.geoCircleCache[0]);
                const egressStartAlongVectorDistance = FlightPathUtils.getAlongArcNormalizedDistance(egressJoinVectorCircle, egressJoinVectorStart, egressJoinVectorEnd, egressStart);
                const normalizedTolerance = GeoCircle.ANGULAR_TOLERANCE / UnitType.METER.convertTo(egressJoinVector.distance, UnitType.GA_RADIAN);
                if (egressStartAlongVectorDistance > normalizedTolerance) {
                    // Egress joins the base flight path after the start of the joined vector.
                    if (egressStartAlongVectorDistance < 1 - normalizedTolerance) {
                        // Egress joins the base flight path before the end of the joined vector.
                        egressJoinVectorCircle.closest(egressStart, egressStart);
                        FlightPathUtils.setCircleVector((_d = vectors[_k = vectorIndex++]) !== null && _d !== void 0 ? _d : (vectors[_k] = FlightPathUtils.createEmptyCircleVector()), egressJoinVectorCircle, egressJoinVectorStart, egressStart, egressJoinVector.flags);
                    }
                    else {
                        // Egress joins the base flight path at or after the end of the joined vector.
                        Object.assign((_e = vectors[_l = vectorIndex++]) !== null && _e !== void 0 ? _e : (vectors[_l] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
                    }
                }
            }
            else {
                // There is no egress, but there is a base flight path vector flagged as the vector with which the egress
                // joins. This is technically an invalid state, but we can easily just treat this as a regular "no-egress"
                // case and copy the entire egress join vector into the resolved vectors array.
                Object.assign((_f = vectors[_m = vectorIndex++]) !== null && _f !== void 0 ? _f : (vectors[_m] = FlightPathUtils.createEmptyCircleVector()), egressJoinVector);
            }
        }
        vectors.length = vectorIndex;
        return legCalc;
    }
}
FlightPathUtils.vec3Cache = [new Float64Array(3), new Float64Array(3)];
FlightPathUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Builds circle vectors.
 */
class CircleVectorBuilder {
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, ...args) {
        if (args[0] instanceof GeoCircle) {
            this.setFromCircle(vectors, index, ...args);
        }
        else {
            this.setFromPoints(vectors, index, ...args);
        }
        return 1;
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param direction The direction of the circle.
     * @param radius The radius of the circle, in meters.
     * @param center The center of the circle.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromPoints(vectors, index, direction, radius, center, start, end, flags = 0) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, CircleVectorBuilder.geoCircleCache[0]);
        return this.setFromCircle(vectors, index, circle, start, end, flags);
    }
    /**
     * Sets the parameters for a circle vector in a flight path vector sequence. If a circle vector does not exist at the
     * specified index in the sequence, a new one will be created.
     * @param vectors A flight path vector sequence.
     * @param index The index in the sequence at which to set the circle vector.
     * @param circle The circle which defines the vector path.
     * @param start The start point.
     * @param end The end point.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The set circle vector.
     */
    setFromCircle(vectors, index, circle, start, end, flags = 0) {
        var _a;
        const vector = (((_a = vectors[index]) === null || _a === void 0 ? void 0 : _a.vectorType) === 'circle' ? vectors[index] : (vectors[index] = FlightPathUtils.createEmptyCircleVector()));
        return FlightPathUtils.setCircleVector(vector, circle, start, end, flags);
    }
}
CircleVectorBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds great-circle paths between defined start and end points.
 */
class GreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, endArg, flags) {
        if (pathArg instanceof GeoCircle) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.buildFromPath(vectors, index, start, pathArg, endArg, flags);
        }
        else {
            return this.buildFromEndpoints(vectors, index, start, pathArg, endArg, flags);
        }
    }
    /**
     * Builds a sequence of vectors representing the shortest great-circle path between two points.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param end The end point.
     * @param initialCourse The initial true course bearing. Used to define a unique great-circle path when `start` and
     * `end` are antipodal.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `start` and `end` are antipodal and `initialCourse` is undefined.
     */
    buildFromEndpoints(vectors, index, start, end, initialCourse, flags) {
        const startPoint = start instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[0].setFromCartesian(start)
            : GreatCircleBuilder.geoPointCache[0].set(start);
        const endPoint = end instanceof Float64Array
            ? GreatCircleBuilder.geoPointCache[1].setFromCartesian(end)
            : GreatCircleBuilder.geoPointCache[1].set(end);
        const distance = startPoint.distance(endPoint);
        const path = GreatCircleBuilder.geoCircleCache[0];
        if (distance >= Math.PI - GeoPoint.EQUALITY_TOLERANCE) {
            if (initialCourse === undefined) {
                throw new Error('GreatCircleVectorBuilder: cannot build a unique direct track from antipodal endpoints.');
            }
            else {
                path.setAsGreatCircle(start, initialCourse);
            }
        }
        else {
            path.setAsGreatCircle(start, end);
        }
        return this.buildFromPath(vectors, index, start, path, end, flags);
    }
    /**
     * Builds a sequence of vectors representing a great-circle path from a start point to either a defined endpoint
     * or a distance offset.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param path The great-circle path.
     * @param endArg The end point or distance offset.
     * @param flags The flags to set on the vector. Defaults to none (0).
     * @returns The number of vectors added to the sequence.
     * @throws Error if `path` is not a great circle.
     */
    buildFromPath(vectors, index, start, path, endArg, flags = 0) {
        if (!path.isGreatCircle()) {
            throw new Error(`GreatCircleVectorBuilder: expected GeoCircle radius of pi / 2; instead was ${path.radius}`);
        }
        const end = typeof endArg === 'number'
            ? path.offsetDistanceAlong(start, UnitType.METER.convertTo(endArg, UnitType.GA_RADIAN), GreatCircleBuilder.vec3Cache[0], Math.PI)
            : endArg;
        return this.circleVectorBuilder.build(vectors, index, path, start, end, flags);
    }
}
GreatCircleBuilder.vec3Cache = [new Float64Array(3)];
GreatCircleBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
GreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds constant-radius turns toward specified course bearings.
 */
class TurnToCourseBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Adds a turn from a defined start point and initial course to a specific final course to a flight path vector
     * sequence. If the difference between the initial and final course is small enough such that the start and end of
     * the turn are identical, no turn will be added to the vector sequence.
     * @param vectors The flight path vector sequence to which to add the turn.
     * @param index The index in the sequence at which to add the turn.
     * @param start The start point of the turn.
     * @param radius The radius of the turn, in meters.
     * @param direction The direction of the turn.
     * @param fromCourse The initial true course at the start of the turn.
     * @param toCourse The final true course at the end of the turn.
     * @param flags The flags to set on the turn vector. Defaults to the `TurnToCourse` flag.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, radius, direction, fromCourse, toCourse, flags = FlightPathVectorFlags.TurnToCourse) {
        if (start instanceof Float64Array) {
            start = TurnToCourseBuilder.geoPointCache[0].setFromCartesian(start);
        }
        const radiusRad = UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnCenterPoint = TurnToCourseBuilder.geoPointCache[1].set(start).offset(fromCourse + (direction === 'left' ? -90 : 90), radiusRad);
        const turnStartBearing = turnCenterPoint.bearingTo(start);
        const turnEndBearing = NavMath.normalizeHeading(turnStartBearing + (toCourse - fromCourse));
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, radiusRad, TurnToCourseBuilder.geoPointCache[2]);
        if (turnEndPoint.equals(start)) {
            return 0;
        }
        return this.circleVectorBuilder.build(vectors, index, direction, radius, turnCenterPoint, start, turnEndPoint, flags);
    }
}
TurnToCourseBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
/**
 * Builds great-circle paths to intercept other geo circles.
 */
class CircleInterceptBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, pathArg, circle, flags = 0) {
        if (circle.includes(start)) {
            return 0;
        }
        let startPath;
        if (pathArg instanceof GeoCircle) {
            if (!pathArg.includes(start)) {
                throw new Error('CircleInterceptBuilder: the starting point does not lie on the starting path.');
            }
            startPath = pathArg;
        }
        else {
            startPath = CircleInterceptBuilder.geoCircleCache[0].setAsGreatCircle(start, pathArg);
        }
        const intersections = CircleInterceptBuilder.intersectionCache;
        const numIntersections = startPath.intersection(circle, intersections);
        if (numIntersections === 0) {
            return 0;
        }
        const intersectionIndex = (numIntersections === 1 || circle.encircles(start)) ? 0 : 1;
        const endVec = intersections[intersectionIndex];
        return startPath.isGreatCircle()
            ? this.greatCircleBuilder.build(vectors, index, start, startPath, endVec, flags)
            : this.circleVectorBuilder.build(vectors, index, startPath, start, endVec, flags);
    }
}
CircleInterceptBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
CircleInterceptBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds constant-radius turns to join great-circle paths.
 */
class TurnToJoinGreatCircleBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPathArg, endPath, radius, flags = FlightPathVectorFlags.TurnToCourse) {
        if (!endPath.isGreatCircle()) {
            throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${endPath.radius}`);
        }
        let startPath;
        if (startPathArg instanceof GeoCircle) {
            if (!startPathArg.isGreatCircle()) {
                throw new Error(`TurnToJoinPathBuilder: expected GeoCircle radius of pi / 2; instead was ${startPathArg.radius}`);
            }
            else if (!startPathArg.includes(start)) {
                throw new Error('TurnToJoinPathBuilder: the starting point does not lie on the starting path.');
            }
            startPath = startPathArg;
        }
        else {
            startPath = TurnToJoinGreatCircleBuilder.geoCircleCache[0].setAsGreatCircle(start, startPathArg);
        }
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, TurnToJoinGreatCircleBuilder.vec3Cache[0]);
        }
        const turnDirection = endPath.encircles(start) ? 'left' : 'right';
        const radiusRad = turnDirection === 'left'
            ? UnitType.METER.convertTo(radius, UnitType.GA_RADIAN)
            : Math.PI - UnitType.METER.convertTo(radius, UnitType.GA_RADIAN);
        const turnStartToCenterNormal = Vec3Math.cross(start, startPath.center, TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        const turnStartToCenterPath = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnStartToCenterNormal, Math.PI / 2);
        const turnCenter = turnStartToCenterPath.offsetDistanceAlong(start, radiusRad, TurnToJoinGreatCircleBuilder.vec3Cache[2]);
        const turnCircle = TurnToJoinGreatCircleBuilder.geoCircleCache[1].set(turnCenter, radiusRad);
        const end = turnCircle.closest(Vec3Math.multScalar(endPath.center, turnDirection === 'left' ? -1 : 1, TurnToJoinGreatCircleBuilder.vec3Cache[3]), TurnToJoinGreatCircleBuilder.vec3Cache[1]);
        return this.circleVectorBuilder.build(vectors, index, turnCircle, start, end, flags);
    }
}
TurnToJoinGreatCircleBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
TurnToJoinGreatCircleBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
[
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0)
];
[new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths via a turn starting at the start
 * point followed by an angled intercept path which intercepts the final path before the end point.
 */
class InterceptGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * intercepts a final course at a specified angle using a great-circle path. Optionally includes a final turn from
     * the intercept path to the final course.
     *
     * If an intercept angle greater than the minimum angle is required to intercept the final course before the end
     * point, no vectors will be calculated.
     *
     * If the initial and final courses are parallel, no vectors will be calculated.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param startTurnRadius The radius of the initial turn, in meters.
     * @param startTurnDirection The direction of the initial turn. If not defined, the direction of the initial turn
     * will be automatically selected.
     * @param interceptAngle The angle at which to intercept the final path, in degrees. Will be clamped to the range
     * `[0, 90]`.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param endTurnRadius The radius of the final turn, in meters, or `undefined` if a turn to join the final path
     * should not be calculated.
     * @param startTurnVectorFlags The flags to set on the initial turn vector. Defaults to none (0).
     * @param interceptVectorFlags The flags to set on the vector along the intercept path. Defaults to none (0).
     * @param endTurnVectorFlags The flags to set on the final turn vector. Defaults to none (0). Ignored if a turn to
     * join the final path is not calculated.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, startTurnRadius, startTurnDirection, interceptAngle, end, endPath, endTurnRadius, startTurnVectorFlags = 0, interceptVectorFlags = 0, endTurnVectorFlags = 0) {
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, InterceptGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, InterceptGreatCircleToPointBuilder.vec3Cache[1]);
        }
        const startToEndPathAngleRad = Math.acos(Vec3Math.dot(startPath.center, endPath.center));
        if (startToEndPathAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // initial and final paths are parallel
            return 0;
        }
        const intersections = InterceptGreatCircleToPointBuilder.intersectionCache;
        const interceptAngleRad = MathUtils.clamp(interceptAngle * Avionics.Utils.DEG2RAD, 0, MathUtils.HALF_PI);
        // The set of centers of great circles that intersect the end path at the desired intercept angle
        const interceptPathCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(endPath.center, interceptAngleRad);
        const startTurnRadiusRad = UnitType.METER.convertTo(startTurnRadius, UnitType.GA_RADIAN);
        if (startTurnDirection === undefined) {
            // Calculate the intercept point if the intercept path were to pass through the start point.
            const interceptCount = interceptPathCenters.intersection(InterceptGreatCircleToPointBuilder.geoCircleCache[0].set(start, MathUtils.HALF_PI), intersections);
            if (interceptCount === 0) {
                // No great-circle path passing through the start point can intercept the final path at the desired intercept angle.
                startTurnDirection = startPath.encircles(end) ? 'left' : 'right';
            }
            else {
                let intersectionIndex = 0;
                if (interceptCount > 1) {
                    // There are two great-circle paths passing through the start point that intercept the final path at the
                    // desired angle. One of them will be directed toward the end path and the other will be directed away from
                    // it. We want to choose the one directed toward it.
                    intersectionIndex = endPath.encircles(start) ? 0 : 1;
                }
                let cross = Vec3Math.cross(startPath.center, intersections[intersectionIndex], InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                // sin x ~= x for x near 0, so to check if the angle between the start path and intercept path is parallel or
                // antiparallel we just have to check the magnitude of their cross product instead of the arcsine of the
                // magnitude.
                if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                    // If start and intercept paths are parallel or antiparallel, it doesn't really matter which direction we
                    // turn, so we will just turn in the direction that aligns us with the end path.
                    cross = Vec3Math.cross(startPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]);
                    if (Vec3Math.abs(cross) <= GeoCircle.ANGULAR_TOLERANCE) {
                        // If start and end paths are antiparallel (they can't be parallel since we would have returned from the
                        // method by now), then we just arbitrarily choose to turn right.
                        startTurnDirection = 'right';
                    }
                    else {
                        startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                    }
                }
                else {
                    startTurnDirection = Vec3Math.dot(cross, start) >= 0 ? 'left' : 'right';
                }
            }
        }
        const startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(start, startPath, startTurnRadiusRad, startTurnDirection, InterceptGreatCircleToPointBuilder.geoCircleCache[0]);
        const endTurnRadiusRad = endTurnRadius === undefined ? undefined : UnitType.METER.convertTo(endTurnRadius, UnitType.GA_RADIAN);
        if (interceptAngleRad <= GeoCircle.ANGULAR_TOLERANCE) {
            // If the desired intercept angle is 0 degrees, the only valid path is when the starting turn ends exactly on the
            // path to intercept and the end of the turn lies before the end point
            if (Math.abs(GeoPoint.distance(startTurnCircle.center, endPath.center) - Math.abs(MathUtils.HALF_PI - startTurnCircle.radius)) > GeoCircle.ANGULAR_TOLERANCE) {
                // starting turn is not tangent to path to intercept
                return 0;
            }
            const startTurnEnd = endPath.closest(startTurnCircle.closest(endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
            const startTurnEndToEndDistance = endPath.angleAlong(startTurnEnd, end, Math.PI);
            if (startTurnEndToEndDistance < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && startTurnEndToEndDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                // the end of the starting turn lies after the end point.
                return 0;
            }
            return this.circleVectorBuilder.build(vectors, index, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
        }
        // Find the great-circle path that intersects the path to intercept at the desired intercept angle and is tangent
        // to the starting turn.
        // The set of centers of great circles that are tangent to the starting turn
        const startTurnInterceptTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(startTurnCircle.center, Math.abs(MathUtils.HALF_PI - startTurnRadiusRad));
        const interceptPathCount = interceptPathCenters.intersection(startTurnInterceptTangentCenters, intersections);
        if (interceptPathCount === 0) {
            return 0;
        }
        const interceptPath = InterceptGreatCircleToPointBuilder.geoCircleCache[1];
        let interceptCrossSign;
        if (startToEndPathAngleRad >= interceptAngleRad) {
            // The start turn is considered to overshoot if it crosses to the contralateral side of the final path before
            // joining the intercept path that requires the shortest turn to join. The contralateral side is defined as the
            // right side for left turns and the left side for right turns. If this occurs, we need to choose the second
            // intercept path (if it exists). This is because choosing the first intercept path would trigger a case below
            // that attempts to end the start turn early, which could produce a path that requires the plane to track toward
            // the final path at an angle greater than the intercept angle.
            const overshootThreshold = Math.asin(MathUtils.clamp(Math.cos(interceptAngleRad) * Math.sin(startTurnRadiusRad), 0, 1));
            const doesStartTurnOvershoot = endPath.distance(startTurnCircle.center) > -overshootThreshold + GeoCircle.ANGULAR_TOLERANCE;
            interceptPath.set(intersections[interceptPathCount === 1 || !doesStartTurnOvershoot ? 0 : 1], MathUtils.HALF_PI);
            interceptCrossSign = doesStartTurnOvershoot === (startTurnDirection === 'right') ? 1 : -1;
        }
        else {
            // If the start path intersects the final path at a shallower angle than the intercept path, then we always want
            // to choose the intercept path that requires the shortest turn to join. Even if the turn has overshot the final
            // path by the time it can join the chosen intercept path, we handle that case below by attempting to end the
            // start turn early. We are guaranteed that ending the start turn early will not result in a path that requires
            // the plane to track toward the final path at an angle greater than the intercept angle because if it did, that
            // would mean the start turn does not overshoot the final path and therefore we wouldn't have needed to end the
            // start turn early in the first place.
            interceptPath.set(intersections[Math.max(1, intersections.length - 1)], MathUtils.HALF_PI);
            interceptCrossSign = startTurnDirection === 'right' ? 1 : -1;
        }
        const startTurnEnd = interceptPath.closest(startTurnCircle.closest(interceptPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[2]), InterceptGreatCircleToPointBuilder.vec3Cache[2]);
        const intercept = Vec3Math.multScalar(Vec3Math.normalize(Vec3Math.cross(interceptPath.center, endPath.center, InterceptGreatCircleToPointBuilder.vec3Cache[3]), InterceptGreatCircleToPointBuilder.vec3Cache[3]), interceptCrossSign, InterceptGreatCircleToPointBuilder.vec3Cache[3]);
        const interceptDistance = interceptPath.distanceAlong(startTurnEnd, intercept, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        // Required turn anticipation for the end turn to join the intercept and final paths.
        let minDInterceptEnd = 0;
        if (endTurnRadiusRad !== undefined) {
            const endTheta = Math.PI - interceptAngleRad;
            minDInterceptEnd = Math.asin(Math.tan(endTurnRadiusRad) / Math.tan(endTheta / 2));
            if (isNaN(minDInterceptEnd)) {
                // Turn radius is too large for the end turn to join the intercept and final paths
                return 0;
            }
        }
        const interceptToEndDistance = endPath.distanceAlong(intercept, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
        const interceptToEndOffset = (interceptToEndDistance + Math.PI) % MathUtils.TWO_PI - Math.PI;
        if (interceptToEndOffset < minDInterceptEnd) {
            // The intercept path does not intercept the final path early enough to make the end turn before the end point
            return 0;
        }
        let vectorIndex = index;
        if (interceptDistance < minDInterceptEnd || interceptDistance > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
            // The start turn ends too late to make a turn to join the final path or the start turn overshoots the end path
            // before reaching the intercept course -> attempt to end the start turn early
            if (endTurnRadiusRad === undefined) {
                // We don't need to calculate a final turn, so attempt to end the start turn where it intersects the end path
                const startTurnEndPathIntersectionCount = startTurnCircle.intersection(endPath, intersections);
                if (startTurnEndPathIntersectionCount === 0) {
                    return 0;
                }
                const startTurnEndPathIntersection = intersections[startTurnEndPathIntersectionCount === 1 || startTurnDirection === 'right' ? 0 : 1];
                if (endPath.distanceAlong(startTurnEndPathIntersection, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The start turn intercepts the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEndPathIntersection, startTurnVectorFlags);
            }
            else {
                // We need to calculate a final turn to join the end path. This final turn must be tangent to the starting turn
                // and the end path.
                const startTurnCenter = FlightPathUtils.getTurnCenterFromCircle(startTurnCircle, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the starting turn
                const startTurnEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[1].set(startTurnCenter, startTurnRadiusRad + endTurnRadiusRad);
                // The set of centers of all geo circles of the desired end turn radius that are tangent to the end path
                const endPathEndTurnTangentCenters = InterceptGreatCircleToPointBuilder.geoCircleCache[2].set(endPath.center, endPath.radius + endTurnRadiusRad * (startTurnDirection === 'left' ? 1 : -1));
                const endTurnCircleCount = endPathEndTurnTangentCenters.intersection(startTurnEndTurnTangentCenters, intersections);
                if (endTurnCircleCount === 0) {
                    return 0;
                }
                const endTurnCenter = intersections[0];
                const endTurnCircle = FlightPathUtils.getTurnCircle(endTurnCenter, endTurnRadiusRad, startTurnDirection === 'left' ? 'right' : 'left', InterceptGreatCircleToPointBuilder.geoCircleCache[1]);
                endTurnCircle.closest(startTurnCenter, startTurnEnd);
                const endTurnEnd = endPath.closest(endTurnCenter, InterceptGreatCircleToPointBuilder.vec3Cache[4]);
                if (endPath.distanceAlong(endTurnEnd, end, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > Math.PI + GeoCircle.ANGULAR_TOLERANCE) {
                    // The end turn joins the final path after the end point
                    return 0;
                }
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endTurnCircle, startTurnEnd, endTurnEnd, endTurnVectorFlags);
            }
        }
        else {
            if (GeoPoint.distance(start, startTurnEnd) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, start, startTurnEnd, startTurnVectorFlags);
            }
            let interceptPathEnd = intercept;
            if (endTurnRadiusRad !== undefined) {
                interceptPathEnd = interceptPath.offsetDistanceAlong(intercept, -minDInterceptEnd, InterceptGreatCircleToPointBuilder.vec3Cache[4], Math.PI);
            }
            if (interceptDistance - minDInterceptEnd > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, interceptPath, startTurnEnd, interceptPathEnd, interceptVectorFlags);
            }
            if (endTurnRadius !== undefined) {
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, interceptPathEnd, interceptPath, endPath, endTurnRadius, endTurnVectorFlags);
            }
        }
        return vectorIndex - index;
    }
}
InterceptGreatCircleToPointBuilder.vec3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)
];
InterceptGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
InterceptGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths connecting initial great-circle paths to final great-circle paths terminating at defined end points.
 */
class JoinGreatCircleToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.turnToJoinGreatCircleBuilder = new TurnToJoinGreatCircleBuilder();
        this.interceptGreatCircleToPointBuilder = new InterceptGreatCircleToPointBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /**
     * Builds a sequence of vectors representing a path from a defined start point and initial course which turns and
     * joins a great-circle path which terminates at a defined end point.
     *
     * This method will first attempt to connect the starting point and final path with a single constant-radius turn
     * of at least the minimum turn radius and in the desired direction that joins the final path before the end point.
     * If this is not possible, then what happens next depends on the `preferSingleTurn` argument:
     * * If it is `true`, then another path connecting the starting point and final path with a single constant-radius
     * turn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn
     * direction.
     * * If it is `false`, then a path to intercept the final path at a 45-degree angle will be computed. If such a path
     * is not possible or if the intercept point lies after the end point, and `allowDirectFallback` is `true`, a direct
     * course to the end point will be computed. If `allowDirectFallback` is `false` and all attempts to compute a path
     * have failed, then no vectors will be built.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param desiredTurnDirection The desired initial turn direction. If not defined, the most efficient turn direction
     * that satisfies the constraints will be chosen.
     * @param minTurnRadius The minimum turn radius, in meters. Defaults to 0.
     * @param preferSingleTurn Whether to prefer flight path solutions that consist of a single constant-radius turn
     * from the initial to final course. Defaults to `false`.
     * @param allowDirectFallback Whether the computed path should fall back to a direct course to the end point if the
     * final path cannot be joined before the end point. Defaults to `true`.
     * @param intersection The point of intersection between the start and end paths closest to the start point. If
     * not defined, it will be calculated.
     * @param flags The flags to set on the vectors. Defaults to none (0).
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @param includeDirectFlag Whether to include the `Direct` flag on vectors when falling back to a direct course.
     * Defaults to `true`.
     * @param includeInterceptFlag Whether to include the `InterceptCourse` flag on vectors when building an intercept
     * path. Defaults to `true`.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, desiredTurnDirection, minTurnRadius, preferSingleTurn = false, allowDirectFallback = true, intersection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true, includeInterceptFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, JoinGreatCircleToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, JoinGreatCircleToPointBuilder.vec3Cache[1]);
        }
        if (!intersection) {
            const intersections = JoinGreatCircleToPointBuilder.intersectionCache;
            const solutionCount = startPath.intersection(endPath, intersections);
            if (solutionCount === 0) {
                return 0;
            }
            // choose the intersection closest to the start point.
            intersection = Vec3Math.copy(Vec3Math.dot(intersections[0], start) > 0
                ? intersections[0]
                : intersections[1], JoinGreatCircleToPointBuilder.vec3Cache[2]);
        }
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        // Calculate the relative directions of the start point, intersection point, and end point.
        const intersectionToStartDot = Vec3Math.dot(Vec3Math.cross(startPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), start);
        // positive -> start point lies after the intersection (with respect to the direction of start path)
        const intersectionToStartSign = intersectionToStartDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToStartDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, JoinGreatCircleToPointBuilder.vec3Cache[3]), end);
        // positive -> end point lies after the intersection (with respect to the direction of end path)
        const intersectionToEndSign = intersectionToEndDot < -GeoCircle.ANGULAR_TOLERANCE ? -1
            : intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE ? 1 : 0;
        const isEndForwardOfIntersection = intersectionToEndSign > 0;
        minTurnRadius !== null && minTurnRadius !== void 0 ? minTurnRadius : (minTurnRadius = 0);
        const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
        const pathDot = Vec3Math.dot(startPath.center, endPath.center);
        const theta = Math.acos(-pathDot);
        const tanHalfTheta = Math.tan(theta / 2);
        // along-track distance from the intersection point to the start/end of the minimum-radius turn from start path to end path
        let minD = Math.asin(Math.tan(minTurnRadiusRad) / tanHalfTheta);
        if (isNaN(minD)) {
            // Turn radius is too large for any turn to join the start and end paths
            minD = Infinity;
        }
        const intersectionStartDistance = intersectionToStartSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, start));
        const intersectionEndDistance = intersectionToEndSign === 0 ? 0 : Math.acos(Vec3Math.dot(intersection, end));
        const intersectionStartOffset = intersectionToStartSign * intersectionStartDistance;
        const intersectionEndOffset = intersectionToEndSign * intersectionEndDistance;
        const towardEndPointTurnDirection = startPath.encircles(end, false) ? 'left' : 'right';
        let needCalculateTwoTurnPath = false;
        let needCalculateOneTurnPath = false;
        if (isEndForwardOfIntersection) {
            if (desiredTurnDirection === undefined || desiredTurnDirection === towardEndPointTurnDirection) {
                const isStartPastRequiredTurnStart = intersectionStartOffset > -minD;
                const isEndBeforeRequiredTurnEnd = intersectionEndOffset < minD;
                if (isStartPastRequiredTurnStart || isEndBeforeRequiredTurnEnd) {
                    // The minimum turn radius is too large to intercept the final path before the end point
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
                else {
                    // Make a single constant-radius turn either starting at the start point, or ending at the end point,
                    // depending on which is closer to the intersection point.
                    const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(Math.min(intersectionStartDistance, intersectionEndDistance))), UnitType.METER);
                    if (intersectionStartDistance <= intersectionEndDistance) {
                        // start turn at start point
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, start, startPath, endPath, turnRadius, turnFlags);
                        if (intersectionEndDistance - intersectionStartDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            const turnEnd = endPath.offsetDistanceAlong(intersection, intersectionStartDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end, flags);
                        }
                    }
                    else {
                        // end turn at end point
                        let turnStart = start;
                        if (intersectionStartDistance - intersectionEndDistance > GeoCircle.ANGULAR_TOLERANCE) {
                            turnStart = startPath.offsetDistanceAlong(intersection, -intersectionEndDistance, JoinGreatCircleToPointBuilder.vec3Cache[3], Math.PI);
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart, flags);
                        }
                        vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                    }
                }
            }
            else {
                if (pathDot >= 0) {
                    // The start and end paths intersect at an angle <= 90 degrees. This means that for a turn away from the end
                    // point, the total flight path distance is minimized when the turn joins the start and end paths directly.
                    if (intersectionStartOffset <= minD) {
                        // The start point lies at or before the required turn start point to minimize the flight path distance.
                        needCalculateOneTurnPath = true;
                    }
                    else {
                        needCalculateTwoTurnPath = !preferSingleTurn;
                        needCalculateOneTurnPath = preferSingleTurn;
                    }
                }
                else {
                    needCalculateTwoTurnPath = !preferSingleTurn;
                    needCalculateOneTurnPath = preferSingleTurn;
                }
            }
        }
        else {
            needCalculateTwoTurnPath = !preferSingleTurn;
            needCalculateOneTurnPath = preferSingleTurn;
        }
        let needDirectFallback = false;
        if (needCalculateTwoTurnPath) {
            const interceptFlag = includeInterceptFlag ? FlightPathVectorFlags.InterceptCourse : 0;
            // Attempt to make a turn to intercept the end path at 45 degrees. At this point we are in fallback territory
            // so we won't honor the desired starting turn direction.
            const numInterceptVectors = this.interceptGreatCircleToPointBuilder.build(vectors, vectorIndex, start, startPath, minTurnRadius, undefined, JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE, end, endPath, minTurnRadius, turnFlags | interceptFlag, flags | interceptFlag, turnFlags | interceptFlag);
            if (numInterceptVectors === 0) {
                needDirectFallback = allowDirectFallback;
            }
            else {
                vectorIndex += numInterceptVectors;
                const lastVector = vectors[vectorIndex - 1];
                const interceptEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, JoinGreatCircleToPointBuilder.vec3Cache[5]);
                if (Math.acos(Vec3Math.dot(interceptEnd, end)) > GeoCircle.ANGULAR_TOLERANCE) {
                    vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, endPath, interceptEnd, end, flags);
                }
            }
        }
        else if (needCalculateOneTurnPath) {
            // Make a single constant-radius turn from the start path to join the end path. The turn must start after the
            // intersection of the start and end paths (the only case where the turn starts before the intersection is
            // handled above).
            if (minD > Math.PI / 2) {
                // No amount of anticipation can provide a turn which joins the start and end paths of the desired radius.
                needDirectFallback = allowDirectFallback;
            }
            else {
                const minTurnEndOffset = Math.min(intersectionEndOffset, -minD);
                const turnStartOffset = Math.max(-minTurnEndOffset, intersectionStartOffset);
                const turnRadius = UnitType.GA_RADIAN.convertTo(Math.atan(tanHalfTheta * Math.sin(turnStartOffset)), UnitType.METER);
                const turnStart = startPath.offsetDistanceAlong(intersection, turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[3]);
                if (turnStartOffset - intersectionStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, turnStart);
                }
                vectorIndex += this.turnToJoinGreatCircleBuilder.build(vectors, vectorIndex, turnStart, startPath, endPath, turnRadius, turnFlags);
                if (intersectionEndOffset + turnStartOffset > GeoPoint.EQUALITY_TOLERANCE) {
                    const turnEnd = endPath.offsetDistanceAlong(intersection, -turnStartOffset, JoinGreatCircleToPointBuilder.vec3Cache[4]);
                    vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEnd, endPath, end);
                }
            }
        }
        if (needDirectFallback) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, start, startPath, end, minTurnRadius, desiredTurnDirection, flags, includeTurnToCourseFlag, includeDirectFlag);
        }
        return vectorIndex - index;
    }
}
JoinGreatCircleToPointBuilder.INTERCEPT_ANGLE = 45; // degrees
JoinGreatCircleToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
JoinGreatCircleToPointBuilder.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
JoinGreatCircleToPointBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds procedure turns.
 */
class ProcedureTurnBuilder {
    constructor() {
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /**
     * Builds a sequence of vectors representing a procedure turn from a defined starting point and initial course to a
     * defined end point and final course. A procedure turn begins with a variable-length leg from the start point along
     * the initial course followed by an initial turn to intercept the outbound leg of the procedure turn, then a
     * variable-length outbound leg, a 180-degree turn, a variable-length inbound leg, and finally a turn to intercept
     * the final course at the end point. If a full set of vectors cannot be computed given the restraints imposed by the
     * path geometry and the desired turn radius, parts of the turn beginning with the inbound leg of the procedure turn
     * may be altered or omitted entirely.
     * @param vectors The flight path vector sequence to which to add the vectors.
     * @param index The index in the sequence at which to add the vectors.
     * @param start The start point.
     * @param startPath The great-circle path defining the initial course.
     * @param end The end point.
     * @param endPath The great-circle path defining the final course.
     * @param outboundCourse The true course, in degrees, of the outbound leg of the turn.
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @param desiredTurnDirection The desired turn direction.
     * @param initialCourse The initial course. If not defined, it will be calculated from `startPath` and `start`.
     * @param finalCourse The final course. If not defined, it will be calculated from `endPath` and `end`.
     * @param flags The flags to set on the vectors. Defaults to the `CourseReversal` flag.
     * @param includeTurnToCourseFlag Whether to include the `TurnToCourse` flag on the turn vectors. True by default.
     * @returns The number of vectors added to the sequence.
     */
    build(vectors, index, start, startPath, end, endPath, outboundCourse, desiredTurnRadius, desiredTurnDirection, initialCourse, finalCourse, flags = FlightPathVectorFlags.CourseReversal, includeTurnToCourseFlag = true) {
        let vectorIndex = index;
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, ProcedureTurnBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            end = GeoPoint.sphericalToCartesian(end, ProcedureTurnBuilder.vec3Cache[1]);
        }
        /*
         * We need to calculate two parameters: (1) the distance to stay on the initial outbound segment, and (2) the
         * distance to stay on the outbound segment of the turn. We ideally would like to choose these parameters such
         * that the procedure turn ends at a location where it can immediately make another turn to intercept the next
         * leg. However, this may not be possible since we are constrained by the fact that the two distance parameters
         * cannot be negative. To simplify the math, we will do an approximated calculation based on a pseudo-Euclidean
         * geometry instead of spherical geometry. The error is proportional to the angle between the outbound path and the
         * the path to intercept; if they are exactly antiparallel the error is zero.
         */
        initialCourse !== null && initialCourse !== void 0 ? initialCourse : (initialCourse = startPath.bearingAt(start, Math.PI));
        finalCourse !== null && finalCourse !== void 0 ? finalCourse : (finalCourse = endPath.bearingAt(end, Math.PI));
        const startPoint = ProcedureTurnBuilder.geoPointCache[0].setFromCartesian(start);
        const initialTurnDirection = NavMath.getTurnDirection(initialCourse, outboundCourse);
        const isInitialTurnTowardEndPath = startPath.encircles(end) === (initialTurnDirection === 'left');
        const deltaOutbound = Math.abs(NavMath.diffAngle(initialCourse, outboundCourse)) * Avionics.Utils.DEG2RAD;
        const thetaOutbound = (Math.PI - deltaOutbound) / 2;
        const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
        // If there is a desired turn direction, honor it. Otherwise choose the direction that results in the shortest path
        // to intercept the next leg.
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (((initialTurnDirection === 'left') === deltaOutbound < Math.PI) ? 'right' : 'left');
        const endPointToStartPathXTrackDistance = Math.abs(startPath.distance(end));
        let desiredAlongTurnOutboundPathDistance = Math.abs(deltaOutbound - Math.PI / 2) > 1e-10
            ? Math.asin(Math.tan(2 * desiredTurnRadiusRad) / Math.tan(deltaOutbound)) * (turnDirection === initialTurnDirection ? -1 : 1)
            : 0;
        desiredAlongTurnOutboundPathDistance += Math.asin(Math.sin(endPointToStartPathXTrackDistance) / Math.sin(deltaOutbound))
            * (isInitialTurnTowardEndPath ? 1 : -1);
        const alongTurnOutboundPathDistance = Math.max(0, desiredAlongTurnOutboundPathDistance);
        let desiredAlongStartPathDistance = (startPath.distanceAlong(start, end, Math.PI) + Math.PI) % (2 * Math.PI) - Math.PI;
        desiredAlongStartPathDistance -= desiredAlongTurnOutboundPathDistance === 0 ? 0 : Math.atan(Math.cos(deltaOutbound) * Math.tan(desiredAlongTurnOutboundPathDistance));
        desiredAlongStartPathDistance += Math.asin(Math.sin(deltaOutbound) * Math.sin(2 * desiredTurnRadiusRad)) * (turnDirection === initialTurnDirection ? 1 : -1);
        const alongStartPathDistance = Math.max(0, desiredAlongStartPathDistance);
        const initialTurnStartPoint = alongStartPathDistance > 0
            ? startPath.offsetDistanceAlong(start, alongStartPathDistance, ProcedureTurnBuilder.geoPointCache[1])
            : startPoint;
        const initialTurnCenterPoint = initialTurnStartPoint.offset(initialCourse + (initialTurnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[2]);
        const initialTurnHalfAngularWidth = Math.acos(Math.sin(thetaOutbound) * Math.cos(desiredTurnRadiusRad)) * Avionics.Utils.RAD2DEG;
        const initialTurnStartBearing = initialTurnCenterPoint.bearingTo(initialTurnStartPoint);
        const initialTurnEndBearing = NavMath.normalizeHeading(initialTurnStartBearing + initialTurnHalfAngularWidth * 2 * (initialTurnDirection === 'left' ? -1 : 1));
        const initialTurnEndPoint = initialTurnCenterPoint.offset(initialTurnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[3]);
        const turnStartPoint = alongTurnOutboundPathDistance > 0
            ? initialTurnEndPoint.offset(outboundCourse, alongTurnOutboundPathDistance, ProcedureTurnBuilder.geoPointCache[4])
            : initialTurnEndPoint;
        const turnCenterPoint = turnStartPoint.offset(outboundCourse + (turnDirection === 'left' ? -90 : 90), desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[5]);
        const turnStartBearing = turnCenterPoint.bearingTo(turnStartPoint);
        let turnEndBearing = NavMath.normalizeHeading(turnStartBearing + 180);
        const turnEndPoint = turnCenterPoint.offset(turnEndBearing, desiredTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[6]);
        const turnEndVec = turnEndPoint.toCartesian(ProcedureTurnBuilder.vec3Cache[2]);
        let finalTurnDirection;
        let finalTurnRadius;
        let finalTurnStartPoint;
        let finalTurnCenterPoint;
        let finalTurnEndPoint;
        let endPoint;
        if (endPath.encircles(turnEndVec) === (initialTurnDirection === 'left')) {
            // the end of the turn lies beyond the path to intercept due to approximation error, so we need to end the turn early.
            const turnCircle = ProcedureTurnBuilder.geoCircleCache[0].set(turnCenterPoint, desiredTurnRadiusRad);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnCircle.intersection(endPath, intersections);
            if (numIntersections === 0) {
                // the path to intersect is completely outside of the turn, which can only happen if there is a major deviation
                // from the pseudo-Euclidean approximation. There is no easy way to recover from this state, so we just bail
                // out with a track directly to the endpoint.
                endPoint = ProcedureTurnBuilder.geoPointCache[7].setFromCartesian(end);
            }
            else {
                if (numIntersections === 2) {
                    // choose the intersection point which gives the smallest angle between the end of the turn and the path to intercept
                    const headingAdjustment = turnDirection === 'left' ? -90 : 90;
                    const angleDiff_0 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[0], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    const angleDiff_1 = Math.abs(NavMath.diffAngle(Math.acos(Vec3Math.dot(GeoCircle.getGreatCircleNormal(turnCenterPoint, intersections[1], ProcedureTurnBuilder.vec3Cache[3]), endPath.center)) * Avionics.Utils.RAD2DEG + headingAdjustment, 0));
                    turnEndPoint.setFromCartesian(intersections[angleDiff_0 < angleDiff_1 ? 0 : 1]);
                }
                else {
                    turnEndPoint.setFromCartesian(intersections[0]);
                }
                turnEndBearing = turnCenterPoint.bearingTo(turnEndPoint);
            }
        }
        else {
            const turnFinalCourse = NavMath.normalizeHeading(outboundCourse + 180);
            const turnInboundPath = ProcedureTurnBuilder.geoCircleCache[0].setAsGreatCircle(turnEndPoint, turnFinalCourse);
            const intersections = ProcedureTurnBuilder.intersectionCache;
            const numIntersections = turnInboundPath.intersection(endPath, intersections);
            // Only move forward if the end of the turn does not lie on the path to intercept.
            if (numIntersections !== 0 && !endPath.includes(turnEndVec)) {
                const intersection = intersections[(numIntersections === 1 || endPath.encircles(turnEndVec)) ? 0 : 1];
                // Only move forward if the intersection lies before the endpoint, otherwise we will just end the leg at the
                // end of the procedure turn.
                if (Vec3Math.dot(GeoCircle.getGreatCircleNormal(intersection, end, ProcedureTurnBuilder.vec3Cache[3]), endPath.center) > 0) {
                    // Because we used an approximation to place the procedure turn, the inbound segment of the turn may not
                    // allow for a turn of the desired radius to perfectly intercept the final path. Therefore, we need to
                    // explicitly calculate the maximum allowed turn radius for this final turn and adjust the turn radius as
                    // needed. Note that if the initial and final paths are antiparallel, these calculations are not strictly
                    // necessary, but we will carry them out in all cases to account for floating point errors that may have
                    // accrued during previous calculations.
                    const deltaInbound = Math.acos(Vec3Math.dot(endPath.center, turnInboundPath.center));
                    const thetaInbound = (Math.PI - deltaInbound) / 2;
                    const tanThetaInbound = Math.tan(thetaInbound);
                    const desiredFinalTurnAlongTrackDistance = Math.asin(Math.tan(desiredTurnRadiusRad) / tanThetaInbound);
                    const finalTurnAlongTrackDistance = Math.min(desiredFinalTurnAlongTrackDistance, Math.acos(Vec3Math.dot(intersection, turnEndVec)), Math.acos(Vec3Math.dot(intersection, end)));
                    const finalTurnRadiusRad = finalTurnAlongTrackDistance === desiredFinalTurnAlongTrackDistance
                        ? desiredTurnRadiusRad
                        : Math.atan(Math.sin(finalTurnAlongTrackDistance) * tanThetaInbound);
                    finalTurnDirection = NavMath.getTurnDirection(turnFinalCourse, finalCourse);
                    finalTurnRadius = UnitType.GA_RADIAN.convertTo(finalTurnRadiusRad, UnitType.METER);
                    finalTurnStartPoint = turnInboundPath.offsetDistanceAlong(intersection, -finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[7], Math.PI);
                    finalTurnCenterPoint = finalTurnStartPoint.offset(turnFinalCourse + (finalTurnDirection === 'left' ? -90 : 90), finalTurnRadiusRad, ProcedureTurnBuilder.geoPointCache[8]);
                    finalTurnEndPoint = endPath.offsetDistanceAlong(intersection, finalTurnAlongTrackDistance, ProcedureTurnBuilder.geoPointCache[9], Math.PI);
                }
            }
        }
        // Set vectors.
        const turnFlags = flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0);
        if (initialTurnStartPoint !== startPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, initialTurnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, initialTurnDirection, desiredTurnRadius, initialTurnCenterPoint, initialTurnStartPoint, initialTurnEndPoint, turnFlags);
        if (turnStartPoint !== initialTurnEndPoint) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, initialTurnEndPoint, turnStartPoint, undefined, flags);
        }
        vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, desiredTurnRadius, turnCenterPoint, turnStartPoint, turnEndPoint, turnFlags);
        if (finalTurnCenterPoint) {
            if (!finalTurnStartPoint.equals(turnEndPoint)) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, finalTurnStartPoint, undefined, flags);
            }
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, finalTurnDirection, finalTurnRadius, finalTurnCenterPoint, finalTurnStartPoint, finalTurnEndPoint, turnFlags);
        }
        else {
            if (endPoint) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndPoint, endPoint, undefined, flags);
            }
        }
        return vectorIndex - index;
    }
}
ProcedureTurnBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
ProcedureTurnBuilder.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
ProcedureTurnBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
ProcedureTurnBuilder.intersectionCache = [new Float64Array(3), new Float64Array(3)];
/**
 * Builds paths directly connecting a defined initial point and course and a defined end point.
 */
class DirectToPointBuilder {
    constructor() {
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    build(vectors, index, start, startPath, end, desiredTurnRadius, desiredTurnDirection, flags = 0, includeTurnToCourseFlag = true, includeDirectFlag = true) {
        let vectorIndex = index;
        if (typeof startPath === 'number') {
            startPath = DirectToPointBuilder.geoCircleCache[0].setAsGreatCircle(start, startPath);
        }
        const endPos = DirectToPointBuilder.geoPointCache[0];
        if (!(start instanceof Float64Array)) {
            start = GeoPoint.sphericalToCartesian(start, DirectToPointBuilder.vec3Cache[0]);
        }
        if (!(end instanceof Float64Array)) {
            endPos.set(end);
            end = GeoPoint.sphericalToCartesian(end, DirectToPointBuilder.vec3Cache[1]);
        }
        else {
            endPos.setFromCartesian(end);
        }
        const distanceToEnd = Math.acos(Utils.Clamp(Vec3Math.dot(start, end), -1, 1));
        if (distanceToEnd < GeoPoint.EQUALITY_TOLERANCE) {
            return vectorIndex - index;
        }
        else if (Math.abs(distanceToEnd - Math.PI) < GeoPoint.EQUALITY_TOLERANCE) {
            // terminator is antipodal to current position
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, start, startPath, end, flags);
            return vectorIndex - index;
        }
        const startPathEncirclesTerminator = startPath.encircles(end);
        const startPathIncludesTerminator = startPath.includes(end);
        const turnDirection = desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPathEncirclesTerminator && !startPathIncludesTerminator ? 'left' : 'right');
        const startToTurnCenterPath = DirectToPointBuilder.geoCircleCache[1].set(turnDirection === 'left'
            ? Vec3Math.cross(start, startPath.center, DirectToPointBuilder.vec3Cache[2])
            : Vec3Math.cross(startPath.center, start, DirectToPointBuilder.vec3Cache[2]), MathUtils.HALF_PI);
        let maxTurnRadiusRad;
        if (!startPathIncludesTerminator && startPathEncirclesTerminator === (turnDirection === 'left')) {
            // terminator lies on the same side as the turn, which means there is the possibility that the turn circle can
            // encircle the terminator, which would make defining a great circle intersecting the terminator fix and also
            // tangent to the turn circle impossible. Therefore, we compute the maximum allowed turn radius, defined as the
            // radius such that the terminator fix lies exactly on the turn circle.
            const startToTerminatorPathNormal = GeoCircle.getGreatCircleNormal(start, end, DirectToPointBuilder.vec3Cache[2]);
            // the angle between the great-circle path from the start point to the turn center and the path from the start
            // point to the terminator fix
            const theta = Math.acos(Vec3Math.dot(startToTurnCenterPath.center, startToTerminatorPathNormal));
            maxTurnRadiusRad = Math.atan(Math.sin(distanceToEnd) / (Math.cos(theta) * (1 + Math.cos(distanceToEnd))));
        }
        else {
            // terminator lies on the starting path or on the opposite side as the turn. Either way, no turn can encircle the
            // terminator, and so there is no maximum turn radius.
            maxTurnRadiusRad = Math.PI / 2;
        }
        const turnRadiusRad = Math.min(maxTurnRadiusRad, UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN));
        const turnCenterVec = startToTurnCenterPath.offsetDistanceAlong(start, turnRadiusRad, DirectToPointBuilder.vec3Cache[2]);
        const turnCenterPoint = DirectToPointBuilder.geoPointCache[1].setFromCartesian(turnCenterVec);
        // Find the great-circle path from the terminator fix that is tangent to the turn circle. There are guaranteed to
        // be two such paths. We choose between the two based on the initial turn direction.
        const turnCenterToTerminatorDistance = Math.acos(Utils.Clamp(Vec3Math.dot(turnCenterVec, end), -1, 1));
        // The angle between the great-circle path from the terminator fix to the turn center and the two
        // great-circle paths from the terminator fix that are tangent to the turn circle.
        const alpha = Math.asin(Math.min(1, Math.sin(turnRadiusRad) / Math.sin(turnCenterToTerminatorDistance)));
        const terminatorFixBearingToTurnCenter = endPos.bearingTo(turnCenterPoint);
        const finalPathCourse = NavMath.normalizeHeading(terminatorFixBearingToTurnCenter + alpha * Avionics.Utils.RAD2DEG * (turnDirection === 'left' ? -1 : 1) + 180);
        const finalPath = DirectToPointBuilder.geoCircleCache[1].setAsGreatCircle(end, finalPathCourse);
        const turnEndVec = finalPath.closest(turnCenterPoint, DirectToPointBuilder.vec3Cache[3]);
        flags |= includeDirectFlag ? FlightPathVectorFlags.Direct : 0;
        if (!GeoPoint.equals(turnEndVec, start)) {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenterPoint, start, turnEndVec, flags | (includeTurnToCourseFlag ? FlightPathVectorFlags.TurnToCourse : 0));
        }
        if (!GeoPoint.equals(turnEndVec, end)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, turnEndVec, end, undefined, flags);
        }
        return vectorIndex - index;
    }
}
DirectToPointBuilder.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
DirectToPointBuilder.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
DirectToPointBuilder.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];

/**
 * Abstract implementation of FlightPathLegCalculator.
 */
class AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param skipWhenActive Whether this calculator will skip calculations for active legs when the leg has already
     * been calculated. False by default.
     */
    constructor(facilityCache, skipWhenActive = false) {
        this.facilityCache = facilityCache;
        this.skipWhenActive = skipWhenActive;
    }
    /**
     * Gets a geographical position from an ICAO string.
     * @param icao An ICAO string.
     * @param out A GeoPoint object to which to write the result.
     * @returns The geographical position corresponding to the ICAO string, or undefined if one could not be obtained.
     */
    getPositionFromIcao(icao, out) {
        const facility = this.facilityCache.get(icao);
        return facility ? out.set(facility) : undefined;
    }
    /**
     * Gets the geographic position for a flight plan leg terminator.
     * @param leg A flight plan leg.
     * @param icao The ICAO string of the leg's terminator fix.
     * @param out A GeoPoint object to which to write the result.
     * @returns The position of the leg terminator, or undefined if it could not be determined.
     */
    getTerminatorPosition(leg, icao, out) {
        if (leg.lat !== undefined && leg.lon !== undefined) {
            return out.set(leg.lat, leg.lon);
        }
        else {
            const facility = this.facilityCache.get(icao);
            return facility ? out.set(facility.lat, facility.lon) : undefined;
        }
    }
    /**
     * Gets the magnetic variation, in degrees, to use when calculating a flight plan leg's course. If the leg defines
     * an origin or fix VOR facility, then the magnetic variation defined at the VOR is used. Otherwise the computed
     * magnetic variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The magnetic variation, in degrees, to use when calculating the specified flight plan leg's course.
     */
    getLegMagVar(leg, point) {
        const facIcao = (leg.originIcao && ICAO.isFacility(leg.originIcao, FacilityType.VOR)) ? leg.originIcao
            : (leg.fixIcao && ICAO.isFacility(leg.fixIcao, FacilityType.VOR)) ? leg.fixIcao
                : undefined;
        const facility = facIcao !== undefined ? this.facilityCache.get(facIcao) : undefined;
        // The sign of magnetic variation on VOR facilities is the opposite of the standard east = positive convention.
        return facility === undefined ? MagVar.get(point) : -facility.magneticVariation;
    }
    /**
     * Gets the true course, in degrees, for a flight plan leg. If the leg defines an origin or fix VOR facility, then
     * the magnetic variation defined at the VOR is used to adjust magnetic course. Otherwise the computed magnetic
     * variation for the specified point is used.
     * @param leg A flight plan leg.
     * @param point The location from which to get magnetic variation, if an origin VOR is not found.
     * @returns The true course, in degrees, for the flight plan leg.
     */
    getLegTrueCourse(leg, point) {
        if (leg.trueDegrees) {
            return leg.course;
        }
        return MagVar.magneticToTrue(leg.course, this.getLegMagVar(leg, point));
    }
    /** @inheritdoc */
    calculate(legs, calculateIndex, activeLegIndex, state, resolveIngressToEgress = true) {
        var _a, _b, _c;
        var _d;
        const calcs = (_a = (_d = legs[calculateIndex]).calculated) !== null && _a !== void 0 ? _a : (_d.calculated = {
            courseMagVar: 0,
            startLat: undefined,
            startLon: undefined,
            endLat: undefined,
            endLon: undefined,
            distance: 0,
            distanceWithTransitions: 0,
            initialDtk: undefined,
            cumulativeDistance: 0,
            cumulativeDistanceWithTransitions: 0,
            flightPath: [],
            ingress: [],
            ingressJoinIndex: -1,
            ingressToEgress: [],
            egressJoinIndex: -1,
            egress: [],
            endsInFallback: false
        });
        const vectors = calcs.flightPath;
        if (this.skipWhenActive && activeLegIndex === calculateIndex && this.shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state)) {
            state.currentPosition = FlightPathUtils.getLegFinalPosition(calcs, (_b = state.currentPosition) !== null && _b !== void 0 ? _b : new GeoPoint(0, 0));
            state.currentCourse = (_c = FlightPathUtils.getLegFinalCourse(calcs)) !== null && _c !== void 0 ? _c : state.currentCourse;
            state.isFallback = calcs.endsInFallback;
            return calcs;
        }
        try {
            this.calculateMagVar(legs, calculateIndex, activeLegIndex, state);
            this.calculateVectors(legs, calculateIndex, activeLegIndex, state);
            resolveIngressToEgress && this.resolveIngressToEgress(calcs);
            calcs.endsInFallback = state.isFallback;
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
            vectors.length = 0;
            calcs.ingress.length = 0;
            calcs.ingressJoinIndex = 0;
            calcs.egress.length = 0;
            calcs.egressJoinIndex = -1;
            calcs.ingressToEgress.length = 0;
            calcs.endsInFallback = false;
            state.isFallback = false;
        }
        return calcs;
    }
    /**
     * Checks whether vector calculations should be skipped when the leg to calculate is the active leg.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param state The current flight path state.
     * @returns Whether to skip vector calculations.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    shouldSkipWhenActive(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return legs[calculateIndex].calculated.flightPath.length > 0;
    }
    /**
     * Calculates the ingress to egress vectors for a flight plan leg and adds them to a leg calculation.
     * @param legCalc The calculations for a flight plan leg.
     */
    resolveIngressToEgress(legCalc) {
        FlightPathUtils.resolveIngressToEgress(legCalc);
    }
}
/**
 * Calculates flight path vectors for legs with no path.
 */
class NoPathLegCalculator extends AbstractFlightPathLegCalculator {
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.courseMagVar = 0;
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        legs[calculateIndex].calculated.flightPath.length = 0;
        state.currentCourse = undefined;
        state.currentPosition = undefined;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track to fix legs.
 */
class TrackToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        const prevLeg = (_a = legs[calculateIndex - 1]) === null || _a === void 0 ? void 0 : _a.leg;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!terminatorPos) {
            vectors.length = 0;
            state.isFallback = false;
            return;
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        const distance = state.currentPosition.distance(terminatorPos);
        if ((!prevLeg || (prevLeg.type !== LegType.FM && prevLeg.type !== LegType.VM)) && distance > GeoPoint.EQUALITY_TOLERANCE) {
            if (state.isFallback && state.currentCourse !== undefined) {
                vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
            }
            else {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, terminatorPos, state.currentCourse);
            }
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        state.currentPosition.set(terminatorPos);
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for direct to fix legs.
 */
class DirectToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!terminatorPos) {
            vectors.length = 0;
            return;
        }
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = terminatorPos.copy());
        const startPoint = this.geoPointCache[0].set(state.currentPosition);
        let initialCourse;
        if (leg.course !== 0) {
            // If a course is defined on the leg, then honor it.
            initialCourse = leg.trueDegrees ? leg.course % 360 : MagVar.magneticToTrue(leg.course, startPoint);
        }
        else {
            if (state.currentCourse === undefined) {
                // If the current course from the previous leg is undefined, then attempt to select an initial course from
                // the definition of the previous leg, if one exists.
                const prevLeg = legs[calculateIndex - 1];
                switch (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) {
                    case LegType.CA:
                    case LegType.CF:
                    case LegType.CR:
                    case LegType.FA:
                    case LegType.FC:
                    case LegType.FD:
                    case LegType.FM:
                    case LegType.VA:
                    case LegType.VD:
                    case LegType.VM:
                    case LegType.VR:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.HA:
                        // If the previous leg defines a course, then use that course.
                        initialCourse = this.getLegTrueCourse(prevLeg.leg, startPoint);
                        break;
                    case LegType.IF:
                        // If the previous leg is an IF for a runway fix, then use runway heading as the initial course.
                        if (ICAO.isFacility(prevLeg.leg.fixIcao, FacilityType.RWY)) {
                            const runwayFix = this.facilityCache.get(prevLeg.leg.fixIcao);
                            if (runwayFix) {
                                initialCourse = runwayFix.runway.course;
                                break;
                            }
                        }
                    // eslint-disable-next-line no-fallthrough
                    default:
                        // If we can't select an initial course from the previous leg, then default to the course that puts us on a
                        // great-circle path from the start point to the terminator fix.
                        initialCourse = startPoint.bearingTo(terminatorPos);
                        // If the calculated course is NaN (only happens when the start and end points are coincident or antipodal),
                        // then just arbitrarily use true north.
                        if (isNaN(initialCourse)) {
                            initialCourse = 0;
                        }
                }
            }
            else {
                // If the current course from the previous leg is defined, use it.
                initialCourse = state.currentCourse;
            }
        }
        const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, initialCourse);
        vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, startPoint, startPath, terminatorPos, state.desiredTurnRadius.asUnit(UnitType.METER), leg.turnDirection === LegTurnDirection.Left ? 'left' : leg.turnDirection === LegTurnDirection.Right ? 'right' : undefined);
        state.currentPosition.set(terminatorPos);
        if (vectorIndex > 0) {
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for legs which define a turn ending at a defined terminator fix.
 */
class TurnToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.circleVectorBuilder = new CircleVectorBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : MagVar.get(terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const terminatorPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        const turnCenter = this.getTurnCenter(leg);
        if (!terminatorPos || !turnCenter) {
            vectors.length = vectorIndex;
            return;
        }
        if (state.currentPosition && !state.currentPosition.equals(terminatorPos)) {
            const direction = leg.turnDirection === LegTurnDirection.Left ? 'left' : 'right';
            const radius = this.getTurnRadius(leg, turnCenter);
            if (radius) {
                const circle = FlightPathUtils.getTurnCircle(turnCenter, radius, direction, this.geoCircleCache[0]);
                const currentVec = circle.closest(state.currentPosition, this.vec3Cache[0]);
                const terminatorVec = circle.closest(terminatorPos, this.vec3Cache[1]);
                vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, circle, currentVec, terminatorVec, FlightPathVectorFlags.Arc);
                state.currentCourse = circle.bearingAt(terminatorVec);
                const turnVector = vectors[vectorIndex - 1];
                ((_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = new GeoPoint(0, 0))).set(turnVector.endLat, turnVector.endLon);
            }
        }
        (_b = state.currentPosition) !== null && _b !== void 0 ? _b : (state.currentPosition = terminatorPos.copy());
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for radius to fix legs.
 */
class RadiusToFixLegCalculator extends TurnToFixLegCalculator {
    constructor() {
        super(...arguments);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
    }
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.arcCenterFixIcao);
    }
    /** @inheritdoc */
    getTurnRadius(leg, center) {
        var _a;
        return (_a = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[2])) === null || _a === void 0 ? void 0 : _a.distance(center);
    }
}
/**
 * Calculates flight path vectors for arc to fix legs.
 */
class ArcToFixLegCalculator extends TurnToFixLegCalculator {
    /** @inheritdoc */
    getTurnCenter(leg) {
        return this.facilityCache.get(leg.originIcao);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTurnRadius(leg, center) {
        return UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN);
    }
}
/**
 * Calculates flight path vectors for legs which define a great-circle path terminating at an intercept with another
 * geo circle.
 */
class CircleInterceptLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     * @param includeInitialTurn Whether this calculator should calculate an initial turn toward the intercept course.
     */
    constructor(facilityCache, includeInitialTurn) {
        super(facilityCache, true);
        this.includeInitialTurn = includeInitialTurn;
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.turnBuilder = new TurnToCourseBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
        this.interceptBuilder = new CircleInterceptBuilder();
        this.interceptInfo = {
            circle: undefined,
            start: undefined,
            end: undefined
        };
        this.handleInvalidInterceptCache = {
            vec3: [new Float64Array(3), new Float64Array(3), new Float64Array(3)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)],
            intersection: [new Float64Array(3), new Float64Array(3)]
        };
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const course = this.getInterceptCourse(legs, calculateIndex, state);
        const interceptInfo = this.getInterceptPathInfo(legs, calculateIndex, state, this.interceptInfo);
        if (course === undefined || !interceptInfo.circle || !state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const startCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : course;
        const effectiveInterceptPathStartVec = interceptInfo.start
            ? GeoPoint.sphericalToCartesian(interceptInfo.start, this.vec3Cache[0])
            : interceptInfo.end
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.end, -Math.PI, this.vec3Cache[0], Math.PI)
                : undefined;
        const effectiveInterceptPathEndVec = interceptInfo.end
            ? GeoPoint.sphericalToCartesian(interceptInfo.end, this.vec3Cache[1])
            : interceptInfo.start
                ? interceptInfo.circle.offsetAngleAlong(interceptInfo.start, Math.PI, this.vec3Cache[1], Math.PI)
                : undefined;
        const effectiveInterceptPathAngularWidth = interceptInfo.start && interceptInfo.end
            ? interceptInfo.circle.angleAlong(interceptInfo.start, interceptInfo.end, Math.PI)
            : effectiveInterceptPathStartVec
                ? Math.PI
                : MathUtils.TWO_PI;
        const initialVec = state.currentPosition.toCartesian(this.vec3Cache[2]);
        const includeInitialTurn = this.includeInitialTurn && Math.abs(NavMath.diffAngle(course, startCourse)) >= 1;
        const interceptPathStartVec = Vec3Math.copy(initialVec, this.vec3Cache[3]);
        let initialTurnVector = undefined;
        if (includeInitialTurn) {
            const turnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                : leg.turnDirection === LegTurnDirection.Right ? 'right'
                    : NavMath.getTurnDirection(startCourse, course);
            vectorIndex += this.turnBuilder.build(vectors, vectorIndex, state.currentPosition, state.desiredTurnRadius.asUnit(UnitType.METER), turnDirection, startCourse, course);
            initialTurnVector = vectors[vectorIndex - 1];
            GeoPoint.sphericalToCartesian(initialTurnVector.endLat, initialTurnVector.endLon, interceptPathStartVec);
        }
        const interceptPath = this.geoCircleCache[0].setAsGreatCircle(interceptPathStartVec, course);
        const startPath = this.geoCircleCache[1].set(interceptPath.center, interceptPath.radius);
        // If an initial turn exists, check if a fallback intercept is required because the end of the initial turn lies
        // past the path to intercept. If an initial turn does not exist, check if any fallback intercept is required.
        let fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, initialTurnVector !== undefined, false, this.vec3Cache[4]);
        if (initialTurnVector !== undefined) {
            if (fallbackInterceptVec === undefined) {
                // An initial turn exists and does not end past the path to intercept. Check if a fallback intercept is required
                // for another reason.
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, false, this.vec3Cache[4]);
            }
            else {
                // An initial turn exists and ends past the path to intercept. First check if the initial turn intersects the
                // path to intercept
                const turnCircle = FlightPathUtils.setGeoCircleFromVector(initialTurnVector, this.geoCircleCache[2]);
                const intersections = this.intersectionCache;
                const numIntersections = turnCircle.intersection(interceptInfo.circle, intersections);
                if (numIntersections > 1) {
                    // Order intersections such that the one closer to the turn end is at index 0.
                    if (interceptInfo.circle.radius > MathUtils.HALF_PI !== interceptInfo.circle.encircles(initialVec)) {
                        const temp = intersections[0];
                        intersections[0] = intersections[1];
                        intersections[1] = temp;
                    }
                }
                for (let i = 0; i < numIntersections; i++) {
                    const intersection = intersections[i];
                    if (FlightPathUtils.isPointAlongArc(turnCircle, initialVec, interceptPathStartVec, intersection)
                        && (!effectiveInterceptPathStartVec
                            || FlightPathUtils.isPointAlongArc(interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathAngularWidth, intersection))) {
                        // End the turn early at the intercept point
                        const distance = turnCircle.distanceAlong(initialVec, intersection, Math.PI);
                        if (distance > GeoCircle.ANGULAR_TOLERANCE) {
                            const intersectionPoint = this.geoPointCache[0].setFromCartesian(intersection);
                            initialTurnVector.distance = UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                            initialTurnVector.endLat = intersectionPoint.lat;
                            initialTurnVector.endLon = intersectionPoint.lon;
                            state.currentPosition.set(initialTurnVector.endLat, initialTurnVector.endLon);
                            state.currentCourse = FlightPathUtils.getVectorFinalCourse(initialTurnVector);
                        }
                        else {
                            vectorIndex--;
                        }
                        vectors.length = vectorIndex;
                        return;
                    }
                }
                // The initial turn does not intersect the path to intercept -> calculate a fallback intercept
                // without an initial turn (i.e. change the intercept path to start at the start of the leg).
                vectorIndex = 0;
                Vec3Math.copy(initialVec, interceptPathStartVec);
                interceptPath.setAsGreatCircle(interceptPathStartVec, course);
                startPath.setAsGreatCircle(interceptPathStartVec, startCourse);
                fallbackInterceptVec = this.calculateFallbackIntercept(interceptPathStartVec, interceptPath, interceptInfo.circle, effectiveInterceptPathStartVec, effectiveInterceptPathEndVec, effectiveInterceptPathAngularWidth, false, true, this.vec3Cache[4]);
            }
        }
        if (fallbackInterceptVec === undefined) {
            vectorIndex += this.interceptBuilder.build(vectors, vectorIndex, interceptPathStartVec, course, interceptInfo.circle);
        }
        else {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, interceptPathStartVec, startPath, fallbackInterceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
    }
    /**
     * Checks if a path to intercept cannot be intercepted from a defined starting point and intercept course, and
     * calculates a fallback intercept point if so.
     * @param start The start point.
     * @param interceptPath The great-circle path defining the intercept course.
     * @param pathToInterceptCircle The geo circle defining the path to intercept.
     * @param pathToInterceptStart The start of the path to intercept.
     * @param pathToInterceptEnd The end of the path to intercept.
     * @param pathToInterceptAngularWidth The angular width of the path to intercept, in radians.
     * @param onlyHandleInitialPointPastIntercept Whether to only handle cases where the start point is located beyond
     * the path to intercept as measured along the intercept course.
     * @param forceFallback Whether to treat the case where the path to intercept can be intercepted from the starting
     * point and intercept course as a fallback case. If `true`, the natural intercept point will be returned as the
     * fallback intercept point.
     * @param out The vector to which to write the result.
     * @returns The fallback intercept point, or `undefined` if a fallback is not necessary.
     */
    calculateFallbackIntercept(start, interceptPath, pathToInterceptCircle, pathToInterceptStart, pathToInterceptEnd, pathToInterceptAngularWidth, onlyHandleInitialPointPastIntercept, forceFallback, out) {
        if (pathToInterceptCircle.includes(start)) {
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, start)) {
                // Initial point already lies on the path to intercept.
                return forceFallback ? Vec3Math.copy(start, out) : undefined;
            }
        }
        // Determine if the starting position is "past" the path to intercept.
        let isInitialPosPastPath = false;
        const intersections = this.handleInvalidInterceptCache.intersection;
        const numIntersections = interceptPath.intersection(pathToInterceptCircle, intersections);
        let desiredIntersection;
        if (numIntersections === 2) {
            const nextIntersectionIndex = pathToInterceptCircle.encircles(start) ? 0 : 1;
            const prevIntersectionIndex = 1 - nextIntersectionIndex;
            const nextIntersection = intersections[nextIntersectionIndex];
            const prevIntersection = intersections[prevIntersectionIndex];
            // Define the desired intercept point as the one that requires the shortest distance traveled along the initial
            // path and path to intercept circle from the initial position to some point along the path to intercept. Then,
            // determine if the initial position lies before or after the desired intercept point, relative to the direction
            // of the initial path.
            if (pathToInterceptAngularWidth === MathUtils.TWO_PI && pathToInterceptCircle.isGreatCircle()) {
                isInitialPosPastPath = interceptPath.angleAlong(start, nextIntersection, Math.PI) > MathUtils.HALF_PI + GeoCircle.ANGULAR_TOLERANCE;
            }
            else {
                const prevIntersectionInitialPathOffset = interceptPath.angleAlong(prevIntersection, start, Math.PI);
                const nextIntersectionInitialPathOffset = interceptPath.angleAlong(start, nextIntersection, Math.PI);
                const prevIntersectionInitialPathDistance = Math.min(prevIntersectionInitialPathOffset, MathUtils.TWO_PI - prevIntersectionInitialPathOffset);
                const nextIntersectionInitialPathDistance = Math.min(nextIntersectionInitialPathOffset, MathUtils.TWO_PI - nextIntersectionInitialPathOffset);
                let prevIntersectionInterceptPathDistance = 0;
                let nextIntersectionInterceptPathDistance = 0;
                if (pathToInterceptStart && pathToInterceptEnd) {
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, prevIntersection)) {
                        const prevIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptStart, Math.PI);
                        const prevIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(prevIntersection, pathToInterceptEnd, Math.PI);
                        prevIntersectionInterceptPathDistance = Math.min(prevIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathStartOffset, prevIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - prevIntersectionInterceptPathEndOffset);
                    }
                    if (!FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, nextIntersection)) {
                        const nextIntersectionInterceptPathStartOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptStart, Math.PI);
                        const nextIntersectionInterceptPathEndOffset = pathToInterceptCircle.angleAlong(nextIntersection, pathToInterceptEnd, Math.PI);
                        nextIntersectionInterceptPathDistance = Math.min(nextIntersectionInterceptPathStartOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathStartOffset, nextIntersectionInterceptPathEndOffset, MathUtils.TWO_PI - nextIntersectionInterceptPathEndOffset);
                    }
                }
                const prevIntersectionTotalDistance = prevIntersectionInitialPathDistance + prevIntersectionInterceptPathDistance;
                const nextIntersectionTotalDistance = nextIntersectionInitialPathDistance + nextIntersectionInterceptPathDistance;
                // Only consider the starting position past the path to intercept if the path to intercept has a defined start
                // and end (i.e. is not a DME circle) OR the distance to one of the two intercept points is greater than pi/2
                // great-arc radians.
                if ((pathToInterceptStart !== undefined && pathToInterceptEnd !== undefined)
                    || (prevIntersectionTotalDistance >= MathUtils.HALF_PI || nextIntersectionTotalDistance >= MathUtils.HALF_PI)) {
                    isInitialPosPastPath = prevIntersectionTotalDistance < nextIntersectionTotalDistance - GeoCircle.ANGULAR_TOLERANCE;
                }
            }
            desiredIntersection = isInitialPosPastPath ? prevIntersection : nextIntersection;
        }
        else if (numIntersections === 1) {
            const distanceToIntersection = interceptPath.angleAlong(start, intersections[0], Math.PI);
            isInitialPosPastPath = distanceToIntersection < MathUtils.TWO_PI - GeoCircle.ANGULAR_TOLERANCE && distanceToIntersection > Math.PI + GeoCircle.ANGULAR_TOLERANCE;
            desiredIntersection = intersections[0];
        }
        if ((onlyHandleInitialPointPastIntercept && !isInitialPosPastPath)) {
            return undefined;
        }
        let needHandleFallback = isInitialPosPastPath;
        if (!desiredIntersection) {
            // The intercept course does not intersect with the path to intercept circle at all -> define the desired
            // intercept point as the point on the path to intercept circle closest to the start point.
            desiredIntersection = pathToInterceptCircle.closest(start, this.handleInvalidInterceptCache.vec3[0]);
            needHandleFallback = true;
        }
        let fallbackIntercept;
        if ((!pathToInterceptStart || !pathToInterceptEnd)
            || FlightPathUtils.isPointAlongArc(pathToInterceptCircle, pathToInterceptStart, pathToInterceptAngularWidth, desiredIntersection)) {
            // The desired intercept point is within the bounds of the path to intercept -> only handle the fallback if we
            // need to (i.e. if the starting point is past the path to intercept, if the starting path does not intersect
            // the path to intercept, or fallback is forced)
            if (needHandleFallback || forceFallback) {
                fallbackIntercept = desiredIntersection;
            }
        }
        else {
            // The desired intercept point is not within the bounds of the path to intercept -> set the fallback intercept
            // point to the start or end of the path to intercept, whichever is closer to the desired intercept point.
            const angularOffset = pathToInterceptCircle.angleAlong(pathToInterceptStart, desiredIntersection, Math.PI);
            const distanceFromStart = Math.min(angularOffset, MathUtils.TWO_PI - angularOffset);
            const distanceFromEnd = Math.abs(angularOffset - pathToInterceptAngularWidth);
            fallbackIntercept = distanceFromStart <= distanceFromEnd ? pathToInterceptStart : pathToInterceptEnd;
        }
        return fallbackIntercept === undefined ? undefined : Vec3Math.copy(fallbackIntercept, out);
    }
}
/**
 * Calculates flight path vectors for course to DME legs.
 */
class CourseToDmeLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.dmeCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const dmeFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = dmeFacility === undefined ? 0 : this.getLegMagVar(leg.leg, dmeFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        return dmeFacility ? this.getLegTrueCourse(leg, dmeFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (dmeFacility) {
            this.dmeCircle.set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
            out.circle = this.dmeCircle;
            out.start = undefined;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to radial intercept legs.
 */
class CourseToRadialLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.radialCircle = new GeoCircle(new Float64Array(3), 0);
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const radialFacility = this.facilityCache.get(leg.leg.originIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = radialFacility === undefined ? 0 : this.getLegMagVar(leg.leg, radialFacility);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        return radialFacility ? this.getLegTrueCourse(leg, radialFacility) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        const leg = legs[index].leg;
        const radialFacility = this.facilityCache.get(leg.originIcao);
        if (radialFacility) {
            const magVar = (ICAO.getFacilityType(radialFacility.icao) === FacilityType.VOR)
                ? -radialFacility.magneticVariation
                : MagVar.get(radialFacility);
            this.radialCircle.setAsGreatCircle(radialFacility, leg.theta + magVar);
            out.circle = this.radialCircle;
            out.start = radialFacility;
            out.end = undefined;
        }
        else {
            out.circle = undefined;
            out.start = undefined;
            out.end = undefined;
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for course to intercept legs.
 */
class CourseToInterceptLegCalculator extends CircleInterceptLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.predictLegPathCache = {
            geoPoint: [new GeoPoint(0, 0)],
            geoCircle: [new GeoCircle(new Float64Array(3), 0)]
        };
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        const leg = legs[calculateIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = state.currentPosition === undefined ? 0 : this.getLegMagVar(leg.leg, state.currentPosition);
    }
    /** @inheritdoc */
    getInterceptCourse(legs, index, state) {
        const leg = legs[index].leg;
        return state.currentPosition ? this.getLegTrueCourse(leg, state.currentPosition) : undefined;
    }
    /** @inheritdoc */
    getInterceptPathInfo(legs, index, state, out) {
        return this.predictLegPath(legs, index + 1, out);
    }
    /**
     * Predicts the path of a leg. If a prediction cannot be made, NaN will be written to all fields of the result.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param out A GeoCircle to which to write the result.
     * @returns the predicted path of the leg.
     */
    predictLegPath(legs, index, out) {
        var _a;
        out.circle = undefined;
        out.start = undefined;
        out.end = undefined;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return out;
        }
        switch (leg.type) {
            case LegType.CF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[0]);
                    if (terminator) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(terminator, this.getLegTrueCourse(leg, terminator));
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.AF:
                {
                    const facility = this.facilityCache.get(leg.originIcao);
                    if (facility) {
                        out.circle = FlightPathUtils.getTurnCircle(facility, UnitType.METER.convertTo(leg.rho, UnitType.GA_RADIAN), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = this.facilityCache.get(leg.fixIcao);
                    }
                    break;
                }
            case LegType.RF:
                {
                    const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.predictLegPathCache.geoPoint[2]);
                    const centerFacility = this.facilityCache.get(leg.arcCenterFixIcao);
                    if (terminator && centerFacility) {
                        out.circle = FlightPathUtils.getTurnCircle(centerFacility, terminator.distance(centerFacility), leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left', this.predictLegPathCache.geoCircle[0]);
                        out.end = terminator;
                    }
                    break;
                }
            case LegType.FM:
            case LegType.VM:
                {
                    const origin = this.facilityCache.get(leg.originIcao);
                    if (origin) {
                        out.circle = this.predictLegPathCache.geoCircle[0].setAsGreatCircle(origin, this.getLegTrueCourse(leg, origin));
                        out.start = origin;
                    }
                    break;
                }
        }
        return out;
    }
}
/**
 * Calculates flight path vectors for fix to DME legs.
 */
class FixToDmeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0), new GeoCircle(Vec3Math.create(), 0)];
        this.intersectionCache = [Vec3Math.create(), Vec3Math.create()];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        const dmeFacility = this.facilityCache.get(leg.originIcao);
        if (!pathStartPoint || !dmeFacility) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const dmeCircle = this.geoCircleCache[1].set(dmeFacility, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN));
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const interceptVec = this.vec3Cache[1];
        const intersections = this.intersectionCache;
        const numIntersections = path.intersection(dmeCircle, intersections);
        if (numIntersections === 0) {
            // The path along the leg's defined course does not intercept the DME circle -> define the intercept to be the
            // closest point on the DME circle to the initial fix.
            dmeCircle.closest(pathStartVec, interceptVec);
        }
        else {
            // The path along the leg's defined course intercepts the DME circle -> choose the first intercept when
            // proceeding along the path from the initial fix.
            const intersectionIndex = (numIntersections === 1 || dmeCircle.encircles(pathStartVec)) ? 0 : 1;
            Vec3Math.copy(intersections[intersectionIndex], interceptVec);
        }
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, interceptVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, interceptVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, interceptVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for track from fix legs.
 */
class TrackFromFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const startFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = startFacility === undefined ? 0 : this.getLegMagVar(leg.leg, startFacility);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const pathStartPoint = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!pathStartPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const course = this.getLegTrueCourse(leg, pathStartPoint);
        const path = this.geoCircleCache[0].setAsGreatCircle(pathStartPoint, course);
        const pathStartVec = pathStartPoint.toCartesian(this.vec3Cache[0]);
        const endVec = path.offsetDistanceAlong(pathStartVec, UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN), this.vec3Cache[1], Math.PI);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endVec, state.desiredTurnRadius.asUnit(UnitType.METER), undefined, FlightPathVectorFlags.Fallback);
        }
        else {
            const startVec = (_b = (_a = state.currentPosition) === null || _a === void 0 ? void 0 : _a.toCartesian(this.vec3Cache[0])) !== null && _b !== void 0 ? _b : pathStartVec;
            if (GeoPoint.distance(startVec, endVec) > GeoCircle.ANGULAR_TOLERANCE) {
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, pathStartVec, endVec, course);
            }
        }
        if (vectorIndex > 0) {
            const lastVector = vectors[vectorIndex - 1];
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
            ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
        }
        vectors.length = vectorIndex;
        state.isFallback = false;
    }
}
/**
 * Calculates flight path vectors for course to fix legs.
 */
class CourseToFixLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0),
            new GeoCircle(new Float64Array(3), 0)
        ];
        this.intersectionCache = [new Float64Array(3), new Float64Array(3)];
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
        this.directToPointBuilder = new DirectToPointBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const terminatorPos = this.getTerminatorPosition(leg.leg, leg.leg.fixIcao, this.geoPointCache[0]);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = terminatorPos === undefined ? 0 : this.getLegMagVar(leg.leg, terminatorPos);
    }
    /** @inheritdoc */
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const leg = legs[calculateIndex].leg;
        const prevLeg = legs[calculateIndex - 1];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = state.currentPosition ? this.geoPointCache[0].set(state.currentPosition) : undefined;
        const endPoint = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[1]);
        if (!endPoint) {
            vectors.length = vectorIndex;
            state.isFallback = false;
            return;
        }
        const minTurnRadius = state.desiredTurnRadius.asUnit(UnitType.METER);
        if (state.isFallback && state.currentPosition !== undefined && state.currentCourse !== undefined) {
            // We are in a fallback state -> plot a direct course to the terminator fix
            vectorIndex += this.directToPointBuilder.build(vectors, vectorIndex, state.currentPosition, state.currentCourse, endPoint, minTurnRadius, undefined, FlightPathVectorFlags.Fallback);
            state.isFallback = false;
        }
        else {
            state.isFallback = false;
            const endCourse = this.getLegTrueCourse(leg, endPoint);
            const endVec = endPoint.toCartesian(this.vec3Cache[1]);
            const endPath = this.geoCircleCache[1].setAsGreatCircle(endPoint, endCourse);
            if (!startPoint || (prevLeg && (prevLeg.leg.type === LegType.FM || prevLeg.leg.type === LegType.VM))) {
                // ---- CASE A ----
                // The leg begins at a discontinuity OR the previous leg is a manual termination leg.
                // Create a great-circle vector with a start point arbitrarily placed 5 NM from the terminator fix.
                const midPoint = endPath.offsetDistanceAlong(endVec, UnitType.NMILE.convertTo(-5, UnitType.GA_RADIAN), this.geoPointCache[2]);
                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, midPoint, endPoint);
            }
            else {
                const startVec = startPoint.toCartesian(this.vec3Cache[0]);
                const currentCourse = (_a = state.currentCourse) !== null && _a !== void 0 ? _a : startPoint.bearingTo(endPoint);
                const startPath = this.geoCircleCache[0].setAsGreatCircle(startPoint, currentCourse);
                const startToEndPath = this.geoCircleCache[3].setAsGreatCircle(startVec, endVec);
                const isStartEqualToEnd = startPoint.equals(endPoint);
                const pathAngleDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(startPath.center, endPath.center), -1, 1));
                // A great circle defining the threshold of the terminator fix - everything to the LEFT of (i.e. encircled by)
                // this great circle is past the terminator fix as projected along the end path.
                const threshold = this.geoCircleCache[2].setAsGreatCircle(endPath.center, endVec);
                const isStartPastThreshold = threshold.encircles(startVec, false);
                // 175 degrees
                const areStartEndPathsAntiParallel = pathAngleDiff >= 3.05432619 - GeoCircle.ANGULAR_TOLERANCE;
                let isDone = false;
                if (!areStartEndPathsAntiParallel && isStartPastThreshold) {
                    // ---- CASE B ----
                    // The start and end paths are not antiparallel and the start point is past the terminator threshold.
                    let shouldTryFallback = true;
                    const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                        : leg.turnDirection === LegTurnDirection.Right ? 'right'
                            : undefined;
                    if (pathAngleDiff >= MathUtils.HALF_PI
                        && (desiredTurnDirection === undefined || (desiredTurnDirection === 'left') === startPath.encircles(endVec))) {
                        // The start path is either heading toward the terminator threshold or is parallel to it and the desired
                        // turn direction is not away from the end point. We now need to find the intersections between the start
                        // and end paths. There should be two intersections since both paths are great circles and they are not
                        // parallel or antiparallel.
                        const intersections = this.intersectionCache;
                        const solutionCount = startPath.intersection(endPath, intersections);
                        if (solutionCount === 2) {
                            // There are two general cases:
                            //
                            // 1. The end point lies past the intersection as measured along the end path.
                            // 2. The end point lies before the intersection as measured along the end path.
                            //
                            // In case 1, we can use the default algorithm for joining the start and end paths. Therefore there is
                            // nothing to do here; we just need to make sure the code falls through to Case E below.
                            //
                            // In case 2, we will try to join the start and end paths with a single constant radius turn. This will
                            // generate a "loop" where the path follows the start path initially away from the end point and then
                            // turns back onto the end path to head back to the end point. If that is not possible or the generated
                            // path is too long, we will fall through to Case E.
                            shouldTryFallback = false;
                            // Choose the intersection closest to the start point.
                            const intersection = Vec3Math.dot(intersections[0], startVec) > 0
                                ? intersections[0]
                                : intersections[1];
                            const intersectionToEndDot = Vec3Math.dot(Vec3Math.cross(endPath.center, intersection, this.vec3Cache[2]), endVec);
                            const isEndPastIntersection = intersectionToEndDot > GeoCircle.ANGULAR_TOLERANCE;
                            if (!isEndPastIntersection) {
                                vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius, true, false, intersection);
                                if (vectorIndex !== 0) {
                                    // Find all the great-circle vectors in the path. These are all guaranteed to be parallel to either
                                    // the start or end paths. If the total distance of all these vectors is greater than a maximum
                                    // threshold, erase the vectors and let the code fall through to Case E, which will generate a
                                    // shorter path.
                                    let distance = 0;
                                    for (let i = 0; i < vectorIndex; i++) {
                                        const vector = vectors[i];
                                        if (FlightPathUtils.isVectorGreatCircle(vector)) {
                                            distance += vector.distance;
                                        }
                                    }
                                    if (distance > 37040 /* 20 nautical miles */) {
                                        vectorIndex = 0;
                                    }
                                }
                                isDone = vectorIndex > 0;
                            }
                        }
                    }
                    if (shouldTryFallback && !leg.flyOver && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg.type)) {
                        // The leg does not end in a fly-over fix and the next leg is eligible for fallback -> end the current leg
                        // at the start point and set a fallback state.
                        ((_c = state.currentPosition) !== null && _c !== void 0 ? _c : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                        (_d = state.currentCourse) !== null && _d !== void 0 ? _d : (state.currentCourse = currentCourse);
                        state.isFallback = true;
                        isDone = true;
                    }
                }
                if (!isDone) {
                    if (areStartEndPathsAntiParallel) {
                        // ---- CASE C ----
                        // The start and end paths are antiparallel. We need to execute a procedure turn to do a 180.
                        let desiredTurnDirection;
                        switch (leg.turnDirection) {
                            // If the leg defines a turn direction, respect it.
                            case LegTurnDirection.Left:
                                desiredTurnDirection = 'left';
                                break;
                            case LegTurnDirection.Right:
                                desiredTurnDirection = 'right';
                                break;
                            default: {
                                const endDistanceFromStartPath = startPath.distance(endVec);
                                if (Math.abs(endDistanceFromStartPath) <= GeoCircle.ANGULAR_TOLERANCE) {
                                    // If the end point lies on the start path, then we want to turn toward the end path after passing
                                    // the end point along the start path (defaulting to a right turn if the start and end paths are
                                    // exactly antiparallel).
                                    const cross = Vec3Math.cross(startPath.center, endVec, this.vec3Cache[2]);
                                    desiredTurnDirection = Vec3Math.dot(cross, endPath.center) > 0 ? 'left' : 'right';
                                }
                                else {
                                    // If the end point does not lie on the start path, then we want to turn toward the end point from
                                    // the start path.
                                    desiredTurnDirection = endDistanceFromStartPath < 0 ? 'left' : 'right';
                                }
                            }
                        }
                        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, currentCourse + 45 * (desiredTurnDirection === 'left' ? -1 : 1), minTurnRadius, desiredTurnDirection, currentCourse, endCourse);
                        // procTurnBuilder will only build vectors up to the point where the proc turn intercepts the end path.
                        // So we need to check if we need to add a vector to connect the intercept point to the end point.
                        if (vectorIndex > 0) {
                            const lastVector = vectors[vectorIndex - 1];
                            const interceptVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const interceptToEndDistance = endPath.angleAlong(interceptVec, endVec, Math.PI);
                            if (interceptToEndDistance > 1e-5 && interceptToEndDistance < Math.PI + GeoCircle.ANGULAR_TOLERANCE) { // ~60 meter tolerance
                                vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, this.geoPointCache[2].set(lastVector.endLat, lastVector.endLon), endPoint);
                            }
                        }
                    }
                    else if (endPath.angleAlong(startVec, endVec, Math.PI, GeoCircle.ANGULAR_TOLERANCE) < Math.PI + GeoCircle.ANGULAR_TOLERANCE
                        && (pathAngleDiff <= GeoCircle.ANGULAR_TOLERANCE
                            || (!isStartEqualToEnd
                                && (Vec3Math.dot(startToEndPath.center, endPath.center) >= 0.996194698 // 5 degrees
                                    || (((_e = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath.length) && endPath.includes(startVec, UnitType.METER.convertTo(10, UnitType.GA_RADIAN))))))) {
                        // ---- CASE D ----
                        // The start and end paths are parallel, so we can just connect the start and end with a track.
                        // Or the start point lies on the final course path (within a generous tolerance) and the previous leg has at
                        // least one calculated vector. In this case we will simply create a track from the start to end and let turn
                        // anticipation handle the initial turn into the final course.
                        if (!isStartEqualToEnd) {
                            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, endPoint);
                        }
                    }
                    else {
                        // ---- CASE E ----
                        // The default case. We will attempt to join the start and end paths with a single constant-radius turn
                        // toward the end point. If that is not possible, we will fall back to using two constant-radius turns. If
                        // that is not possible, we will fall back to a direct-to path from the start point to the end point.
                        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
                            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                                : undefined;
                        vectorIndex += this.joinGreatCircleToPointBuilder.build(vectors, vectorIndex, startVec, startPath, endVec, endPath, desiredTurnDirection, minTurnRadius);
                        const lastVector = vectors[vectorIndex - 1];
                        if (lastVector !== undefined
                            && !leg.flyOver
                            && !CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES.includes((_f = legs[calculateIndex + 1]) === null || _f === void 0 ? void 0 : _f.leg.type)) {
                            const lastVectorEndVec = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[2]);
                            const lastVectorEndPath = FlightPathUtils.getGreatCircleTangentToVector(lastVectorEndVec, lastVector, this.geoCircleCache[3]);
                            const lastVectorCourseDiff = Math.acos(MathUtils.clamp(Vec3Math.dot(lastVectorEndPath.center, endPath.center), -1, 1));
                            if (lastVectorCourseDiff > 0.0174533 /* 1 degree */) {
                                // We are allowed to use a fallback path which does not end at the defined terminator fix and a fallback
                                // direct-to path was calculated. We need to determine if we should end the direct-to path early if it
                                // crosses past the terminator threshold or remove it entirely and end the leg immediately at the start
                                // point.
                                const minTurnRadiusRad = UnitType.METER.convertTo(minTurnRadius, UnitType.GA_RADIAN);
                                let useImmediateFallback = false;
                                let startTurnCircle;
                                let startTurnEnd;
                                // The direct-to path can consist of either a single turn vector, a single great-circle vector, or a
                                // starting turn vector followed by a great-circle vector.
                                if (FlightPathUtils.isVectorGreatCircle(lastVector)) {
                                    if (vectorIndex < 2) {
                                        // The direct-to path has a single great-circle vector. If the direct-to course differs from the end
                                        // course by more than 90 degrees, then the entire direct-to path is past the terminator threshold.
                                        // In that case we will end this leg at the start point and set a fallback state. If the direct-to
                                        // course is within 90 degrees of the end course, then the path must be entirely behind the
                                        // threshold. In that case we will leave the path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            useImmediateFallback = true;
                                        }
                                    }
                                    else {
                                        // The direct-to path consists of a starting turn followed by a great-circle vector. If the course of
                                        // the great-circle vector differs from the end course by more than 90 degrees, then we need to
                                        // deal with the possibility that the direct-to path starts behind the terminator threshold and then
                                        // crosses past the threshold. If the courses differ by 90 or degrees or less, then we will leave
                                        // the direct-to path in place.
                                        if (lastVectorCourseDiff > MathUtils.HALF_PI) {
                                            if (isStartPastThreshold) {
                                                // If the start point is past the terminator threshold, then the entire direct-to path is
                                                // guaranteed to be past the terminator threshold. Therefore we will end this leg at the start
                                                // point and set a fallback state.
                                                useImmediateFallback = true;
                                            }
                                            else {
                                                // If the start point is not past the terminator threshold, then that means at some point the
                                                // direct-to path (specifically the starting turn) must cross the threshold. Therefore we will
                                                // trigger the evaluation code below to find out where we need to end the path early as it
                                                // crosses the threshold.
                                                const startTurnVector = vectors[vectorIndex - 2];
                                                startTurnCircle = FlightPathUtils.setGeoCircleFromVector(startTurnVector, this.geoCircleCache[3]);
                                                startTurnEnd = GeoPoint.sphericalToCartesian(startTurnVector.endLat, startTurnVector.endLon, this.vec3Cache[3]);
                                            }
                                        }
                                    }
                                }
                                else {
                                    // The direct-to path is a single turn vector.
                                    if (isStartPastThreshold) {
                                        // If the start point is past the terminator threshold, we will end this leg at the start point and
                                        // set a fallback state.
                                        useImmediateFallback = true;
                                    }
                                    else {
                                        // If the start point is behind the terminator threshold, then it is possible the turn crosses past
                                        // the threshold before it ends. Therefore we will trigger the evaluation code below to find out if
                                        // we need to end the path early as it crosses the threshold.
                                        // If the direct course calculation produced only a single turn vector, it possibly reduced the radius
                                        // of the starting turn below the minimum radius in order to build a valid path to the terminator.
                                        // We always want the starting turn to respect the minimum turn radius, so we will define it ourselves.
                                        startTurnCircle = FlightPathUtils.getTurnCircleStartingFromPath(startVec, startPath, minTurnRadiusRad, desiredTurnDirection !== null && desiredTurnDirection !== void 0 ? desiredTurnDirection : (startPath.encircles(endVec) ? 'left' : 'right'), this.geoCircleCache[3]);
                                        // If the direct course turn radius was reduced, then the terminator fix lies inside the starting turn
                                        // circle of minimum radius. Therefore, the turn technically never ends because there is no point on
                                        // the turn circle that either includes the terminator fix or is tangent to a great-circle path which
                                        // includes the terminator fix.
                                        if (Math.min(lastVector.radius, Math.PI - lastVector.radius) >= minTurnRadiusRad - GeoCircle.ANGULAR_TOLERANCE) {
                                            startTurnEnd = GeoPoint.sphericalToCartesian(lastVector.endLat, lastVector.endLon, this.vec3Cache[3]);
                                        }
                                    }
                                }
                                if (startTurnCircle !== undefined) {
                                    // Find the intersections of the direct-to starting turn circle with the terminator threshold.
                                    const intersections = this.intersectionCache;
                                    const intersectionCount = threshold.intersection(startTurnCircle, intersections);
                                    // If the starting turn is tangent to the threshold, then the entire turn must be behind the threshold
                                    // because we are guaranteed that the start point is behind the threshold if we made it into this case.
                                    // Therefore, we only care about starting turns that are secant to the threshold.
                                    if (intersectionCount === 2) {
                                        // Because the start point is guaranteed to be behind the threshold, the next intersection of the
                                        // starting turn circle with the threshold will take the path past the threshold.
                                        const thresholdCrossing = intersections[0];
                                        const thresholdCrossingAngle = startTurnCircle.angleAlong(startVec, thresholdCrossing, Math.PI, GeoCircle.ANGULAR_TOLERANCE);
                                        if (startTurnEnd === undefined
                                            || startTurnCircle.angleAlong(startVec, startTurnEnd, Math.PI, GeoCircle.ANGULAR_TOLERANCE) > thresholdCrossingAngle + GeoCircle.ANGULAR_TOLERANCE) {
                                            // The starting turn crosses the terminator threshold before the end of the turn (or the turn has
                                            // no end) -> end the turn at the crossing point and set the fallback state.
                                            vectorIndex = 0;
                                            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, startTurnCircle, startVec, thresholdCrossing, FlightPathVectorFlags.TurnToCourse | FlightPathVectorFlags.Fallback);
                                            state.isFallback = true;
                                        }
                                    }
                                }
                                if (useImmediateFallback) {
                                    vectorIndex = 0;
                                    ((_g = state.currentPosition) !== null && _g !== void 0 ? _g : (state.currentPosition = new GeoPoint(0, 0))).set(startPoint);
                                    (_h = state.currentCourse) !== null && _h !== void 0 ? _h : (state.currentCourse = currentCourse);
                                    state.isFallback = true;
                                }
                            }
                        }
                    }
                }
            }
        }
        const lastVector = vectors[vectorIndex - 1];
        if (lastVector !== undefined) {
            ((_j = state.currentPosition) !== null && _j !== void 0 ? _j : (state.currentPosition = new GeoPoint(0, 0))).set(lastVector.endLat, lastVector.endLon);
            state.currentCourse = FlightPathUtils.getVectorFinalCourse(vectors[vectorIndex - 1]);
        }
        vectors.length = vectorIndex;
    }
}
CourseToFixLegCalculator.FALLBACK_INELIGIBLE_LEG_TYPES = [
    LegType.AF,
    LegType.RF,
    LegType.PI
];
/**
 * Calculates flight path vectors for procedure turn legs.
 */
class ProcedureTurnLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const originFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = originFacility === undefined ? 0 : MagVar.get(originFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const origin = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!origin) {
            vectors.length = vectorIndex;
            return;
        }
        // If current lat/lon is not defined, then set it to the origin's location, simulating an IF at the leg origin.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = origin.copy());
        const nextLeg = (_b = legs[calculateIndex + 1]) === null || _b === void 0 ? void 0 : _b.leg;
        if (!origin.equals(state.currentPosition)) {
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, state.currentPosition, origin, state.currentCourse);
            state.currentCourse = origin.bearingFrom(state.currentPosition);
            state.currentPosition.set(origin);
        }
        if (!nextLeg) {
            vectors.length = vectorIndex;
            return;
        }
        const nextLegTerminatorFix = this.getTerminatorPosition(nextLeg, nextLeg.fixIcao, this.geoPointCache[1]);
        if (!nextLegTerminatorFix) {
            vectors.length = vectorIndex;
            return;
        }
        const inboundCourse = (_c = this.predictLegFinalTrueCourse(legs, calculateIndex + 1, nextLegTerminatorFix)) !== null && _c !== void 0 ? _c : 0;
        const outboundCourse = NavMath.normalizeHeading(inboundCourse + 180);
        const turnInitialCourse = leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
        if (outboundCourse === turnInitialCourse) {
            vectors.length = vectorIndex;
            return;
        }
        // must intercept the next leg at least 1 NM from the terminator fix
        const inboundPathEndpoint = nextLegTerminatorFix.offset(inboundCourse + 180, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN));
        const outboundPath = this.geoCircleCache[0].setAsGreatCircle(origin, outboundCourse);
        const inboundPath = this.geoCircleCache[1].setAsGreatCircle(inboundPathEndpoint, inboundCourse);
        const desiredTurnDirection = leg.turnDirection === LegTurnDirection.Left ? 'left'
            : leg.turnDirection === LegTurnDirection.Right ? 'right'
                : undefined;
        vectorIndex += this.procTurnBuilder.build(vectors, vectorIndex, origin, outboundPath, inboundPathEndpoint, inboundPath, turnInitialCourse, state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), desiredTurnDirection, outboundCourse, inboundCourse);
        // addVectorsForProcTurn() is guaranteed to add at least one vector.
        const lastVector = vectors[vectorIndex - 1];
        state.currentPosition.set(lastVector.endLat, lastVector.endLon);
        state.currentCourse = FlightPathUtils.getVectorFinalCourse(lastVector);
        vectors.length = vectorIndex;
    }
    /**
     * Predicts the final true course of a leg at its terminator fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param terminator The location of the leg's terminator fix.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegFinalTrueCourse(legs, index, terminator) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        switch (leg.type) {
            case LegType.IF:
                return this.predictLegInitialTrueCourse(legs, index + 1, terminator);
            case LegType.CF:
                return this.getLegTrueCourse(leg, terminator);
            default:
                return undefined;
        }
    }
    /**
     * Predicts the initial true course of a leg at its origin fix.
     * @param legs A leg sequence.
     * @param index The index of the leg in the sequence.
     * @param origin The location of the leg's origin.
     * @returns the predicted final course of a leg at its terminator fix, or undefined if a prediction cannot be made.
     */
    predictLegInitialTrueCourse(legs, index, origin) {
        var _a;
        const leg = (_a = legs[index]) === null || _a === void 0 ? void 0 : _a.leg;
        if (!leg) {
            return undefined;
        }
        try {
            switch (leg.type) {
                case LegType.IF:
                case LegType.TF:
                case LegType.DF:
                case LegType.CF:
                    {
                        const terminator = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[2]);
                        return terminator ? origin.bearingTo(terminator) : undefined;
                    }
                case LegType.CD:
                case LegType.VD:
                case LegType.CR:
                case LegType.VR:
                case LegType.FC:
                case LegType.FD:
                    return this.getLegTrueCourse(leg, origin);
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.FM:
                case LegType.VM:
                case LegType.CI:
                case LegType.VI:
                    return leg.trueDegrees ? leg.course : MagVar.magneticToTrue(leg.course, origin);
                default:
                    return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
}
/**
 * Calculates flight path vectors for course to manual legs.
 */
class CourseToManualLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        const startPoint = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
        if (!startPoint) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, startPoint);
        const normalizedEnd = startPoint.offset(course, UnitType.NMILE.convertTo(1, UnitType.GA_RADIAN), this.geoPointCache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, startPoint, normalizedEnd);
        state.currentPosition = undefined;
        state.currentCourse = undefined;
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for course to altitude legs.
 */
class CourseToAltitudeLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, false);
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex, activeLegIndex, state) {
        var _a;
        const leg = legs[calculateIndex];
        const origin = (_a = state.currentPosition) !== null && _a !== void 0 ? _a : this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = origin === undefined ? 0 : this.getLegMagVar(leg.leg, origin);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const vectors = legs[calculateIndex].calculated.flightPath;
        let vectorIndex = 0;
        if (!state.currentPosition) {
            const fixPosition = this.getPositionFromIcao(leg.fixIcao, this.geoPointCache[0]);
            if (fixPosition) {
                state.currentPosition = new GeoPoint(fixPosition.lat, fixPosition.lon);
            }
        }
        if (!state.currentPosition) {
            vectors.length = vectorIndex;
            return;
        }
        const course = this.getLegTrueCourse(leg, state.currentPosition);
        const path = this.geoCircleCache[0].setAsGreatCircle(state.currentPosition, course);
        const originVec = state.currentPosition.toCartesian(this.vec3Cache[0]);
        const climbStartVec = activeLegIndex === calculateIndex
            ? path.closest(state.planePosition, this.vec3Cache[1])
            : originVec;
        const originToClimbStartDistance = (path.distanceAlong(originVec, climbStartVec) + 3 * Math.PI) % (2 * Math.PI) - Math.PI; // -pi to +pi
        const targetFeet = UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT);
        const deltaAltitude = Math.max(0, targetFeet - state.planeAltitude.asUnit(UnitType.FOOT));
        const distanceRemaining = UnitType.NMILE.convertTo((deltaAltitude / state.planeClimbRate.asUnit(UnitType.FPM)) / 60 * state.planeSpeed.asUnit(UnitType.KNOT), UnitType.GA_RADIAN);
        const offsetDistance = Math.max(UnitType.FOOT.convertTo(100, UnitType.GA_RADIAN), originToClimbStartDistance + distanceRemaining);
        const legEndVec = path.offsetDistanceAlong(originVec, offsetDistance, this.vec3Cache[1]);
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, originVec, path, legEndVec);
        state.currentPosition.setFromCartesian(legEndVec);
        state.currentCourse = path.bearingAt(legEndVec);
        vectors.length = vectorIndex;
    }
}
/**
 * Calculates flight path vectors for hold legs.
 */
class HoldLegCalculator extends AbstractFlightPathLegCalculator {
    /**
     * Constructor.
     * @param facilityCache This calculator's cache of facilities.
     */
    constructor(facilityCache) {
        super(facilityCache, true);
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.greatCircleBuilder = new GreatCircleBuilder();
        this.circleVectorBuilder = new CircleVectorBuilder();
        this.turnToCourseBuilder = new TurnToCourseBuilder();
        this.joinGreatCircleToPointBuilder = new JoinGreatCircleToPointBuilder();
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /** @inheritdoc */
    calculateMagVar(legs, calculateIndex) {
        const leg = legs[calculateIndex];
        const holdFacility = this.facilityCache.get(leg.leg.fixIcao);
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        leg.calculated.courseMagVar = holdFacility === undefined ? 0 : this.getLegMagVar(leg.leg, holdFacility);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    calculateVectors(legs, calculateIndex, activeLegIndex, state) {
        var _a, _b, _c, _d;
        state.isFallback = false;
        const leg = legs[calculateIndex].leg;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const calcs = legs[calculateIndex].calculated;
        const vectors = calcs.flightPath;
        const ingress = calcs.ingress;
        let vectorIndex = 0, ingressVectorIndex = 0;
        const holdPos = this.getTerminatorPosition(leg, leg.fixIcao, this.geoPointCache[0]);
        if (!holdPos) {
            vectors.length = 0;
            ingress.length = 0;
            calcs.ingressJoinIndex = -1;
            return;
        }
        // If current lat/lon is not defined, then set it to the facility's location, simulating an IF at the hold's
        // facility.
        (_a = state.currentPosition) !== null && _a !== void 0 ? _a : (state.currentPosition = holdPos.copy());
        if (!state.currentPosition.equals(holdPos)) {
            ingressVectorIndex += this.greatCircleBuilder.build(ingress, ingressVectorIndex, state.currentPosition, holdPos, state.currentCourse);
            state.currentCourse = holdPos.bearingFrom(state.currentPosition);
        }
        const course = this.getLegTrueCourse(leg, holdPos);
        const distance = leg.distanceMinutes
            ? UnitType.NMILE.convertTo(leg.distance * (state.planeSpeed.asUnit(UnitType.KNOT) / 60), UnitType.GA_RADIAN)
            : UnitType.METER.convertTo(leg.distance, UnitType.GA_RADIAN);
        const turnDirection = leg.turnDirection === LegTurnDirection.Right ? 'right' : 'left';
        const turnDirectionSign = turnDirection === 'left' ? -1 : 1;
        const turnRadiusMeters = state.desiredHoldTurnRadius.asUnit(UnitType.METER);
        const inboundPath = this.geoCircleCache[0].setAsGreatCircle(holdPos, course);
        const outboundTurnCenterCourse = NavMath.normalizeHeading(course + 90 * turnDirectionSign);
        const turnRadiusRad = state.desiredHoldTurnRadius.asUnit(UnitType.GA_RADIAN);
        const outboundTurnCenter = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
        const outboundTurnEnd = holdPos.offset(outboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
        const oppositeCourse = NavMath.normalizeHeading(course + 180);
        const outboundEnd = outboundTurnEnd.offset(oppositeCourse, distance, this.geoPointCache[3]);
        // Handle hold entry
        state.currentPosition.set(holdPos);
        (_b = state.currentCourse) !== null && _b !== void 0 ? _b : (state.currentCourse = course);
        const normalizedEntryCourse = ((state.currentCourse - course) + 540) % 360 - 180; // -180 to +180
        const directionalEntryCourse = normalizedEntryCourse * turnDirectionSign;
        const isDirectEntry = directionalEntryCourse >= -70 && directionalEntryCourse <= 135;
        const skipRacetrack = leg.type === LegType.HF && !isDirectEntry;
        if (isDirectEntry) {
            // direct entry
            if (directionalEntryCourse > 0) {
                // The entry course is toward the outbound leg, so we just intercept the outbound leg directly, bypassing
                // the turn from the inbound to outbound leg.
                ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), outboundEnd, this.geoCircleCache[2].setAsGreatCircle(outboundTurnEnd, oppositeCourse), turnDirection, turnRadiusMeters, false, true, undefined, FlightPathVectorFlags.HoldDirectEntry);
                calcs.ingressJoinIndex = 1;
            }
            else if (BitFlags.isAny((_d = (_c = ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.AnticipatedTurn)) {
                // Don't erase turn anticipation for direct entries
                ingressVectorIndex = ingress.length;
            }
        }
        else if (directionalEntryCourse > 110) {
            // teardrop entry
            if (directionalEntryCourse > 135) {
                // need to make initial turn to get a 45-degree outbound leg
                const outboundCourse = course + 135 * turnDirectionSign;
                const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, outboundCourse, FlightPathVectorFlags.HoldTeardropEntry | FlightPathVectorFlags.TurnToCourse);
                if (numTurnVectorsAdded > 0) {
                    ingressVectorIndex += numTurnVectorsAdded;
                    const turnVector = ingress[ingressVectorIndex - 1];
                    state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                    state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
                }
            }
            ingressVectorIndex += this.joinGreatCircleToPointBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, turnDirection, turnRadiusMeters, true, true, undefined, FlightPathVectorFlags.HoldTeardropEntry);
            if (skipRacetrack) {
                // If we skip the racetrack, remove the part of the hold entry that is coincident with the inbound leg
                const lastEntryVector = ingress[ingressVectorIndex - 1];
                if (lastEntryVector && FlightPathUtils.isVectorGreatCircle(lastEntryVector) && holdPos.equals(lastEntryVector.endLat, lastEntryVector.endLon)) {
                    if (UnitType.METER.convertTo(lastEntryVector.distance, UnitType.GA_RADIAN) > distance + GeoPoint.EQUALITY_TOLERANCE) {
                        const lastEntryVectorEnd = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
                        lastEntryVector.endLat = lastEntryVectorEnd.lat;
                        lastEntryVector.endLon = lastEntryVectorEnd.lon;
                        lastEntryVector.distance -= UnitType.GA_RADIAN.convertTo(distance, UnitType.METER);
                    }
                    else {
                        ingressVectorIndex--;
                    }
                }
            }
            calcs.ingressJoinIndex = 0;
        }
        else if (directionalEntryCourse < -70) {
            // parallel entry
            const parallelCourse = course + 180;
            const numTurnVectorsAdded = this.turnToCourseBuilder.build(ingress, ingressVectorIndex, holdPos, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, parallelCourse, FlightPathVectorFlags.HoldParallelEntry | FlightPathVectorFlags.TurnToCourse);
            if (numTurnVectorsAdded > 0) {
                ingressVectorIndex += numTurnVectorsAdded;
                const turnVector = ingress[ingressVectorIndex - 1];
                state.currentPosition.set(turnVector.endLat, turnVector.endLon);
                state.currentCourse = FlightPathUtils.getVectorFinalCourse(turnVector);
            }
            ingressVectorIndex += this.procTurnBuilder.build(ingress, ingressVectorIndex, state.currentPosition, this.geoCircleCache[1].setAsGreatCircle(state.currentPosition, state.currentCourse), holdPos, inboundPath, course + 135 * turnDirectionSign, turnRadiusMeters, turnDirection === 'left' ? 'right' : 'left', state.currentCourse, course, FlightPathVectorFlags.HoldParallelEntry);
            calcs.ingressJoinIndex = 0;
        }
        ingress.length = ingressVectorIndex;
        if (ingress.length === 0) {
            calcs.ingressJoinIndex = -1;
        }
        let inboundStart;
        if (skipRacetrack) {
            inboundStart = holdPos.offset(course + 180, distance, this.geoPointCache[1]);
        }
        else {
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, outboundTurnCenter, holdPos, outboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, outboundTurnEnd, outboundEnd, undefined, FlightPathVectorFlags.HoldOutboundLeg);
            const inboundTurnCenterCourse = NavMath.normalizeHeading(oppositeCourse + 90 * turnDirectionSign);
            const inboundTurnCenter = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad, this.geoPointCache[1]);
            const inboundTurnEnd = outboundEnd.offset(inboundTurnCenterCourse, turnRadiusRad * 2, this.geoPointCache[2]);
            vectorIndex += this.circleVectorBuilder.build(vectors, vectorIndex, turnDirection, turnRadiusMeters, inboundTurnCenter, outboundEnd, inboundTurnEnd, FlightPathVectorFlags.TurnToCourse);
            inboundStart = inboundTurnEnd;
        }
        vectorIndex += this.greatCircleBuilder.build(vectors, vectorIndex, inboundStart, holdPos, undefined, FlightPathVectorFlags.HoldInboundLeg);
        state.currentPosition.set(holdPos);
        state.currentCourse = course;
        vectors.length = vectorIndex;
    }
}

/**
 * Utility class for working with flight plans.
 */
class FlightPlanUtils {
    /**
     * Checks if a leg type is an "to altitude" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.ALTITUDE_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "heading to" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HEADING_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a "hold" leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a "hold" leg type.
     */
    static isHoldLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.HOLD_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a manual termination leg type that ends in a discontinuity.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a manual termination leg type that ends in a discontinuity.
     */
    static isManualDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.MANUAL_DISCO_LEG_TYPES, legType);
    }
    /**
     * Checks if a leg type is a discontinuity leg type.
     * @param legType The leg type to check.
     * @returns Whether the leg type is a discontinuity leg type.
     */
    static isDiscontinuityLeg(legType) {
        return ArrayUtils.includes(FlightPlanUtils.DISCO_LEG_TYPES, legType);
    }
    /**
     * Gets the ICAO of the facility defining the terminator of a flight plan leg.
     * @param leg A flight plan leg.
     * @returns The ICAO of the facility defining the terminator of the specified flight plan leg, or `undefined` if
     * the leg's terminator is not defined by a facility.
     */
    static getTerminatorIcao(leg) {
        switch (leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
                return leg.fixIcao;
            default:
                return undefined;
        }
    }
}
/** Array of "to altitude" leg types. */
FlightPlanUtils.ALTITUDE_LEG_TYPES = [LegType.CA, LegType.FA, LegType.VA];
/** Array of "heading to" leg types. */
FlightPlanUtils.HEADING_LEG_TYPES = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold" leg types. */
FlightPlanUtils.HOLD_LEG_TYPES = [LegType.HA, LegType.HF, LegType.HM];
/** Array of manual termination leg types that end in a discontinuity. */
FlightPlanUtils.MANUAL_DISCO_LEG_TYPES = [LegType.FM, LegType.VM];
/** Array of discontinuity leg types. */
FlightPlanUtils.DISCO_LEG_TYPES = [LegType.Discontinuity, LegType.ThruDiscontinuity];

/**
 * A flight path calculator for turns between legs.
 */
class FlightPathTurnCalculator {
    constructor() {
        this.procTurnBuilder = new ProcedureTurnBuilder();
    }
    /**
     * Computes leg to leg turns for a given sequence of legs. Turns will only be calculated between legs with defined
     * flight path vectors and no pre-existing egress/ingress transition (unless it is a leg-to-leg turn) at the junction
     * of the turn.
     * @param legs A sequence of legs.
     * @param startIndex The index of the first leg for which to compute turns.
     * @param count The total number of legs for which to compute turns.
     * @param desiredTurnRadius The desired general turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     */
    computeTurns(legs, startIndex, count, desiredTurnRadius, desiredCourseReversalTurnRadius, desiredTurnAnticipationTurnRadius) {
        var _a, _b, _c, _d;
        const end = startIndex + count;
        let currentIndex = startIndex;
        while (currentIndex < end) {
            const fromLeg = legs[currentIndex];
            const toLeg = legs[currentIndex + 1];
            const fromLegCalc = fromLeg === null || fromLeg === void 0 ? void 0 : fromLeg.calculated;
            const toLegCalc = toLeg === null || toLeg === void 0 ? void 0 : toLeg.calculated;
            if (fromLegCalc
                && toLegCalc
                && !FlightPlanUtils.isManualDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(fromLeg.leg.type)
                && !FlightPlanUtils.isDiscontinuityLeg(toLeg.leg.type)) {
                const fromVector = fromLegCalc.flightPath[fromLegCalc.flightPath.length - 1];
                const toVector = toLegCalc.flightPath[0];
                if (fromVector && toVector
                    && (fromLegCalc.egress.length === 0 || BitFlags.isAll(fromLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))
                    && (toLegCalc.ingress.length === 0 || BitFlags.isAll(toLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                    if (fromVector.radius === Math.PI / 2 && toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeTrackTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true);
                        continue;
                    }
                    else if (toVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, fromVector, toVector, true, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                    else if (fromVector.radius === Math.PI / 2) {
                        currentIndex = this.computeArcTrackTurn(legs, currentIndex, currentIndex + 1, toVector, fromVector, false, desiredTurnAnticipationTurnRadius);
                        continue;
                    }
                }
            }
            if (fromLegCalc && BitFlags.isAll((_b = (_a = fromLegCalc.egress[0]) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, FlightPathVectorFlags.LegToLegTurn)) {
                fromLegCalc.egress.length = 0;
                fromLegCalc.egressJoinIndex = -1;
            }
            if (toLegCalc && BitFlags.isAll((_d = (_c = toLegCalc.ingress[0]) === null || _c === void 0 ? void 0 : _c.flags) !== null && _d !== void 0 ? _d : 0, FlightPathVectorFlags.LegToLegTurn)) {
                toLegCalc.ingress.length = 0;
                toLegCalc.ingressJoinIndex = -1;
            }
            currentIndex++;
        }
    }
    /**
     * Calculates a leg-to-leg turn between two track vectors.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @param isRestrictedByPrevTurn Whether turn anticipation is restricted by the previous leg-to-leg turn. If `true`,
     * turn anticipation will be restricted so that the turn does not overlap the previous turn if they share a common
     * flight path vector.
     * @param previousTanTheta The tangent of the theta value of the previous turn. Theta is defined as the (acute)
     * angle between either `fromTrack` or `toTrack` and the great circle passing through the turn vertex (where the two
     * tracks meet) and the center of the turn. If this value is defined and `isRestrictedByPrevTurn` is `true`, the
     * anticipation of both turns will be adjusted if necessary such that the turns do not overlap if they share a common
     * flight path vector. If the value is undefined, the anticipation of the current turn will be restricted by the
     * previous turn, if necessary, without changing the anticipation of the previous turn.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackTurn(legs, fromIndex, toIndex, fromTrack, toTrack, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, isRestrictedByPrevTurn, previousTanTheta) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        const fromTrackBearing = turnVertexPoint.bearingFrom(fromTrack.startLat, fromTrack.startLon);
        const toTrackBearing = turnVertexPoint.bearingTo(toTrack.endLat, toTrack.endLon);
        const trackAngleDiff = Math.abs(NavMath.diffAngle(fromTrackBearing, toTrackBearing));
        if (trackAngleDiff < 1
            || fromTrack.distance === 0
            || toTrack.distance === 0
            || !turnVertexPoint.equals(toTrack.startLat, toTrack.startLon, 1e-5)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        if (trackAngleDiff > 175) {
            return this.computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius);
        }
        const theta = (180 - trackAngleDiff) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // D is defined as the distance from the start/end of the turn to the turn vertex along the from- and to- tracks
        // (i.e. the anticipation).
        const desiredD = Math.asin(Math.tan(UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)) / tanTheta);
        let restrictedD = Infinity;
        if (isRestrictedByPrevTurn) {
            if (previousTanTheta === undefined) {
                // Check to see if there is a ingress transition on the from leg and if it shares a common flight path vector
                // with the one involved in the turn currently being calculated.
                if (fromLegCalc.ingress.length > 0 && fromLegCalc.ingressJoinIndex === fromLegCalc.flightPath.length - 1) {
                    const lastIngressVector = fromLegCalc.ingress[fromLegCalc.ingress.length - 1];
                    restrictedD = turnVertexPoint.distance(lastIngressVector.endLat, lastIngressVector.endLon);
                }
            }
            else {
                // D is restricted by a previous turn. The values of D_current and D_previous are restricted such that their sum
                // cannot exceed the total length of their shared vector (the from- vector for this turn). Therefore, we set the
                // maximum value of D_current such that at D_current(max), the radius of this turn equals the radius of the
                // previous turn. This will maximize min(radius_current, radius_prev).
                const tanThetaRatio = previousTanTheta / tanTheta;
                const totalD = UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN);
                const cosTotalD = Math.cos(totalD);
                let prevTurnRestrictedD = Math.acos((tanThetaRatio * cosTotalD + 1) / Math.sqrt(tanThetaRatio * tanThetaRatio + 2 * tanThetaRatio * cosTotalD + 1));
                if (prevTurnRestrictedD > totalD) {
                    prevTurnRestrictedD = Math.PI - prevTurnRestrictedD;
                }
                restrictedD = prevTurnRestrictedD;
            }
        }
        // We need to scan forward in the leg sequence to compute any restrictions on D imposed by later turns.
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                let nextTurnRestrictedD;
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    nextTurnRestrictedD = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, true, tanTheta);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    nextTurnRestrictedD = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : Infinity;
                }
                restrictedD = Math.min(restrictedD, nextTurnRestrictedD);
            }
        }
        const D = Math.min(desiredD, restrictedD, UnitType.METER.convertTo(fromTrack.distance, UnitType.GA_RADIAN), UnitType.METER.convertTo(toTrack.distance, UnitType.GA_RADIAN));
        // distance from the turn vertex to the center of the turn
        const H = Math.atan(Math.tan(D) / Math.cos(theta * Avionics.Utils.DEG2RAD));
        const turnRadiusRad = desiredD === D
            ? UnitType.METER.convertTo(desiredTurnAnticipationTurnRadius, UnitType.GA_RADIAN)
            : Math.atan(Math.sin(D) * tanTheta);
        if (D <= GeoPoint.EQUALITY_TOLERANCE || turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            // prevent zero-length turns
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return lastComputedIndex;
        }
        const turnDirection = NavMath.getTurnDirection(fromTrackBearing, toTrackBearing);
        const turnBisectorBearing = toTrackBearing + theta * (turnDirection === 'left' ? -1 : 1);
        const turnCenter = turnVertexPoint.offset(turnBisectorBearing, H, FlightPathTurnCalculator.geoPointCache[1]);
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const turnStart = fromTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[2]);
        const turnMiddle = turnVertexPoint.offset(turnBisectorBearing, H - turnRadiusRad, FlightPathTurnCalculator.geoPointCache[3]);
        const turnEnd = toTrackPath.closest(turnCenter, FlightPathTurnCalculator.geoPointCache[4]);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER), turnCenter, turnStart, turnMiddle, turnEnd);
        return lastComputedIndex;
    }
    /**
     * Computes a leg-to-leg course reversal.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param fromTrack The track vector on which the turn begins.
     * @param toTrack The track vector on which the turn ends.
     * @param fromTrackBearing The true course bearing of the track vector on which the turn begins, at the end of the vector.
     * @param toTrackBearing The true course bearing of the track vector on which the turn ends, at the beginning of the vector.
     * @param desiredTurnAnticipationTurnRadius The desired turn anticipation turn radius, in meters.
     * @param desiredCourseReversalTurnRadius The desired course reversal turn radius, in meters.
     * @returns The index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeTrackTrackCourseReversal(legs, fromIndex, toIndex, fromTrack, toTrack, fromTrackBearing, toTrackBearing, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius) {
        var _a;
        let lastComputedIndex = toIndex;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = legs[fromIndex].calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = legs[toIndex].calculated;
        const turnVertexPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromTrack.endLat, fromTrack.endLon);
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        // Let the course reversal "cut"
        let courseReversalEndDistance = UnitType.METER.convertTo(toLegCalc.flightPath[0].distance, UnitType.GA_RADIAN);
        if (toLegCalc.flightPath.length === 1 && (toLegCalc.egress.length === 0 || BitFlags.isAll(toLegCalc.egress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
            const nextLegCalc = (_a = legs[toIndex + 1]) === null || _a === void 0 ? void 0 : _a.calculated;
            const nextVector = nextLegCalc === null || nextLegCalc === void 0 ? void 0 : nextLegCalc.flightPath[0];
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            if (nextVector && (nextLegCalc.ingress.length === 0 || BitFlags.isAll(nextLegCalc.ingress[0].flags, FlightPathVectorFlags.LegToLegTurn))) {
                if (!FlightPathUtils.isVectorGreatCircle(nextVector)) {
                    courseReversalEndDistance = UnitType.METER.convertTo(toTrack.distance / 2, UnitType.GA_RADIAN);
                }
                else {
                    // if the next turn to share a vector with this turn is to a track vector, we need to recursively compute
                    // future turns since the next turn may be restricted by the turn after that, etc.
                    lastComputedIndex = this.computeTrackTrackTurn(legs, toIndex, toIndex + 1, toTrack, nextVector, desiredTurnAnticipationTurnRadius, desiredCourseReversalTurnRadius, false);
                    turnVertexPoint.set(fromTrack.endLat, fromTrack.endLon);
                    const nextTurnEgress = toLegCalc.egress[0];
                    courseReversalEndDistance = nextTurnEgress ? turnVertexPoint.distance(nextTurnEgress.startLat, nextTurnEgress.startLon) : courseReversalEndDistance;
                }
            }
        }
        const fromTrackPath = FlightPathTurnCalculator.geoCircleCache[0].setAsGreatCircle(turnVertexPoint, fromTrackBearing);
        const toTrackPath = FlightPathTurnCalculator.geoCircleCache[1].setAsGreatCircle(turnVertexPoint, toTrackBearing);
        const courseReversalEnd = toTrackPath.offsetDistanceAlong(turnVertexPoint, courseReversalEndDistance, FlightPathTurnCalculator.vector3Cache[0]);
        const turnDirection = NavMath.diffAngle(toTrackBearing, fromTrackBearing) < 0 ? 'left' : 'right';
        const length = this.procTurnBuilder.build(toLegCalc.ingress, 0, turnVertexPoint, fromTrackPath, courseReversalEnd, toTrackPath, fromTrackBearing + 45 * (turnDirection === 'left' ? -1 : 1), desiredCourseReversalTurnRadius, turnDirection, fromTrackBearing, toTrackBearing, FlightPathVectorFlags.LegToLegTurn | FlightPathVectorFlags.CourseReversal);
        toLegCalc.ingress.length = length;
        toLegCalc.ingressJoinIndex = 0;
        return lastComputedIndex;
    }
    /**
     * Calculates a leg to leg turn between an arc vector and a track vector.
     * @param legs The sequence of legs to which the turn belongs.
     * @param fromIndex The index of the leg on which the turn begins.
     * @param toIndex The index of the leg on which the turn ends.
     * @param arc The arc vector.
     * @param track The track vector.
     * @param isArcFirst Whether the arc vector precedes the track vector (i.e. whether the arc vector is the vector on
     * which the turn begins).
     * @param desiredTurnRadius The desired turn radius, in meters.
     * @returns the index of the last leg in the sequence for which a turn ending on that leg was computed.
     */
    computeArcTrackTurn(legs, fromIndex, toIndex, arc, track, isArcFirst, desiredTurnRadius) {
        var _a, _b;
        var _c, _d;
        const fromLeg = legs[fromIndex];
        const toLeg = legs[toIndex];
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const fromLegCalc = fromLeg.calculated;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const toLegCalc = toLeg.calculated;
        if (arc.distance === 0 || track.distance === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        /*
         * Theory: find the center of the turn circle. Since the turn circle is tangent to both the arc circle and the
         * great circle defined by the track path, it follows that the center of the turn circle lies at a distance equal
         * to the turn radius from both the arc circle and great circle. Therefore, we can find the center by applying a
         * radial offset equal to +/-[turn radius] to both the arc circle and great circle (the sign of the offset depends
         * on the direction of the arc and track path) and solving for the points of intersection between the offset
         * circles.
         */
        const fromVector = isArcFirst ? arc : track;
        const toVector = isArcFirst ? track : arc;
        const fromVectorEndPoint = FlightPathTurnCalculator.geoPointCache[0].set(fromVector.endLat, fromVector.endLon);
        const toVectorStartPoint = FlightPathTurnCalculator.geoPointCache[1].set(toVector.startLat, toVector.startLon);
        const areLegsContinuous = fromVectorEndPoint.equals(toVectorStartPoint, 1e-5);
        if (!areLegsContinuous) {
            // The from-leg does not end within ~60 meters of the start of the to-leg.
            let shouldQuit = true;
            // Either the from- or to- leg is an AF or RF leg. These legs often end up discontinuous with the preceding or
            // proceeding leg due to the arcs being slightly offset from the intended origin and/or terminator fixes.
            if (fromLeg.leg.type === LegType.AF
                || fromLeg.leg.type === LegType.RF
                || toLeg.leg.type === LegType.AF
                || toLeg.leg.type === LegType.RF) {
                shouldQuit = false;
            }
            if (shouldQuit) {
                return toIndex;
            }
        }
        const fromVectorEndBearing = FlightPathUtils.getVectorFinalCourse(fromVector);
        const toVectorStartBearing = FlightPathUtils.getVectorInitialCourse(toVector);
        const vectorBearingDiff = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing));
        if (vectorBearingDiff < 1) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        // Define the circles
        const arcPath = FlightPathUtils.setGeoCircleFromVector(arc, FlightPathTurnCalculator.geoCircleCache[0]);
        const arcCenter = FlightPathUtils.getTurnCenterFromCircle(arcPath, FlightPathTurnCalculator.geoPointCache[2]);
        const arcRadiusRad = FlightPathUtils.getTurnRadiusFromCircle(arcPath);
        const arcDirection = FlightPathUtils.getTurnDirectionFromCircle(arcPath);
        const arcCircle = FlightPathTurnCalculator.geoCircleCache[1].set(arcCenter, arcRadiusRad);
        const trackPath = FlightPathUtils.setGeoCircleFromVector(track, FlightPathTurnCalculator.geoCircleCache[2]);
        const trackPathNormalPoint = FlightPathTurnCalculator.geoPointCache[3].setFromCartesian(trackPath.center);
        const fromVectorPath = isArcFirst ? arcPath : trackPath;
        const toVectorPath = isArcFirst ? trackPath : arcPath;
        // calculate whether the arc intersects the track; if they don't (or if they are entirely coincident), something
        // has gone wrong!
        const arcTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
        const arcTrackIntersectionCount = arcCircle.intersection(trackPath, arcTrackIntersections);
        if (arcTrackIntersectionCount === 0 || isNaN(arcTrackIntersectionCount)) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const fromVectorEndVec = fromVectorEndPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[0]);
        const toVectorStartVec = toVectorStartPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[1]);
        const fromVectorHalfDistanceRad = UnitType.METER.convertTo(fromVector.distance / 2, UnitType.GA_RADIAN);
        const toVectorHalfDistanceRad = UnitType.METER.convertTo(toVector.distance / 2, UnitType.GA_RADIAN);
        const intersectionPoint = FlightPathTurnCalculator.geoPointCache[4];
        const intersectionVec = FlightPathTurnCalculator.vector3Cache[2];
        let intersectionFromVectorEndOffset = 0;
        let intersectionToVectorStartOffset = 0;
        const turnDirection = NavMath.getTurnDirection(fromVectorEndBearing, toVectorStartBearing);
        let isInside;
        let turnRadiusRad;
        let arcCircleOffsetSign;
        let trackPathOffsetSign;
        if (arcTrackIntersectionCount === 1) {
            // The arc circle and track path are tangent.
            if (areLegsContinuous) {
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
            }
            else {
                // The from-leg does not end within ~60 meters of the start of the to-leg.
                Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                intersectionFromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, intersectionVec);
                intersectionToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, toVectorStartVec);
                if (!this.isArcTrackIntersectionValid(intersectionVec, fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersectionFromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersectionToVectorStartOffset)) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
            }
            const isForward = Math.abs(NavMath.diffAngle(fromVectorEndBearing, toVectorStartBearing)) < 90;
            if (isForward) {
                if (intersectionFromVectorEndOffset === 0 && intersectionToVectorStartOffset === 0) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                }
                else {
                    if (intersectionFromVectorEndOffset !== 0) {
                        // The intersection is not coincident with the end of the from-vector. The egress path will start 1
                        // nautical mile before the intersection point or at the end of the from-vector, whichever comes
                        // earlier (without going past the mid-point of the from-vector) and follow the from-vector path.
                        if (fromVectorHalfDistanceRad + intersectionFromVectorEndOffset <= 1e-5) {
                            // The intersection is at the mid-point of the from-vector.
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const egressStartVec = fromVectorPath.offsetDistanceAlong(intersectionVec, -Math.min(0.00029, Math.max(0, intersectionFromVectorEndOffset), fromVectorHalfDistanceRad + intersectionFromVectorEndOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnEgress(fromLegCalc, fromVectorPath, egressStartVec, intersectionVec);
                        }
                    }
                    if (intersectionToVectorStartOffset !== 0) {
                        // The intersection is not coincident with the start of the to-vector. The ingress path will end 1
                        // nautical mile after the intersection point or at the start of the to-vector, whichever comes
                        // later (without going past the mid-point of the to-vector) and follow the to-vector path.
                        if (toVectorHalfDistanceRad + intersectionToVectorStartOffset <= 1e-5) {
                            // The intersection is at the mid-point of the to-vector.
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, intersectionVec);
                        }
                        else {
                            const ingressEndVec = toVectorPath.offsetDistanceAlong(intersectionVec, Math.min(0.00029, Math.max(0, intersectionToVectorStartOffset), toVectorHalfDistanceRad + intersectionToVectorStartOffset), FlightPathTurnCalculator.vector3Cache[3], Math.PI);
                            this.setAnticipatedTurnIngress(toLegCalc, toVectorPath, intersectionVec, ingressEndVec);
                        }
                    }
                }
                return toIndex;
            }
            else {
                intersectionPoint.setFromCartesian(intersectionVec);
                // in this case, the plane effectively needs to make a 180...
                isInside = false;
                turnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
                arcCircleOffsetSign = 1;
                trackPathOffsetSign = trackPath.encircles(arcCenter) ? -1 : 1;
            }
        }
        else {
            // The arc circle and track path are secant.
            let arcStartVec;
            let arcEndVec;
            let fromVectorIntersectionBearing;
            let toVectorIntersectionBearing;
            if (areLegsContinuous) {
                intersectionPoint.set(fromVectorEndPoint);
                Vec3Math.copy(fromVectorEndVec, intersectionVec);
                arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                fromVectorIntersectionBearing = fromVectorEndBearing;
                toVectorIntersectionBearing = toVectorStartBearing;
            }
            else {
                const intersection0FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[0]);
                const intersection0ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[0], toVectorStartVec);
                const intersection1FromVectorEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, fromVectorEndVec, arcTrackIntersections[1]);
                const intersection1ToVectorStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, arcTrackIntersections[1], toVectorStartVec);
                const isIntersection0Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[0], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection0FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection0ToVectorStartOffset);
                const isIntersection1Valid = this.isArcTrackIntersectionValid(arcTrackIntersections[1], fromVectorPath, fromVectorEndVec, fromVectorHalfDistanceRad, intersection1FromVectorEndOffset, toVectorPath, toVectorStartVec, toVectorHalfDistanceRad, intersection1ToVectorStartOffset);
                if (!isIntersection0Valid && !isIntersection1Valid) {
                    this.setEmptyTurn(fromLegCalc, toLegCalc);
                    return toIndex;
                }
                let intersectionIndex;
                if (!isIntersection0Valid) {
                    intersectionIndex = 1;
                }
                else if (!isIntersection1Valid) {
                    intersectionIndex = 0;
                }
                else {
                    // Both intersections are valid. We will bias toward intersections that lie after the end of the from-vector
                    // and before the start of the to-vector.
                    if (intersection0FromVectorEndOffset + intersection0ToVectorStartOffset >= intersection1FromVectorEndOffset + intersection1ToVectorStartOffset) {
                        intersectionIndex = 0;
                    }
                    else {
                        intersectionIndex = 1;
                    }
                }
                if (intersectionIndex === 0) {
                    Vec3Math.copy(arcTrackIntersections[0], intersectionVec);
                    intersectionFromVectorEndOffset = intersection0FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection0ToVectorStartOffset;
                }
                else if (isIntersection1Valid) {
                    Vec3Math.copy(arcTrackIntersections[1], intersectionVec);
                    intersectionFromVectorEndOffset = intersection1FromVectorEndOffset;
                    intersectionToVectorStartOffset = intersection1ToVectorStartOffset;
                }
                intersectionPoint.setFromCartesian(intersectionVec);
                if (isArcFirst) {
                    arcStartVec = GeoPoint.sphericalToCartesian(arc.startLat, arc.startLon, FlightPathTurnCalculator.vector3Cache[3]);
                    arcEndVec = intersectionVec;
                }
                else {
                    arcStartVec = intersectionVec;
                    arcEndVec = GeoPoint.sphericalToCartesian(arc.endLat, arc.endLon, FlightPathTurnCalculator.vector3Cache[4]);
                }
                fromVectorIntersectionBearing = fromVectorPath.bearingAt(intersectionVec, Math.PI);
                toVectorIntersectionBearing = toVectorPath.bearingAt(intersectionVec, Math.PI);
            }
            const arcStartRadial = arcCircle.bearingAt(arcStartVec, Math.PI) + 90;
            const arcEndRadial = arcCircle.bearingAt(arcEndVec, Math.PI) + 90;
            const desiredTurnRadiusRad = UnitType.METER.convertTo(desiredTurnRadius, UnitType.GA_RADIAN);
            isInside = isArcFirst
                ? Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), toVectorIntersectionBearing)) >= 90
                : Math.abs(NavMath.diffAngle(intersectionPoint.bearingFrom(arcCenter), fromVectorIntersectionBearing)) < 90;
            /**
             * Now we must calculate the maximum allowed turn radius such that the turn does not start or end beyond the
             * limits of the arc or track. First, we convert the track limit to a pseudo-arc limit, then take the more
             * restrictive of the pseudo-arc limit and the actual arc limit. This maximally restrictive arc limit is then
             * used to compute the turn radius that would result in a turn which has an endpoint exactly at the limit.
             */
            const turnVertexRadialNormal = GeoCircle.getGreatCircleNormal(arcCenter, intersectionVec, FlightPathTurnCalculator.vector3Cache[5]);
            // If the turn is inside the arc, then clamp track limit distance to half the length of the track path within the
            // arc, since that is the point at which turn radius is maximized.
            const maxTrackLimitDistance = isInside
                ? Math.atan(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)) * Math.tan(arcRadiusRad))
                : Infinity;
            const trackLimitPoint = FlightPathTurnCalculator.geoPointCache[5];
            if (isArcFirst) {
                const trackLimitDistance = Math.min(toVectorHalfDistanceRad + intersectionToVectorStartOffset, maxTrackLimitDistance);
                intersectionPoint.offset(toVectorStartBearing, trackLimitDistance, trackLimitPoint);
            }
            else {
                const trackLimitDistance = Math.min(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset, maxTrackLimitDistance);
                intersectionPoint.offset(fromVectorEndBearing + 180, trackLimitDistance, trackLimitPoint);
            }
            // the great circle which passes through the center of the arc and is perpendicular to the track
            const trackPerpendicularDiameter = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(trackPath.center, arcCircle.center);
            const antipodes = FlightPathTurnCalculator.intersectionVecArrayCache;
            trackPerpendicularDiameter.intersection(arcCircle, antipodes);
            // Compute the great circle which passes through the appropriate antipode and the track limit endpoint. The
            // intersection of this great circle with the arc that is NOT the antipode is the pseudo-arc limit endpoint.
            const intersectingPath = FlightPathTurnCalculator.geoCircleCache[4].setAsGreatCircle(arcDirection === 'left' ? antipodes[0] : antipodes[1], trackLimitPoint);
            const arcIntersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
            const numArcIntersections = intersectingPath.intersectionGeoPoint(arcCircle, arcIntersections);
            let arcLimitAngularWidth = Infinity;
            if (numArcIntersections > 0) {
                const pseudoArcLimitPoint = arcIntersections[0];
                const pseudoArcLimitPointAngle = arcCenter.bearingTo(pseudoArcLimitPoint);
                arcLimitAngularWidth = Math.abs(NavMath.diffAngle((isArcFirst ? arcEndRadial : arcStartRadial), pseudoArcLimitPointAngle));
            }
            let arcTurnRadiusLimit = 0;
            // the angular width of the portion of the arc path from the intersection to the mid-point of the arc vector
            const arcMidPointAngularWidth = Avionics.Utils.RAD2DEG * (isArcFirst
                ? fromVectorPath.angularWidth(fromVectorHalfDistanceRad + intersectionFromVectorEndOffset)
                : toVectorPath.angularWidth(toVectorHalfDistanceRad + intersectionToVectorStartOffset));
            arcLimitAngularWidth = Math.min(arcLimitAngularWidth, arcMidPointAngularWidth);
            if (arcLimitAngularWidth > 0) {
                const arcLimitPointAngle = (isArcFirst ? arcEndRadial : arcStartRadial) + arcLimitAngularWidth * ((arcDirection === 'left') === isArcFirst ? 1 : -1);
                const arcLimitPoint = arcCenter.offset(arcLimitPointAngle, arcRadiusRad, FlightPathTurnCalculator.geoPointCache[5]);
                const arcLimitRadialPath = FlightPathTurnCalculator.geoCircleCache[3].setAsGreatCircle(arcCenter, arcLimitPoint);
                // the angle between the radial to the arc endpoint and the track path (directed away from the arc at the point of intersection)
                const theta = Math.acos(Vec3Math.dot(arcLimitRadialPath.center, trackPath.center) * (isArcFirst === isInside ? -1 : 1));
                if (theta >= Math.PI / 2) {
                    if (isInside) {
                        const d = Math.asin(Math.sin(Math.acos(Math.abs(Vec3Math.dot(trackPath.center, turnVertexRadialNormal)))) * Math.sin(arcRadiusRad));
                        arcTurnRadiusLimit = (arcRadiusRad - d) / 2;
                    }
                    else {
                        arcTurnRadiusLimit = Infinity;
                    }
                }
                else {
                    const arcLimitRadialTrackIntersections = FlightPathTurnCalculator.intersectionVecArrayCache;
                    arcLimitRadialPath.intersection(trackPath, arcLimitRadialTrackIntersections);
                    const arcLimitPointVec = arcLimitPoint.toCartesian(FlightPathTurnCalculator.vector3Cache[5]);
                    const thresholdNormal = Vec3Math.normalize(Vec3Math.cross(arcLimitRadialPath.center, arcLimitPointVec, FlightPathTurnCalculator.vector3Cache[6]), FlightPathTurnCalculator.vector3Cache[6]);
                    const arcLimitRadialTrackIntersection = arcLimitRadialTrackIntersections[Vec3Math.dot(arcLimitRadialTrackIntersections[0], thresholdNormal) >= 0 ? 0 : 1];
                    // cosine of the distance from the arc endpoint to the intersection of the radial to the arc endpoint and the track path
                    const cosD = Vec3Math.dot(arcLimitRadialTrackIntersection, arcLimitPointVec);
                    const sinTheta = Math.sin(theta);
                    const sign = isInside ? -1 : 1;
                    arcTurnRadiusLimit = Math.acos((1 + sinTheta * cosD * sign) / Math.sqrt(1 + 2 * sinTheta * cosD * sign + sinTheta * sinTheta));
                }
            }
            turnRadiusRad = Math.min(desiredTurnRadiusRad, arcTurnRadiusLimit);
            arcCircleOffsetSign = isInside ? -1 : 1;
            trackPathOffsetSign = turnDirection === 'left' ? -1 : 1;
        }
        if (turnRadiusRad <= GeoPoint.EQUALITY_TOLERANCE) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        const arcCircleOffset = FlightPathTurnCalculator.geoCircleCache[3].set(arcCircle.center, arcCircle.radius + turnRadiusRad * arcCircleOffsetSign);
        const trackPathOffset = FlightPathTurnCalculator.geoCircleCache[4].set(trackPath.center, trackPath.radius + turnRadiusRad * trackPathOffsetSign);
        const intersections = FlightPathTurnCalculator.intersectionGeoPointArrayCache;
        const intersectionCount = arcCircleOffset.intersectionGeoPoint(trackPathOffset, FlightPathTurnCalculator.intersectionGeoPointArrayCache);
        if (intersectionCount === 0) {
            this.setEmptyTurn(fromLegCalc, toLegCalc);
            return toIndex;
        }
        let turnCenter;
        if (intersectionCount === 2) {
            if (arcTrackIntersectionCount === 1 || intersectionPoint.distance(intersections[0]) >= intersectionPoint.distance(intersections[1])) {
                turnCenter = intersections[1];
            }
            else {
                turnCenter = intersections[0];
            }
        }
        else {
            turnCenter = intersections[0];
        }
        const arcTangentBearing = (turnCenter.bearingTo(arcCenter) + (arcCircleOffsetSign === 1 ? 0 : 180)) % 360;
        const trackTangentBearing = (turnCenter.bearingTo(trackPathNormalPoint) + (trackPathOffsetSign === 1 ? 0 : 180)) % 360;
        const turnStartBearing = isArcFirst ? arcTangentBearing : trackTangentBearing;
        const turnEndBearing = isArcFirst ? trackTangentBearing : arcTangentBearing;
        let turnAngularDelta = turnEndBearing - turnStartBearing;
        if (turnDirection === 'right' && turnEndBearing <= turnStartBearing) {
            turnAngularDelta += 360;
        }
        else if (turnDirection === 'left' && turnEndBearing >= turnStartBearing) {
            turnAngularDelta -= 360;
        }
        const turnMiddleBearing = ((turnStartBearing + turnAngularDelta / 2) + 360) % 360;
        const turnStart = turnCenter.offset(turnStartBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[0]);
        const turnEnd = turnCenter.offset(turnEndBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[1]);
        const turnMiddle = turnCenter.offset(turnMiddleBearing, turnRadiusRad, FlightPathTurnCalculator.geoPointCache[2]);
        const turnRadiusMeters = UnitType.GA_RADIAN.convertTo(turnRadiusRad, UnitType.METER);
        this.setAnticipatedTurn(fromLegCalc, toLegCalc, turnDirection, turnRadiusMeters, turnCenter, turnStart, turnMiddle, turnEnd, areLegsContinuous);
        // If the from- and to- legs are not continuous, then we need to check if we need to extend the turn anticipation
        // path beyond the turn vector to join the from- and to- vectors. If the legs are continuous, we don't need to
        // check because the turn vector is guaranteed to begin before the end of the from-vector and end after the start
        // of the to-vector.
        if (!areLegsContinuous) {
            const intersectionTurnStartOffset = FlightPathTurnCalculator.getAlongCircleOffset(fromVectorPath, turnStart, intersectionVec);
            const intersectionTurnEndOffset = FlightPathTurnCalculator.getAlongCircleOffset(toVectorPath, intersectionVec, turnEnd);
            if (intersectionTurnStartOffset > intersectionFromVectorEndOffset + 1e-5) {
                // The turn begins after the end of the from-vector. We need to join the turn vector to the end of the
                // from-vector.
                Object.assign((_a = (_c = fromLegCalc.egress)[1]) !== null && _a !== void 0 ? _a : (_c[1] = FlightPathUtils.createEmptyCircleVector()), fromLegCalc.egress[0]);
                FlightPathUtils.setCircleVector(fromLegCalc.egress[0], fromVectorPath, fromVectorEndPoint, turnStart, fromLegCalc.egress[0].flags);
                fromLegCalc.egress.length = 2;
            }
            else {
                fromLegCalc.egress.length = 1;
            }
            if (intersectionTurnEndOffset < intersectionToVectorStartOffset - 1e-5) {
                // The turn ends before the start of the to-vector. We need to join the turn vector to the start of the
                // to-vector.
                (_b = (_d = toLegCalc.ingress)[1]) !== null && _b !== void 0 ? _b : (_d[1] = FlightPathUtils.createEmptyCircleVector());
                FlightPathUtils.setCircleVector(toLegCalc.ingress[1], toVectorPath, turnEnd, toVectorStartPoint, toLegCalc.ingress[0].flags);
                toLegCalc.ingress.length = 2;
            }
            else {
                toLegCalc.ingress.length = 1;
            }
        }
        return toIndex;
    }
    /**
     * Checks if an intersection between an arc path and a track path is valid for computing turn anticipation between
     * arc and track vectors. The intersection is considered valid if and only if all the following conditions are true:
     * - The intersection is within one nautical mile of the end of the vector on which the turn begins.
     * - The intersection is within one nautical mile of the start of the vector on which the turn ends.
     * - The intersection is located after the mid-point of the vector on which the turn begins.
     * - The intersection is located before the mid-point of the vector on which the turn ends.
     * @param intersection The intersection to check.
     * @param fromVectorPath A geo circle defining the path of the vector on which the turn begins.
     * @param fromVectorEnd The end point of the vector on which the turn begins.
     * @param fromVectorHalfDistance Half of the distance covered by the vector on which the turn begins.
     * @param intersectionFromVectorEndOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the end point of the vector on which the turn begins. Positive offsets indicate the intersection is located
     * after the end point.
     * @param toVectorPath A geo circle defining the path of the vector on which the turn ends.
     * @param toVectorStart The start point of the vector on which the turn ends.
     * @param toVectorHalfDistance Half of the distance covered by the vector on which the turn ends.
     * @param intersectionToVectorStartOffset The along-vector offset distance, in great-arc radians, of the intersection
     * from the start point of the vector on which the turn ends. Positive offsets indicate the intersection is located
     * before the start point.
     * @returns Whether the specified intersection is valid for computing turn anticipation between arc and track
     * vectors.
     */
    isArcTrackIntersectionValid(intersection, fromVectorPath, fromVectorEnd, fromVectorHalfDistance, intersectionFromVectorEndOffset, toVectorPath, toVectorStart, toVectorHalfDistance, intersectionToVectorStartOffset) {
        const fromVectorMidVec = fromVectorPath.offsetDistanceAlong(fromVectorEnd, -fromVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[0], Math.PI);
        const toVectorMidVec = toVectorPath.offsetDistanceAlong(toVectorStart, toVectorHalfDistance, FlightPathTurnCalculator.isArcTrackIntersectionValidCache.vec3[1], Math.PI);
        return (Math.abs(intersectionFromVectorEndOffset) <= 2.9e-4
            && Math.abs(intersectionToVectorStartOffset) <= 2.9e-4
            && FlightPathUtils.isPointAlongArc(fromVectorPath, fromVectorMidVec, Math.PI, intersection)
            && !FlightPathUtils.isPointAlongArc(toVectorPath, toVectorMidVec, Math.PI, intersection));
    }
    /**
     * Removes all ingress and egress flight path vectors from a pair of legs at their junction.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     */
    setEmptyTurn(fromLegCalc, toLegCalc) {
        fromLegCalc.egress.length = 0;
        fromLegCalc.egressJoinIndex = -1;
        toLegCalc.ingress.length = 0;
        toLegCalc.ingressJoinIndex = -1;
    }
    /**
     * Adds flight path vectors to a pair of legs for an anticipated leg to leg turn.
     * @param fromLegCalc The calculations for the leg on which the turn begins.
     * @param toLegCalc The calculations for the leg on which the turn ends.
     * @param direction The direction of the turn.
     * @param radius The radius of the turn, in meters.
     * @param center The location of the center of the turn.
     * @param start The location of the start of the turn.
     * @param middle The location of the midpoint of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressEgressArrayLengths Whether to set the ingress and egress vector array lengths to 1. Defaults to
     * `true`.
     */
    setAnticipatedTurn(fromLegCalc, toLegCalc, direction, radius, center, start, middle, end, setIngressEgressArrayLengths = true) {
        const circle = FlightPathUtils.getTurnCircle(center, UnitType.METER.convertTo(radius, UnitType.GA_RADIAN), direction, FlightPathTurnCalculator.setAnticipatedTurnCache.geoCircle[0]);
        this.setAnticipatedTurnEgress(fromLegCalc, circle, start, middle, setIngressEgressArrayLengths);
        this.setAnticipatedTurnIngress(toLegCalc, circle, middle, end, setIngressEgressArrayLengths);
    }
    /**
     * Adds an egress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn begins.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the turn.
     * @param end The location of the end of the egress portion of the turn.
     * @param setEgressArrayLength Whether to set the egress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnEgress(legCalc, circle, start, end, setEgressArrayLength = true) {
        var _a;
        var _b;
        const egress = (_a = (_b = legCalc.egress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setEgressArrayLength) {
            legCalc.egress.length = 1;
        }
        legCalc.egressJoinIndex = legCalc.flightPath.length - 1;
        const egressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.egressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(egress, circle, start, end, egressFlags);
    }
    /**
     * Adds an ingress flight path vector to a leg for an anticipated leg to leg turn.
     * @param legCalc The calculations for the leg on which the turn ends.
     * @param circle The geo circle describing the turn path.
     * @param start The location of the start of the ingress portion of the turn.
     * @param end The location of the end of the turn.
     * @param setIngressArrayLength Whether to set the ingress vector array length to 1. Defaults to `true`.
     */
    setAnticipatedTurnIngress(legCalc, circle, start, end, setIngressArrayLength = true) {
        var _a;
        var _b;
        const ingress = (_a = (_b = legCalc.ingress)[0]) !== null && _a !== void 0 ? _a : (_b[0] = FlightPathUtils.createEmptyCircleVector());
        if (setIngressArrayLength) {
            legCalc.ingress.length = 1;
        }
        legCalc.ingressJoinIndex = 0;
        const ingressFlags = FlightPathVectorFlags.LegToLegTurn
            | FlightPathVectorFlags.AnticipatedTurn
            | (legCalc.flightPath[legCalc.ingressJoinIndex].flags & FlightPathVectorFlags.Fallback);
        FlightPathUtils.setCircleVector(ingress, circle, start, end, ingressFlags);
    }
    /**
     * Gets the along-circle offset distance from a reference point to a query point, in great-arc radians. The offset
     * is signed, with positive values indicating offsets in the direction of the circle. The calculated offset has the
     * range `[-c / 2, c / 2)`, where `c` is the circumference of the circle.
     * @param circle The geo circle along which to measure the offset.
     * @param reference The reference point.
     * @param query The query point.
     * @param equalityTolerance The tolerance for considering the reference and query points to be equal, in great-arc
     * radians. If the absolute (direction-agnostic) along-circle distance between the reference and query points is less
     * than or equal to this value, then zero will be returned. Defaults to `0`.
     * @returns The along-circle offset distance from the specified reference point to the query point, in great-arc
     * radians.
     */
    static getAlongCircleOffset(circle, reference, query, equalityTolerance) {
        const circumference = circle.arcLength(MathUtils.TWO_PI);
        const halfCircumference = circumference / 2;
        return (circle.distanceAlong(reference, query, Math.PI, equalityTolerance) + halfCircumference) % circumference - halfCircumference;
    }
}
FlightPathTurnCalculator.vector3Cache = [
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
    new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3),
];
FlightPathTurnCalculator.geoPointCache = [
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0),
    new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)
];
FlightPathTurnCalculator.geoCircleCache = [
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0),
    new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)
];
FlightPathTurnCalculator.intersectionVecArrayCache = [new Float64Array(3), new Float64Array(3)];
FlightPathTurnCalculator.intersectionGeoPointArrayCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
FlightPathTurnCalculator.isArcTrackIntersectionValidCache = {
    vec3: [Vec3Math.create(), Vec3Math.create()]
};
FlightPathTurnCalculator.setAnticipatedTurnCache = {
    geoPoint: [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)],
    geoCircle: [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)]
};

/**
 * Modes for calculating airplane speed for use in flight path calculations.
 */
var FlightPathAirplaneSpeedMode;
(function (FlightPathAirplaneSpeedMode) {
    /** The default airplane speed is always used. */
    FlightPathAirplaneSpeedMode["Default"] = "Default";
    /** Ground speed is used. */
    FlightPathAirplaneSpeedMode["GroundSpeed"] = "GroundSpeed";
    /** True airspeed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeed"] = "TrueAirspeed";
    /** True airspeed plus wind speed is used. */
    FlightPathAirplaneSpeedMode["TrueAirspeedPlusWind"] = "TrueAirspeedPlusWind";
})(FlightPathAirplaneSpeedMode || (FlightPathAirplaneSpeedMode = {}));
/**
 * Calculates the flight path vectors for a given set of legs.
 */
class FlightPathCalculator {
    /**
     * Creates an instance of the FlightPathCalculator.
     * @param facilityLoader The facility loader to use with this instance.
     * @param options The options to use with this flight path calculator.
     * @param bus An instance of the EventBus.
     */
    constructor(facilityLoader, options, bus) {
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        this.facilityCache = new Map();
        this.legCalculatorMap = this.createLegCalculatorMap();
        this.turnCalculator = new FlightPathTurnCalculator();
        this.state = new FlightPathStateClass();
        this.calculateQueue = [];
        this.isBusy = false;
        this.options = Object.assign({}, options);
        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
        this.bus.getSubscriber().on('flightpath_set_options').handle(newOptions => this.setOptions(newOptions));
    }
    /**
     * Method to update this calculator's options.
     * @param newOptions A Partial FlightPathCalculatorOptions object.
     */
    setOptions(newOptions) {
        for (const key in newOptions) {
            const option = newOptions[key];
            if (option !== undefined) {
                this.options[key] = option;
                switch (key) {
                    case 'bankAngle':
                        this.bankAngleTable = this.buildBankAngleTable(this.options.bankAngle);
                        break;
                    case 'holdBankAngle':
                        this.holdBankAngleTable = this.options.holdBankAngle === null ? undefined : this.buildBankAngleTable(this.options.holdBankAngle);
                        break;
                    case 'courseReversalBankAngle':
                        this.courseReversalBankAngleTable = this.options.courseReversalBankAngle === null ? undefined : this.buildBankAngleTable(this.options.courseReversalBankAngle);
                        break;
                    case 'turnAnticipationBankAngle':
                        this.turnAnticipationBankAngleTable = this.options.turnAnticipationBankAngle === null ? undefined : this.buildBankAngleTable(this.options.turnAnticipationBankAngle);
                        break;
                }
            }
        }
    }
    /**
     * Builds a bank angle lookup table.
     * @param angle A constant bank angle, in degrees, or an array of bank angle (degrees) versus airplane speed (knots)
     * breakpoints.
     * @returns A bank angle lookup table.
     */
    buildBankAngleTable(angle) {
        if (typeof angle === 'number') {
            return new LerpLookupTable([[angle, 0]]);
        }
        else {
            return new LerpLookupTable(angle);
        }
    }
    /**
     * Creates a map from leg types to leg calculators.
     * @returns A map from leg types to leg calculators.
     */
    createLegCalculatorMap() {
        let calc;
        return {
            [LegType.Unknown]: calc = new TrackToFixLegCalculator(this.facilityCache),
            [LegType.IF]: calc,
            [LegType.TF]: calc,
            [LegType.AF]: new ArcToFixLegCalculator(this.facilityCache),
            [LegType.CD]: calc = new CourseToDmeLegCalculator(this.facilityCache),
            [LegType.VD]: calc,
            [LegType.CF]: new CourseToFixLegCalculator(this.facilityCache),
            [LegType.CR]: calc = new CourseToRadialLegCalculator(this.facilityCache),
            [LegType.VR]: calc,
            [LegType.FC]: new TrackFromFixLegCalculator(this.facilityCache),
            [LegType.FD]: new FixToDmeLegCalculator(this.facilityCache),
            [LegType.RF]: new RadiusToFixLegCalculator(this.facilityCache),
            [LegType.DF]: new DirectToFixLegCalculator(this.facilityCache),
            [LegType.FA]: calc = new CourseToAltitudeLegCalculator(this.facilityCache),
            [LegType.CA]: calc,
            [LegType.VA]: calc,
            [LegType.FM]: calc = new CourseToManualLegCalculator(this.facilityCache),
            [LegType.VM]: calc,
            [LegType.CI]: calc = new CourseToInterceptLegCalculator(this.facilityCache),
            [LegType.VI]: calc,
            [LegType.PI]: new ProcedureTurnLegCalculator(this.facilityCache),
            [LegType.HA]: calc = new HoldLegCalculator(this.facilityCache),
            [LegType.HM]: calc,
            [LegType.HF]: calc,
            [LegType.Discontinuity]: calc = new NoPathLegCalculator(this.facilityCache),
            [LegType.ThruDiscontinuity]: calc
        };
    }
    /**
     * Calculates a flight path for a given set of flight plan legs.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculation is finished.
     */
    calculateFlightPath(legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        if (this.isBusy || this.calculateQueue.length > 0) {
            return new Promise((resolve, reject) => {
                this.calculateQueue.push(() => { this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count); });
            });
        }
        else {
            return new Promise((resolve, reject) => {
                this.doCalculate(resolve, reject, legs, activeLegIndex, initialIndex, count);
            });
        }
    }
    /**
     * Executes a calculate operation. When the operation is finished, the next operation in the queue, if one exists,
     * will be started.
     * @param resolve The Promise resolve function to invoke when the calculation is finished.
     * @param reject The Promise reject function to invoke when an error occurs during calculation.
     * @param legs The legs of the flight plan to calculate.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the leg at which to start the calculation.
     * @param count The number of legs to calculate.
     * @returns A Promise which is fulfilled when the calculate operation is finished, or rejected if an error occurs
     * during calculation.
     */
    async doCalculate(resolve, reject, legs, activeLegIndex, initialIndex = 0, count = Number.POSITIVE_INFINITY) {
        this.isBusy = true;
        try {
            initialIndex = Math.max(0, initialIndex);
            count = Math.max(0, Math.min(legs.length - initialIndex, count));
            this.state.updatePlaneState(this.options, this.bankAngleTable, this.holdBankAngleTable, this.courseReversalBankAngleTable, this.turnAnticipationBankAngleTable);
            // Because some facilities can be mutated, we always want to get the most up-to-date version from the facility loader
            this.facilityCache.clear();
            await this.loadFacilities(legs, initialIndex, count);
            this.initCurrentLatLon(legs, initialIndex);
            this.initCurrentCourse(legs, initialIndex);
            this.initIsFallback(legs, initialIndex);
            this.calculateLegPaths(legs, activeLegIndex, initialIndex, count);
            this.turnCalculator.computeTurns(legs, initialIndex, count, this.state.desiredTurnRadius.asUnit(UnitType.METER), this.state.desiredCourseReversalTurnRadius.asUnit(UnitType.METER), this.state.desiredTurnAnticipationTurnRadius.asUnit(UnitType.METER));
            this.resolveLegsIngressToEgress(legs, initialIndex, count);
            this.updateLegDistances(legs, initialIndex, count);
            this.isBusy = false;
            resolve();
        }
        catch (e) {
            this.isBusy = false;
            reject(e);
        }
        const nextInQueue = this.calculateQueue.shift();
        if (nextInQueue !== undefined) {
            nextInQueue();
        }
    }
    /**
     * Loads facilities required for flight path calculations from the flight plan.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    async loadFacilities(legs, initialIndex, count) {
        const facilityPromises = [];
        for (let i = initialIndex; i < initialIndex + count; i++) {
            this.stageFacilityLoad(legs[i].leg.fixIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.originIcao, facilityPromises);
            this.stageFacilityLoad(legs[i].leg.arcCenterFixIcao, facilityPromises);
        }
        if (facilityPromises.length > 0) {
            await Promise.all(facilityPromises);
        }
    }
    /**
     * Stages a facility to be loaded.
     * @param icao The ICAO of the facility.
     * @param facilityPromises The array of facility load promises to push to.
     */
    stageFacilityLoad(icao, facilityPromises) {
        if (ICAO.isFacility(icao)) {
            facilityPromises.push(this.facilityLoader.getFacility(ICAO.getFacilityType(icao), icao)
                .then(facility => {
                this.facilityCache.set(icao, facility);
                return true;
            })
                .catch(() => false));
        }
    }
    /**
     * Initializes the current lat/lon.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentLatLon(legs, initialIndex) {
        var _a;
        var _b;
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) || FlightPlanUtils.isManualDiscontinuityLeg(leg.leg.type)) {
                break;
            }
            const calc = leg.calculated;
            if (calc && calc.endLat !== undefined && calc.endLon !== undefined) {
                ((_a = (_b = this.state).currentPosition) !== null && _a !== void 0 ? _a : (_b.currentPosition = new GeoPoint(0, 0))).set(calc.endLat, calc.endLon);
                return;
            }
        }
        this.state.currentPosition = undefined;
    }
    /**
     * Initializes the current course.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initCurrentCourse(legs, initialIndex) {
        let index = Math.min(initialIndex, legs.length);
        while (--index >= 0) {
            const leg = legs[index];
            if (leg.leg.type === LegType.Discontinuity || leg.leg.type === LegType.ThruDiscontinuity) {
                return;
            }
            const legCalc = leg.calculated;
            if (legCalc && legCalc.flightPath.length > 0) {
                this.state.currentCourse = FlightPathUtils.getLegFinalCourse(legCalc);
                if (this.state.currentCourse !== undefined) {
                    return;
                }
            }
        }
        this.state.currentCourse = undefined;
    }
    /**
     * Initializes the fallback state.
     * @param legs The legs of the flight plan to calculate.
     * @param initialIndex The index of the first leg to calculate.
     */
    initIsFallback(legs, initialIndex) {
        var _a, _b, _c;
        this.state.isFallback = (_c = (_b = (_a = legs[Math.min(initialIndex, legs.length) - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.endsInFallback) !== null && _c !== void 0 ? _c : false;
    }
    /**
     * Calculates flight paths for a sequence of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param activeLegIndex The index of the active leg.
     * @param initialIndex The index of the first leg to calculate.
     * @param count The number of legs to calculate.
     */
    calculateLegPaths(legs, activeLegIndex, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            this.calculateLegPath(legs, i, activeLegIndex);
        }
    }
    /**
     * Calculates a flight path for a leg in a sequence of legs.
     * @param legs A sequence of flight plan legs.
     * @param calculateIndex The index of the leg to calculate.
     * @param activeLegIndex The index of the active leg.
     */
    calculateLegPath(legs, calculateIndex, activeLegIndex) {
        const definition = legs[calculateIndex];
        const calcs = this.legCalculatorMap[definition.leg.type].calculate(legs, calculateIndex, activeLegIndex, this.state, false);
        const start = calcs.flightPath[0];
        const end = calcs.flightPath[calcs.flightPath.length - 1];
        calcs.initialDtk = undefined;
        if (start !== undefined) {
            const trueDtk = FlightPathUtils.getVectorInitialCourse(start);
            if (!isNaN(trueDtk)) {
                calcs.initialDtk = MagVar.trueToMagnetic(trueDtk, start.startLat, start.startLon);
            }
        }
        calcs.startLat = start === null || start === void 0 ? void 0 : start.startLat;
        calcs.startLon = start === null || start === void 0 ? void 0 : start.startLon;
        calcs.endLat = end === null || end === void 0 ? void 0 : end.endLat;
        calcs.endLon = end === null || end === void 0 ? void 0 : end.endLon;
        if (!end && this.state.currentPosition) {
            calcs.endLat = this.state.currentPosition.lat;
            calcs.endLon = this.state.currentPosition.lon;
        }
    }
    /**
     * Resolves the ingress to egress vectors for a set of flight plan legs.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to resolve.
     * @param count The number of legs to resolve.
     */
    resolveLegsIngressToEgress(legs, initialIndex, count) {
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const legCalc = legs[i].calculated;
            legCalc && FlightPathUtils.resolveIngressToEgress(legCalc);
        }
    }
    /**
     * Updates leg distances with turn anticipation.
     * @param legs A sequence of flight plan legs.
     * @param initialIndex The index of the first leg to update.
     * @param count The number of legs to update.
     */
    updateLegDistances(legs, initialIndex, count) {
        var _a, _b, _c, _d, _e, _f;
        const end = initialIndex + count;
        for (let i = initialIndex; i < end; i++) {
            const leg = legs[i];
            const calc = leg.calculated;
            // Calculate distance without transitions
            calc.distance = 0;
            const len = calc.flightPath.length;
            for (let j = 0; j < len; j++) {
                calc.distance += calc.flightPath[j].distance;
            }
            calc.cumulativeDistance = calc.distance + ((_c = (_b = (_a = legs[i - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance) !== null && _c !== void 0 ? _c : 0);
            // Calculate distance with transitions
            calc.distanceWithTransitions = 0;
            const ingressLen = calc.ingress.length;
            for (let j = 0; j < ingressLen; j++) {
                calc.distanceWithTransitions += calc.ingress[j].distance;
            }
            const ingressToEgressLen = calc.ingressToEgress.length;
            for (let j = 0; j < ingressToEgressLen; j++) {
                calc.distanceWithTransitions += calc.ingressToEgress[j].distance;
            }
            const egressLen = calc.egress.length;
            for (let j = 0; j < egressLen; j++) {
                calc.distanceWithTransitions += calc.egress[j].distance;
            }
            calc.cumulativeDistanceWithTransitions = calc.distanceWithTransitions + ((_f = (_e = (_d = legs[i - 1]) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
    }
}
/**
 * An implementation of {@link FlightPathState}
 */
class FlightPathStateClass {
    constructor() {
        this.isFallback = false;
        this._planePosition = new GeoPoint(0, 0);
        this.planePosition = this._planePosition.readonly;
        this._planeHeading = 0;
        this._planeAltitude = UnitType.FOOT.createNumber(0);
        this.planeAltitude = this._planeAltitude.readonly;
        this._planeSpeed = UnitType.KNOT.createNumber(0);
        this.planeSpeed = this._planeSpeed.readonly;
        this._planeClimbRate = UnitType.FPM.createNumber(0);
        this.planeClimbRate = this._planeClimbRate.readonly;
        this._desiredTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnRadius = this._desiredTurnRadius.readonly;
        this._desiredHoldTurnRadius = UnitType.METER.createNumber(0);
        this.desiredHoldTurnRadius = this._desiredHoldTurnRadius.readonly;
        this._desiredCourseReversalTurnRadius = UnitType.METER.createNumber(0);
        this.desiredCourseReversalTurnRadius = this._desiredCourseReversalTurnRadius.readonly;
        this._desiredTurnAnticipationTurnRadius = UnitType.METER.createNumber(0);
        this.desiredTurnAnticipationTurnRadius = this._desiredTurnAnticipationTurnRadius.readonly;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get planeHeading() {
        return this._planeHeading;
    }
    /**
     * Updates this state with the latest information on the airplane.
     * @param options Flight path calculator options.
     * @param bankAngleTable A lookup table for general turn bank angle, in degrees, versus airplane speed.
     * @param holdBankAngleTable A lookup table for hold turn bank angle, in degrees, versus airplane speed, in knots.
     * If not defined, the general turn bank angle table will be used instead.
     * @param courseReversalBankAngleTable A lookup table for course reversal turn bank angle, in degrees, versus
     * airplane speed, in knots. If not defined, the general turn bank angle table will be used instead.
     * @param turnAnticipationBankAngleTable A lookup table for turn anticipation bank angle, in degrees, versus airplane
     * speed, in knots. If not defined, the general turn bank angle table will be used instead.
     */
    updatePlaneState(options, bankAngleTable, holdBankAngleTable, courseReversalBankAngleTable, turnAnticipationBankAngleTable) {
        this._planePosition.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        this._planeAltitude.set(SimVar.GetSimVarValue('INDICATED ALTITUDE', 'feet'));
        this._planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degree');
        switch (options.airplaneSpeedMode) {
            case FlightPathAirplaneSpeedMode.GroundSpeed:
                this._planeSpeed.set(Math.max(SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots), options.defaultSpeed));
                break;
            case FlightPathAirplaneSpeedMode.TrueAirspeed:
            case FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind: {
                const trueAirspeed = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
                const windSpeed = options.airplaneSpeedMode === FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
                    ? SimVar.GetSimVarValue('AMBIENT WIND VELOCITY', SimVarValueType.Knots)
                    : 0;
                this._planeSpeed.set(Math.max(trueAirspeed + windSpeed, options.defaultSpeed));
                break;
            }
            default:
                this._planeSpeed.set(options.defaultSpeed);
        }
        this._planeClimbRate.set(Math.max(SimVar.GetSimVarValue('VERTICAL SPEED', 'feet per minute'), options.defaultClimbRate));
        const planeSpeedKnots = this._planeSpeed.asUnit(UnitType.KNOT);
        this._desiredTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(bankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        if (holdBankAngleTable) {
            this._desiredHoldTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(holdBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredHoldTurnRadius.set(this._desiredTurnRadius);
        }
        if (courseReversalBankAngleTable) {
            this._desiredCourseReversalTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(courseReversalBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredCourseReversalTurnRadius.set(this._desiredTurnRadius);
        }
        if (turnAnticipationBankAngleTable) {
            this._desiredTurnAnticipationTurnRadius.set(NavMath.turnRadius(planeSpeedKnots, Math.min(turnAnticipationBankAngleTable.get(planeSpeedKnots), options.maxBankAngle)));
        }
        else {
            this._desiredTurnAnticipationTurnRadius.set(this._desiredTurnRadius);
        }
    }
}

var LegEventType;
(function (LegEventType) {
    LegEventType["Added"] = "Added";
    LegEventType["Removed"] = "Removed";
    LegEventType["Changed"] = "Changed";
})(LegEventType || (LegEventType = {}));
var SegmentEventType;
(function (SegmentEventType) {
    SegmentEventType["Added"] = "Added";
    SegmentEventType["Removed"] = "Removed";
    SegmentEventType["Changed"] = "Changed";
    SegmentEventType["Inserted"] = "Inserted";
})(SegmentEventType || (SegmentEventType = {}));
var ActiveLegType;
(function (ActiveLegType) {
    ActiveLegType["Lateral"] = "Lateral";
    ActiveLegType["Vertical"] = "Vertical";
    ActiveLegType["Calculating"] = "Calculating";
})(ActiveLegType || (ActiveLegType = {}));
var OriginDestChangeType;
(function (OriginDestChangeType) {
    OriginDestChangeType["OriginAdded"] = "OriginAdded";
    OriginDestChangeType["OriginRemoved"] = "OriginRemoved";
    OriginDestChangeType["DestinationAdded"] = "DestinationAdded";
    OriginDestChangeType["DestinationRemoved"] = "DestinationRemoved";
})(OriginDestChangeType || (OriginDestChangeType = {}));
/**
 * A flight plan managed by the flight plan system.
 */
class FlightPlan {
    /**
     * Creates an instance of a FlightPlan.
     * @param planIndex The index within the flight planner of this flight plan.
     * @param calculator The flight path calculator to use to calculate the flight path.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(planIndex, calculator, onLegNameRequested) {
        this.planIndex = planIndex;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        this._activeLateralLeg = 0;
        this._activeVerticalLeg = 0;
        this._activeCalculatingLeg = 0;
        /** The direct to metadata for this plan. */
        this.directToData = { segmentIndex: -1, segmentLegIndex: -1 };
        /** Events fired when the plan is modified. */
        this.events = {};
        /** The details about the selected procedures. */
        this.procedureDetails = new ProcedureDetails();
        /** The flight plan segments that make up this flight plan. */
        this.planSegments = [];
        /** User assignable data. */
        this.userData = {};
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the origin airport in the flight plan, if any. */
    get originAirport() {
        return this._originAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The ICAO of the destination airport in the flight plan, if any. */
    get destinationAirport() {
        return this._destinationAirport;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active lateral navigation leg. */
    get activeLateralLeg() {
        return this._activeLateralLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active vertical navigation leg. */
    get activeVerticalLeg() {
        return this._activeVerticalLeg;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The global index of the currently active calculating leg. */
    get activeCalculatingLeg() {
        return this._activeCalculatingLeg;
    }
    /**
     * Gets the current number of legs in the flight plan.
     * @returns The number of legs in the plan.
     */
    get length() {
        const segment = this.planSegments[this.planSegments.length - 1];
        if (segment !== undefined) {
            return segment.offset + segment.legs.length;
        }
        return 0;
    }
    /**
     * Gets the current number of segments in the flight plan.
     * @returns The number of legs in the plan.
     */
    get segmentCount() {
        return this.planSegments.length;
    }
    /**
     * Gets this flight plan's legs.
     * @param reverse Whether to get the legs in reverse order. False by default.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
     * `false` or `this.length` if `reverse` is `true`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
     * is `false` or `-1` if `reverse` is `true`.
     * @returns A generator which yields this flight plan's legs.
     */
    legs(reverse = false, startIndex, endIndex) {
        return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
    }
    /**
     * Gets this flight plan's legs in forward order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
     * @yields This flight plan's legs in forward order.
     */
    *_legs(startIndex = 0, endIndex = this.length) {
        endIndex = Math.min(this.length, endIndex);
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.min(segment.legs.length, endIndex - segment.offset);
                if (end <= 0) {
                    return;
                }
                for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets this flight plan's legs in reverse order.
     * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
     * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
     * @yields This flight plan's legs in reverse order.
     */
    *_legsReverse(startIndex = this.length - 1, endIndex = -1) {
        endIndex = Math.max(-1, endIndex);
        for (let i = this.planSegments.length - 1; i > -1; i--) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.legs.length > 0) {
                const end = Math.max(-1, endIndex - segment.offset);
                if (end >= segment.legs.length) {
                    return;
                }
                for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
                    yield segment.legs[l];
                }
            }
        }
    }
    /**
     * Gets the segments for the flightplan.
     * @yields The flight plan segments.
     */
    *segments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined) {
                yield segment;
            }
        }
    }
    /**
     * Gets all of the segments of a given type.
     * @param segmentType The type of the segments to retrieve.
     * @yields The segments of the requested type.
     */
    *segmentsOfType(segmentType) {
        for (const segment of this.segments()) {
            if (segment.segmentType == segmentType) {
                yield segment;
            }
        }
    }
    /**
     * Adds a segment to the flight plan at a specified index.
     * @param segmentIndex The index of the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any.
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    addSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
        this.planSegments[segmentIndex] = segment;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment);
        return segment;
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    insertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segment !== undefined) {
            const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
            this.planSegments.splice(segmentIndex, 0, newSegment);
            this.reflowSegments();
            this.reflowSegmentOffsets();
            notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment);
            return newSegment;
        }
        else {
            return this.addSegment(segmentIndex, segmentType, airway, notify);
        }
    }
    /**
     * Reflows the flight plan segments after an insert.
     */
    reflowSegments() {
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment !== undefined && segment.segmentIndex !== i) {
                segment.segmentIndex = i;
            }
        }
    }
    /**
     * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    deleteSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        if (segmentIndex === this.planSegments.length - 1) {
            this.planSegments.splice(segmentIndex, 1);
        }
        else {
            delete this.planSegments[segmentIndex];
        }
        if (this.directToData.segmentIndex === segmentIndex) ;
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeSegment(segmentIndex, notify = true) {
        const segment = this.planSegments[segmentIndex];
        this.planSegments.splice(segmentIndex, 1);
        this.reflowSegments();
        this.reflowSegmentOffsets();
        notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment);
    }
    /**
     * Gets a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment.
     * @throws An error if the flight plan segment could not be found.
     */
    getSegment(segmentIndex) {
        const segment = this.tryGetSegment(segmentIndex);
        if (segment === null) {
            throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
        }
        else {
            return segment;
        }
    }
    /**
     * Attempts to get a flight plan segment from the plan.
     * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
     * @returns The requested flight plan segment, or `null` if it could not be found.
     */
    tryGetSegment(segmentIndex) {
        if (segmentIndex === undefined) {
            let calculatedSegmentIndex = 0;
            for (const segment of this.segments()) {
                if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
                    calculatedSegmentIndex++;
                }
                else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
                    calculatedSegmentIndex++;
                }
                else {
                    break;
                }
            }
            const segment = this.planSegments[calculatedSegmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        else if (segmentIndex >= 0) {
            const segment = this.planSegments[segmentIndex];
            if (segment !== undefined) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was added.
     */
    addLeg(segmentIndex, leg, segmentLegIndex, flags = 0, notify = true) {
        const segment = this.getSegment(segmentIndex);
        const legDefinition = {
            name: this.onLegNameRequested(leg),
            leg,
            flags,
            verticalData: {
                phase: VerticalFlightPhase.Descent,
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS,
            }
        };
        if (segmentLegIndex === undefined) {
            segment.legs.push(legDefinition);
            segmentLegIndex = segment.legs.length - 1;
        }
        else {
            segment.legs.splice(segmentLegIndex, 0, legDefinition);
        }
        this.reflowSegmentOffsets();
        notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition);
        return legDefinition;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLeg(arg1, arg2) {
        const leg = this._tryGetLeg(arg1, arg2);
        if (leg) {
            return leg;
        }
        throw new Error(`Leg with ${arg2 === undefined ? `index ${arg1}` : `segmentIndex ${arg1}, segmentLegIndex ${arg2}`} could not be found.`);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    tryGetLeg(arg1, arg2) {
        return this._tryGetLeg(arg1, arg2);
    }
    /**
     * Attempts to get a leg from the flight plan.
     * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
     * @param arg2 The index of the leg to get in its segment.
     * @returns A flight plan leg, or `null` if one could not be found at the specified index.
     */
    _tryGetLeg(arg1, arg2) {
        var _a, _b;
        if (arg2 === undefined) {
            const legIndex = arg1;
            for (const segment of this.segments()) {
                if (segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
                    return segment.legs[legIndex - segment.offset];
                }
            }
            return null;
        }
        else {
            const segmentIndex = arg1;
            const segmentLegIndex = arg2;
            return (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs[segmentLegIndex]) !== null && _b !== void 0 ? _b : null;
        }
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
     * @param notify Whether or not to send notifications after the operation.
     * @returns the leg that was removed, or null if a leg was not removed.
     */
    removeLeg(segmentIndex, segmentLegIndex, notify = true) {
        const segment = this.getSegment(segmentIndex);
        let legDefinition;
        if (segmentLegIndex === undefined) {
            legDefinition = segment.legs.pop();
            segmentLegIndex = segment.legs.length;
        }
        else {
            const deleted = segment.legs.splice(segmentLegIndex, 1);
            legDefinition = deleted[0];
        }
        if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) ;
        this.reflowSegmentOffsets();
        notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition);
        return legDefinition !== null && legDefinition !== void 0 ? legDefinition : null;
    }
    /**
     * Calculates the flight path for the plan.
     * @param globalLegIndex The global leg index to start calculating from.
     * @param notify Whether or not to send notifications after the operation.
     */
    async calculate(globalLegIndex, notify = true) {
        const legs = [...this.legs()];
        await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
        notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex);
    }
    /**
     * Sets the origin airport in the flight plan.
     * @param facilityIcao The origin airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setOriginAirport(facilityIcao, notify = true) {
        this._originAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, facilityIcao);
    }
    /**
     * Removes the origin airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeOriginAirport(notify = true) {
        const facilityIcao = this._originAirport;
        this._originAirport = undefined;
        this.procedureDetails.departureIndex = -1;
        this.procedureDetails.departureRunwayIndex = -1;
        this.procedureDetails.departureTransitionIndex = -1;
        this.procedureDetails.originRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao);
    }
    /**
     * Sets the destination airport in the flight plan.
     * @param facilityIcao The destination airport to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setDestinationAirport(facilityIcao, notify = true) {
        this._destinationAirport = facilityIcao;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, facilityIcao);
    }
    /**
     * Removes the destination airport from the flight plan.
     * @param notify Whether or not to send notifications after the operation.
     */
    removeDestinationAirport(notify = true) {
        const facilityIcao = this._destinationAirport;
        this._destinationAirport = undefined;
        this.procedureDetails.approachIndex = -1;
        this.procedureDetails.approachTransitionIndex = -1;
        this.procedureDetails.arrivalIndex = -1;
        this.procedureDetails.arrivalRunwayTransitionIndex = -1;
        this.procedureDetails.arrivalRunway = undefined;
        this.procedureDetails.arrivalTransitionIndex = -1;
        this.procedureDetails.destinationRunway = undefined;
        notify && this.events.onOriginDestChanged && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setLateralLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeLateralLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeLateralLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Lateral);
    }
    /**
     * Sets the active lateral leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setVerticalLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeVerticalLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeVerticalLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Vertical);
    }
    /**
     * Sets the active calculating leg index in the flight plan.
     * @param globalLegIndex The global leg index to set.
     * @param notify Whether or not to send notifications after the operation.
     */
    setCalculatingLeg(globalLegIndex, notify = true) {
        let previousLegIndex = -1;
        let previousSegmentIndex = -1;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        if (this.length > 0) {
            previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (previousSegmentIndex > -1) {
                previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
            }
            this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
            segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
            if (segmentIndex > -1) {
                segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
            }
        }
        else {
            this._activeCalculatingLeg = 0;
        }
        notify
            && this.events.onActiveLegChanged
            && this.events.onActiveLegChanged(this._activeCalculatingLeg, segmentIndex, segmentLegIndex, previousSegmentIndex, previousLegIndex, ActiveLegType.Calculating);
    }
    /**
     * Sets the flight plan procedure details.
     * @param details The details of the flight plan's procedures.
     * @param notify Whether or not to send notifications after the operation.
     */
    setProcedureDetails(details, notify = true) {
        // We iterate of the keys of `details` because we need to be able to set fields to undefined
        // and we only want to overwrite fields that were in the `details` object
        for (const key of Object.keys(details)) {
            this.procedureDetails[key] = details[key];
        }
        notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails);
    }
    /**
     * Gets the global index of a flight plan leg in this flight plan.
     * @param leg A flight plan leg definition.
     * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
     */
    getLegIndexFromLeg(leg) {
        let index = 0;
        for (const toCompare of this.legs()) {
            if (toCompare === leg) {
                return index;
            }
            index++;
        }
        return -1;
    }
    /**
     * Gets the flight plan segment to which a leg belongs.
     * @param leg A flight plan leg definition.
     * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
     */
    getSegmentFromLeg(leg) {
        for (const segment of this.segments()) {
            if (segment.legs.includes(leg)) {
                return segment;
            }
        }
        return null;
    }
    /**
     * Gets the segment index for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment index for.
     * @returns The segment index for the given global leg index, or -1 if not found.
     */
    getSegmentIndex(globalLegIndex) {
        for (const segment of this.segments()) {
            if (segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.segmentIndex;
            }
        }
        return -1;
    }
    /**
     * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
     * @param globalLegIndex The global leg index to get the segment leg index for.
     * @returns The segment leg index, or -1 if not found.
     */
    getSegmentLegIndex(globalLegIndex) {
        const segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex === -1) {
            return -1;
        }
        return globalLegIndex - this.getSegment(segmentIndex).offset;
    }
    /**
     * Gets the leg immediately previous to a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately previous to the specified position, or null if there is no such leg.
     */
    getPrevLeg(segmentIndex, legIndex) {
        var _a, _b;
        if (segmentIndex < 0) {
            return null;
        }
        segmentIndex = Math.min(segmentIndex, this.planSegments.length);
        legIndex = Math.min(legIndex, (_b = (_a = this.planSegments[segmentIndex]) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex - 1];
        while (!leg && --segmentIndex >= 0) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[segment.legs.length - 1];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    /**
     * Gets the leg immediately after a position in this flight plan specified by segment index and leg index.
     * @param segmentIndex A segment index.
     * @param legIndex A leg index.
     * @returns the leg immediately after the specified position, or null if there is no such leg.
     */
    getNextLeg(segmentIndex, legIndex) {
        if (segmentIndex >= this.planSegments.length) {
            return null;
        }
        segmentIndex = Math.max(segmentIndex, -1);
        legIndex = Math.max(legIndex, -1);
        let segment = this.planSegments[segmentIndex];
        let leg = segment === null || segment === void 0 ? void 0 : segment.legs[legIndex + 1];
        while (!leg && ++segmentIndex < this.planSegments.length) {
            segment = this.planSegments[segmentIndex];
            if (segment) {
                leg = segment.legs[0];
            }
        }
        return leg !== null && leg !== void 0 ? leg : null;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setDirectToData(arg1, arg2, arg3) {
        if (typeof arg1 !== 'number') {
            // arg1 is a LegDefinition or null.
            arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
        }
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let notify = true;
        if (typeof arg2 !== 'number') {
            const globalLegIndex = arg1;
            if (globalLegIndex >= 0) {
                segmentIndex = this.getSegmentIndex(globalLegIndex);
                if (segmentIndex >= 0) {
                    segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
                }
            }
            notify = arg2 !== null && arg2 !== void 0 ? arg2 : true;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            notify = arg3 !== null && arg3 !== void 0 ? arg3 : true;
        }
        this.directToData.segmentIndex = segmentIndex;
        this.directToData.segmentLegIndex = segmentLegIndex;
        notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setLegVerticalData(arg1, arg2, arg3, arg4) {
        let notify = true;
        let segmentIndex = -1;
        let segmentLegIndex = -1;
        let verticalData;
        if (typeof arg2 !== 'number') {
            segmentIndex = this.getSegmentIndex(arg1);
            const segment = this.getSegment(segmentIndex);
            segmentLegIndex = arg1 - segment.offset;
            verticalData = arg2;
            notify = arg3 !== undefined ? arg3 : notify;
        }
        else {
            segmentIndex = arg1;
            segmentLegIndex = arg2;
            verticalData = arg3;
            notify = arg4 !== undefined ? arg4 : notify;
        }
        const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
        if (leg) {
            Object.assign(leg.verticalData, verticalData);
            notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg);
        }
        else {
            console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
        }
    }
    /**
     * Sets the airway for a segment.
     * @param segmentIndex A segment index.
     * @param airway The airway name.
     * @param notify is whether to send an event for this change
     */
    setAirway(segmentIndex, airway, notify = true) {
        const segment = this.getSegment(segmentIndex);
        if (!airway) {
            segment.airway = undefined;
        }
        else {
            segment.airway = airway;
        }
        this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param data The data to set.
     * @param notify Whether or not to notify subscribers.
     */
    setUserData(key, data, notify = true) {
        this.userData[key] = data;
        this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data);
    }
    /**
     * Sets user data in the flight plan.
     * @param key The key of the user data.
     * @param notify Whether or not to notify subscribers.
     */
    deleteUserData(key, notify = true) {
        if (this.userData[key] !== undefined) {
            delete this.userData[key];
        }
        this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key);
    }
    /**
     * Gets user data from the flight plan.
     * @param key The key of the user data.
     * @returns The user data, if found.
     */
    getUserData(key) {
        return this.userData[key];
    }
    /**
     * Reflows all flight plan segment offsets after a plan change.
     */
    reflowSegmentOffsets() {
        let nextOffset = undefined;
        for (let i = 0; i < this.planSegments.length; i++) {
            const segment = this.planSegments[i];
            if (segment) {
                if (nextOffset === undefined) {
                    segment.offset = 0;
                }
                else {
                    segment.offset = nextOffset;
                }
                nextOffset = segment.legs.length + segment.offset;
            }
        }
    }
    /**
     * Sets the origin runway in procedure details.
     * @param runway The oneway runway to set as the origin, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setOriginRunway(runway = undefined, notify = true) {
        this.procedureDetails.originRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the destination runway in procedure details.
     * @param runway The oneway runway to set as the destination, or undefined
     * @param notify Whether or not to notify subscribers.
     */
    setDestinationRunway(runway = undefined, notify = true) {
        this.procedureDetails.destinationRunway = runway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the departure procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param departureIndex The index of the departure in the origin airport information
     * @param departureTransitionIndex The index of the departure transition in the origin airport departure information
     * @param departureRunwayIndex The index of the selected runway in the original airport departure information
     * @param notify Whether or not to notify subscribers.
     */
    setDeparture(facilityIcao = undefined, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true) {
        this.procedureDetails.departureIndex = departureIndex;
        this.procedureDetails.departureFacilityIcao = facilityIcao;
        this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
        this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the arrival procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param arrivalIndex The index of the arrival in the destination airport information
     * @param arrivalTransitionIndex index of the arrival transition in the destination airport arrival information
     * @param arrivalRunwayTransitionIndex The index of the selected runway transition at the destination airport arrival information
     * @param arrivalRunway The oneway runway to set as the arrival runway, or undefined
     * @param notify Whether or not to notify subscribers
     */
    setArrival(facilityIcao = undefined, arrivalIndex = -1, arrivalTransitionIndex = -1, arrivalRunwayTransitionIndex = -1, arrivalRunway = undefined, notify = true) {
        this.procedureDetails.arrivalIndex = arrivalIndex;
        this.procedureDetails.arrivalFacilityIcao = facilityIcao;
        this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
        this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
        this.procedureDetails.arrivalRunway = arrivalRunway;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Sets the approach procedure details.
     * @param facilityIcao The facility ICAO of the facility containing the procedure
     * @param approachIndex The index of the apporach in the destination airport information
     * @param approachTransitionIndex The index of the approach transition in the destination airport approach information
     * @param notify Whether or not to notify subscribers
     */
    setApproach(facilityIcao = undefined, approachIndex = -1, approachTransitionIndex = -1, notify = true) {
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachFacilityIcao = facilityIcao;
        this.procedureDetails.approachIndex = approachIndex;
        this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
        const details = new ProcedureDetails;
        Object.assign(details, this.procedureDetails);
        this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details);
    }
    /**
     * Copies the flight plan.
     * @param planIndex The flight plan index to assign to this plan, or the same plan
     * index if not provided.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @returns The copied flight plan.
     */
    copy(planIndex, copyCalcs = false) {
        if (planIndex === undefined) {
            planIndex = this.planIndex;
        }
        const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        newPlan.copyFrom(this, copyCalcs);
        return newPlan;
    }
    /**
     * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
     * @param sourcePlan The plan to copy from.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     */
    copyFrom(sourcePlan, copyCalcs = false) {
        if (sourcePlan._originAirport !== undefined) {
            this.setOriginAirport(sourcePlan._originAirport, false);
        }
        else {
            this.removeOriginAirport();
        }
        if (sourcePlan._destinationAirport !== undefined) {
            this.setDestinationAirport(sourcePlan._destinationAirport, false);
        }
        else {
            this.removeDestinationAirport();
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        this.setProcedureDetails(Object.assign(new ProcedureDetails(), sourcePlan.procedureDetails), false);
        for (let i = 0; i < sourcePlan.planSegments.length; i++) {
            const segment = sourcePlan.planSegments[i];
            if (segment !== undefined) {
                this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
                for (const leg of segment.legs) {
                    const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
                    const legIndex = this.getLegIndexFromLeg(newLeg);
                    this.setLegVerticalData(legIndex, leg.verticalData);
                    copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
                }
            }
        }
        this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex);
        // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
        this.setLateralLeg(sourcePlan._activeLateralLeg);
        this.setVerticalLeg(sourcePlan._activeVerticalLeg);
        this.setCalculatingLeg(sourcePlan._activeCalculatingLeg);
        for (const key in this.userData) {
            this.deleteUserData(key);
        }
        for (const key in sourcePlan.userData) {
            this.setUserData(key, sourcePlan.userData[key], false);
        }
    }
    /**
     * Copies leg calcs from an existing leg to a new leg.
     * @param existingLeg The leg that we want to copy the calcs from.
     * @param newLeg The leg that we want to copy the calcs to.
     * @returns the newLeg with the copied calcs.
     */
    static copyLegCalculations(existingLeg, newLeg) {
        if (existingLeg.calculated !== undefined) {
            newLeg.calculated = {
                courseMagVar: existingLeg.calculated.courseMagVar,
                initialDtk: existingLeg.calculated.initialDtk,
                distance: existingLeg.calculated.distance,
                cumulativeDistance: existingLeg.calculated.cumulativeDistance,
                distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
                cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
                startLat: existingLeg.calculated.startLat,
                startLon: existingLeg.calculated.startLon,
                endLat: existingLeg.calculated.endLat,
                endLon: existingLeg.calculated.endLon,
                flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
                ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
                ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
                ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
                egressJoinIndex: existingLeg.calculated.egressJoinIndex,
                egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
                endsInFallback: existingLeg.calculated.endsInFallback
            };
        }
        return newLeg;
    }
}
/**
 * Creates a default instance of a flight plan leg.
 * @param partial A portion of leg options to apply.
 * @returns A default instance of a flight plan leg.
 */
FlightPlan.createLeg = (partial) => Object.assign({
    type: 0,
    fixIcao: ICAO.emptyIcao,
    arcCenterFixIcao: ICAO.emptyIcao,
    originIcao: ICAO.emptyIcao,
    flyOver: 0,
    turnDirection: 0,
    trueDegrees: 0,
    theta: 0,
    rho: 0,
    distance: 0,
    distanceMinutes: 0,
    speedRestriction: 0,
    altDesc: 0,
    altitude1: 0,
    altitude2: 0,
    course: 0,
    fixTypeFlags: 0,
    verticalAngle: 0,
}, partial);

/**
 * An implementation of {@link SubEventInterface}.
 */
class SubEvent {
    constructor() {
        this.subs = [];
        this.notifyDepth = 0;
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    on(handler, paused = false) {
        const sub = new HandlerSubscription(handler, undefined, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        return sub;
    }
    /** @inheritdoc */
    off(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /** @inheritdoc */
    clear() {
        this.notifyDepth++;
        for (let i = 0; i < this.subs.length; i++) {
            this.subs[i].destroy();
        }
        this.notifyDepth--;
        if (this.notifyDepth === 0) {
            this.subs.length = 0;
        }
    }
    /** @inheritdoc */
    notify(sender, data) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(sender, data);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`SubEvent: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Responds to when a subscription to this event is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
}

/**
 * Manages the active flightplans of the navigational systems.
 */
class FlightPlanner {
    /**
     * Creates an instance of the FlightPlanner.
     * @param bus The event bus instance to notify changes on.
     * @param calculator The flight path calculator to use with this planner.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     */
    constructor(bus, calculator, onLegNameRequested = FlightPlanner.buildDefaultLegName) {
        this.bus = bus;
        this.calculator = calculator;
        this.onLegNameRequested = onLegNameRequested;
        /** The flight plans managed by this flight planner. */
        this.flightPlans = [];
        this.ignoreSync = false;
        /** The active flight plan index. */
        this._activePlanIndex = 0;
        /** Invoked when we receive a flight plan response event. */
        this.flightPlanSynced = new SubEvent();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('fplsync_fplRequest').handle(data => !this.ignoreSync && this.onFlightPlanRequest(data));
        subscriber.on('fplsync_fplResponse').handle(data => !this.ignoreSync && this.onFlightPlanResponse(data));
        subscriber.on('fplsync_fplCreated').handle(data => !this.ignoreSync && this.onPlanCreated(data));
        subscriber.on('fplsync_fplDeleted').handle(data => !this.ignoreSync && this.onPlanDeleted(data));
        subscriber.on('fplsync_fplActiveLegChange').handle(data => !this.ignoreSync && this.onActiveLegChanged(data));
        subscriber.on('fplsync_fplLegChange').handle(data => !this.ignoreSync && this.onLegChanged(data));
        subscriber.on('fplsync_fplSegmentChange').handle(data => !this.ignoreSync && this.onSegmentChanged(data));
        subscriber.on('fplsync_fplCalculated').handle(data => !this.ignoreSync && this.onCalculated(data));
        subscriber.on('fplsync_fplOriginDestChanged').handle(data => !this.ignoreSync && this.onOriginDestChanged(data));
        subscriber.on('fplsync_fplProcDetailsChanged').handle(data => !this.ignoreSync && this.onProcedureDetailsChanged(data));
        subscriber.on('fplsync_fplIndexChanged').handle(data => !this.ignoreSync && this.onPlanIndexChanged(data));
        subscriber.on('fplsync_fplCopied').handle(data => !this.ignoreSync && this.onPlanCopied(data));
        subscriber.on('fplsync_fplUserDataSet').handle(data => !this.ignoreSync && this.onUserDataSet(data));
        subscriber.on('fplsync_fplUserDataDelete').handle(data => !this.ignoreSync && this.onUserDataDelete(data));
        subscriber.on('fplsync_fplDirectToDataChanged').handle(data => !this.ignoreSync && this.onDirectToDataChanged(data));
    }
    /**
     * Set a new active plan index.
     * @param planIndex The new active plan index.
     */
    set activePlanIndex(planIndex) {
        this._activePlanIndex = planIndex;
    }
    /**
     * Get the active plan index.
     * @returns The active plan index number.
     */
    get activePlanIndex() {
        return this._activePlanIndex;
    }
    /**
     * Requests synchronization from other FlightPlanner instances.
     */
    requestSync() {
        this.sendFlightPlanRequest();
    }
    /**
     * An event generated when a set of flight plans is requested.
     * @param data The event data.
     */
    onFlightPlanRequest(data) {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplResponse', {
            uid: data.uid,
            flightPlans: this.flightPlans.map(plan => {
                const newPlan = Object.assign({}, plan);
                newPlan.calculator = undefined;
                return newPlan;
            }), planIndex: this.activePlanIndex
        }, true, false);
        this.ignoreSync = false;
    }
    /**
     * Sends a flight plan request event.
     */
    sendFlightPlanRequest() {
        this.ignoreSync = true;
        this.publisher.pub('fplsync_fplRequest', { uid: this.lastRequestUid = Math.trunc(Math.random() * Number.MAX_SAFE_INTEGER) }, true, false);
        this.ignoreSync = false;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onFlightPlanResponse(data) {
        if (data.uid !== this.lastRequestUid) {
            return;
        }
        this.lastRequestUid = undefined;
        for (let i = 0; i < data.flightPlans.length; i++) {
            // ignore bogus flight plans
            if (data.flightPlans[i].segmentCount === 0) {
                continue;
            }
            const newPlan = new FlightPlan(i, this.calculator, this.onLegNameRequested);
            newPlan.copyFrom(data.flightPlans[i], true);
            newPlan.events = this.buildPlanEventHandlers(i);
            this.flightPlans[i] = newPlan;
            this.sendEvent('fplLoaded', { planIndex: i }, false);
            // Make sure the newly loaded plans are calculated at least once from the beginning
            newPlan.calculate(0);
        }
        // Only process a plan index changed event if the plan actually exists.
        if (this.flightPlans[data.planIndex]) {
            this.onPlanIndexChanged(data);
        }
        this.flightPlanSynced.notify(this, true);
    }
    /**
     * Checks whether a flight plan exists at a specified index.
     * @param planIndex The index to check.
     * @returns Whether a a flight plan exists at `planIndex`.
     */
    hasFlightPlan(planIndex) {
        return !!this.flightPlans[planIndex];
    }
    /**
     * Gets a flight plan from the flight planner.
     * @param planIndex The index of the flight plan.
     * @returns The requested flight plan.
     * @throws Error if a flight plan does not exist at `planIndex`.
     */
    getFlightPlan(planIndex) {
        const plan = this.flightPlans[planIndex];
        if (!plan) {
            throw new Error(`FlightPlanner: Flight plan does not exist at index ${planIndex}`);
        }
        return plan;
    }
    /**
     * Creates a new flight plan at a specified index if one does not already exist.
     * @param planIndex The index at which to create the new flight plan.
     * @param notify Whether to send an event notification. True by default.
     * @returns The new flight plan, or the existing flight plan at `planIndex`.
     */
    createFlightPlan(planIndex, notify = true) {
        if (this.flightPlans[planIndex]) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            return this.flightPlans[planIndex];
        }
        const flightPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);
        flightPlan.events = this.buildPlanEventHandlers(planIndex);
        this.flightPlans[planIndex] = flightPlan;
        notify && this.sendPlanCreated(planIndex);
        return flightPlan;
    }
    /**
     * A callback which is called in response to flight plan request response sync events.
     * @param data The event data.
     */
    onPlanCreated(data) {
        this.createFlightPlan(data.planIndex, false);
        this.sendEvent('fplCreated', data, false);
    }
    /**
     * Sends a flight plan created event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanCreated(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplCreated', data, true);
    }
    /**
     * Deletes a flight plan from the flight planner.
     * @param planIndex The index of the flight plan to delete.
     * @param notify Whether to send an event notification. True by default.
     */
    deleteFlightPlan(planIndex, notify = true) {
        const flightPlan = this.flightPlans[planIndex];
        if (flightPlan) {
            flightPlan.events = {};
            this.flightPlans[planIndex] = undefined;
            notify && this.sendPlanDeleted(planIndex);
        }
        if (planIndex === this.flightPlans.length - 1) {
            this.flightPlans.length--;
        }
    }
    /**
     * A callback which is called in response to flight plan deleted sync events.
     * @param data The event data.
     */
    onPlanDeleted(data) {
        this.deleteFlightPlan(data.planIndex, false);
        this.sendEvent('fplDeleted', data, false);
    }
    /**
     * Sends a flight plan deleted event.
     * @param planIndex The index of the flight plan that was created.
     */
    sendPlanDeleted(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplDeleted', data, true);
    }
    /**
     * Builds the plan event handlers for the flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The plan event handlers.
     */
    buildPlanEventHandlers(planIndex) {
        return {
            onLegChanged: (segmentIndex, index, type, leg) => this.sendLegChanged(planIndex, segmentIndex, index, type, leg),
            onSegmentChanged: (segmentIndex, type, segment) => this.sendSegmentChanged(planIndex, segmentIndex, type, segment),
            onActiveLegChanged: (index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) => this.sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type),
            onCalculated: (index) => this.sendCalculated(planIndex, index),
            onOriginDestChanged: (type, airport) => this.sendOriginDestChanged(planIndex, type, airport),
            onProcedureDetailsChanged: (details) => this.sendProcedureDetailsChanged(planIndex, details),
            onUserDataSet: (key, data) => this.sendUserDataSet(planIndex, key, data),
            onUserDataDelete: (key) => this.sendUserDataDelete(planIndex, key),
            onDirectDataChanged: (directToData) => this.sendDirectToData(planIndex, directToData)
        };
    }
    /**
     * Checks whether an active flight plan exists.
     * @returns Whether an active flight plan exists.
     */
    hasActiveFlightPlan() {
        return this.hasFlightPlan(this.activePlanIndex);
    }
    /**
     * Gets the currently active flight plan from the flight planner.
     * @returns The currently active flight plan.
     * @throws Error if no active flight plan exists.
     */
    getActiveFlightPlan() {
        return this.getFlightPlan(this.activePlanIndex);
    }
    /**
     * Copies a flight plan to another flight plan slot.
     * @param sourcePlanIndex The source flight plan index.
     * @param targetPlanIndex The target flight plan index.
     * @param copyCalcs Whether to copy leg calculations (defaults to false).
     * @param notify Whether or not to notify subscribers that the plan has been copied.
     */
    copyFlightPlan(sourcePlanIndex, targetPlanIndex, copyCalcs = false, notify = true) {
        const sourcePlan = this.flightPlans[sourcePlanIndex];
        if (!sourcePlan) {
            return;
        }
        const newPlan = sourcePlan.copy(targetPlanIndex, copyCalcs);
        newPlan.events = this.buildPlanEventHandlers(targetPlanIndex);
        this.flightPlans[targetPlanIndex] = newPlan;
        if (notify) {
            this.sendPlanCopied(sourcePlanIndex, targetPlanIndex, copyCalcs);
        }
    }
    /**
     * A callback which is called in response to flight plan copied sync events.
     * @param data The event data.
     */
    onPlanCopied(data) {
        this.copyFlightPlan(data.planIndex, data.targetPlanIndex, data.copyCalcs, false);
        this.sendEvent('fplCopied', data, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan that was the source of the copy.
     * @param targetPlanIndex The index of the copy.
     * @param copyCalcs Whether to leg calculations were copied.
     */
    sendPlanCopied(planIndex, targetPlanIndex, copyCalcs) {
        const data = { planIndex, targetPlanIndex, copyCalcs };
        this.sendEvent('fplCopied', data, true);
    }
    /**
     * A callback which is called in response to leg changed sync events.
     * @param data The event data.
     */
    onLegChanged(data) {
        const plan = this.getFlightPlan(data.planIndex);
        let localLeg;
        switch (data.type) {
            case LegEventType.Added: {
                localLeg = plan.addLeg(data.segmentIndex, data.leg.leg, data.legIndex, data.leg.flags, false);
                break;
            }
            case LegEventType.Removed: {
                const leg = plan.removeLeg(data.segmentIndex, data.legIndex, false);
                // We don't want to send the event locally if we didn't find a leg
                if (!leg) {
                    return;
                }
                localLeg = leg;
                break;
            }
            case LegEventType.Changed: {
                try {
                    localLeg = plan.getLeg(data.segmentIndex, data.legIndex);
                }
                catch (_a) {
                    // We don't want to send the event locally if we didn't find a leg
                    return;
                }
                plan.setLegVerticalData(data.segmentIndex, data.legIndex, data.leg.verticalData, false);
                break;
            }
        }
        // We need to send a reference to the local flight plan's copy of the leg with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            legIndex: data.legIndex,
            leg: localLeg
        };
        this.sendEvent('fplLegChange', localData, false);
    }
    /**
     * Sends a leg change event.
     * @param planIndex The index of the flight plan.
     * @param segmentIndex The index of the segment.
     * @param index The index of the leg.
     * @param type The type of change.
     * @param leg The leg that was changed.
     */
    sendLegChanged(planIndex, segmentIndex, index, type, leg) {
        const data = {
            planIndex, segmentIndex, legIndex: index, type, leg
        };
        this.sendEvent('fplLegChange', data, true);
    }
    /**
     * A callback which is called in response to segment changed sync events.
     * @param data The event data.
     */
    onSegmentChanged(data) {
        var _a, _b;
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        let localSegment = undefined;
        switch (data.type) {
            case SegmentEventType.Added:
                localSegment = data.segment && plan.addSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Inserted:
                localSegment = data.segment && plan.insertSegment(data.segmentIndex, data.segment.segmentType, data.segment.airway, false);
                break;
            case SegmentEventType.Removed:
                localSegment = (_a = plan.tryGetSegment(data.segmentIndex)) !== null && _a !== void 0 ? _a : undefined;
                plan.removeSegment(data.segmentIndex, false);
                break;
            case SegmentEventType.Changed:
                localSegment = data.segment === undefined ? undefined : (_b = plan.tryGetSegment(data.segmentIndex)) !== null && _b !== void 0 ? _b : undefined;
                if (localSegment === undefined) {
                    return;
                }
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                plan.setAirway(data.segmentIndex, data.segment.airway, false);
                break;
        }
        // We need to send a reference to the local flight plan's copy of the segment with the local event so that
        // event consumers that save the reference don't become desynced with the local flight plan.
        const localData = {
            planIndex: data.planIndex,
            type: data.type,
            segmentIndex: data.segmentIndex,
            segment: localSegment
        };
        this.sendEvent('fplSegmentChange', localData, false);
    }
    /**
     * Sends a segment change event.
     * @param planIndex The index of the flight plan.
     * @param index The index of the segment.
     * @param type The type of change.
     * @param segment The segment that was changed.
     */
    sendSegmentChanged(planIndex, index, type, segment) {
        const data = {
            planIndex, segmentIndex: index, type, segment
        };
        this.sendEvent('fplSegmentChange', data, true);
    }
    /**
     * A callback which is called in response to active leg changed sync events.
     * @param data The event data.
     */
    onActiveLegChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case ActiveLegType.Lateral:
                plan.setLateralLeg(data.index, false);
                break;
            case ActiveLegType.Vertical:
                plan.setVerticalLeg(data.index, false);
                break;
            case ActiveLegType.Calculating:
                plan.setCalculatingLeg(data.index, false);
                break;
        }
        this.sendEvent('fplActiveLegChange', data, false);
    }
    /**
     * Sends an active leg change event.
     * @param planIndex The index of the flight plan.
     * @param index The global index of the leg.
     * @param segmentIndex The index of the plan segment.
     * @param legIndex The index of the leg within the segment.
     * @param previousSegmentIndex The index of the segment in which the previously active leg is.
     * @param previousLegIndex The index of the previously active leg within the previously active segment.
     * @param type The type of leg that was changed.
     */
    sendActiveLegChange(planIndex, index, segmentIndex, legIndex, previousSegmentIndex, previousLegIndex, type) {
        const data = {
            segmentIndex, legIndex, planIndex,
            index, previousSegmentIndex, previousLegIndex, type
        };
        this.sendEvent('fplActiveLegChange', data, true);
    }
    /**
     * A callback which is called in response to calculation sync events.
     * @param data The event data.
     */
    async onCalculated(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        await plan.calculate(data.index, false);
        if (this.flightPlans[data.planIndex] !== plan) {
            return;
        }
        this.sendEvent('fplCalculated', data, false);
    }
    /**
     * Sends a calculated event.
     * @param planIndex The index of the flight plan.
     * @param index The index that the path was generated from.
     */
    sendCalculated(planIndex, index) {
        const data = { planIndex, index };
        this.sendEvent('fplCalculated', data, true);
    }
    /**
     * A callback which is called in response to origin/destination changed sync events.
     * @param data The event data.
     */
    onOriginDestChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        switch (data.type) {
            case OriginDestChangeType.OriginAdded:
                data.airport && plan.setOriginAirport(data.airport, false);
                break;
            case OriginDestChangeType.OriginRemoved:
                plan.removeOriginAirport(false);
                break;
            case OriginDestChangeType.DestinationAdded:
                data.airport && plan.setDestinationAirport(data.airport, false);
                break;
            case OriginDestChangeType.DestinationRemoved:
                plan.removeDestinationAirport(false);
                break;
        }
        this.sendEvent('fplOriginDestChanged', data, false);
    }
    /**
     * Sends a origin/dest change event.
     * @param planIndex The index of the flight plan.
     * @param type The origin/destination change type.
     * @param airport The airport that was changed.
     */
    sendOriginDestChanged(planIndex, type, airport) {
        const data = { planIndex, type, airport };
        this.sendEvent('fplOriginDestChanged', data, true);
    }
    /**
     * A callback which is called in response to procedure changed sync events.
     * @param data The event data.
     */
    onProcedureDetailsChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
        // and because we want to overwrite the entire object, instead of just some fields.
        plan.setProcedureDetails(Object.assign(new ProcedureDetails(), data.details), false);
        this.sendEvent('fplProcDetailsChanged', data, false);
    }
    /**
     * Sends a procedure details change event.
     * @param planIndex The index of the flight plan.
     * @param details The details that were changed.
     */
    sendProcedureDetailsChanged(planIndex, details) {
        const data = { planIndex, details };
        this.sendEvent('fplProcDetailsChanged', data, true);
    }
    /**
     * A callback which is called in response to flight plan index changed sync events.
     * @param data The event data.
     */
    onPlanIndexChanged(data) {
        this.activePlanIndex = data.planIndex;
        this.sendEvent('fplIndexChanged', data, false);
    }
    /**
     * Sends an active plan index change event.
     * @param planIndex The index of the flight plan.
     */
    sendPlanIndexChanged(planIndex) {
        const data = { planIndex };
        this.sendEvent('fplIndexChanged', data, true);
    }
    /**
     * A callback which is called in response to user data set sync events.
     * @param data The event data.
     */
    onUserDataSet(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setUserData(data.key, data.data, false);
        this.sendEvent('fplUserDataSet', data, false);
    }
    /**
     * A callback which is called in response to user data delete sync events.
     * @param data The event data.
     */
    onUserDataDelete(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.deleteUserData(data.key, false);
        this.sendEvent('fplUserDataDelete', data, false);
    }
    /**
     * Sends a user data set event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     * @param userData The data that was set.
     */
    sendUserDataSet(planIndex, key, userData) {
        const data = { planIndex, key, data: userData };
        this.sendEvent('fplUserDataSet', data, true);
    }
    /**
     * Sends a user data delete event.
     * @param planIndex The index of the flight plan.
     * @param key The key of the user data.
     */
    sendUserDataDelete(planIndex, key) {
        const data = { planIndex, key, data: undefined };
        this.sendEvent('fplUserDataDelete', data, true);
    }
    /**
     * A callback which is called in response to direct to data changed sync events.
     * @param data The event data.
     */
    onDirectToDataChanged(data) {
        const plan = this.flightPlans[data.planIndex];
        if (!plan) {
            return;
        }
        plan.setDirectToData(data.directToData.segmentIndex, data.directToData.segmentLegIndex, false);
        this.sendEvent('fplDirectToDataChanged', data, false);
    }
    /**
     * Sends a direct to data changed event.
     * @param planIndex The index of the flight plan.
     * @param directToData The direct to data.
     */
    sendDirectToData(planIndex, directToData) {
        const data = { planIndex, directToData: directToData };
        this.sendEvent('fplDirectToDataChanged', data, true);
    }
    /**
     * Method to set an active flight plan index.
     * @param planIndex The index of the flight plan to make active.
     */
    setActivePlanIndex(planIndex) {
        if (this.hasFlightPlan(planIndex)) {
            this.activePlanIndex = planIndex;
            this.sendPlanIndexChanged(planIndex);
        }
    }
    /**
     * Sends a local event and its sync counterpart.
     * @param topic The topic of the local event.
     * @param data The event data.
     * @param sync Whether to send the sync event.
     */
    sendEvent(topic, data, sync) {
        if (sync) {
            this.ignoreSync = true;
            this.publisher.pub(`fplsync_${topic}`, data, true, false);
            this.ignoreSync = false;
        }
        this.publisher.pub(topic, data, false, false);
    }
    /**
     * Gets an instance of FlightPlanner.
     * @param bus The event bus.
     * @param calculator A flight path calculator.
     * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
     * @returns An instance of FlightPlanner.
     */
    static getPlanner(bus, calculator, onLegNameRequested) {
        var _a;
        return (_a = FlightPlanner.INSTANCE) !== null && _a !== void 0 ? _a : (FlightPlanner.INSTANCE = new FlightPlanner(bus, calculator, onLegNameRequested));
    }
    /**
     * Default Method for leg naming - builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildDefaultLegName(leg) {
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0)}FT`;
            case LegType.FM:
            case LegType.VM:
                return 'MANSEQ';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
                return 'INTRCPT';
            case LegType.PI:
                return 'PROC. TURN';
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
                return 'HOLD';
            default:
                return ICAO.getIdent(leg.fixIcao);
        }
    }
}

/**
 * A Utility Class that supports iterating through a flight plan either forward or reverse.
 */
class FlightPlanLegIterator {
    constructor() {
        this.cursor = {
            segment: undefined,
            legIndex: -1,
            legDefinition: undefined,
            index: 0
        };
        this.cursorIsBusy = false;
    }
    /**
     * Method that checks whether the FlightPlanLegIterator is busy.
     * @returns Whether the cursor is busy.
     */
    isBusy() {
        return this.cursorIsBusy;
    }
    /**
     * Iterates through the active flight plan in reverse order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateReverse(lateralPlan, each) {
        if (this.cursorIsBusy) {
            throw new Error('FlightPlanLegIterator - iterateReverse: The iterator cursor is busy');
        }
        this.cursorIsBusy = true;
        let segmentIndex = lateralPlan.segmentCount - 1;
        let index = 0;
        try {
            while (segmentIndex >= 0) {
                const segment = lateralPlan.getSegment(segmentIndex);
                let legIndex = segment.legs.length - 1;
                while (legIndex >= 0) {
                    this.cursor.legDefinition = segment.legs[legIndex];
                    this.cursor.legIndex = legIndex;
                    this.cursor.segment = segment;
                    this.cursor.index = index;
                    each(this.cursor);
                    legIndex--;
                    index++;
                }
                segmentIndex--;
            }
        }
        catch (error) {
            console.error(`FlightPlanLegIterator - iterateReverse: error in while loop: ${error}`);
            if (error instanceof Error) {
                console.error(error.stack);
            }
        }
        this.cursorIsBusy = false;
    }
    /**
     * Iterates through the active flight plan in forward order.
     * @param lateralPlan The lateral flight plan to iterate through.
     * @param each The function to call for each flight plan leg.
     * @throws an Error if the cursor is busy.
     */
    iterateForward(lateralPlan, each) {
        if (this.cursorIsBusy) {
            throw new Error('FlightPlanLegIterator - iterateForward: The iterator cursor is busy');
        }
        this.cursorIsBusy = true;
        let segmentIndex = 0;
        let index = 0;
        try {
            while (segmentIndex < lateralPlan.segmentCount) {
                const segment = lateralPlan.getSegment(segmentIndex);
                let legIndex = 0;
                while (legIndex < segment.legs.length) {
                    this.cursor.legDefinition = segment.legs[legIndex];
                    this.cursor.legIndex = legIndex;
                    this.cursor.segment = segment;
                    this.cursor.index = index;
                    each(this.cursor);
                    legIndex++;
                    index++;
                }
                segmentIndex++;
            }
        }
        catch (error) {
            console.error(`FlightPlanLegIterator - iterateForward: error in while loop: ${error}`);
            if (error instanceof Error) {
                console.error(error.stack);
            }
        }
        this.cursorIsBusy = false;
    }
}

/**
 * Types of changes made to {@link SubscribableMap}.
 */
var SubscribableMapEventType;
(function (SubscribableMapEventType) {
    /** A key was added. */
    SubscribableMapEventType["Added"] = "Added";
    /** A key's entry was changed. */
    SubscribableMapEventType["Changed"] = "Changed";
    /** A key was deleted. */
    SubscribableMapEventType["Deleted"] = "Deleted";
})(SubscribableMapEventType || (SubscribableMapEventType = {}));

/**
 * A pipe from an input subscribable map to an output mutable subscribable map. Each key-value pair
 * added/changed/removed notification received by the pipe is used to add/change/remove key-value pairs in the output
 * map.
 */
class SubscribableMapPipe extends HandlerSubscription {
    /**
     * Constructor.
     * @param from The input subscribable map.
     * @param to The output mutable subscribable map.
     * @param onDestroy A function which is called when this subscription is destroyed.
     */
    constructor(from, to, onDestroy) {
        const handler = (map, type, key, value) => {
            if (type === SubscribableMapEventType.Deleted) {
                to.delete(key);
            }
            else {
                to.setValue(key, value);
            }
        };
        const initialNotifyFunc = () => {
            const fromMap = from.get();
            for (const key of to.get().keys()) {
                if (!fromMap.has(key)) {
                    to.delete(key);
                }
            }
            for (const [key, value] of fromMap) {
                to.setValue(key, value);
            }
        };
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableMap {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableMap = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this map.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    getValue(key) {
        return this.get().get(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this map.
     * @param type The type of change.
     * @param key The key related to the change.
     * @param value The value related to the change.
     */
    notify(type, key, value) {
        const map = this.get();
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(map, type, key, value);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(map, type, key, value);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableMap: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this map's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const map = this.get();
        for (const [key, value] of map) {
            sub.handler(map, SubscribableMapEventType.Added, key, value);
        }
    }
    /**
     * Responds to when a subscription to this map is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableMap' in to) {
                sub = new SubscribableMapPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * Types of changes made to {@link SubscribableSet}.
 */
var SubscribableSetEventType;
(function (SubscribableSetEventType) {
    /** A key was added. */
    SubscribableSetEventType["Added"] = "Added";
    /** A key was deleted. */
    SubscribableSetEventType["Deleted"] = "Deleted";
})(SubscribableSetEventType || (SubscribableSetEventType = {}));

/**
 * A pipe from an input subscribable set to an output mutable subscribable set. Each key added/removed notification
 * received by the pipe is used to add/remove keys to/from the output set.
 */
class SubscribableSetPipe extends HandlerSubscription {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(from, to, arg3, arg4) {
        let handler;
        let initialNotifyFunc;
        let onDestroy;
        if (typeof arg4 === 'function') {
            const toCast = to;
            const map = arg3;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(map(key));
                }
                else {
                    const mappedKey = map(key);
                    // Only delete the mapped key if no other key in the input set maps to the same key
                    for (const inputKey of set) {
                        if (map(inputKey) === mappedKey) {
                            return;
                        }
                    }
                    toCast.delete(mappedKey);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set();
                for (const key of fromSet) {
                    toAdd.add(map(key));
                }
                for (const key of toCast.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg4;
        }
        else {
            const toCast = to;
            handler = (set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    toCast.add(key);
                }
                else {
                    toCast.delete(key);
                }
            };
            initialNotifyFunc = () => {
                const fromSet = from.get();
                const toAdd = new Set(fromSet);
                for (const key of to.get()) {
                    if (!toAdd.delete(key)) {
                        toCast.delete(key);
                    }
                }
                for (const key of toAdd) {
                    toCast.add(key);
                }
            };
            onDestroy = arg3;
        }
        super(handler, initialNotifyFunc, onDestroy);
    }
}

/**
 * An abstract implementation of a subscribable set which allows adding, removing, and notifying subscribers.
 */
class AbstractSubscribableSet {
    constructor() {
        this.isSubscribable = true;
        this.isSubscribableSet = true;
        this.notifyDepth = 0;
        /** A function which sends initial notifications to subscriptions. */
        this.initialNotifyFunc = this.initialNotify.bind(this);
        /** A function which responds to when a subscription to this subscribable is destroyed. */
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /** @inheritdoc */
    get size() {
        return this.get().size;
    }
    /**
     * Adds a subscription to this set.
     * @param sub The subscription to add.
     */
    addSubscription(sub) {
        if (this.subs) {
            this.subs.push(sub);
        }
        else if (this.singletonSub) {
            this.subs = [this.singletonSub, sub];
            delete this.singletonSub;
        }
        else {
            this.singletonSub = sub;
        }
    }
    /** @inheritdoc */
    has(key) {
        return this.get().has(key);
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        let toDestroy = undefined;
        if (this.singletonSub && this.singletonSub.handler === handler) {
            toDestroy = this.singletonSub;
        }
        else if (this.subs) {
            toDestroy = this.subs.find(sub => sub.handler === handler);
        }
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions of a change in this set.
     * @param type The type of change.
     * @param key The key related to the change.
     */
    notify(type, key) {
        const set = this.get();
        let needCleanUpSubs = false;
        this.notifyDepth++;
        if (this.singletonSub) {
            try {
                if (this.singletonSub.isAlive && !this.singletonSub.isPaused) {
                    this.singletonSub.handler(set, type, key);
                }
                needCleanUpSubs || (needCleanUpSubs = !this.singletonSub.isAlive);
            }
            catch (error) {
                console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        else if (this.subs) {
            const subLen = this.subs.length;
            for (let i = 0; i < subLen; i++) {
                try {
                    const sub = this.subs[i];
                    if (sub.isAlive && !sub.isPaused) {
                        sub.handler(set, type, key);
                    }
                    needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
                }
                catch (error) {
                    console.error(`AbstractSubscribableSet: error in handler: ${error}`);
                    if (error instanceof Error) {
                        console.error(error.stack);
                    }
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            if (this.singletonSub && !this.singletonSub.isAlive) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                this.subs = this.subs.filter(sub => sub.isAlive);
            }
        }
    }
    /**
     * Notifies a subscription of this set's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        const set = this.get();
        for (const key of set) {
            sub.handler(set, SubscribableSetEventType.Added, key);
        }
    }
    /**
     * Responds to when a subscription to this set is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            if (this.singletonSub === sub) {
                delete this.singletonSub;
            }
            else if (this.subs) {
                const index = this.subs.indexOf(sub);
                if (index >= 0) {
                    this.subs.splice(index, 1);
                }
            }
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            }
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            if ('isSubscribableSet' in to) {
                sub = new SubscribableSetPipe(this, to, this.onSubDestroyedFunc);
            }
            else {
                sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            }
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.addSubscription(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * An array-like class to observe changes in a list of objects.
 * @class ArraySubject
 * @template T
 */
class ArraySubject extends AbstractSubscribableArray {
    /**
     * Constructs an observable array.
     * @param arr The initial array elements.
     */
    constructor(arr) {
        super();
        this.array = arr;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The length of this array. */
    get length() {
        return this.array.length;
    }
    /**
     * Creates and returns a new observable array.
     * @static
     * @template AT The type of the array items.
     * @param arr The initial array elements.
     * @returns A new instance of SubjectArray.
     */
    static create(arr = []) {
        return new ArraySubject(arr);
    }
    /**
     * Inserts a new item at the end or the specified index.
     * @param item The item to insert.
     * @param index The optional index to insert the item to. Will add the item at then end if index not given.
     */
    insert(item, index) {
        if (index === undefined || index > this.array.length - 1) {
            index = this.array.length;
            this.array.push(item);
        }
        else {
            this.array.splice(index, 0, item);
        }
        this.notify(index, SubscribableArrayEventType.Added, item);
    }
    /**
     * Inserts items of an array beginning at the specified index.
     * @param [index] The index to begin inserting the array items.
     * @param arr The array to insert.
     */
    insertRange(index = 0, arr) {
        this.array.splice(index, 0, ...arr);
        this.notify(index, SubscribableArrayEventType.Added, arr);
    }
    /**
     * Removes the item at the specified index.
     * @param index The index of the item to remove.
     */
    removeAt(index) {
        const removedItem = this.array.splice(index, 1);
        this.notify(index, SubscribableArrayEventType.Removed, removedItem[0]);
    }
    /**
     * Removes the given item from the array.
     * @param item The item to remove.
     * @returns Returns a boolean indicating if the item was found and removed.
     */
    removeItem(item) {
        const index = this.array.indexOf(item);
        if (index > -1) {
            this.removeAt(index);
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Replaces all items in the array with the new array.
     * @param arr The array.
     */
    set(arr) {
        this.clear();
        this.insertRange(0, arr);
    }
    /**
     * Clears all data in the array.
     */
    clear() {
        this.array.length = 0;
        this.notify(0, SubscribableArrayEventType.Cleared);
    }
    /**
     * Gets the array.
     * @returns The array.
     */
    getArray() {
        return this.array;
    }
}

/**
 * A class for subjects that return a computed value.
 * @class ComputedSubject
 * @template I The type of the input value.
 * @template T The type of the computed output value.
 */
class ComputedSubject {
    /**
     * Creates an instance of ComputedSubject.
     * @param value The initial value.
     * @param computeFn The computation function.
     */
    constructor(value, computeFn) {
        this.computeFn = computeFn;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.notifySubscription.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
        this.rawValue = value;
        this.value = computeFn(value);
    }
    /**
     * Creates and returns a new ComputedSubject.
     * @param v The initial value of the Subject.
     * @param fn A function which transforms raw values to computed values.
     * @returns A ComputedSubject instance.
     */
    static create(v, fn) {
        return new ComputedSubject(v, fn);
    }
    /**
     * Sets the new value and notifies the subscribers when value changed.
     * @param value The new value.
     */
    set(value) {
        this.rawValue = value;
        const compValue = this.computeFn(value);
        if (compValue !== this.value) {
            this.value = compValue;
            this.notify();
        }
    }
    /**
     * Gets the computed value of the Subject.
     * @returns The computed value.
     */
    get() {
        return this.value;
    }
    /**
     * Gets the raw value of the Subject.
     * @returns The raw value.
     */
    getRaw() {
        return this.rawValue;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    /**
     * Notifies subscriptions that this subject's value has changed.
     */
    notify() {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    this.notifySubscription(sub);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ComputedSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    notifySubscription(sub) {
        sub.handler(this.value, this.rawValue);
    }
    /**
     * Responds to when a subscription to this subject is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable map whose key-value pairs can be freely added and removed.
 */
class MapSubject extends AbstractSubscribableMap {
    /**
     * Constructor.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     */
    constructor(initialEntries) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableMap = true;
        this.backingMap = new Map(initialEntries);
    }
    /**
     * Creates and returns a new MapSubject.
     * @param initialEntries The key-value pairs initially contained in the new map. If not defined, then the new map
     * will initially be empty.
     * @returns A new MapSubject instance.
     */
    static create(initialEntries) {
        return new MapSubject(initialEntries);
    }
    /** @inheritdoc */
    get() {
        return this.backingMap;
    }
    /**
     * Sets the key-value pairs contained in this map.
     * @param entries The key-value pairs to set.
     */
    set(entries) {
        const toAdd = entries instanceof Map ? entries : new Map(entries);
        for (const key of this.backingMap.keys()) {
            if (!toAdd.has(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd.keys()) {
            this.setValue(key, toAdd.get(key));
        }
    }
    /** @inheritdoc */
    setValue(key, value) {
        const hasKey = this.backingMap.has(key);
        const shouldNotify = !hasKey || this.backingMap.get(key) !== value;
        this.backingMap.set(key, value);
        if (shouldNotify) {
            this.notify(hasKey ? SubscribableMapEventType.Changed : SubscribableMapEventType.Added, key, value);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const value = this.backingMap.get(key);
        const wasDeleted = this.backingMap.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
        return wasDeleted;
    }
    /** @inheritdoc */
    clear() {
        for (const [key, value] of this.backingMap) {
            this.backingMap.delete(key);
            this.notify(SubscribableMapEventType.Deleted, key, value);
        }
    }
}

/**
 * A object-valued subscribable subject which supports setting individual properties on the object and notifying
 * subscribers of any changes to those properties.
 */
class ObjectSubject {
    /**
     * Constructs an observable object Subject.
     * @param obj The initial object.
     */
    constructor(obj) {
        this.obj = obj;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subs = [];
        this.notifyDepth = 0;
        this.initialNotifyFunc = this.initialNotify.bind(this);
        this.onSubDestroyedFunc = this.onSubDestroyed.bind(this);
    }
    /**
     * Creates and returns a new ObjectSubject.
     * @param v The initial value of the subject.
     * @returns An ObjectSubject instance.
     */
    static create(v) {
        return new ObjectSubject(v);
    }
    /**
     * Gets this subject's object.
     * @returns This subject's object.
     */
    get() {
        return this.obj;
    }
    /** @inheritdoc */
    sub(handler, initialNotify = false, paused = false) {
        const sub = new HandlerSubscription(handler, this.initialNotifyFunc, this.onSubDestroyedFunc);
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else if (initialNotify) {
            sub.initialNotify();
        }
        return sub;
    }
    /** @inheritdoc */
    unsub(handler) {
        const toDestroy = this.subs.find(sub => sub.handler === handler);
        toDestroy === null || toDestroy === void 0 ? void 0 : toDestroy.destroy();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set(arg1, value) {
        if (typeof arg1 === 'object') {
            for (const prop in arg1) {
                if (prop in this.obj) {
                    this.set(prop, arg1[prop]);
                }
            }
        }
        else {
            const oldValue = this.obj[arg1];
            if (value !== oldValue) {
                this.obj[arg1] = value;
                this.notify(arg1, oldValue);
            }
        }
    }
    /**
     * Notifies subscriptions that one of the properties of this subject's object has changed.
     * @param key The property of the object that changed.
     * @param oldValue The old value of the property that changed.
     */
    notify(key, oldValue) {
        let needCleanUpSubs = false;
        this.notifyDepth++;
        const subLen = this.subs.length;
        for (let i = 0; i < subLen; i++) {
            try {
                const sub = this.subs[i];
                if (sub.isAlive && !sub.isPaused) {
                    sub.handler(this.obj, key, this.obj[key], oldValue);
                }
                needCleanUpSubs || (needCleanUpSubs = !sub.isAlive);
            }
            catch (error) {
                console.error(`ObjectSubject: error in handler: ${error}`);
                if (error instanceof Error) {
                    console.error(error.stack);
                }
            }
        }
        this.notifyDepth--;
        if (needCleanUpSubs && this.notifyDepth === 0) {
            this.subs = this.subs.filter(sub => sub.isAlive);
        }
    }
    /**
     * Notifies a subscription of this subject's current state.
     * @param sub The subscription to notify.
     */
    initialNotify(sub) {
        for (const key in this.obj) {
            const v = this.obj[key];
            sub.handler(this.obj, key, v, v);
        }
    }
    /**
     * Responds to when a subscription to this subscribable is destroyed.
     * @param sub The destroyed subscription.
     */
    onSubDestroyed(sub) {
        // If we are not in the middle of a notify operation, remove the subscription.
        // Otherwise, do nothing and let the post-notify clean-up code handle it.
        if (this.notifyDepth === 0) {
            this.subs.splice(this.subs.indexOf(sub), 1);
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    map(fn, equalityFunc, mutateFunc, initialVal) {
        const mapFunc = (inputs, previousVal) => fn(inputs[0], previousVal);
        return mutateFunc
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            ? MappedSubject.create(mapFunc, equalityFunc, mutateFunc, initialVal, this)
            : MappedSubject.create(mapFunc, equalityFunc !== null && equalityFunc !== void 0 ? equalityFunc : AbstractSubscribable.DEFAULT_EQUALITY_FUNC, this);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    pipe(to, arg2, arg3) {
        let sub;
        let paused;
        if (typeof arg2 === 'function') {
            sub = new SubscribablePipe(this, to, arg2, this.onSubDestroyedFunc);
            paused = arg3 !== null && arg3 !== void 0 ? arg3 : false;
        }
        else {
            sub = new SubscribablePipe(this, to, this.onSubDestroyedFunc);
            paused = arg2 !== null && arg2 !== void 0 ? arg2 : false;
        }
        this.subs.push(sub);
        if (paused) {
            sub.pause();
        }
        else {
            sub.initialNotify();
        }
        return sub;
    }
}

/**
 * A subscribable set whose keys can be freely added and removed.
 */
class SetSubject extends AbstractSubscribableSet {
    /**
     * Constructor.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     */
    constructor(initialKeys) {
        super();
        this.isMutableSubscribable = true;
        this.isMutableSubscribableSet = true;
        this.backingSet = new Set(initialKeys);
    }
    /**
     * Creates and returns a new SetSubject.
     * @param initialKeys The keys initially contained in the new set. If not defined, then the new set will be
     * initialized to the empty set.
     * @returns A new SetSubject instance.
     */
    static create(initialKeys) {
        return new SetSubject(initialKeys);
    }
    /** @inheritdoc */
    get() {
        return this.backingSet;
    }
    /**
     * Sets the keys contained in this set.
     * @param keys The keys to set.
     */
    set(keys) {
        const toAdd = new Set(keys);
        for (const key of this.backingSet) {
            if (!toAdd.delete(key)) {
                this.delete(key);
            }
        }
        for (const key of toAdd) {
            this.add(key);
        }
    }
    /** @inheritdoc */
    add(key) {
        const oldSize = this.backingSet.size;
        this.backingSet.add(key);
        if (oldSize !== this.backingSet.size) {
            this.notify(SubscribableSetEventType.Added, key);
        }
        return this;
    }
    /** @inheritdoc */
    delete(key) {
        const wasDeleted = this.backingSet.delete(key);
        if (wasDeleted) {
            this.notify(SubscribableSetEventType.Deleted, key);
        }
        return wasDeleted;
    }
    /**
     * Toggles the presence of a key in this set.
     * @param key The key to toggle.
     * @param force The state of the key to force. If `true`, the key will be added to this set. If `false`, the key will
     * be removed from this set. If not defined, the key will be added to this set if it is not already present and
     * removed if it is already present.
     * @returns Whether the key is present in this set after the toggle operation.
     */
    toggle(key, force) {
        const shouldAdd = force !== null && force !== void 0 ? force : !this.backingSet.has(key);
        if (shouldAdd) {
            this.add(key);
        }
        else {
            this.delete(key);
        }
        // Explicitly query the set again instead of just returning shouldAdd in case the key was manipulated in a handler
        // triggered by its addition/removal
        return this.backingSet.has(key);
    }
    /**
     * Removes all keys from this set.
     */
    clear() {
        for (const key of this.backingSet) {
            this.backingSet.delete(key);
            this.notify(SubscribableSetEventType.Deleted, key);
        }
    }
}

/**
 * A singleton context of all nearest facility information.
 */
class NearestContext {
    /**
     * Creates an instance of a NearestContext.
     * @param facilityLoader The facility loader to use for this instance.
     * @param bus An instance of the EventBus.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     */
    constructor(facilityLoader, bus, planePos) {
        this.facilityLoader = facilityLoader;
        this.bus = bus;
        /** The max number of airports in the context.*/
        this.maxAirports = 25;
        /** The max number of VORs in the context. */
        this.maxVors = 25;
        /** The max number of intersections in the context. */
        this.maxIntersections = 25;
        /** The max number of NDBs in the context. */
        this.maxNdbs = 25;
        /** The max number of user facilities in the context. */
        this.maxUsrs = 25;
        /** The search radius for airports, in nautical miles. */
        this.airportRadius = 50;
        /** The search radius for VORs, in nautical miles. */
        this.vorRadius = 150;
        /** The search radius for intersections, in nautical miles. */
        this.intersectionRadius = 10;
        /** The search radius for NDBs, in nautical miles. */
        this.ndbRadius = 150;
        /** The search radius for user facilities, in nautical miles */
        this.usrRadius = 150;
        this.position = new GeoPoint(0, 0);
        this.airports = new NearestAirportSubscription(facilityLoader);
        this.vors = new NearestVorSubscription(facilityLoader);
        this.intersections = new NearestIntersectionSubscription(facilityLoader);
        this.ndbs = new NearestNdbSubscription(facilityLoader);
        this.usrs = new NearestUsrSubscription(facilityLoader);
        if (planePos) {
            planePos.sub(pos => this.position.set(pos));
        }
        else {
            this.bus.getSubscriber().on('gps-position')
                .handle(pos => this.position.set(pos.lat, pos.long));
        }
        this.airports.start();
        this.vors.start();
        this.intersections.start();
        this.ndbs.start();
        this.usrs.start();
    }
    /**
     * Gets an instance of the NearestContext.
     * @returns An instance of the NearestContext.
     * @throws An error if the NearestContext has not yet been initailized.
     */
    static getInstance() {
        if (this.instance !== undefined) {
            return this.instance;
        }
        throw new Error('NearestContext was not initialized.');
    }
    /**
     * Initialized the NearestContext instance.
     * @param facilityLoader The facility loader to use for the instance.
     * @param bus The EventBus to use with this instance.
     * @param planePos A subscribable which provides the current position of the airplane. If not defined, the context
     * will automatically retrieve the position from the event bus.
     * @throws An error if the NearestContext is already initialized.
     */
    static initialize(facilityLoader, bus, planePos) {
        if (this.instance === undefined) {
            this.instance = new NearestContext(facilityLoader, bus, planePos);
            this.initializedSubEvent.notify(null, this.instance);
        }
        else {
            throw new Error('NearestContext was already initialized.');
        }
    }
    /**
     * Subscribes to this NearestContext being initialized, or invokes the handler immediately if it is already initialized
     *
     * @param handler the handler
     *
     * @returns the subscription, if the action was not immediately performed
     */
    static onInitialized(handler) {
        if (this.instance) {
            handler(this.instance);
            return null;
        }
        else {
            return this.initializedSubEvent.on((_, instance) => handler(instance));
        }
    }
    /**
     * Updates the NearestContext.
     */
    async update() {
        await Promise.all([
            this.airports.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.airportRadius, UnitType.METER), this.maxAirports),
            this.intersections.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.intersectionRadius, UnitType.METER), this.maxIntersections),
            this.vors.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.vorRadius, UnitType.METER), this.maxVors),
            this.ndbs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.ndbRadius, UnitType.METER), this.maxNdbs),
            this.usrs.update(this.position.lat, this.position.lon, UnitType.NMILE.convertTo(this.usrRadius, UnitType.METER), this.maxUsrs),
        ]);
    }
    /**
     * Get the local ICAO region code based on nearby facility data.
     * @returns The region code.
     */
    getRegionCode() {
        const nearest = Array.from(this.airports.getArray()).sort(this.orderByPPosDistance.bind(this));
        for (let i = 0; i < nearest.length; i++) {
            const region = AirportUtils.tryGetRegionCode(nearest[i]);
            if (region !== undefined) {
                return region;
            }
        }
        return undefined;
    }
    /**
     * Get the variant of the region code used in airport idents.   Generally this will
     * be the region code except for the case of the US, where it will just be 'K'.
     * @returns The region code or just 'K' for the US.
     */
    getRegionIdent() {
        const region = this.getRegionCode();
        if (region !== undefined) {
            return region[0] === 'K' ? 'K' : region;
        }
        return undefined;
    }
    /**
     * Gets the first letter of the local ICAO region code.
     * @returns The airport region letter.
     */
    getRegionLetter() {
        const region = this.getRegionCode();
        return region !== undefined ? region[0] : undefined;
    }
    /**
     * Gets the nearest facility for a given type.
     * @param facilityType The type of facility.
     * @returns The nearest facility for a given type.
     */
    getNearest(facilityType) {
        switch (facilityType) {
            case FacilityType.Airport:
                return this.findNearest(this.airports.getArray());
            case FacilityType.Intersection:
                return this.findNearest(this.intersections.getArray());
            case FacilityType.VOR:
                return this.findNearest(this.vors.getArray());
            case FacilityType.NDB:
                return this.findNearest(this.ndbs.getArray());
            case FacilityType.USR:
                return this.findNearest(this.usrs.getArray());
            default:
                return undefined;
        }
    }
    /**
     * Finds the nearest facility in an array.
     * @param array A non-empty array of facilities.
     * @returns The nearest facility in the specified array.
     */
    findNearest(array) {
        let nearest = undefined;
        let nearestDistance = Infinity;
        for (let i = 0; i < array.length; i++) {
            const fac = array[i];
            const distance = this.position.distance(fac);
            if (distance < nearestDistance) {
                nearest = fac;
                nearestDistance = distance;
            }
        }
        return nearest;
    }
    /**
     * Orders facilities by their distance to the plane PPOS.
     * @param a The first facility.
     * @param b The second facility.
     * @returns The comparison order number.
     */
    orderByPPosDistance(a, b) {
        const aDist = this.position.distance(a.lat, a.lon);
        const bDist = this.position.distance(b.lat, b.lon);
        if (aDist < bDist) {
            return -1;
        }
        if (aDist > bDist) {
            return 1;
        }
        return 0;
    }
}
NearestContext.initializedSubEvent = new SubEvent();
new SubEvent();

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for electrical information.
 */
class ElectricalPublisher extends SimVarPublisher {
    /**
     * Create an ElectricalPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(ElectricalPublisher.simvars, bus, pacer);
        this.flightStarted = false;
        this.avBusList = ['elec_av1_bus', 'elec_av2_bus'];
        for (const topic of this.avBusList) {
            if (bus.getTopicSubscriberCount(topic)) {
                this.subscribed.add(topic);
            }
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle((event) => {
            if (this.avBusList.includes(event)) {
                this.subscribed.add(event);
            }
        });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.flightStarted = true;
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    onUpdate() {
        if (this.flightStarted) {
            super.onUpdate();
            if (this.av1BusLogic && this.subscribed.has('elec_av1_bus')) {
                this.publish('elec_av1_bus', this.av1BusLogic.getValue() !== 0);
            }
            if (this.av2BusLogic && this.subscribed.has('elec_av2_bus')) {
                this.publish('elec_av2_bus', this.av2BusLogic.getValue() !== 0);
            }
        }
    }
    /**
     * Sets the logic element to use for the avionics 1 bus.
     * @param logicElement The logic element to use.
     */
    setAv1Bus(logicElement) {
        this.av1BusLogic = logicElement;
    }
    /**
     * Sets the logic element to use for the avionics 2 bus.
     * @param logicElement The logic element to use.
     */
    setAv2Bus(logicElement) {
        this.av2BusLogic = logicElement;
    }
}
ElectricalPublisher.simvars = new Map([
    ['elec_master_battery', { name: 'ELECTRICAL MASTER BATTERY:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_avionics_on', { name: 'CIRCUIT AVIONICS ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_navcom1_on', { name: 'CIRCUIT NAVCOM1 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom2_on', { name: 'CIRCUIT NAVCOM2 ON', type: SimVarValueType.Bool }],
    ['elec_circuit_navcom3_on', { name: 'CIRCUIT NAVCOM3 ON', type: SimVarValueType.Bool }],
    ['elec_bus_main_v', { name: 'ELECTRICAL MAIN BUS VOLTAGE:#index#', type: SimVarValueType.Volts, indexed: true }],
    ['elec_bus_main_a', { name: 'ELECTRICAL MAIN BUS AMPS:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bus_avionics_v', { name: 'ELECTRICAL AVIONICS BUS VOLTAGE', type: SimVarValueType.Volts }],
    ['elec_bus_avionics_a', { name: 'ELECTRICAL AVIONICS BUS AMPS', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_1_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:1', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_2_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:2', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_3_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:3', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_4_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:4', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_5_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:5', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_6_v', { name: 'ELECTRICAL GENALT BUS VOLTAGE:6', type: SimVarValueType.Volts }],
    ['elec_bus_genalt_1_a', { name: 'ELECTRICAL GENALT BUS AMPS:1', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_2_a', { name: 'ELECTRICAL GENALT BUS AMPS:2', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_3_a', { name: 'ELECTRICAL GENALT BUS AMPS:3', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_4_a', { name: 'ELECTRICAL GENALT BUS AMPS:4', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_5_a', { name: 'ELECTRICAL GENALT BUS AMPS:5', type: SimVarValueType.Amps }],
    ['elec_bus_genalt_6_a', { name: 'ELECTRICAL GENALT BUS AMPS:6', type: SimVarValueType.Amps }],
    ['elec_bat_a', { name: 'ELECTRICAL BATTERY LOAD:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_bat_v', { name: 'ELECTRICAL BATTERY VOLTAGE:#index#', type: SimVarValueType.Amps, indexed: true }],
    ['elec_ext_power_available', { name: 'EXTERNAL POWER AVAILABLE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_ext_power_on', { name: 'EXTERNAL POWER ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_switch', { name: 'APU GENERATOR SWITCH:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_apu_gen_active', { name: 'APU GENERATOR ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_eng_gen_switch', { name: 'GENERAL ENG MASTER ALTERNATOR:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_on', { name: 'CIRCUIT ON:#index#', type: SimVarValueType.Bool, indexed: true }],
    ['elec_circuit_switch_on', { name: 'CIRCUIT SWITCH ON:#index#', type: SimVarValueType.Bool, indexed: true }],
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/** A publisher for Engine information. */
class EISPublisher extends SimVarPublisher {
    /**
     * Create an EISPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const isUsingAdvancedFuelSystem = SimVar.GetSimVarValue('NEW FUEL SYSTEM', SimVarValueType.Bool) !== 0;
        const totalUnusableFuelGal = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.GAL);
        const totalUnusableFuelLb = SimVar.GetSimVarValue('UNUSABLE FUEL TOTAL QUANTITY', SimVarValueType.LBS);
        const nonIndexedSimVars = [
            ['vac', { name: 'SUCTION PRESSURE', type: SimVarValueType.InHG }],
            ['fuel_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? v => v + totalUnusableFuelGal : undefined }],
            ['fuel_usable_total', { name: 'FUEL TOTAL QUANTITY', type: SimVarValueType.GAL, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelGal, 0) }],
            ['fuel_usable_total_weight', { name: 'FUEL TOTAL QUANTITY WEIGHT', type: SimVarValueType.Pounds, map: isUsingAdvancedFuelSystem ? undefined : v => Math.max(v - totalUnusableFuelLb, 0) }],
            ['fuel_left', { name: 'FUEL LEFT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right', { name: 'FUEL RIGHT QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main', { name: 'FUEL TANK LEFT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_left_main_pct', { name: 'FUEL TANK LEFT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_right_main', { name: 'FUEL TANK RIGHT MAIN QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_right_main_pct', { name: 'FUEL TANK RIGHT MAIN LEVEL', type: SimVarValueType.Percent }],
            ['fuel_center', { name: 'FUEL TANK CENTER QUANTITY', type: SimVarValueType.GAL }],
            ['fuel_weight_per_gallon', { name: 'FUEL WEIGHT PER GALLON', type: SimVarValueType.LBS }],
            ['fuel_tank_selector_state_1', { name: 'FUEL TANK SELECTOR:1', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_2', { name: 'FUEL TANK SELECTOR:2', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_3', { name: 'FUEL TANK SELECTOR:3', type: SimVarValueType.Number }],
            ['fuel_tank_selector_state_4', { name: 'FUEL TANK SELECTOR:4', type: SimVarValueType.Number }],
            ['eng_hours_1', { name: 'GENERAL ENG ELAPSED TIME:1', type: SimVarValueType.Hours }],
            ['apu_pct', { name: 'APU PCT RPM', type: SimVarValueType.Percent }],
            ['apu_pct_starter', { name: 'APU PCT STARTER', type: SimVarValueType.Percent }],
            ['apu_switch', { name: 'APU SWITCH', type: SimVarValueType.Bool }],
            ['eng_starter_active', { name: 'GENERAL ENG STARTER ACTIVE:#index#', type: SimVarValueType.Bool, indexed: true }],
        ];
        const engineIndexedSimVars = [
            ['rpm', { name: 'GENERAL ENG RPM', type: SimVarValueType.RPM }],
            ['prop_rpm', { name: 'PROP RPM', type: SimVarValueType.RPM }],
            ['n1', { name: 'TURB ENG CORRECTED N1', type: SimVarValueType.Percent }],
            ['n2', { name: 'TURB ENG CORRECTED N2', type: SimVarValueType.Percent }],
            ['torque', { name: 'TURB ENG MAX TORQUE PERCENT', type: SimVarValueType.Percent }],
            ['fuel_flow', { name: 'ENG FUEL FLOW GPH', type: SimVarValueType.GPH }],
            ['recip_ff', { name: 'RECIP ENG FUEL FLOW', type: SimVarValueType.PPH }],
            ['oil_press', { name: 'ENG OIL PRESSURE', type: SimVarValueType.PSI }],
            ['oil_temp', { name: 'ENG OIL TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['itt', { name: 'TURB ENG ITT', type: SimVarValueType.Celsius }],
            ['egt', { name: 'ENG EXHAUST GAS TEMPERATURE', type: SimVarValueType.Farenheit }],
            ['eng_hyd_press', { name: 'ENG HYDRAULIC PRESSURE', type: SimVarValueType.PSI }],
            ['eng_starter_on', { name: 'GENERAL ENG STARTER', type: SimVarValueType.Bool }],
            ['eng_combustion', { name: 'GENERAL ENG COMBUSTION', type: SimVarValueType.Bool }],
            ['eng_ignition_switch_state', { name: 'TURB ENG IGNITION SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_igniting', { name: 'TURB ENG IS IGNITING', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_on', { name: 'GENERAL ENG FUEL PUMP ON', type: SimVarValueType.Bool }],
            ['eng_fuel_pump_switch_state', { name: 'GENERAL ENG FUEL PUMP SWITCH EX1', type: SimVarValueType.Number }],
            ['eng_vibration', { name: 'ENG VIBRATION', type: SimVarValueType.Number }],
            ['fuel_flow_pph', { name: 'ENG FUEL FLOW PPH', type: SimVarValueType.PPH }],
        ];
        const simvars = new Map(nonIndexedSimVars);
        // add engine-indexed simvars
        const engineCount = SimVar.GetSimVarValue('NUMBER OF ENGINES', SimVarValueType.Number);
        for (const [topic, simvar] of [...engineIndexedSimVars]) {
            // describe the indexed engine topics
            for (let i = 1; i <= engineCount; i++) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type,
                    map: simvar.map
                });
            }
        }
        super(simvars, bus, pacer);
        this.engineCount = engineCount;
        this.subscribed.add('fuel_flow_total');
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.subscribed.has('fuel_flow_total')) {
            let totalFuelFlow = 0;
            for (let i = 1; i <= this.engineCount; i++) {
                totalFuelFlow += SimVar.GetSimVarValue(`ENG FUEL FLOW GPH:${i}`, SimVarValueType.GPH);
            }
            this.publish('fuel_flow_total', totalFuelFlow);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A publisher for Engine information.
 */
class WeightBalanceSimvarPublisher extends SimVarPublisher {
    /**
     * Create a WeightAndBalancePublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer) {
        const simvars = new Map([
            ['total_weight', { name: 'TOTAL WEIGHT', type: SimVarValueType.Pounds }],
            ['payload_station_weight', { name: 'PAYLOAD STATION WEIGHT:#index#', type: SimVarValueType.Pounds, indexed: true }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * Flight timer modes.
 */
var FlightTimerMode;
(function (FlightTimerMode) {
    FlightTimerMode[FlightTimerMode["CountingDown"] = 0] = "CountingDown";
    FlightTimerMode[FlightTimerMode["CountingUp"] = 1] = "CountingUp";
})(FlightTimerMode || (FlightTimerMode = {}));
/**
 * A publisher for flight timer information.
 */
class FlightTimerPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param timerCount The number of supported timers.
     * @param pacer An optional pacer to use to control the rate of publishing.
     */
    constructor(bus, timerCount, pacer) {
        const simVars = new Map();
        const baseSimVars = [
            ['timer_mode', { name: 'L:WTFltTimer_Mode', type: SimVarValueType.Number }],
            ['timer_is_running', { name: 'L:WTFltTimer_Running', type: SimVarValueType.Bool }],
            ['timer_initial_value_ms', { name: 'L:WTFltTimer_Initial_Value', type: SimVarValueType.Number }],
            ['timer_value_ms', { name: 'L:WTFltTimer_Value', type: SimVarValueType.Number }]
        ];
        timerCount = Math.max(timerCount, 0);
        for (let i = 1; i <= timerCount; i++) {
            for (const [topic, simvar] of baseSimVars) {
                simVars.set(`${topic}_${i}`, {
                    name: `${simvar.name}:${i}`,
                    type: simvar.type
                });
            }
        }
        super(simVars, bus, pacer);
    }
}

/// <reference types="@microsoft/msfs-types/js/simplane" />
/**
 * A publisher for global positioning and inertial data.
 */
class GNSSPublisher extends BasePublisher {
    /**
     * Create an GNSSPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        super(bus, pacer);
        this.vec3Cache = [Vec3Math.create(), Vec3Math.create()];
        this.simVarPublisher = new SimVarPublisher(new Map([
            ['zulu_time', { name: 'E:ZULU TIME', type: SimVarValueType.Seconds }],
            ['time_of_day', { name: 'E:TIME OF DAY', type: SimVarValueType.Number }],
            ['ground_speed', { name: 'GROUND VELOCITY', type: SimVarValueType.Knots }],
            ['inertial_vertical_speed', { name: 'VELOCITY WORLD Y', type: SimVarValueType.FPM }]
        ]), this.bus, this.pacer);
        this.needPublish = {
            'gps-position': false,
            'track_deg_true': false,
            'track_deg_magnetic': false,
            'magvar': false,
            'inertial_speed': false,
            'inertial_acceleration': false,
            'inertial_track_acceleration': false
        };
        for (const topic in this.needPublish) {
            this.needPublish[topic] = bus.getTopicSubscriberCount(topic) > 0;
        }
        bus.getSubscriber().on('event_bus_topic_first_sub').handle(this.onTopicSubscribed.bind(this));
    }
    /**
     * Responds to when a topic is first subscribed to on the event bus.
     * @param topic The subscribed topic.
     */
    onTopicSubscribed(topic) {
        if (topic in this.needPublish) {
            this.needPublish[topic] = true;
            if (this.publishActive) {
                switch (topic) {
                    case 'gps-position':
                        this.publishPosition();
                        break;
                    case 'track_deg_true':
                        this.publishTrack(true, false, false);
                        break;
                    case 'track_deg_magnetic':
                        this.publishTrack(false, true, false);
                        break;
                    case 'magvar':
                        this.publishTrack(false, false, true);
                        break;
                    case 'inertial_speed':
                        this.publishInertialData(true, false, false);
                        break;
                    case 'inertial_acceleration':
                        this.publishInertialData(false, true, false);
                        break;
                    case 'inertial_track_acceleration':
                        this.publishInertialData(false, false, true);
                        break;
                }
            }
        }
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
        this.simVarPublisher.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
        this.simVarPublisher.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        this.needPublish['gps-position'] && this.publishPosition();
        this.publishTrack(this.needPublish['track_deg_true'], this.needPublish['track_deg_magnetic'], this.needPublish['magvar']);
        this.publishInertialData(this.needPublish['inertial_speed'], this.needPublish['inertial_acceleration'], this.needPublish['inertial_track_acceleration']);
        this.simVarPublisher.onUpdate();
    }
    /**
     * Publishes the gps-position event.
     */
    publishPosition() {
        const lat = SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree);
        const lon = SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree);
        const alt = SimVar.GetSimVarValue('PLANE ALTITUDE', SimVarValueType.Meters);
        this.publish('gps-position', new LatLongAlt(lat, lon, alt));
    }
    /**
     * Publishes the `track_deg_true`, `track_deg_magnetic`, and `magvar` topics.
     * @param publishTrue Whether to publish the `track_deg_true` topic.
     * @param publishMagnetic Whether to publish the `track_deg_magnetic` topic.
     * @param publishMagvar Whether to publish the `magvar` topic.
     */
    publishTrack(publishTrue, publishMagnetic, publishMagvar) {
        let trueTrack = 0;
        let magneticTrack = 0;
        let magvar = 0;
        if (publishTrue || publishMagnetic) {
            const headingTrue = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree);
            trueTrack = GNSSPublisher.getInstantaneousTrack(headingTrue);
        }
        if (publishMagvar || publishMagnetic) {
            magvar = SimVar.GetSimVarValue('MAGVAR', SimVarValueType.Degree);
            if (publishMagnetic) {
                magneticTrack = NavMath.normalizeHeading(trueTrack - magvar);
            }
        }
        publishTrue && this.publish('track_deg_true', trueTrack);
        publishMagnetic && this.publish('track_deg_magnetic', magneticTrack);
        publishMagvar && this.publish('magvar', magvar);
    }
    /**
     * Publishes the `inertial_speed`, `inertial_acceleration`, and `inertial_track_acceleration` topics.
     * @param publishSpeed Whether to publish the `inertial_speed` topic.
     * @param publishAcceleration Whether to publish the `inertial_acceleration` topic.
     * @param publishTrackAcceleration Whether to publish the `inertial_track_acceleration` topic.
     */
    publishInertialData(publishSpeed, publishAcceleration, publishTrackAcceleration) {
        const velocityVec = this.vec3Cache[0];
        const accelerationVec = this.vec3Cache[1];
        let speed = 0;
        let acceleration = 0;
        if (publishSpeed || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('VELOCITY BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('VELOCITY BODY Z', SimVarValueType.MetersPerSecond), velocityVec);
            speed = Vec3Math.abs(velocityVec);
        }
        if (publishAcceleration || publishTrackAcceleration) {
            Vec3Math.set(SimVar.GetSimVarValue('ACCELERATION BODY X', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Y', SimVarValueType.MetersPerSecond), SimVar.GetSimVarValue('ACCELERATION BODY Z', SimVarValueType.MetersPerSecond), accelerationVec);
            acceleration = Vec3Math.abs(accelerationVec);
        }
        publishSpeed && this.publish('inertial_speed', speed);
        publishAcceleration && this.publish('inertial_acceleration', acceleration);
        publishTrackAcceleration && this.publish('inertial_track_acceleration', speed === 0 ? acceleration : Vec3Math.dot(accelerationVec, velocityVec) / speed);
    }
    /**
     * Gets the instantaneous true track.
     * @param headingTrue The true heading, in degrees.
     * @returns The true track, in degrees.
     */
    static getInstantaneousTrack(headingTrue = 0) {
        const velocityEW = SimVar.GetSimVarValue('VELOCITY WORLD X', SimVarValueType.Knots);
        const velocityNS = SimVar.GetSimVarValue('VELOCITY WORLD Z', SimVarValueType.Knots);
        let track = headingTrue;
        if (velocityEW !== 0 || velocityNS !== 0) {
            track = NavMath.normalizeHeading(Math.atan2(velocityEW, velocityNS) * Avionics.Utils.RAD2DEG);
        }
        return track;
    }
}

/**
 * A heap which allocates instances of a resource.
 */
class ResourceHeap {
    /**
     * Constructor.
     * @param factory A function which creates new instances of this heap's resource.
     * @param destructor A function which destroys instances of this heap's resource.
     * @param onAllocated A function which is called when an instance of this heap's resource is allocated.
     * @param onFreed A function which is called when an instance of this heap's resource is freed.
     * @param initialSize The initial size of this heap. Defaults to `0`.
     * @param maxSize The maximum size of this heap. Defaults to `Number.MAX_SAFE_INTEGER`. This heap cannot allocate
     * more resources than its maximum size.
     * @param autoShrinkThreshold The size above which this heap will attempt to automatically reduce its size when
     * resources are freed. The heap will never reduce its size below this threshold. Defaults to
     * `Number.MAX_SAFE_INTEGER`.
     */
    constructor(factory, destructor, onAllocated, onFreed, initialSize = 0, maxSize = Number.MAX_SAFE_INTEGER, autoShrinkThreshold = Number.MAX_SAFE_INTEGER) {
        this.factory = factory;
        this.destructor = destructor;
        this.onAllocated = onAllocated;
        this.onFreed = onFreed;
        this.maxSize = maxSize;
        this.autoShrinkThreshold = autoShrinkThreshold;
        this.cache = [];
        this.numAllocated = 0;
        for (let i = 0; i < Math.min(initialSize, maxSize); i++) {
            this.cache.push(factory());
        }
    }
    /**
     * Allocates a resource instance from this heap. If this heap has an existing free resource available, one will be
     * returned. Otherwise, a new resource instance will be created, added to the heap, and returned.
     * @returns A resource.
     * @throws Error if this heap has reached its allocation limit.
     */
    allocate() {
        if (this.numAllocated >= this.maxSize) {
            throw new Error(`ResourceHeap: maximum number of allocations (${this.maxSize}) reached`);
        }
        let resource;
        if (this.numAllocated < this.cache.length) {
            resource = this.cache[this.numAllocated];
        }
        else {
            this.cache.push(resource = this.factory());
        }
        this.numAllocated++;
        if (this.onAllocated !== undefined) {
            this.onAllocated(resource);
        }
        return resource;
    }
    /**
     * Frees a resource instance allocated from this heap, allowing it to be re-used.
     * @param resource The resource to free.
     */
    free(resource) {
        const index = this.cache.indexOf(resource);
        if (index < 0 || index >= this.numAllocated) {
            return;
        }
        const freed = this.cache[index];
        this.numAllocated--;
        this.cache[index] = this.cache[this.numAllocated];
        this.cache[this.numAllocated] = freed;
        // If the heap size is over the auto-shrink threshold and the number of allocated instances drops to less than or
        // equal to half of the heap size, then reduce the size of the heap to the threshold, or 125% of the number of
        // allocated instances, whichever is greater.
        if (this.cache.length > this.autoShrinkThreshold && this.numAllocated <= this.cache.length / 2) {
            const newLength = Math.max(this.autoShrinkThreshold, this.numAllocated * 1.25);
            for (let i = newLength; i < this.cache.length; i++) {
                this.destructor(this.cache[i]);
            }
            this.cache.length = newLength;
        }
        if (this.onFreed !== undefined) {
            this.onFreed(resource);
        }
    }
}

/**
 * SBAS group names.
 */
var SBASGroupName;
(function (SBASGroupName) {
    /** Wide Area Augmentation System (USA). */
    SBASGroupName["WAAS"] = "WAAS";
    /** European Geostationary Navigation Overlay Service (EU). */
    SBASGroupName["EGNOS"] = "EGNOS";
    /** GPS Aided Geo Augmented Navigation System (India). */
    SBASGroupName["GAGAN"] = "GAGAN";
    /** Multi-functional Satellite Augmentation System (Japan). */
    SBASGroupName["MSAS"] = "MSAS";
})(SBASGroupName || (SBASGroupName = {}));
/**
 * An instrument that computes GPS satellite information.
 */
class GPSSatComputer {
    /**
     * Creates an instance of GPSSat.
     * @param index The index of this GPSSat.
     * @param bus An instance of the event bus.
     * @param ephemerisFile The HTTP path to the ephemeris file to use for computations.
     * @param sbasFile The HTTP path to the SBAS definitions file.
     * @param updateInterval The interval in milliseconds to update the satellite positions.
     * @param enabledSBASGroups The names of the SBAS satellite groups for which signal reception is enabled.
     * @param syncRole This system's sync role. A `primary` system will broadcast sync events through the event bus when
     * satellite positions are calculated, satellite states change, or the system is reset. A `replica` system will
     * listen for the aforementioned sync events on the event bus and set its state accordingly. A system with a sync
     * role of `none` does neither; it maintains its own independent state and does not sync it to other systems.
     */
    constructor(index, bus, ephemerisFile, sbasFile, updateInterval, enabledSBASGroups, syncRole = 'none') {
        this.index = index;
        this.bus = bus;
        this.ephemerisFile = ephemerisFile;
        this.sbasFile = sbasFile;
        this.updateInterval = updateInterval;
        this.syncRole = syncRole;
        this.publisher = this.bus.getPublisher();
        this.syncPublisher = this.bus.getPublisher();
        this.stateChangedTopic = `gps_system_state_changed_${this.index}`;
        this.satStateChangedTopic = `gps_sat_state_changed_${this.index}`;
        this.satPosCalcTopic = `gps_sat_pos_calculated_${this.index}`;
        this.sbasStateChangedTopic = `gps_system_sbas_state_changed_${this.index}`;
        this.pdopTopic = `gps_system_pdop_${this.index}`;
        this.hdopTopic = `gps_system_hdop_${this.index}`;
        this.vdopTopic = `gps_system_vdop_${this.index}`;
        this.satCalcSyncTopic = `gps_system_sync_sat_calc_${this.index}`;
        this.satStateSyncTopic = `gps_system_sync_sat_state_changed_${this.index}`;
        this.resetSyncTopic = `gps_system_sync_reset_${this.index}`;
        this.satStateRequestSyncTopic = `gps_system_sync_sat_state_request_${this.index}`;
        this.satStateResponseSyncTopic = `gps_system_sync_sat_state_response_${this.index}`;
        this.ephemerisData = {};
        this.sbasData = [];
        this.sbasServiceAreas = new Map();
        this.currentSbasGroupsInView = new Set();
        this.satellites = [];
        this.ppos = new GeoPoint(0, 0);
        this.pposVec = new Float64Array(2);
        this.vecHeap = new ResourceHeap(() => Vec3Math.create(), () => { });
        this.altitude = 0;
        this.previousSimTime = 0;
        this.previousUpdate = 0;
        this.simTime = 0;
        this._state = GPSSystemState.Searching;
        this._sbasState = GPSSystemSBASState.Disabled;
        this.dops = Vec3Math.create();
        this._pdop = -1;
        this._hdop = -1;
        this._vdop = -1;
        this.isInit = false;
        this.needAcquireAndUse = false;
        this.needSatCalc = false;
        this.pendingSatStateUpdates = new Map();
        this.enabledSBASGroups = 'isSubscribableSet' in enabledSBASGroups ? enabledSBASGroups : SetSubject.create(enabledSBASGroups);
        this.bus.getSubscriber().on('gps-position').handle(pos => {
            this.ppos.set(pos.lat, pos.long);
            Vec2Math.set(pos.lat, pos.long, this.pposVec);
            this.altitude = pos.alt;
        });
        this.bus.getSubscriber().on('simTime').handle(time => this.simTime = time);
    }
    /**
     * Gets the current GPS system state.
     * @returns The current GPS system state.
     */
    get state() {
        return this._state;
    }
    /**
     * Gets the current GPS system SBAS state.
     * @returns The current GPS system SBAS state.
     */
    get sbasState() {
        return this._sbasState;
    }
    /**
     * Gets this system's current position dilution of precision value (PDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current position dilution of precision value (PDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get pdop() {
        return this._pdop;
    }
    /**
     * Gets this system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current horizontal dilution of precision value (HDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get hdop() {
        return this._hdop;
    }
    /**
     * Gets this system's current vertical dilution of precision value (VDOP), or `-1` if this system has not acquired a
     * position solution.
     * @returns This system's current vertical dilution of precision value (VDOP), or `-1` if this system has not
     * acquired a position solution.
     */
    get vdop() {
        return this._vdop;
    }
    /**
     * Adds the defined SBAS satellites to the tracked satellites.
     */
    addSbasSatellites() {
        const tempVec = new Float64Array(3);
        const tempGeoPoint = new GeoPoint(0, 0);
        const orbitHeight = UnitType.KILOMETER.convertTo(35785, UnitType.GA_RADIAN);
        for (let i = 0; i < this.sbasData.length; i++) {
            const sbasDef = this.sbasData[i];
            this.sbasServiceAreas.set(sbasDef.group, sbasDef.coverage);
            for (const satDef of sbasDef.constellation) {
                const sat = new GPSSatellite(satDef.prn, sbasDef.group);
                tempGeoPoint.set(0, satDef.lon);
                const positionCartesian = Vec3Math.multScalar(tempGeoPoint.toCartesian(tempVec), orbitHeight, tempVec);
                sat.positionCartesian.set(positionCartesian);
                this.satellites.push(sat);
            }
        }
    }
    /** @inheritdoc */
    init() {
        // Publish initial state.
        this.publisher.pub(this.stateChangedTopic, this._state, false, true);
        this.publisher.pub(this.sbasStateChangedTopic, this._sbasState, false, true);
        this.publisher.pub(this.pdopTopic, this._pdop, false, true);
        this.publisher.pub(this.hdopTopic, this._hdop, false, true);
        this.publisher.pub(this.vdopTopic, this._vdop, false, true);
        this.loadEphemerisData().then(() => this.loadSbasData()).then(() => {
            this.isInit = true;
            // Setup sync logic.
            if (this.syncRole === 'replica') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satCalcSyncTopic).handle(() => { this.needSatCalc = true; });
                sub.on(this.satStateSyncTopic).handle(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                sub.on(this.resetSyncTopic).handle(() => { this.reset(); });
                sub.on(this.satStateResponseSyncTopic).handle(response => {
                    this.needSatCalc = true;
                    response.forEach(data => { this.pendingSatStateUpdates.set(data.prn, data); });
                });
                // Request initial state.
                this.syncPublisher.pub(this.satStateRequestSyncTopic, undefined, true, false);
            }
            else if (this.syncRole === 'primary') {
                const sub = this.bus.getSubscriber();
                sub.on(this.satStateRequestSyncTopic).handle(() => {
                    this.syncPublisher.pub(this.satStateResponseSyncTopic, this.satellites.map(sat => { return { prn: sat.prn, state: sat.state.get() }; }), true, false);
                });
            }
            if (this.needAcquireAndUse) {
                this.needAcquireAndUse = false;
                this.acquireAndUseSatellites();
            }
            else {
                this.reset();
            }
        });
    }
    /**
     * Loads the GPS ephemeris data file.
     */
    loadEphemerisData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.ephemerisData = JSON.parse(request.responseText);
                        for (const prn in this.ephemerisData) {
                            this.satellites.push(new GPSSatellite(parseInt(prn), undefined, this.ephemerisData[prn]));
                        }
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with ephemeris data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.ephemerisFile);
            request.send();
        });
    }
    /**
     * Loads the GPS SBAS data file.
     */
    loadSbasData() {
        return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.onreadystatechange = () => {
                if (request.readyState === XMLHttpRequest.DONE) {
                    if (request.status === 200) {
                        this.sbasData = JSON.parse(request.responseText);
                        this.addSbasSatellites();
                        resolve();
                    }
                    else {
                        reject(`Could not initialize sat computer system with sbas data: ${request.responseText}`);
                    }
                }
            };
            request.open('GET', this.sbasFile);
            request.send();
        });
    }
    /**
     * Instantly acquires and starts using all satellites with sufficient signal strength. If signal strength allows,
     * SBAS satellites are instantly promoted to the {@link GPSSatelliteState.Acquired} state, and GPS satellites are
     * instantly promoted to the {@link GPSSatelliteState.InUse}/{@link GPSSatelliteState.InUseDiffApplied} state.
     *
     * If this system is not initialized, the operation will be delayed until just after initialization, unless `reset()`
     * is called between now and then.
     *
     * Has no effect if this system is a replica.
     */
    acquireAndUseSatellites() {
        if (this.syncRole === 'replica') {
            return;
        }
        if (this.isInit) {
            this.updateSatellites(0, true, true);
        }
        else {
            this.needAcquireAndUse = true;
        }
    }
    /**
     * Resets the GPSSatComputer system. This will set the of the system to {@link GPSSystemState.Searching} and the
     * state of every satellite to {@link GPSSatelliteState.None}.
     *
     * If this system is not initialized, this method has no effect other than to cancel any pending operations triggered
     * by previous calls to `acquireAndUseSatellites()`.
     */
    reset() {
        this.needAcquireAndUse = false;
        if (!this.isInit) {
            return;
        }
        this.satellites.forEach(sat => {
            const currentState = sat.state.get();
            sat.state.set(GPSSatelliteState.None);
            if (currentState !== GPSSatelliteState.None) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
            }
        });
        const currentState = this._state;
        this._state = GPSSystemState.Searching;
        if (currentState !== GPSSystemState.Searching) {
            this.publisher.pub(this.stateChangedTopic, GPSSystemState.Searching, false, true);
        }
        this.setDop(-1, -1, -1);
        if (this.syncRole === 'primary') {
            this.syncPublisher.pub(this.resetSyncTopic, undefined, true, false);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isInit) {
            return;
        }
        const deltaTime = this.simTime - this.previousSimTime;
        if (this.syncRole !== 'replica') {
            if (deltaTime < 0 || deltaTime > (this.updateInterval * 2)) {
                this.previousSimTime = this.simTime;
                this.previousUpdate = this.simTime;
                return;
            }
        }
        const shouldUpdatePositions = this.syncRole === 'replica'
            ? this.needSatCalc
            : this.simTime >= this.previousUpdate + this.updateInterval;
        this.needSatCalc = false;
        this.updateSatellites(deltaTime, shouldUpdatePositions, false);
    }
    /**
     * Updates the states and optionally the orbital positions of all satellites.
     * @param deltaTime The time elapsed, in milliseconds, since the last satellite update.
     * @param shouldUpdatePositions Whether to update the orbital positions of the satellites.
     * @param forceAcquireAndUse Whether to immediately force satellites to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} for SBAS satellites and {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} for GPS satellites) if signal strength is sufficient.
     */
    updateSatellites(deltaTime, shouldUpdatePositions, forceAcquireAndUse) {
        var _a, _b, _c, _d;
        let numAcquiring = 0;
        let numActiveSbas = 0;
        let shouldUpdateDop = shouldUpdatePositions;
        if (shouldUpdatePositions && this.syncRole === 'primary') {
            (_a = this.syncPublisher) === null || _a === void 0 ? void 0 : _a.pub(this.satCalcSyncTopic, undefined, true, false);
        }
        this.currentSbasGroupsInView.clear();
        const enabledSBASGroups = this.enabledSBASGroups.get();
        for (let i = 0; i < this.satellites.length; i++) {
            const sat = this.satellites[i];
            if (shouldUpdatePositions) {
                sat.computeSatellitePositions(this.simTime);
                sat.applyProjection(this.ppos, this.altitude);
            }
            sat.calculateSignalStrength(this.altitude);
            const updatedState = this.syncRole === 'replica'
                ? sat.forceUpdateState((_c = (_b = this.pendingSatStateUpdates.get(sat.prn)) === null || _b === void 0 ? void 0 : _b.state) !== null && _c !== void 0 ? _c : sat.state.get())
                : sat.updateState(deltaTime, this._state === GPSSystemState.DiffSolutionAcquired, forceAcquireAndUse);
            if (updatedState) {
                this.publisher.pub(this.satStateChangedTopic, sat, false, false);
                if (this.syncRole === 'primary') {
                    this.syncPublisher.pub(this.satStateSyncTopic, { prn: sat.prn, state: sat.state.get() }, true, false);
                }
                shouldUpdateDop = true;
            }
            const satState = sat.state.get();
            if (satState === GPSSatelliteState.Acquired || satState === GPSSatelliteState.DataCollected) {
                numAcquiring++;
                if (sat.sbasGroup !== undefined && enabledSBASGroups.has(sat.sbasGroup)) {
                    numActiveSbas++;
                    this.currentSbasGroupsInView.add(sat.sbasGroup);
                }
            }
        }
        this.pendingSatStateUpdates.clear();
        let withinSbasArea = false;
        for (const group of this.currentSbasGroupsInView) {
            const coverage = this.sbasServiceAreas.get(group);
            if (coverage !== undefined) {
                withinSbasArea = (_d = Vec2Math.pointWithinPolygon(coverage, this.pposVec)) !== null && _d !== void 0 ? _d : false;
            }
            if (withinSbasArea) {
                break;
            }
        }
        const newSBASState = withinSbasArea
            ? GPSSystemSBASState.Active
            : enabledSBASGroups.size === 0 ? GPSSystemSBASState.Disabled : GPSSystemSBASState.Inactive;
        let newSystemState = GPSSystemState.Searching;
        if (numAcquiring > 0) {
            newSystemState = GPSSystemState.Acquiring;
        }
        let pdop = this._pdop, hdop = this._hdop, vdop = this._vdop;
        if (shouldUpdateDop) {
            [pdop, hdop, vdop] = this.calculateDop(this.dops);
        }
        const is3dSolutionPossible = pdop >= 0;
        if (is3dSolutionPossible) {
            newSystemState = numActiveSbas > 0 && withinSbasArea ? GPSSystemState.DiffSolutionAcquired : GPSSystemState.SolutionAcquired;
        }
        if (this._state !== newSystemState) {
            this._state = newSystemState;
            this.publisher.pub(this.stateChangedTopic, newSystemState, false, true);
        }
        if (this._sbasState !== newSBASState) {
            this._sbasState = newSBASState;
            this.publisher.pub(this.sbasStateChangedTopic, newSBASState, false, true);
        }
        if (shouldUpdatePositions) {
            this.previousUpdate = this.simTime;
            this.publisher.pub(this.satPosCalcTopic, undefined, false, false);
        }
        this.setDop(pdop, hdop, vdop);
        this.previousSimTime = this.simTime;
    }
    /**
     * Gets the current satellites that are being tracked by this computer.
     * @returns The collection of current satellites.
     */
    get sats() {
        return this.satellites;
    }
    /**
     * Calculates the horizon zenith angle.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    calcHorizonAngle() {
        return Math.acos(6378100 / (6378100 + this.altitude));
    }
    /**
     * Calculates dilution of precision values (PDOP, HDOP, VDOP) for the current satellite constellation.
     * @param out The vector to which to write the results.
     * @returns Dilution of precision values for the current satellite constellation, as `[PDOP, HDOP, VDOP]`.
     */
    calculateDop(out) {
        Vec3Math.set(-1, -1, -1, out);
        const satsInUse = this.satellites.filter(sat => {
            const state = sat.state.get();
            return state === GPSSatelliteState.InUse || state === GPSSatelliteState.InUseDiffApplied;
        });
        if (satsInUse.length < 4) {
            return out;
        }
        // Get unit line-of-sight vectors for each satellite
        for (let i = 0; i < satsInUse.length; i++) {
            const [zenith, hour] = satsInUse[i].position.get();
            satsInUse[i] = Vec3Math.setFromSpherical(1, zenith, hour, this.vecHeap.allocate());
        }
        const satVecs = satsInUse;
        // First define line-of-sight matrix L composed of row vectors Si = [xi, yi, zi, 1], where xi, yi, zi are the
        // components of the unit line-of-sight vector for satellite i. Then compute the covariance matrix as C = (LᵀL)⁻¹.
        // P = LᵀL is guaranteed to be symmetric, so we need only compute the upper triangular part of the product.
        const P11 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[0], 0);
        const P12 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[1], 0);
        const P13 = satVecs.reduce((sum, vec) => sum + vec[0] * vec[2], 0);
        const P14 = satVecs.reduce((sum, vec) => sum + vec[0], 0);
        const P22 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[1], 0);
        const P23 = satVecs.reduce((sum, vec) => sum + vec[1] * vec[2], 0);
        const P24 = satVecs.reduce((sum, vec) => sum + vec[1], 0);
        const P33 = satVecs.reduce((sum, vec) => sum + vec[2] * vec[2], 0);
        const P34 = satVecs.reduce((sum, vec) => sum + vec[2], 0);
        const P44 = satVecs.length;
        for (let i = 0; i < satVecs.length; i++) {
            this.vecHeap.free(satVecs[i]);
        }
        // Perform block-wise inversion of LᵀL (which is 4x4, so neatly decomposes into four 2x2 matrices) with optimizations
        // presented in Ingemarsson, C and Gustafsson O, 2015.
        // P = [A  B]
        //     [Bᵀ D]
        // C = P⁻¹ = [E  F]
        //           [Fᵀ H]
        // Since we only care about the variance terms along the diagonal of C, we can skip calculating F.
        // V = A⁻¹ (A is symmetric, therefore V is also symmetric, so we only need to compute the upper triangular part)
        const detA = 1 / (P11 * P22 - P12 * P12);
        const V11 = P22 * detA;
        const V12 = -P12 * detA;
        const V22 = P11 * detA;
        // X = VB
        const X11 = V11 * P13 + V12 * P23;
        const X12 = V11 * P14 + V12 * P24;
        const X21 = V12 * P13 + V22 * P23;
        const X22 = V12 * P14 + V22 * P24;
        // H = (D - BᵀX)⁻¹ (H and D are symmetric, which means BᵀX is also symmetric)
        const Hi11 = P33 - (P13 * X11 + P23 * X21);
        const Hi12 = P34 - (P13 * X12 + P23 * X22);
        const Hi22 = P44 - (P14 * X12 + P24 * X22);
        const detHi = 1 / (Hi11 * Hi22 - Hi12 * Hi12);
        const H11 = Hi22 * detHi;
        const H12 = -Hi12 * detHi;
        const H22 = Hi11 * detHi;
        // Z = XH
        const Z11 = X11 * H11 + X12 * H12;
        const Z12 = X11 * H12 + X12 * H22;
        const Z21 = X21 * H11 + X22 * H12;
        const Z22 = X21 * H12 + X22 * H22;
        // E = V + ZXᵀ (We can skip calculating E12 and E21 since we only care about the diagonal)
        const E11 = V11 + Z11 * X11 + Z12 * X12;
        const E22 = V22 + Z21 * X21 + Z22 * X22;
        // Grab the variance terms var(x), var(y), var(z) along the diagonal of C
        const varX = E11;
        const varY = E22;
        const varZ = H11;
        if (!isFinite(varX) || !isFinite(varY) || !isFinite(varZ)) {
            return out;
        }
        const horizSumVar = varX + varY;
        const pdop = Math.sqrt(horizSumVar + varZ);
        const hdop = Math.sqrt(horizSumVar);
        const vdop = Math.sqrt(varZ);
        return Vec3Math.set(pdop, hdop, vdop, out);
    }
    /**
     * Sets this system's dilution of precision values, and if they are different from the current values, publishes the
     * new values to the event bus.
     * @param pdop The position DOP value to set.
     * @param hdop The horizontal DOP value to set.
     * @param vdop The vertical DOP valu to set.
     */
    setDop(pdop, hdop, vdop) {
        if (this._pdop !== pdop) {
            this._pdop = pdop;
            this.publisher.pub(this.pdopTopic, pdop, false, true);
        }
        if (this._hdop !== hdop) {
            this._hdop = hdop;
            this.publisher.pub(this.hdopTopic, hdop, false, true);
        }
        if (this._vdop !== vdop) {
            this._vdop = vdop;
            this.publisher.pub(this.vdopTopic, vdop, false, true);
        }
    }
}
/**
 * A tracked GPS satellite.
 */
class GPSSatellite {
    /**
     * Creates an instance of a GPSSatellite.
     * @param prn The GPS PRN number for this satellite.
     * @param sbasGroup Whether or not this satellite is a SBAS satellite.
     * @param ephemeris The ephemeris data to use for position calculation.
     */
    constructor(prn, sbasGroup, ephemeris) {
        this.prn = prn;
        this.sbasGroup = sbasGroup;
        this.ephemeris = ephemeris;
        this.stateChangeTime = (5 + (10 * Math.random())) * 1000;
        this.stateChangeTimeRemaining = 0;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3), new Float64Array(3)];
        /** The current satellite state. */
        this.state = Subject.create(GPSSatelliteState.None);
        /** The current satellite position, in zenith angle radians and hour angle radians. */
        this.position = Vec2Subject.create(new Float64Array(2));
        /** The current satellite position, in cartesian coordinates. */
        this.positionCartesian = Vec3Subject.create(new Float64Array(3));
        /** The current satellite signal strength. */
        this.signalStrength = Subject.create(0);
        this.isApplyingDiffCorrections = false;
        this.hasComputedPosition = false;
    }
    /**
     * Computes the current satellite positions given the loaded ephemeris data.
     * @param simTime The current simulator time, in milliseconds UNIX epoch
     */
    computeSatellitePositions(simTime) {
        const record = this.ephemeris;
        if (record !== undefined) {
            const mu = 3.986005e14; //WGS84 gravitational constant for GPS user (meters3/sec2)
            const omegae_dot = 7.2921151467e-5; //WGS84 earth rotation rate (rad/sec)
            // Restore semi-major axis
            const a = record.sqrtA * record.sqrtA;
            // Computed mean motion
            const n0 = Math.sqrt(mu / (a * a * a));
            // Time from ephemeris reference epoch
            const now = simTime / 1000;
            const t = (now - (86400 * 3) + 1735) % 604800;
            let tk = t - record.toeTimeEphemeris;
            if (tk > 302400) {
                tk -= 604800;
            }
            else if (tk < -302400) {
                tk += 604800;
            }
            // Corrected mean motion
            const n = n0 + record.deltaN;
            // Mean anomaly
            const M = record.m0 + n * tk;
            // Initial guess of eccentric anomaly
            let E = M;
            let E_old;
            let dE;
            // Iterative computation of eccentric anomaly
            for (let i = 1; i < 20; i++) {
                E_old = E;
                E = M + record.eEccentricity * Math.sin(E);
                dE = E - E_old % (2.0 * Math.PI);
                if (Math.abs(dE) < 1e-12) {
                    // Necessary precision is reached, exit from the loop
                    break;
                }
            }
            const sek = Math.sin(E);
            const cek = Math.cos(E);
            const OneMinusecosE = 1.0 - record.eEccentricity * cek;
            const sq1e2 = Math.sqrt(1.0 - record.eEccentricity * record.eEccentricity);
            // Compute the true anomaly
            const tmp_Y = sq1e2 * sek;
            const tmp_X = cek - record.eEccentricity;
            const nu = Math.atan2(tmp_Y, tmp_X);
            // Compute angle phi (argument of Latitude)
            const phi = nu + record.omegaS;
            // Reduce phi to between 0 and 2*pi rad
            const s2pk = Math.sin(2.0 * phi);
            const c2pk = Math.cos(2.0 * phi);
            // Correct argument of latitude
            const u = phi + record.cuc * c2pk + record.cus * s2pk;
            const suk = Math.sin(u);
            const cuk = Math.cos(u);
            // Correct radius
            const r = a * OneMinusecosE + record.crc * c2pk + record.crs * s2pk;
            // Correct inclination
            const i = record.i0 + record.idot * tk + record.cic * c2pk + record.cis * s2pk;
            const sik = Math.sin(i);
            const cik = Math.cos(i);
            // Compute the angle between the ascending node and the Greenwich meridian
            const Omega_dot = record.omegaLDot - omegae_dot;
            const Omega = record.omegaL + Omega_dot * tk - omegae_dot * record.toeTimeEphemeris;
            const sok = Math.sin(Omega);
            const cok = Math.cos(Omega);
            //Compute satellite coordinates in Earth-fixed coordinates
            const xprime = r * cuk;
            const yprime = r * suk;
            const x = xprime * cok - yprime * cik * sok;
            const y = xprime * sok + yprime * cik * cok;
            const z = yprime * sik;
            this.positionCartesian.set(UnitType.METER.convertTo(x, UnitType.GA_RADIAN), UnitType.METER.convertTo(y, UnitType.GA_RADIAN), UnitType.METER.convertTo(z, UnitType.GA_RADIAN));
        }
    }
    /**
     * Applies a projection to the satellite cartesian coordinates to convert to zenith and hour angles.
     * @param ppos The current plane position.
     * @param altitude The current plane altitude in meters.
     */
    applyProjection(ppos, altitude) {
        const satPos = this.positionCartesian.get();
        const altRadians = UnitType.METER.convertTo(altitude, UnitType.GA_RADIAN);
        const pposCartesian = Vec3Math.multScalar(ppos.toCartesian(this.vec3Cache[0]), 1 + altRadians, this.vec3Cache[0]);
        const delta = Vec3Math.normalize(Vec3Math.sub(satPos, pposCartesian, this.vec3Cache[1]), this.vec3Cache[1]);
        const zenithAngle = Math.acos(Vec3Math.dot(delta, Vec3Math.normalize(pposCartesian, this.vec3Cache[2])));
        const satPos0 = Vec3Math.normalize(satPos, this.vec3Cache[1]);
        const northPole = Vec3Math.set(0, 0, 1, this.vec3Cache[2]);
        if (Math.abs(zenithAngle) < 1e-8 || Math.abs(zenithAngle - 180) < 1e-8) {
            this.position.set(zenithAngle, 0);
        }
        else {
            const A = Vec3Math.normalize(Vec3Math.cross(pposCartesian, northPole, this.vec3Cache[3]), this.vec3Cache[3]);
            const B = Vec3Math.normalize(Vec3Math.cross(pposCartesian, satPos0, this.vec3Cache[4]), this.vec3Cache[4]);
            const signBz = B[2] >= 0 ? 1 : -1;
            const hourAngle = Math.acos(Vec3Math.dot(A, B)) * signBz;
            this.position.set(zenithAngle, -hourAngle);
        }
        this.hasComputedPosition = true;
    }
    /**
     * Calculates the current signal strength.
     * @param altitude The current plane altitude in meters.
     */
    calculateSignalStrength(altitude) {
        if (this.hasComputedPosition) {
            const maxZenithAngle = GPSSatellite.calcHorizonAngle(altitude) + (Math.PI / 2);
            const signalStrength = Math.max(0, 1 - (this.position.get()[0] / maxZenithAngle));
            this.signalStrength.set(signalStrength);
        }
    }
    /**
     * Calculates the horizon zenith angle.
     * @param altitude The altitude, in meters.
     * @returns The calculated horizon zenith angle based on the current altitude.
     */
    static calcHorizonAngle(altitude) {
        return Math.acos(6378100 / (6378100 + Math.max(altitude, 0)));
    }
    /**
     * Updates the state of the satellite.
     * @param deltaTime The amount of sim time that has passed, in milliseconds.
     * @param applyDiffCorrections Whether or not to apply differential corrections to this GPS satellite.
     * @param forceAcquireAndUse Whether to force this satellite to the highest possible use state
     * ({@link GPSSatelliteState.Acquired} if this is an SBAS satellite or {@link GPSSatelliteState.InUse}/
     * {@link GPSSatelliteState.InUseDiffApplied} if this is a GPS satellite) if signal strength is sufficient.
     * @returns True if the satellite state changed, false otherwise.
     */
    updateState(deltaTime, applyDiffCorrections, forceAcquireAndUse) {
        const reachable = this.signalStrength.get() > 0.05;
        if (this.stateChangeTimeRemaining >= 0) {
            this.stateChangeTimeRemaining -= deltaTime;
        }
        if (forceAcquireAndUse) {
            this.isApplyingDiffCorrections = applyDiffCorrections;
            const state = this.state.get();
            if (reachable) {
                const targetState = this.sbasGroup === undefined
                    ? applyDiffCorrections ? GPSSatelliteState.InUseDiffApplied : GPSSatelliteState.InUse
                    : GPSSatelliteState.Acquired;
                if (state !== targetState) {
                    this.state.set(targetState);
                    return true;
                }
            }
            else {
                if (state !== GPSSatelliteState.Unreachable) {
                    this.state.set(GPSSatelliteState.Unreachable);
                    return true;
                }
            }
        }
        else {
            switch (this.state.get()) {
                case GPSSatelliteState.None:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    else {
                        this.state.set(GPSSatelliteState.Unreachable);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                case GPSSatelliteState.Unreachable:
                    if (reachable) {
                        this.state.set(GPSSatelliteState.Acquired);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.Acquired:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0 && this.sbasGroup === undefined) {
                        this.state.set(GPSSatelliteState.DataCollected);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.DataCollected:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (this.stateChangeTimeRemaining <= 0) {
                        this.state.set(GPSSatelliteState.InUse);
                        this.stateChangeTimeRemaining = this.stateChangeTime;
                        return true;
                    }
                    break;
                case GPSSatelliteState.InUse:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (applyDiffCorrections) {
                        if (this.isApplyingDiffCorrections && this.stateChangeTimeRemaining <= 0) {
                            this.state.set(GPSSatelliteState.InUseDiffApplied);
                            return true;
                        }
                        else if (!this.isApplyingDiffCorrections) {
                            this.isApplyingDiffCorrections = true;
                            this.stateChangeTimeRemaining = this.stateChangeTime;
                        }
                    }
                    break;
                case GPSSatelliteState.InUseDiffApplied:
                    if (!reachable) {
                        this.state.set(GPSSatelliteState.Unreachable);
                        return true;
                    }
                    else if (!applyDiffCorrections) {
                        this.isApplyingDiffCorrections = false;
                        this.state.set(GPSSatelliteState.InUse);
                        return true;
                    }
                    break;
            }
        }
        return false;
    }
    /**
     * Forces an update of this satellite's state to a specific value.
     * @param state The state to which to update this satellite.
     * @returns Whether the satellite's state was changed as a result of the forced update.
     */
    forceUpdateState(state) {
        this.stateChangeTimeRemaining = 0;
        this.isApplyingDiffCorrections = state === GPSSatelliteState.InUseDiffApplied;
        if (this.state.get() !== state) {
            this.state.set(state);
            return true;
        }
        else {
            return false;
        }
    }
}
/**
 * Possible state on GPS satellites.
 */
var GPSSatelliteState;
(function (GPSSatelliteState) {
    /** There is no current valid state. */
    GPSSatelliteState["None"] = "None";
    /** The satellite is out of view and cannot be reached. */
    GPSSatelliteState["Unreachable"] = "Unreachable";
    /** The satellite has been found and data is being downloaded. */
    GPSSatelliteState["Acquired"] = "Acquired";
    /** The satellite is faulty. */
    GPSSatelliteState["Faulty"] = "Faulty";
    /** The satellite has been found, data is downloaded, but is not presently used in the GPS solution. */
    GPSSatelliteState["DataCollected"] = "DataCollected";
    /** The satellite is being active used in the GPS solution. */
    GPSSatelliteState["InUse"] = "InUse";
    /** The satellite is being active used in the GPS solution and SBAS differential corrections are being applied. */
    GPSSatelliteState["InUseDiffApplied"] = "InUseDiffApplied";
})(GPSSatelliteState || (GPSSatelliteState = {}));
/**
 * Possible {@link GPSSatComputer} states.
 */
var GPSSystemState;
(function (GPSSystemState) {
    /** The GPS receiver is trying to locate satellites. */
    GPSSystemState["Searching"] = "Searching";
    /** The GPS receiver has found satellites and is acquiring a solution. */
    GPSSystemState["Acquiring"] = "Acquiring";
    /** A 3D solution has been acquired. */
    GPSSystemState["SolutionAcquired"] = "SolutionAcquired";
    /** A 3D solution using differential computations has been acquired. */
    GPSSystemState["DiffSolutionAcquired"] = "DiffSolutionAcquired";
})(GPSSystemState || (GPSSystemState = {}));
/**
 * Possible SBAS connection states.
 */
var GPSSystemSBASState;
(function (GPSSystemSBASState) {
    /** SBAS is disabled. */
    GPSSystemSBASState["Disabled"] = "Disabled";
    /** SBAS is enabled but not receiving differential corrections. */
    GPSSystemSBASState["Inactive"] = "Inactive";
    /** SBAS is enabled and is receiving differential corrections. */
    GPSSystemSBASState["Active"] = "Active";
})(GPSSystemSBASState || (GPSSystemSBASState = {}));

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/baseinstrument" />
/**
 * A publisher for VCockpit BaseInstrument events.
 */
class BaseInstrumentPublisher extends BasePublisher {
    /**
     * Creates an instance of BasePublisher.
     * @param instrument The BaseInstrument instance.
     * @param bus The common event bus.
     * @param pacer An optional pacer to control the rate of publishing.
     */
    constructor(instrument, bus, pacer = undefined) {
        super(bus, pacer);
        this.instrument = instrument;
        this.lastGameState = undefined;
        this.lastIsPowered = undefined;
        this.lastScreenState = undefined;
        this.hasFlightStarted = false;
        instrument.addEventListener('mouseleave', (e) => {
            this.publish('vc_mouse_leave', e, false, false);
        });
        instrument.addEventListener('mouseenter', (e) => {
            this.publish('vc_mouse_enter', e, false, false);
        });
    }
    /** @inheritdoc */
    startPublish() {
        super.startPublish();
    }
    /** @inheritdoc */
    stopPublish() {
        super.stopPublish();
    }
    /** @inheritdoc */
    onUpdate() {
        if (!this.isPublishing()) {
            return;
        }
        this.updateFromGameState(this.instrument.getGameState());
        this.updateFromPowered(this.instrument.isStarted); // Big hack here since there is no other way to get the isStarted state from BaseInstrument
        this.updateFromScreenState(this.instrument.screenState); // Another big hack
    }
    /**
     * Updates this publisher from the current game state.
     * @param gameState The current game state.
     */
    updateFromGameState(gameState) {
        if (this.lastGameState === gameState) {
            return;
        }
        this.lastGameState = gameState;
        this.publish('vc_game_state', gameState);
        if (!this.hasFlightStarted && gameState === GameState.ingame) {
            this.publish('vc_flight_start', true);
        }
    }
    /**
     * Updates this publisher from the current powered state.
     * @param isPowered The current powered state.
     */
    updateFromPowered(isPowered) {
        if (this.lastIsPowered === isPowered) {
            return;
        }
        this.lastIsPowered = isPowered;
        this.publish('vc_powered', isPowered);
    }
    /**
     * Updates this publisher from the current screen state.
     * @param screenState The current screen state.
     */
    updateFromScreenState(screenState) {
        if (this.lastScreenState === screenState) {
            return;
        }
        const lastScreenState = this.lastScreenState;
        this.lastScreenState = screenState;
        this.publish('vc_screen_state', { current: screenState, previous: lastScreenState });
    }
}

/** Minimums Modes */
var MinimumsMode;
(function (MinimumsMode) {
    MinimumsMode[MinimumsMode["OFF"] = 0] = "OFF";
    MinimumsMode[MinimumsMode["BARO"] = 1] = "BARO";
    MinimumsMode[MinimumsMode["RA"] = 2] = "RA";
    MinimumsMode[MinimumsMode["TEMP_COMP_BARO"] = 3] = "TEMP_COMP_BARO";
})(MinimumsMode || (MinimumsMode = {}));
/** A publisher for minimums simvar events. */
class MinimumsSimVarPublisher extends SimVarPublisher {
    /**
     * @inheritdoc
     */
    constructor(bus) {
        super(MinimumsSimVarPublisher.simvars, bus);
    }
}
MinimumsSimVarPublisher.simvars = new Map([
    ['decision_height_feet', { name: 'DECISION HEIGHT', type: SimVarValueType.Feet }],
    ['decision_altitude_feet', { name: 'DECISION ALTITUDE MSL', type: SimVarValueType.Feet }],
    ['minimums_mode', { name: 'L:WT_MINIMUMS_MODE', type: SimVarValueType.Number }]
]);

/**
 * A simple timer for handling debounce.
 */
class DebounceTimer {
    constructor() {
        this.timer = null;
    }
    /**
     * Checks whether an action is pending on this timer.
     * @returns Whether an action is pending on this timer.
     */
    isPending() {
        return this.timer !== null;
    }
    /**
     * Schedules an action. Waits for a specified amount of time, and executes the action only if no other action is
     * scheduled on this timer during the delay.
     * @param action The action to schedule.
     * @param delay The debounce delay, in milliseconds.
     */
    schedule(action, delay) {
        this.clear();
        this.timer = setTimeout(() => {
            this.timer = null;
            action();
        }, delay);
    }
    /**
     * Clears this timer of any pending actions. Actions that are cleared will not be executed.
     */
    clear() {
        if (this.timer === null) {
            return;
        }
        clearTimeout(this.timer);
        this.timer = null;
    }
}

/** Transponder modes. */
var XPDRMode;
(function (XPDRMode) {
    XPDRMode[XPDRMode["OFF"] = 0] = "OFF";
    XPDRMode[XPDRMode["STBY"] = 1] = "STBY";
    XPDRMode[XPDRMode["TEST"] = 2] = "TEST";
    XPDRMode[XPDRMode["ON"] = 3] = "ON";
    XPDRMode[XPDRMode["ALT"] = 4] = "ALT";
    XPDRMode[XPDRMode["GROUND"] = 5] = "GROUND";
})(XPDRMode || (XPDRMode = {}));
/** A publiher to poll transponder simvars. */
class XPDRSimVarPublisher extends SimVarPublisher {
    /**
     * Create an XPDRSimVarPublisher.
     * @param bus The EventBus to publish to.
     * @param pacer An optional pacer to use to control the pace of publishing.
     * @param transponderCount The number of transponders supported by this publisher.
     */
    constructor(bus, pacer = undefined, transponderCount = 1) {
        const vars = [];
        for (let i = 0; i < transponderCount; i++) {
            vars.push([`xpdr_mode_${i + 1}`, { name: `TRANSPONDER STATE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_code_${i + 1}`, { name: `TRANSPONDER CODE:${i + 1}`, type: SimVarValueType.Number }]);
            vars.push([`xpdr_ident_${i + 1}`, { name: `TRANSPONDER IDENT:${i + 1}`, type: SimVarValueType.Bool }]);
        }
        super(new Map(vars), bus, pacer);
    }
}
/** A transponder. */
class XPDRInstrument {
    /**
     * Create an XPDRInstrument.
     * @param bus The event bus to publish to.
     * @param transponderCount The number of transponders supported by this instrument. Defaults to `1`.
     */
    constructor(bus, transponderCount = 1) {
        this.bus = bus;
        this.transponderCount = transponderCount;
        this.identDebounceTimers = Array.from({ length: this.transponderCount }, () => new DebounceTimer());
        this.bus = bus;
        this.simVarPublisher = new XPDRSimVarPublisher(bus);
        this.controlSubscriber = bus.getSubscriber();
    }
    /** Initialize the instrument. */
    init() {
        this.simVarPublisher.startPublish();
        for (let i = 0; i < this.transponderCount; i++) {
            this.controlSubscriber.on(`publish_xpdr_code_${i + 1}`).handle(this.setXpdrCode.bind(this, i + 1));
            this.controlSubscriber.on(`publish_xpdr_mode_${i + 1}`).handle(this.setXpdrMode.bind(this, i + 1));
            this.controlSubscriber.on(`xpdr_send_ident_${i + 1}`).handle(this.sendIdent.bind(this, i + 1));
            // force standby on plane load when off
            if (this.getXpdrMode(i + 1) === XPDRMode.OFF) {
                this.setXpdrMode(i + 1, XPDRMode.STBY);
            }
        }
    }
    /**
     * Perform events for the update loop.
     */
    onUpdate() {
        // Currently, we just need to update our simvar publisher so it polls.
        this.simVarPublisher.onUpdate();
    }
    /**
     * Set the transponder code in the sim.
     * @param index The index of the transponder.
     * @param code The xpdr code.
     */
    setXpdrCode(index, code) {
        const bcdCode = Avionics.Utils.make_xpndr_bcd16(code);
        SimVar.SetSimVarValue(`K:${index}:XPNDR_SET`, 'Frequency BCD16', bcdCode);
    }
    /**
     * Set the transponder mode in the sim.
     * @param index The index of the transponder.
     * @param mode The transponder mode.
     */
    setXpdrMode(index, mode) {
        SimVar.SetSimVarValue(`TRANSPONDER STATE:${index}`, 'number', mode);
    }
    /**
     * Gets xpdr mode from the sim.
     * @param index The index of the transponder.
     * @returns The xpdr mode.
     */
    getXpdrMode(index) {
        return SimVar.GetSimVarValue(`TRANSPONDER STATE:${index}`, 'number');
    }
    /**
     * Sends ident to ATC for 18 seconds.
     * @param index The index of the transponder.
     */
    sendIdent(index) {
        if (this.getXpdrMode(index) > XPDRMode.STBY) {
            SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_ON`, 'number', 1);
            this.identDebounceTimers[index - 1].schedule(() => {
                SimVar.SetSimVarValue(`K:${index}:XPNDR_IDENT_OFF`, 'number', 0);
            }, 18000);
        }
    }
}

/**
 * A utility class for generating Promises that wait for certain conditions before they are fulfilled.
 */
class Wait {
    /**
     * Waits for a set amount of time.
     * @param delay The amount of time to wait in milliseconds.
     * @returns a Promise which is fulfilled after the delay.
     */
    static awaitDelay(delay) {
        return new Promise(resolve => setTimeout(() => resolve(), delay));
    }
    /**
     * Waits for a condition to be satisfied.
     * @param predicate A function which evaluates whether the condition is satisfied.
     * @param interval The interval, in milliseconds, at which to evaluate the condition. A zero or negative value
     * causes the condition to be evaluated every frame. Defaults to 0.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected and the condition to be
     * continually evaluated until it is satisfied. Defaults to 0.
     * @returns a Promise which is fulfilled when the condition is satisfied.
     */
    static awaitCondition(predicate, interval = 0, timeout = 0) {
        const t0 = Date.now();
        if (interval <= 0) {
            const loopFunc = (resolve, reject) => {
                if (timeout > 0 && Date.now() - t0 >= timeout) {
                    reject('Await condition timed out.');
                }
                else {
                    predicate() ? resolve() : requestAnimationFrame(loopFunc.bind(undefined, resolve, reject));
                }
            };
            return new Promise((resolve, reject) => { loopFunc(resolve, reject); });
        }
        else {
            return new Promise((resolve, reject) => {
                const timer = setInterval(() => {
                    if (timeout > 0 && Date.now() - t0 > timeout) {
                        clearInterval(timer);
                        reject('Await condition timed out.');
                    }
                    else if (predicate()) {
                        clearInterval(timer);
                        resolve();
                    }
                }, interval);
            });
        }
    }
    /**
     * Waits for a notification from a {@link Subscribable}, with an optional condition to end the wait based on the value
     * of the subscribable.
     * @param subscribable The subscribable to wait for.
     * @param predicate A function which evaluates whether the value of the subscribable satisfies the condition for the
     * wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive a notification from the subscribable at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the subscribable when a notification is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitSubscribable(subscribable, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = subscribable.sub(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, false, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link Consumer}, with an optional condition to end the wait based on the value of the
     * consumed event.
     * @param consumer The event consumer to wait for.
     * @param predicate A function which evaluates whether the value of the consumed event satisfies the condition for
     * the wait to end. If not defined, any value is considered satisfactory.
     * @param initialCheck Whether to immediately receive an event from the event consumer at the start of the wait.
     * Defaults to `false`.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the value of the consumed event when an event is received with a
     * value that satisfies the condition for the wait to end.
     */
    static awaitConsumer(consumer, predicate, initialCheck = false, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = consumer.handle(val => {
                if (predicate === undefined || predicate(val)) {
                    sub.destroy();
                    resolve(val);
                }
            }, true);
            sub.resume(initialCheck);
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
    /**
     * Waits for an event from a {@link ReadonlySubEvent}, with an optional condition to end the wait based on the sender
     * and data of the event.
     * @param event The event to wait for.
     * @param predicate A function which evaluates whether the sender and data of the event satisfy the condition for
     * the wait to end. If not defined, any sender/data is considered satisfactory.
     * @param timeout The amount of time, in milliseconds, before the returned Promise is rejected if the condition is
     * not satisfied. A zero or negative value causes the Promise to never be rejected. Defaults to 0.
     * @returns A Promise which is fulfilled with the data of the event when an event is received with a sender and data
     * that satisfy the condition for the wait to end.
     */
    static awaitSubEvent(event, predicate, timeout = 0) {
        return new Promise((resolve, reject) => {
            const sub = event.on((sender, data) => {
                if (predicate === undefined || predicate(data, sender)) {
                    sub.destroy();
                    resolve(data);
                }
            }, true);
            sub.resume();
            if (timeout > 0) {
                setTimeout(() => {
                    if (sub.isAlive) {
                        sub.destroy();
                        reject('Await condition timed out.');
                    }
                }, timeout);
            }
        });
    }
}

/**
 * Tracks aircraft traffic. Maintains a list of contacts, periodically updates their position, altitude, and reported
 * heading, and uses these data to compute ground speed, ground track, and vertical speed.
 */
class TrafficInstrument {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options with which to initialize this instrument.
     */
    constructor(bus, options) {
        this.bus = bus;
        this.tracked = new Map();
        this.lastUpdateRealTime = 0;
        this.lastUpdateSimTime = 0;
        this.isBusy = false;
        this.options = Object.assign({}, options);
    }
    /**
     * Retrieves a traffic contact by its assigned ID number.
     * @param uid an ID number.
     * @returns the traffic contact with the assigned ID number, or undefined if no such contact exists.
     */
    getContact(uid) {
        return this.tracked.get(uid);
    }
    /**
     * Iterates through all tracked traffic contacts with a visitor function.
     * @param visitor A visitor function.
     */
    forEachContact(visitor) {
        this.tracked.forEach(visitor);
    }
    /**
     * Initializes this instrument. Once initialized, this instrument will automatically track and update traffic
     * contacts.
     */
    init() {
        this.bus.getSubscriber()
            .on('simTime')
            .whenChanged()
            .handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Updates this instrument's list of contacts.
     * @param data An array of the most recent traffic data entries.
     * @param simTime The sim time at which the traffic data was generated.
     */
    updateContacts(data, simTime) {
        const len = data.length;
        for (let i = 0; i < len; i++) {
            const entry = data[i];
            const contact = this.tracked.get(entry.uId);
            if (contact) {
                this.updateContact(contact, entry, simTime);
            }
            else {
                this.createContact(entry, simTime);
            }
        }
    }
    /**
     * Creates a contact.
     * @param entry The traffic data entry from which to create the new contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    createContact(entry, simTime) {
        const contact = new TrafficContactClass(entry.uId, 1000 / this.options.simTimeUpdateFreq * 5);
        this.tracked.set(contact.uid, contact);
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_added', contact.uid, false, false);
    }
    /**
     * Updates a contact.
     * @param contact The contact to update.
     * @param entry The current traffic data entry for the contact.
     * @param simTime The sim time at which the traffic data entry was generated.
     */
    updateContact(contact, entry, simTime) {
        contact.update(entry.lat, entry.lon, UnitType.METER.convertTo(entry.alt, UnitType.FOOT), entry.heading, simTime);
        this.bus.pub('traffic_contact_updated', contact.uid, false, false);
    }
    /**
     * Removes all contacts whose time since last contact exceeds the deprecation threshold.
     * @param simTime The current sim time.
     */
    deprecateContacts(simTime) {
        this.tracked.forEach(contact => {
            const dt = Math.abs(simTime - contact.lastContactTime);
            if (dt >= this.options.contactDeprecateTime) {
                this.tracked.delete(contact.uid);
                this.bus.pub('traffic_contact_removed', contact.uid, false, false);
            }
        });
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    async onSimTimeChanged(simTime) {
        const realTime = Date.now();
        if (this.isBusy
            || Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.options.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.options.realTimeUpdateFreq) {
            return;
        }
        this.isBusy = true;
        try {
            const data = await Promise.race([Coherent.call('GET_AIR_TRAFFIC'), Wait.awaitDelay(1000)]);
            if (data) {
                this.updateContacts(data, simTime);
                this.deprecateContacts(simTime);
                this.lastUpdateSimTime = simTime;
                this.lastUpdateRealTime = realTime;
            }
        }
        catch (e) {
            console.error(e);
            if (e instanceof Error) {
                console.error(e.stack);
            }
        }
        this.isBusy = false;
    }
    /**
     * This method does nothing.
     */
    onUpdate() {
        // noop
    }
}
/**
 * An aircraft contact that is being tracked. Each contact tracks its last reported position, altitude, and heading.
 * Successively updating these values will allow ground speed, ground track, and vertical speed to be calculated based
 * on changes in the values over time. The calculated values are exponentially smoothed to reduce artifacts from
 * potentially noisy data.
 */
class TrafficContactClass {
    /**
     * Constructor.
     * @param uid This contact's unique ID number.
     * @param contactTimeResetThreshold The maximum allowed elapsed sim time, in milliseconds, since time of last contact
     * before this contact's computed values are reset.
     */
    constructor(uid, contactTimeResetThreshold) {
        this.uid = uid;
        this.contactTimeResetThreshold = contactTimeResetThreshold;
        // reported data
        this._lastPosition = new GeoPoint(NaN, NaN);
        this.lastPosition = this._lastPosition.readonly;
        this._lastAltitude = UnitType.FOOT.createNumber(NaN);
        this.lastAltitude = this._lastAltitude.readonly;
        this._lastHeading = NaN;
        this._lastContactTime = NaN;
        // computed data
        this._groundSpeed = UnitType.KNOT.createNumber(NaN);
        this.groundSpeed = this._groundSpeed.readonly;
        this._groundTrack = NaN;
        this._verticalSpeed = UnitType.FPM.createNumber(NaN);
        this.verticalSpeed = this._verticalSpeed.readonly;
        this.groundSpeedSmoother = new ExpSmoother(TrafficContactClass.GROUND_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.groundTrackSmoother = new ExpSmoother(TrafficContactClass.GROUND_TRACK_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
        this.verticalSpeedSmoother = new ExpSmoother(TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT, null, this.contactTimeResetThreshold / 1000);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastHeading() {
        return this._lastHeading;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get lastContactTime() {
        return this._lastContactTime;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get groundTrack() {
        return this._groundTrack;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    predict(simTime, positionOut, altitudeOut) {
        if (this.groundSpeed.isNaN()) {
            positionOut.set(NaN, NaN);
            altitudeOut.set(NaN);
            return;
        }
        const dt = simTime - this.lastContactTime;
        const distance = UnitType.NMILE.convertTo(this._groundSpeed.number * (dt / 3600000), UnitType.GA_RADIAN);
        this._lastPosition.offset(this._groundTrack, distance, positionOut);
        const deltaAlt = this._verticalSpeed.number * (dt / 60000);
        this._lastAltitude.add(deltaAlt, UnitType.FOOT, altitudeOut);
    }
    /**
     * Updates this contact with the current reported position, altitude and heading. Also updates the computed ground
     * speed, ground track, and vertical speed if there are sufficient data to do so.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    update(lat, lon, altitude, heading, simTime) {
        const dt = simTime - this._lastContactTime;
        if (!isNaN(dt) && (dt < 0 || dt > this.contactTimeResetThreshold)) {
            this.reset(lat, lon, altitude, heading, simTime);
            return;
        }
        if (!isNaN(dt) && dt > 0) {
            this.updateComputedValues(dt / 1000, lat, lon, altitude);
        }
        this.setReportedValues(lat, lon, altitude, heading);
        if (this.areComputedValuesValid()) {
            this._lastContactTime = simTime;
        }
        else {
            this.reset(lat, lon, altitude, heading, simTime);
        }
    }
    /**
     * Erases this contact's tracking history and sets the initial reported position, altitude, and heading.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     * @param heading The current reported heading.
     * @param simTime The current sim time.
     */
    reset(lat, lon, altitude, heading, simTime) {
        this.setReportedValues(lat, lon, altitude, heading);
        this._groundSpeed.set(NaN);
        this._groundTrack = NaN;
        this._verticalSpeed.set(NaN);
        this.groundSpeedSmoother.reset();
        this.groundTrackSmoother.reset();
        this.verticalSpeedSmoother.reset();
        this._lastContactTime = simTime;
    }
    /**
     * Sets the most recent reported values.
     * @param lat The reported latitude.
     * @param lon The reported longitude.
     * @param altitude The reported altitude, in feet.
     * @param heading The reported heading.
     */
    setReportedValues(lat, lon, altitude, heading) {
        this._lastPosition.set(lat, lon);
        this._lastAltitude.set(altitude);
        this._lastHeading = heading;
    }
    /**
     * Updates this contact's computed values.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param lat The current reported latitude.
     * @param lon The current reported longitude.
     * @param altitude The current reported altitude, in feet.
     */
    updateComputedValues(dt, lat, lon, altitude) {
        const pos = TrafficContactClass.tempGeoPoint.set(lat, lon);
        const distanceNM = UnitType.GA_RADIAN.convertTo(this.lastPosition.distance(pos), UnitType.NMILE);
        const track = pos.bearingFrom(this._lastPosition);
        this.updateGroundSpeed(dt, distanceNM);
        this.updateGroundTrack(dt, track, distanceNM);
        this.updateVerticalSpeed(dt, altitude);
    }
    /**
     * Updates this contact's ground speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundSpeed(dt, distanceNM) {
        const dtHours = dt / 3600;
        const speedKnots = distanceNM / dtHours;
        this._groundSpeed.set(this.groundSpeedSmoother.next(speedKnots, dt));
    }
    /**
     * Updates this contact's ground track.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param track The true ground track from this contact's position at last contact to this contact's current reported
     * position, as measured at the current reported position.
     * @param distanceNM The distance, in nautical miles, from this contact's position at last contact to this contact's
     * current reported position.
     */
    updateGroundTrack(dt, track, distanceNM) {
        const last = this.groundTrackSmoother.last();
        if (distanceNM >= TrafficContactClass.MIN_GROUND_TRACK_DISTANCE) {
            if (last !== null && !isNaN(last)) {
                // need to handle wraparounds
                let delta = track - last;
                if (delta > 180) {
                    delta = delta - 360;
                }
                else if (delta < -180) {
                    delta = delta + 360;
                }
                track = last + delta;
            }
        }
        else {
            // if distance between current and last position is too small, computed ground track will be unreliable
            // (and if distance = 0 the track will be meaningless), so we just copy forward the last computed track,
            // or NaN if there is no previously computed track
            track = last === null ? NaN : last;
        }
        const next = last !== null && isNaN(last) ? this.groundTrackSmoother.reset(track) : this.groundTrackSmoother.next(track, dt);
        this._groundTrack = (next + 360) % 360; // enforce range 0-359
    }
    /**
     * Updates this contact's vertical speed.
     * @param dt The elapsed time, in seconds, since last contact.
     * @param altitude The current reported altitude, in feet.
     */
    updateVerticalSpeed(dt, altitude) {
        const dtMin = dt / 60;
        const deltaAltFeet = altitude - this._lastAltitude.number;
        const vsFPM = deltaAltFeet / dtMin;
        this._verticalSpeed.set(this.verticalSpeedSmoother.next(vsFPM, dt));
    }
    /**
     * Checks whether this contact's calculated ground speed and vertical speeds are valid.
     * @returns whether this contact's calculated ground speed and vertical speeds are valid.
     */
    areComputedValuesValid() {
        const isGroundSpeedValid = this._groundSpeed.isNaN() || this._groundSpeed.number <= TrafficContactClass.MAX_VALID_GROUND_SPEED;
        const isVerticalSpeedValid = this._verticalSpeed.isNaN() || this._verticalSpeed.number <= TrafficContactClass.MAX_VALID_VERTICAL_SPEED;
        return isGroundSpeedValid && isVerticalSpeedValid;
    }
}
TrafficContactClass.GROUND_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.GROUND_TRACK_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.VERTICAL_SPEED_TIME_CONSTANT = 2 / Math.LN2;
TrafficContactClass.MAX_VALID_GROUND_SPEED = 1500; // knots
TrafficContactClass.MAX_VALID_VERTICAL_SPEED = 10000; // fpm
TrafficContactClass.MIN_GROUND_TRACK_DISTANCE = 10 / 1852; // nautical miles
TrafficContactClass.tempGeoPoint = new GeoPoint(0, 0);

/// <reference types="@microsoft/msfs-types/pages/vcockpit/instruments/shared/utils/xmllogic" />
/** The acceptable priority types for a given annunciation. */
var AnnunciationType;
(function (AnnunciationType) {
    AnnunciationType[AnnunciationType["Warning"] = 0] = "Warning";
    AnnunciationType[AnnunciationType["Caution"] = 1] = "Caution";
    AnnunciationType[AnnunciationType["Advisory"] = 2] = "Advisory";
    AnnunciationType[AnnunciationType["SafeOp"] = 3] = "SafeOp";
})(AnnunciationType || (AnnunciationType = {}));

/** A class that linearly drives a SimVar value towards a given set point. */
class LinearServo {
    /**
     * Creates an instance of a LinearServo.
     * @param rate The default rate to drive this servo, in units per second.
     */
    constructor(rate) {
        this.rate = rate;
    }
    /**
     * Drives this servo towards the set point.
     * @param currentValue The current value.
     * @param setValue The value to drive towards.
     * @param time The current timestamp, in milliseconds. Defaults to the current operating system time, as a Javascript
     * timestamp.
     * @param rate The rate to use to drive this servo, in units per second. Defaults to this servo's default rate.
     * @returns The output value.
     */
    drive(currentValue, setValue, time = Date.now(), rate = this.rate) {
        if (this.currentTime === undefined) {
            this.currentTime = time;
            return currentValue;
        }
        const currentTime = time;
        const deltaTime = currentTime - this.currentTime;
        this.currentTime = currentTime;
        const deltaValue = setValue - currentValue;
        const maximumDrive = rate * (deltaTime / 1000);
        const output = Math.abs(deltaValue) > maximumDrive
            ? currentValue + (Math.sign(deltaValue) * maximumDrive)
            : setValue;
        return output;
    }
    /**
     * Resets the servo to initial state
     */
    reset() {
        this.currentTime = undefined;
    }
}

/** A PID controller. */
class PidController {
    /**
     * Creates a new PidController.
     * @param kP The proportional gain of the controller.
     * @param kI The integral gain of the controller.
     * @param kD The differential gain of the controller.
     * @param maxOut The maximum output of the controller.
     * @param minOut The minumum output of the controller.
     * @param maxI The maximum integral gain.
     * @param minI The minimum integral gain.
     */
    constructor(kP, kI, kD, maxOut, minOut, maxI = Number.MAX_SAFE_INTEGER, minI = Number.MIN_SAFE_INTEGER) {
        this.kP = kP;
        this.kI = kI;
        this.kD = kD;
        this.maxOut = maxOut;
        this.minOut = minOut;
        this.maxI = maxI;
        this.minI = minI;
        /** The previously sampled error. */
        this.previousError = undefined;
        /** The previously generated output. */
        this.previousOutput = undefined;
        /** The currently accumulated integral. */
        this.integral = 0;
    }
    /**
     * Gets this controller's most recent error input since it was created or reset.
     * @returns This controller's most recent error input since it was created or reset.
     */
    getPreviousError() {
        return this.previousError;
    }
    /**
     * Gets the output of the PID controller at a given time.
     * @param deltaTime The difference in time between the previous sample and this sample.
     * @param error The amount of error seen between the desired output and the current output.
     * @returns The PID output.
     */
    getOutput(deltaTime, error) {
        var _a;
        const p = this.kP * error;
        if (this.previousError !== undefined && Math.sign(error) === Math.sign(this.previousError)) {
            this.integral += ((error * deltaTime) + ((deltaTime * (error - this.previousError)) / 2)) * this.kI;
            this.integral = PidController.clamp(this.integral, this.maxI, this.minI);
        }
        else {
            this.integral = 0;
        }
        const i = this.integral;
        const d = deltaTime === 0 ? 0 : this.kD * ((error - ((_a = this.previousError) !== null && _a !== void 0 ? _a : error)) / deltaTime);
        const output = PidController.clamp(p + i + d, this.maxOut, this.minOut);
        this.previousError = error;
        this.previousOutput = output;
        return output;
    }
    /** Resets the controller. */
    reset() {
        this.previousError = undefined;
        this.previousOutput = undefined;
        this.integral = 0;
    }
    /**
     * Clamps a number to maximum and minimum values.
     * @param value The value to clamp.
     * @param max The maximum value.
     * @param min The minumum value.
     * @returns The clamped value.
     */
    static clamp(value, max, min) {
        return Math.min(Math.max(value, min), max);
    }
}

// TODO: move to SDK?
/** A class to simulate knob acceleration on value inputs */
class InputAcceleration {
    /**
     * Ctor
     * @param options the knob acceleration settings
     * @param initiallyPaused whether the knob acceleration is initially paused
     */
    constructor(options = {}, initiallyPaused = false) {
        var _a;
        this.acceleration = 0;
        this.isPaused = false;
        this.maxAcceleration = 15;
        this.accelDampeningPeriod = 50;
        this.options = Object.assign({
            increment: 1,
            bigIncrement: ((_a = options.increment) !== null && _a !== void 0 ? _a : 1) * 10,
        }, options);
        this.isPaused = initiallyPaused;
        if (!initiallyPaused) {
            this.resume();
        }
    }
    /** Updates the acceleration. */
    update() {
        // dampen acceleration
        if (this.acceleration > 0) {
            this.acceleration = MathUtils.clamp(this.acceleration - 1, 0, this.maxAcceleration);
            if (!this.isPaused) {
                setTimeout(() => { this.update(); }, this.accelDampeningPeriod);
            }
        }
    }
    /**
     * Does a step and returns the increment value.
     * @returns the increment value
     */
    doStep() {
        this.acceleration += 2;
        const increment = (this.acceleration > 8 ? this.options.bigIncrement : this.options.increment);
        if (this.acceleration <= 2) {
            this.update();
        }
        return increment;
    }
    /** Pauses the update loop */
    pause() {
        this.isPaused = true;
    }
    /** Resumes the update loop */
    resume() {
        this.isPaused = false;
        this.acceleration = 0;
    }
}

/* eslint-disable no-inner-declarations */
/** A releative render position. */
var RenderPosition;
(function (RenderPosition) {
    RenderPosition[RenderPosition["Before"] = 0] = "Before";
    RenderPosition[RenderPosition["After"] = 1] = "After";
    RenderPosition[RenderPosition["In"] = 2] = "In";
})(RenderPosition || (RenderPosition = {}));
/**
 * A display component in the component framework.
 * @typedef P The type of properties for this component.
 * @typedef C The type of context that this component might have.
 */
class DisplayComponent {
    /**
     * Creates an instance of a DisplayComponent.
     * @param props The propertis of the component.
     */
    constructor(props) {
        /** The context on this component, if any. */
        this.context = undefined;
        /** The type of context for this component, if any. */
        this.contextType = undefined;
        this.props = props;
    }
    /**
     * A callback that is called before the component is rendered.
     */
    onBeforeRender() { return; }
    /**
     * A callback that is called after the component is rendered.
     * @param node The component's VNode.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onAfterRender(node) { return; }
    /**
     * Destroys this component.
     */
    destroy() { return; }
    /**
     * Gets a context data subscription from the context collection.
     * @param context The context to get the subscription for.
     * @returns The requested context.
     * @throws An error if no data for the specified context type could be found.
     */
    getContext(context) {
        if (this.context !== undefined && this.contextType !== undefined) {
            const index = this.contextType.indexOf(context);
            return this.context[index];
        }
        throw new Error('Could not find the provided context type.');
    }
}
/**
 * A reference to a component or element node.
 */
class NodeReference {
    constructor() {
        /** The internal reference instance. */
        this._instance = null;
    }
    /**
     * The instance of the element or component.
     * @returns The instance of the element or component.
     */
    get instance() {
        if (this._instance !== null) {
            return this._instance;
        }
        throw new Error('Instance was null.');
    }
    /**
     * Sets the value of the instance.
     */
    set instance(val) {
        this._instance = val;
    }
    /**
     * Gets the instance, or null if the instance is not populated.
     * @returns The component or element instance.
     */
    getOrDefault() {
        return this._instance;
    }
}
/**
 * Provides a context of data that can be passed down to child components via a provider.
 */
class Context {
    /**
     * Creates an instance of a Context.
     * @param defaultValue The default value of this context.
     */
    constructor(defaultValue) {
        this.defaultValue = defaultValue;
        /**
         * The provider component that can be set to a specific context value.
         * @param props The props of the provider component.
         * @returns A new context provider.
         */
        this.Provider = (props) => new ContextProvider(props, this);
    }
}
/**
 * A provider component that can be set to a specific context value.
 */
class ContextProvider extends DisplayComponent {
    /**
     * Creates an instance of a ContextProvider.
     * @param props The props on the component.
     * @param parent The parent context instance for this provider.
     */
    constructor(props, parent) {
        super(props);
        this.parent = parent;
    }
    /** @inheritdoc */
    render() {
        var _a;
        const children = (_a = this.props.children) !== null && _a !== void 0 ? _a : [];
        return FSComponent.buildComponent(FSComponent.Fragment, this.props, ...children);
    }
}
/**
 * The FS component namespace.
 */
// eslint-disable-next-line @typescript-eslint/no-namespace
var FSComponent;
(function (FSComponent) {
    /**
     * Valid SVG element tags.
     */
    const svgTags = {
        'circle': true,
        'clipPath': true,
        'color-profile': true,
        'cursor': true,
        'defs': true,
        'desc': true,
        'ellipse': true,
        'g': true,
        'image': true,
        'line': true,
        'linearGradient': true,
        'marker': true,
        'mask': true,
        'path': true,
        'pattern': true,
        'polygon': true,
        'polyline': true,
        'radialGradient': true,
        'rect': true,
        'stop': true,
        'svg': true,
        'text': true
    };
    /**
     * A fragment of existing elements with no specific root.
     * @param props The fragment properties.
     * @returns The fragment children.
     */
    function Fragment(props) {
        return props.children;
    }
    FSComponent.Fragment = Fragment;
    /**
     * Builds a JSX based FSComponent.
     * @param type The DOM element tag that will be built.
     * @param props The properties to apply to the DOM element.
     * @param children Any children of this DOM element.
     * @returns The JSX VNode for the component or element.
     */
    // eslint-disable-next-line no-inner-declarations
    function buildComponent(type, props, ...children) {
        let vnode = null;
        if (typeof type === 'string') {
            let element;
            if (svgTags[type] !== undefined) {
                element = document.createElementNS('http://www.w3.org/2000/svg', type);
            }
            else {
                element = document.createElement(type);
            }
            if (props !== null) {
                for (const key in props) {
                    if (key === 'ref' && props.ref !== undefined) {
                        props.ref.instance = element;
                    }
                    else {
                        const prop = props[key];
                        if (key === 'class' && typeof prop === 'object' && 'isSubscribableSet' in prop) {
                            // Bind CSS classes to a subscribable set
                            prop.sub((set, eventType, modifiedKey) => {
                                if (eventType === SubscribableSetEventType.Added) {
                                    element.classList.add(modifiedKey);
                                }
                                else {
                                    element.classList.remove(modifiedKey);
                                }
                            }, true);
                        }
                        else if (typeof prop === 'object' && 'isSubscribable' in prop) {
                            if (key === 'style' && prop instanceof ObjectSubject) {
                                // Bind CSS styles to an object subject.
                                prop.sub((v, style, newValue) => {
                                    element.style.setProperty(style.toString(), newValue);
                                }, true);
                            }
                            else {
                                // Bind an attribute to a subscribable.
                                prop.sub((v) => {
                                    element.setAttribute(key, v);
                                }, true);
                            }
                        }
                        else if (key === 'class' && typeof prop === 'object') {
                            // Bind CSS classes to an object of key value pairs where the values can be boolean | Subscribable<boolean>
                            for (const className in prop) {
                                if (className.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[className];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub((showClass) => {
                                        element.classList.toggle(className, !!showClass);
                                    }, true);
                                }
                                else {
                                    element.classList.toggle(className, !!value);
                                }
                            }
                        }
                        else if (key === 'style' && typeof prop === 'object') {
                            // Bind styles to an object of key value pairs
                            for (const style in prop) {
                                if (style.trim().length === 0) {
                                    continue;
                                }
                                const value = prop[style];
                                if (typeof value === 'object' && 'isSubscribable' in value) {
                                    value.sub(newValue => {
                                        element.style.setProperty(style, newValue !== null && newValue !== void 0 ? newValue : '');
                                    }, true);
                                }
                                else {
                                    element.style.setProperty(style, value !== null && value !== void 0 ? value : '');
                                }
                            }
                        }
                        else {
                            element.setAttribute(key, prop);
                        }
                    }
                }
            }
            vnode = {
                instance: element,
                props: props,
                children: null
            };
            vnode.children = createChildNodes(vnode, children);
        }
        else if (typeof type === 'function') {
            if (children !== null && props === null) {
                props = {
                    children: children
                };
            }
            else if (props !== null) {
                props.children = children;
            }
            if (typeof type === 'function' && type.name === Fragment.name) {
                let childNodes = type(props);
                //Handle the case where the single fragment children is an array of nodes passsed down from above
                while (childNodes !== null && childNodes.length === 1 && Array.isArray(childNodes[0])) {
                    childNodes = childNodes[0];
                }
                vnode = {
                    instance: null,
                    props,
                    children: childNodes
                };
            }
            else {
                let instance;
                const pluginSystem = (window._pluginSystem);
                try {
                    instance = type(props);
                }
                catch (_a) {
                    let pluginInstance = undefined;
                    if (pluginSystem !== undefined) {
                        pluginInstance = pluginSystem.onComponentCreating(type, props);
                    }
                    if (pluginInstance !== undefined) {
                        instance = pluginInstance;
                    }
                    else {
                        instance = new type(props);
                    }
                }
                if (props !== null && props.ref !== null && props.ref !== undefined) {
                    props.ref.instance = instance;
                }
                if (instance.contextType !== undefined) {
                    instance.context = instance.contextType.map(c => Subject.create(c.defaultValue));
                }
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentCreated(instance);
                }
                vnode = {
                    instance,
                    props,
                    children: [instance.render()]
                };
            }
        }
        return vnode;
    }
    FSComponent.buildComponent = buildComponent;
    /**
     * Creates the collection of child VNodes.
     * @param parent The parent VNode.
     * @param children The JSX children to convert to nodes.
     * @returns A collection of child VNodes.
     */
    function createChildNodes(parent, children) {
        let vnodes = null;
        if (children !== null && children !== undefined && children.length > 0) {
            vnodes = [];
            for (const child of children) {
                if (child !== null) {
                    if (child instanceof Array) {
                        const arrayNodes = createChildNodes(parent, child);
                        if (arrayNodes !== null) {
                            vnodes.push(...arrayNodes);
                        }
                    }
                    else if (typeof child === 'object') {
                        if ('isSubscribable' in child) {
                            const node = {
                                instance: child,
                                children: null,
                                props: null,
                                root: undefined,
                            };
                            child.sub((v) => {
                                if (node.root !== undefined) {
                                    // TODO workaround. gotta find a solution for the text node vanishing when text is empty
                                    node.root.nodeValue = (v === '' || v === null || v === undefined)
                                        ? ' '
                                        : v.toString();
                                }
                            });
                            vnodes.push(node);
                        }
                        else {
                            vnodes.push(child);
                        }
                    }
                    else if (typeof child === 'string' || typeof child === 'number') {
                        vnodes.push(createStaticContentNode(child));
                    }
                }
            }
        }
        return vnodes;
    }
    FSComponent.createChildNodes = createChildNodes;
    /**
     * Creates a static content VNode.
     * @param content The content to create a node for.
     * @returns A static content VNode.
     */
    function createStaticContentNode(content) {
        return {
            instance: content,
            children: null,
            props: null
        };
    }
    FSComponent.createStaticContentNode = createStaticContentNode;
    /**
     * Renders a VNode to a DOM element.
     * @param node The node to render.
     * @param element The DOM element to render to.
     * @param position The RenderPosition to put the item in.
     */
    function render(node, element, position = RenderPosition.In) {
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            if (element !== null) {
                insertNode(node, position, element);
            }
        }
        else if (node.children && node.children.length > 0 && element !== null) {
            const componentInstance = node.instance;
            if (componentInstance !== null && componentInstance.onBeforeRender !== undefined) {
                componentInstance.onBeforeRender();
            }
            if (position === RenderPosition.After) {
                for (let i = node.children.length - 1; i >= 0; i--) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            else {
                for (let i = 0; i < node.children.length; i++) {
                    if (node.children[i] === undefined || node.children[i] === null) {
                        continue;
                    }
                    insertNode(node.children[i], position, element);
                }
            }
            const instance = node.instance;
            if (instance instanceof ContextProvider) {
                visitNodes(node, (n) => {
                    if (n === undefined || n === null) {
                        return false;
                    }
                    const nodeInstance = n.instance;
                    if (nodeInstance !== null && nodeInstance.contextType !== undefined) {
                        const contextSlot = nodeInstance.contextType.indexOf(instance.parent);
                        if (contextSlot >= 0) {
                            if (nodeInstance.context === undefined) {
                                nodeInstance.context = [];
                            }
                            nodeInstance.context[contextSlot].set(instance.props.value);
                        }
                        if (nodeInstance instanceof ContextProvider && nodeInstance !== instance && nodeInstance.parent === instance.parent) {
                            return true;
                        }
                    }
                    return false;
                });
            }
            if (componentInstance !== null && componentInstance.onAfterRender !== undefined) {
                const pluginSystem = (window._pluginSystem);
                componentInstance.onAfterRender(node);
                if (pluginSystem !== undefined) {
                    pluginSystem.onComponentRendered(node);
                }
            }
        }
    }
    FSComponent.render = render;
    /**
     * Inserts a node into the DOM.
     * @param node The node to insert.
     * @param position The position to insert the node in.
     * @param element The element to insert relative to.
     */
    function insertNode(node, position, element) {
        var _a, _b, _c, _d, _e, _f;
        if (node.instance instanceof HTMLElement || node.instance instanceof SVGElement) {
            switch (position) {
                case RenderPosition.In:
                    element.appendChild(node.instance);
                    node.root = (_a = element.lastChild) !== null && _a !== void 0 ? _a : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentElement('beforebegin', node.instance);
                    node.root = (_b = element.previousSibling) !== null && _b !== void 0 ? _b : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentElement('afterend', node.instance);
                    node.root = (_c = element.nextSibling) !== null && _c !== void 0 ? _c : undefined;
                    break;
            }
            if (node.children !== null) {
                for (const child of node.children) {
                    insertNode(child, RenderPosition.In, node.instance);
                }
            }
        }
        else if (typeof node.instance === 'string'
            || (typeof node.instance === 'object'
                && node.instance !== null &&
                'isSubscribable' in node.instance)) {
            let toRender;
            if (typeof node.instance === 'string') {
                toRender = node.instance;
            }
            else {
                toRender = node.instance.get();
                if (toRender === '') {
                    toRender = ' '; // prevent disappearing text node
                }
            }
            switch (position) {
                case RenderPosition.In:
                    element.insertAdjacentHTML('beforeend', toRender);
                    node.root = (_d = element.lastChild) !== null && _d !== void 0 ? _d : undefined;
                    break;
                case RenderPosition.Before:
                    element.insertAdjacentHTML('beforebegin', toRender);
                    node.root = (_e = element.previousSibling) !== null && _e !== void 0 ? _e : undefined;
                    break;
                case RenderPosition.After:
                    element.insertAdjacentHTML('afterend', toRender);
                    node.root = (_f = element.nextSibling) !== null && _f !== void 0 ? _f : undefined;
                    break;
            }
        }
        else if (Array.isArray(node)) {
            if (position === RenderPosition.After) {
                for (let i = node.length - 1; i >= 0; i--) {
                    render(node[i], element, position);
                }
            }
            else {
                for (let i = 0; i < node.length; i++) {
                    render(node[i], element, position);
                }
            }
        }
        else {
            render(node, element, position);
        }
    }
    /**
     * Render a node before a DOM element.
     * @param node The node to render.
     * @param element The element to render boeore.
     */
    function renderBefore(node, element) {
        render(node, element, RenderPosition.Before);
    }
    FSComponent.renderBefore = renderBefore;
    /**
     * Render a node after a DOM element.
     * @param node The node to render.
     * @param element The element to render after.
     */
    function renderAfter(node, element) {
        render(node, element, RenderPosition.After);
    }
    FSComponent.renderAfter = renderAfter;
    /**
     * Remove a previously rendered element.  Currently, this is just a simple
     * wrapper so that all of our high-level "component maniuplation" state is kept
     * in the FSComponent API, but it's not doing anything other than a simple
     * remove() on the element.   This can probably be enhanced.
     * @param element The element to remove.
     */
    function remove(element) {
        if (element !== null) {
            element.remove();
        }
    }
    FSComponent.remove = remove;
    /**
     * Creates a component or element node reference.
     * @returns A new component or element node reference.
     */
    function createRef() {
        return new NodeReference();
    }
    FSComponent.createRef = createRef;
    /**
     * Creates a new context to hold data for passing to child components.
     * @param defaultValue The default value of this context.
     * @returns A new context.
     */
    function createContext(defaultValue) {
        return new Context(defaultValue);
    }
    FSComponent.createContext = createContext;
    /**
     * Visits VNodes with a supplied visitor function within the given children tree.
     * @param node The node to visit.
     * @param visitor The visitor function to inspect VNodes with. Return true if the search should stop at the visited
     * node and not proceed any further down the node's children.
     */
    function visitNodes(node, visitor) {
        if (node === undefined || node === null) {
            return;
        }
        const stopVisitation = visitor(node);
        if (!stopVisitation && node.children !== undefined && node.children !== null) {
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (Array.isArray(child)) {
                    for (let childIndex = 0; childIndex < child.length; childIndex++) {
                        visitNodes(child[childIndex], visitor);
                    }
                }
                else {
                    visitNodes(child, visitor);
                }
            }
        }
        return;
    }
    FSComponent.visitNodes = visitNodes;
    /**
     * Parses a space-delimited CSS class string into an array of CSS classes.
     * @param classString A space-delimited CSS class string.
     * @param filter A function which filters parsed classes. For each class, the function should return `true` if the
     * class should be included in the output array and `false` otherwise.
     * @returns An array of CSS classes derived from the specified CSS class string.
     */
    function parseCssClassesFromString(classString, filter) {
        return classString.split(' ').filter(str => str !== '' && (filter === undefined || filter(str)));
    }
    FSComponent.parseCssClassesFromString = parseCssClassesFromString;
    // eslint-disable-next-line jsdoc/require-jsdoc
    function bindCssClassSet(setToBind, classesToSubscribe, reservedClasses) {
        const reservedClassSet = new Set(reservedClasses);
        if (classesToSubscribe.isSubscribableSet === true) {
            return bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet);
        }
        else {
            return bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet);
        }
    }
    FSComponent.bindCssClassSet = bindCssClassSet;
    /**
     * Binds a {@link MutableSubscribableSet} to a subscribable set of CSS classes. CSS classes added to and removed from
     * the subscribed set will also be added to and removed from the bound set, with the exception of a set of reserved
     * classes. The presence or absence of any of the reserved classes in the bound set is not affected by the subscribed
     * set.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A set of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscription to the subscribed CSS class set.
     */
    function bindCssClassSetToSubscribableSet(setToBind, classesToSubscribe, reservedClassSet) {
        if (reservedClassSet.size === 0) {
            return classesToSubscribe.sub((set, type, key) => {
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
        else {
            return classesToSubscribe.sub((set, type, key) => {
                if (reservedClassSet.has(key)) {
                    return;
                }
                if (type === SubscribableSetEventType.Added) {
                    setToBind.add(key);
                }
                else {
                    setToBind.delete(key);
                }
            }, true);
        }
    }
    /**
     * Binds a {@link MutableSubscribableSet} to a record of CSS classes. CSS classes toggled in the record will also be
     * added to and removed from the bound set, with the exception of a set of reserved classes. The presence or absence
     * of any of the reserved classes in the bound set is not affected by the subscribed record.
     * @param setToBind The set to bind.
     * @param classesToSubscribe A record of CSS classes to which to subscribe.
     * @param reservedClassSet A set of reserved classes.
     * @returns The newly created subscriptions to the CSS class record.
     */
    function bindCssClassSetToRecord(setToBind, classesToSubscribe, reservedClassSet) {
        const subs = [];
        for (const cssClass in classesToSubscribe) {
            if (reservedClassSet.has(cssClass)) {
                continue;
            }
            const value = classesToSubscribe[cssClass];
            if (typeof value === 'object') {
                subs.push(value.sub(setToBind.toggle.bind(setToBind, cssClass), true));
            }
            else if (value === true) {
                setToBind.add(cssClass);
            }
            else {
                setToBind.delete(cssClass);
            }
        }
        return subs;
    }
    /**
     * Adds CSS classes to a {@link ToggleableClassNameRecord}.
     * @param record The CSS class record to which to add the new classes. The record will be mutated as classes are
     * added.
     * @param classesToAdd The CSS classes to add to the record, as a space-delimited class string, an iterable of
     * individual class names, or a {@link ToggleableClassNameRecord}.
     * @param allowOverwrite Whether to allow the new classes to overwrite existing entries in the CSS class record.
     * Defaults to `true`.
     * @param filter A function which filters the classes to add. For each class, the function should return `true` if
     * the class should be included in the record and `false` otherwise.
     * @returns The mutated CSS class record, after the new classes have been added.
     */
    function addCssClassesToRecord(record, classesToAdd, allowOverwrite = true, filter) {
        if (classesToAdd === '') {
            return record;
        }
        if (typeof classesToAdd === 'string') {
            classesToAdd = FSComponent.parseCssClassesFromString(classesToAdd, filter);
            filter = undefined;
        }
        if (typeof classesToAdd[Symbol.iterator] === 'function') {
            for (const cssClass of classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = true;
                }
            }
        }
        else {
            for (const cssClass in classesToAdd) {
                if ((allowOverwrite || record[cssClass] === undefined) && (!filter || filter(cssClass))) {
                    record[cssClass] = classesToAdd[cssClass];
                }
            }
        }
        return record;
    }
    FSComponent.addCssClassesToRecord = addCssClassesToRecord;
    /**
     * Traverses a VNode tree in depth-first order and destroys the first {@link DisplayComponent} encountered in each
     * branch of the tree.
     * @param root The root of the tree to traverse.
     */
    function shallowDestroy(root) {
        FSComponent.visitNodes(root, node => {
            if (node !== root && node.instance instanceof DisplayComponent) {
                node.instance.destroy();
                return true;
            }
            return false;
        });
    }
    FSComponent.shallowDestroy = shallowDestroy;
    /**
     * An empty callback handler.
     */
    FSComponent.EmptyHandler = () => { return; };
})(FSComponent || (FSComponent = {}));
FSComponent.Fragment;

var DmsDirection;
(function (DmsDirection) {
    DmsDirection["NORTH"] = "N";
    DmsDirection["SOUTH"] = "S";
    DmsDirection["WEST"] = "W";
    DmsDirection["EAST"] = "E";
})(DmsDirection || (DmsDirection = {}));
/**
 * A class to format latitude/longitude to DMS.
 * @class DmsFormatter
 */
class DmsFormatter {
    constructor() {
        this.coordsParts = {
            direction: DmsDirection.NORTH,
            degrees: 0,
            minutes: 0,
            seconds: 0
        };
    }
    /**
     * Builds a DMS string out of the given latitude.
     * @param value The latitude.
     * @param spaceAfterDirection Whether to insert a space after the direction letter.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLatDmsStr(value, spaceAfterDirection = true, minuteApostrophe = true, precision = 2, padMinutesTo = 3) {
        const parts = this.parseLat(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction}${spaceAfterDirection ? ' ' : ''}${parts.degrees.toString().padStart(2, '0')}°${parts.minutes.toFixed(precision).padStart(padMinutesTo + precision, '0')}${minuteApostrophe ? '\'' : ''}`;
    }
    /**
     * Builds a DMS string out of the given longitude.
     * @param value The longitude.
     * @param minuteApostrophe Whether to insert an apostrophe (') after the string.
     * @param precision Decimal precision for the minutes part.
     * @param padMinutesTo Padding applied to integer part of minutes.
     * @returns The DMS string.
     */
    getLonDmsStr(value, minuteApostrophe = true, precision = 2, padMinutesTo = 3) {
        const parts = this.parseLon(value);
        if (parts.minutes >= 59.5) {
            parts.minutes = 0;
            parts.degrees++;
        }
        return `${parts.direction}${parts.degrees.toString().padStart(3, '0')}°${parts.minutes.toFixed(precision).padStart(padMinutesTo + precision, '0')}${minuteApostrophe ? '\'' : ''}`;
    }
    /**
     * Parses a latitude in to the dms parts.
     * @param value The latitude in degrees.
     * @returns The DMS parts.
     */
    parseLat(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.SOUTH : DmsDirection.NORTH;
        return this.parse(value);
    }
    /**
     * Parses a longitude in to the dms parts.
     * @param value The longitude in degrees.
     * @returns The DMS parts.
     */
    parseLon(value) {
        this.coordsParts.direction = value < 0 ? DmsDirection.WEST : DmsDirection.EAST;
        return this.parse(value);
    }
    /**
     * Parses the latitude/longitude.
     * @private
     * @param value The value to parse.
     * @returns The DMS parts.
     */
    parse(value) {
        value = Math.abs(value);
        this.coordsParts.degrees = Math.trunc(value);
        value = (value - this.coordsParts.degrees) * 60;
        this.coordsParts.minutes = value;
        this.coordsParts.seconds = (value - this.coordsParts.minutes) * 60;
        return this.coordsParts;
    }
}

/**
 * Map own airplane icon orientations.
 */
var MapOwnAirplaneIconOrientation;
(function (MapOwnAirplaneIconOrientation) {
    MapOwnAirplaneIconOrientation["HeadingUp"] = "HeadingUp";
    MapOwnAirplaneIconOrientation["TrackUp"] = "TrackUp";
    MapOwnAirplaneIconOrientation["MapUp"] = "MapUp";
})(MapOwnAirplaneIconOrientation || (MapOwnAirplaneIconOrientation = {}));

/**
 * A utility class for creating number formatters.
 *
 * Each number formatter is a function which generates output strings from input numeric values. The formatting
 * behavior of a formatter is defined by its options. Please refer to the {@link NumberFormatterOptions} type
 * documentation for more information on each individual option.
 */
class NumberFormatter {
    /**
     * Formats a number to a string.
     * @param number The number to format.
     * @param opts Options describing how to format the number.
     * @returns The formatted string representation of the specified number.
     */
    static formatNumber(number, opts) {
        if (isNaN(number)) {
            return opts.nanString;
        }
        const { precision, roundFunc, maxDigits, forceDecimalZeroes, pad, showCommas, useMinusSign, forceSign, cache } = opts;
        const sign = number < 0 ? -1 : 1;
        const abs = Math.abs(number);
        let rounded = abs;
        if (precision !== 0) {
            rounded = roundFunc(abs / precision) * precision;
        }
        if (cache) {
            if (opts.cachedString !== undefined && opts.cachedNumber === rounded) {
                return opts.cachedString;
            }
            opts.cachedNumber = rounded;
        }
        const signText = sign === -1
            ? useMinusSign ? '−' : '-'
            : '+';
        let formatted;
        if (precision != 0) {
            const precisionString = `${precision}`;
            const decimalIndex = precisionString.indexOf('.');
            if (decimalIndex >= 0) {
                formatted = rounded.toFixed(precisionString.length - decimalIndex - 1);
            }
            else {
                formatted = `${rounded}`;
            }
        }
        else {
            formatted = `${abs}`;
        }
        let decimalIndex = formatted.indexOf('.');
        if (!forceDecimalZeroes && decimalIndex >= 0) {
            formatted = formatted.replace(NumberFormatter.TRAILING_ZERO_REGEX, '');
            if (formatted.indexOf('.') == formatted.length - 1) {
                formatted = formatted.substring(0, formatted.length - 1);
            }
        }
        decimalIndex = formatted.indexOf('.');
        if (decimalIndex >= 0 && formatted.length - 1 > maxDigits) {
            const shift = Math.max(maxDigits - decimalIndex, 0);
            const shiftPrecision = Math.pow(0.1, shift);
            formatted = (roundFunc(abs / shiftPrecision) * shiftPrecision).toFixed(shift);
        }
        if (pad === 0) {
            formatted = formatted.replace(NumberFormatter.LEADING_ZERO_REGEX, '.');
        }
        else if (pad > 1) {
            decimalIndex = formatted.indexOf('.');
            if (decimalIndex < 0) {
                decimalIndex = formatted.length;
            }
            formatted = formatted.padStart(pad + formatted.length - decimalIndex, '0');
        }
        if (showCommas) {
            const parts = formatted.split('.');
            parts[0] = parts[0].replace(NumberFormatter.COMMAS_REGEX, ',');
            formatted = parts.join('.');
        }
        formatted = ((forceSign || signText !== '+') ? signText : '') + formatted;
        if (cache) {
            opts.cachedString = formatted;
        }
        return formatted;
    }
    /**
     * Creates a function which formats numeric values to strings. The formatting behavior of the function can be
     * customized using a number of options. Please refer to the {@link NumberFormatterOptions} type documentation for
     * more information on each individual option.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `precision = 0`
     * * `round = 0`
     * * `maxDigits = Infinity`
     * * `forceDecimalZeroes = true`
     * * `pad = 1`
     * * `showCommas = false`
     * * `useMinusSign = false`
     * * `forceSign = false`
     * * `nanString = 'NaN'`
     * * `cache = false`
     * @returns A function which formats numeric values to strings.
     */
    static create(options) {
        const optsToUse = Object.assign({}, NumberFormatter.DEFAULT_OPTIONS, options);
        optsToUse.roundFunc = NumberFormatter.roundFuncs[optsToUse.round];
        return (number) => {
            return NumberFormatter.formatNumber(number, optsToUse);
        };
    }
}
NumberFormatter.DEFAULT_OPTIONS = {
    precision: 0,
    round: 0,
    maxDigits: Infinity,
    forceDecimalZeroes: true,
    pad: 1,
    showCommas: false,
    useMinusSign: false,
    forceSign: false,
    nanString: 'NaN',
    cache: false
};
NumberFormatter.roundFuncs = {
    [-1]: Math.floor,
    [0]: Math.round,
    [1]: Math.ceil
};
NumberFormatter.TRAILING_ZERO_REGEX = /0+$/;
NumberFormatter.LEADING_ZERO_REGEX = /^0\./;
NumberFormatter.COMMAS_REGEX = /\B(?=(\d{3})+(?!\d))/g;

/**
 * An enumeration of possible map rotation types.
 */
var MapRotation;
(function (MapRotation) {
    /** Map up position does not follow a defined pattern. */
    MapRotation["Undefined"] = "Undefined";
    /** Map up position points towards true north. */
    MapRotation["NorthUp"] = "NorthUp";
    /** Map up position points towards the current airplane track. */
    MapRotation["TrackUp"] = "TrackUp";
    /** Map up position points towards the current airplane heading. */
    MapRotation["HeadingUp"] = "HeadingUp";
    /** Map up position points towards the current nav desired track. */
    MapRotation["DtkUp"] = "DtkUp";
})(MapRotation || (MapRotation = {}));

/**
 * TCAS operating modes.
 */
var TcasOperatingMode;
(function (TcasOperatingMode) {
    TcasOperatingMode["Off"] = "Off";
    TcasOperatingMode["Standby"] = "Standby";
    TcasOperatingMode["TAOnly"] = "TAOnly";
    TcasOperatingMode["TA_RA"] = "TA/RA";
    TcasOperatingMode["Test"] = "Test";
    TcasOperatingMode["Failed"] = "Failed";
})(TcasOperatingMode || (TcasOperatingMode = {}));
/**
 * TCAS alert level.
 */
var TcasAlertLevel;
(function (TcasAlertLevel) {
    TcasAlertLevel[TcasAlertLevel["None"] = 0] = "None";
    TcasAlertLevel[TcasAlertLevel["ProximityAdvisory"] = 1] = "ProximityAdvisory";
    TcasAlertLevel[TcasAlertLevel["TrafficAdvisory"] = 2] = "TrafficAdvisory";
    TcasAlertLevel[TcasAlertLevel["ResolutionAdvisory"] = 3] = "ResolutionAdvisory";
})(TcasAlertLevel || (TcasAlertLevel = {}));
/**
 * Bit flags describing TCAS resolution advisories.
 */
var TcasResolutionAdvisoryFlags;
(function (TcasResolutionAdvisoryFlags) {
    /** A corrective resolution advisory. Requires a change in the own airplane's vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Corrective"] = 1] = "Corrective";
    /** An upward sense resolution advisory. Commands a vertical speed above a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["UpSense"] = 2] = "UpSense";
    /** A downward sense resolution advisory. Commands a vertical speed below a certain value. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DownSense"] = 4] = "DownSense";
    /** A resolution advisory which crosses an intruder's altitude. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Crossing"] = 8] = "Crossing";
    /** A CLIMB resolution advisory. Commands a positive vertical speed above 1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Climb"] = 16] = "Climb";
    /** A DESCEND resolution advisory. Commands a negative vertical speed below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Descend"] = 32] = "Descend";
    /** An INCREASE CLIMB or INCREASE DESCENT resolution advisory. Commands a vertical speed above 2500 FPM or below -2500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Increase"] = 64] = "Increase";
    /** A CLIMB or DESCEND resolution advisory that reverses sense. Commands a vertical speed above 1500 FPM or below -1500 FPM. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["Reversal"] = 128] = "Reversal";
    /** A corrective REDUCE CLIMB resolution advisory. Commands a vertical speed of 0 FPM or less. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceClimb"] = 256] = "ReduceClimb";
    /** A corrective REDUCE DESCENT resolution advisory. Commands a vertical speed of 0 FPM or more. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["ReduceDescent"] = 512] = "ReduceDescent";
    /** A preventative DO NOT CLIMB resolution advisory. Commands a non-positive vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotClimb"] = 1024] = "DoNotClimb";
    /** A preventative DO NOT DESCEND resolution advisory. Commands a non-negative vertical speed. */
    TcasResolutionAdvisoryFlags[TcasResolutionAdvisoryFlags["DoNotDescend"] = 2048] = "DoNotDescend";
})(TcasResolutionAdvisoryFlags || (TcasResolutionAdvisoryFlags = {}));
/**
 * Types of TCAS resolution advisories.
 */
var TcasResolutionAdvisoryType;
(function (TcasResolutionAdvisoryType) {
    /** Upward sense, positive, corrective, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["Climb"] = "Climb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingClimb"] = "CrossingClimb";
    /** Upward sense, positive, corrective, required vertical speed 1500 to 4400 fpm. */
    TcasResolutionAdvisoryType["MaintainClimb"] = "MaintainClimb";
    /** Upward sense, positive, corrective, crosses intruder altitude, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainClimb"] = "CrossingMaintainClimb";
    /** Upward sense, positive, corrective, required vertical speed 2500 to 3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseClimb"] = "IncreaseClimb";
    /** Upward sense, positive, corrective, transition from downward sense, required vertical speed 1500 to 2000 fpm. */
    TcasResolutionAdvisoryType["ReversalClimb"] = "ReversalClimb";
    /** Upward sense, negative, corrective, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceDescent"] = "ReduceDescent";
    /** Upward sense, negative, preventative, required vertical speed >= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend0"] = "DoNotDescend0";
    /** Upward sense, negative, preventative, required vertical speed >= -500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend500"] = "DoNotDescend500";
    /** Upward sense, negative, preventative, required vertical speed >= -1000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1000"] = "DoNotDescend1000";
    /** Upward sense, negative, preventative, required vertical speed >= -1500 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend1500"] = "DoNotDescend1500";
    /** Upward sense, negative, preventative, required vertical speed >= -2000 fpm. */
    TcasResolutionAdvisoryType["DoNotDescend2000"] = "DoNotDescend2000";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["Descend"] = "Descend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["CrossingDescend"] = "CrossingDescend";
    /** Downward sense, positive, corrective, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["MaintainDescend"] = "MaintainDescend";
    /** Downward sense, positive, corrective, crosses intruder altitude, required vertical speed -1500 to -4400 fpm. */
    TcasResolutionAdvisoryType["CrossingMaintainDescend"] = "CrossingMaintainDescend";
    /** Downward sense, positive, corrective, required vertical speed -2500 to -3000 fpm. */
    TcasResolutionAdvisoryType["IncreaseDescend"] = "IncreaseDescend";
    /** Downward sense, positive, corrective, transition from upward sense, required vertical speed -1500 to -2000 fpm. */
    TcasResolutionAdvisoryType["ReversalDescend"] = "ReversalDescend";
    /** Downward sense, negative, corrective, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["ReduceClimb"] = "ReduceClimb";
    /** Downward sense, negative, preventative, required vertical speed <= 0 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb0"] = "DoNotClimb0";
    /** Downward sense, negative, preventative, required vertical speed <= 500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb500"] = "DoNotClimb500";
    /** Downward sense, negative, preventative, required vertical speed <= 1000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1000"] = "DoNotClimb1000";
    /** Downward sense, negative, preventative, required vertical speed <= 1500 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb1500"] = "DoNotClimb1500";
    /** Downward sense, negative, preventative, required vertical speed <= 2000 fpm. */
    TcasResolutionAdvisoryType["DoNotClimb2000"] = "DoNotClimb2000";
    /** Clear of conflict. */
    TcasResolutionAdvisoryType["Clear"] = "Clear";
})(TcasResolutionAdvisoryType || (TcasResolutionAdvisoryType = {}));
/**
 * A TCAS-II-like system.
 */
class Tcas {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param tfcInstrument The traffic instrument which provides traffic contacts for this TCAS.
     * @param maxIntruderCount The maximum number of intruders tracked at any one time by this TCAS.
     * @param realTimeUpdateFreq The maximum update frequency (Hz) in real time.
     * @param simTimeUpdateFreq The maximum update frequency (Hz) in sim time.
     * @param raOptions Options to adjust how resolution advisories are calculated.
     */
    constructor(bus, tfcInstrument, maxIntruderCount, realTimeUpdateFreq, simTimeUpdateFreq, raOptions) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        this.bus = bus;
        this.tfcInstrument = tfcInstrument;
        this.maxIntruderCount = maxIntruderCount;
        this.realTimeUpdateFreq = realTimeUpdateFreq;
        this.simTimeUpdateFreq = simTimeUpdateFreq;
        this.operatingModeSub = Subject.create(TcasOperatingMode.Standby);
        this.intrudersSorted = [];
        this.intrudersFiltered = [];
        this.intrudersRA = new Set();
        this.contactCreatedHandler = this.onContactAdded.bind(this);
        this.contactRemovedHandler = this.onContactRemoved.bind(this);
        this.ownAirplaneSubs = {
            position: GeoPointSubject.create(new GeoPoint(0, 0)),
            altitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            groundTrack: ConsumerSubject.create(null, 0),
            groundSpeed: NumberUnitSubject.create(UnitType.KNOT.createNumber(0)),
            verticalSpeed: NumberUnitSubject.create(UnitType.FPM.createNumber(0)),
            radarAltitude: NumberUnitSubject.create(UnitType.FOOT.createNumber(0)),
            isOnGround: ConsumerSubject.create(null, false)
        };
        this.simTime = ConsumerSubject.create(null, 0);
        this.lastUpdateSimTime = 0;
        this.lastUpdateRealTime = 0;
        this.alertLevelSubs = new Map();
        this.eventPublisher = this.bus.getPublisher();
        this.eventSubscriber = this.bus.getSubscriber();
        this.paSeparationCache = {
            horizontal: UnitType.NMILE.createNumber(0),
            vertical: UnitType.FOOT.createNumber(0)
        };
        this.sensitivity = this.createSensitivity();
        this.ownAirplane = new OwnAirplane(this.ownAirplaneSubs);
        const fullRAOptions = {
            initialResponseTime: ((_a = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialResponseTime) !== null && _a !== void 0 ? _a : Tcas.DEFAULT_RA_OPTIONS.initialResponseTime).copy(),
            initialAcceleration: ((_b = raOptions === null || raOptions === void 0 ? void 0 : raOptions.initialAcceleration) !== null && _b !== void 0 ? _b : Tcas.DEFAULT_RA_OPTIONS.initialAcceleration).copy(),
            subsequentResponseTime: ((_c = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentResponseTime) !== null && _c !== void 0 ? _c : Tcas.DEFAULT_RA_OPTIONS.subsequentResponseTime).copy(),
            subsequentAcceleration: ((_d = raOptions === null || raOptions === void 0 ? void 0 : raOptions.subsequentAcceleration) !== null && _d !== void 0 ? _d : Tcas.DEFAULT_RA_OPTIONS.subsequentAcceleration).copy(),
            allowClimb: (_e = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowClimb) !== null && _e !== void 0 ? _e : (() => true),
            allowIncreaseClimb: (_f = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseClimb) !== null && _f !== void 0 ? _f : (() => true),
            allowDescend: (_g = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowDescend) !== null && _g !== void 0 ? _g : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1100),
            allowIncreaseDescent: (_h = raOptions === null || raOptions === void 0 ? void 0 : raOptions.allowIncreaseDescent) !== null && _h !== void 0 ? _h : (() => this.ownAirplaneSubs.radarAltitude.get().asUnit(UnitType.FOOT) >= 1450)
        };
        this.resolutionAdvisoryHost = new TcasResolutionAdvisoryHostClass(bus, fullRAOptions, this.ownAirplane);
    }
    /**
     * Gets this system's operating mode.
     * @returns This system's operating mode.
     */
    getOperatingMode() {
        return this.operatingModeSub.get();
    }
    /**
     * Sets this system's operating mode.
     * @param mode The new operating mode.
     */
    setOperatingMode(mode) {
        this.operatingModeSub.set(mode);
    }
    /**
     * Gets an array of all currently tracked intruders. The intruders are sorted in order of decreasing threat.
     * @returns an array of all currently tracked intruders.
     */
    getIntruders() {
        return this.intrudersFiltered;
    }
    /**
     * Gets this system's resolution advisory host.
     * @returns This system's resolution advisory host.
     */
    getResolutionAdvisoryHost() {
        return this.resolutionAdvisoryHost;
    }
    /**
     * Gets an event bus subscriber for TCAS events.
     * @returns an event bus subscriber for TCAS events..
     */
    getEventSubscriber() {
        return this.eventSubscriber;
    }
    /**
     * Initializes this system.
     */
    init() {
        // init contact listeners
        const sub = this.bus.getSubscriber();
        this.contactCreatedConsumer = sub.on('traffic_contact_added');
        this.contactRemovedConsumer = sub.on('traffic_contact_removed');
        this.contactCreatedConsumer.handle(this.contactCreatedHandler);
        this.contactRemovedConsumer.handle(this.contactRemovedHandler);
        // add all existing contacts
        this.tfcInstrument.forEachContact(contact => { this.onContactAdded(contact.uid); });
        // init own airplane subjects
        sub.on('gps-position').atFrequency(this.realTimeUpdateFreq).handle(lla => {
            this.ownAirplaneSubs.position.set(lla.lat, lla.long);
            this.ownAirplaneSubs.altitude.set(lla.alt, UnitType.METER);
        });
        sub.on('ground_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(gs => { this.ownAirplaneSubs.groundSpeed.set(gs); });
        sub.on('vertical_speed').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(vs => { this.ownAirplaneSubs.verticalSpeed.set(vs); });
        sub.on('radio_alt').whenChanged().atFrequency(this.realTimeUpdateFreq).handle(alt => { this.ownAirplaneSubs.radarAltitude.set(alt); });
        this.ownAirplaneSubs.groundTrack.setConsumer(sub.on('track_deg_true'));
        this.ownAirplaneSubs.isOnGround.setConsumer(sub.on('on_ground'));
        // init sim time subject
        this.simTime.setConsumer(sub.on('simTime'));
        // init operating mode notifier
        this.operatingModeSub.sub(this.onOperatingModeChanged.bind(this), true);
        // init update loop
        sub.on('simTime').whenChanged().handle(this.onSimTimeChanged.bind(this));
    }
    /**
     * Responds to changes in this TCAS's operating mode.
     * @param mode The current operating mode.
     */
    onOperatingModeChanged(mode) {
        this.bus.pub('tcas_operating_mode', mode, false, true);
        if (mode !== TcasOperatingMode.TAOnly && mode !== TcasOperatingMode.TA_RA) {
            // We are in a mode where TCAS is not operating normally.
            // Cancel any active resolution advisories.
            this.resolutionAdvisoryHost.cancel(this.simTime.get());
            // Clean up all intruders.
            for (let i = 0; i < this.intrudersFiltered.length; i++) {
                this.cleanUpIntruder(this.intrudersFiltered[i]);
            }
            this.intrudersFiltered = [];
        }
    }
    /**
     * Sorts two intruders.
     * @param a The first intruder.
     * @param b The second intruder.
     * @returns A negative number if `a` is to be sorted before `b`, a positive number if `b` is to be sorted before `a`,
     * and zero if the two are equal.
     */
    intruderComparator(a, b) {
        // always sort intruders with valid predictions first
        if (a.isPredictionValid && !b.isPredictionValid) {
            return -1;
        }
        else if (!a.isPredictionValid && b.isPredictionValid) {
            return 1;
        }
        else if (a.isPredictionValid) {
            let tcaPredictionA, tcaPredictionB;
            // Always sort intruders predicted to violate RA protected volume first (or for whom an RA has been issued), then
            // TA protected volume (or for whom a TA has been issued)
            const aRA = a.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (a.tcaRA.isValid && a.tcaRA.isThreat);
            const bRA = b.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory || (b.tcaRA.isValid && b.tcaRA.isThreat);
            if (aRA && !bRA) {
                return -1;
            }
            else if (!aRA && bRA) {
                return 1;
            }
            else if (aRA && bRA) {
                tcaPredictionA = a.tcaRA;
                tcaPredictionB = b.tcaRA;
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                const aTA = a.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (a.tcaTA.isValid && a.tcaTA.isThreat);
                const bTA = b.alertLevel.get() === TcasAlertLevel.TrafficAdvisory || (b.tcaTA.isValid && b.tcaTA.isThreat);
                if (aTA && !bTA) {
                    return -1;
                }
                else if (!aTA && bTA) {
                    return 1;
                }
                else if (aTA && bTA) {
                    tcaPredictionA = a.tcaTA;
                    tcaPredictionB = b.tcaTA;
                }
            }
            if (!tcaPredictionA || !tcaPredictionB) {
                if ((a.tcaRA.isValid || a.tcaTA.isValid) && !b.tcaRA.isValid && !b.tcaTA.isValid) {
                    return -1;
                }
                else if ((b.tcaRA.isValid || b.tcaTA.isValid) && !a.tcaRA.isValid && !a.tcaTA.isValid) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            // If both are predicted to violate the RA or TA protected volume, sort by time to CPA.
            // Otherwise sort by how close they approach the protected volume at CPA.
            const tcaComparison = tcaPredictionA.tcpa.compare(tcaPredictionB.tcpa);
            const normComparison = tcaPredictionA.cpaNorm - tcaPredictionB.cpaNorm;
            let firstComparison;
            let secondComparison;
            if (tcaPredictionA.isThreat) {
                firstComparison = tcaComparison;
                secondComparison = normComparison;
            }
            else {
                firstComparison = normComparison;
                secondComparison = tcaComparison;
            }
            if (firstComparison === 0) {
                return secondComparison;
            }
            else {
                return firstComparison;
            }
        }
        else {
            return 0;
        }
    }
    /**
     * A callback which is called when a new traffic contact is added by this system's traffic instrument.
     * @param uid The ID number of the new contact.
     */
    onContactAdded(uid) {
        const contact = this.tfcInstrument.getContact(uid);
        const intruder = this.createIntruderEntry(contact);
        this.intrudersSorted.push(intruder);
    }
    /**
     * A callback which is called when a traffic contact is removed by this system's traffic instrument.
     * @param uid The ID number of the removed contact.
     */
    onContactRemoved(uid) {
        const sortedIndex = this.intrudersSorted.findIndex(intruder => intruder.contact.uid === uid);
        const culledIndex = this.intrudersFiltered.findIndex(intruder => intruder.contact.uid === uid);
        if (sortedIndex >= 0) {
            this.intrudersSorted.splice(sortedIndex, 1);
        }
        if (culledIndex >= 0) {
            const removed = this.intrudersFiltered[culledIndex];
            this.intrudersFiltered.splice(culledIndex, 1);
            this.cleanUpIntruder(removed);
        }
    }
    /**
     * A callback which is called when the sim time changes.
     * @param simTime The current sim time.
     */
    onSimTimeChanged(simTime) {
        switch (this.operatingModeSub.get()) {
            case TcasOperatingMode.Off:
            case TcasOperatingMode.Standby:
            case TcasOperatingMode.Failed:
            case TcasOperatingMode.Test: // TODO: support TEST mode
                return;
        }
        const realTime = Date.now();
        if (Math.abs(simTime - this.lastUpdateSimTime) < 1000 / this.simTimeUpdateFreq
            || Math.abs(realTime - this.lastUpdateRealTime) < 1000 / this.realTimeUpdateFreq) {
            return;
        }
        this.doUpdate(simTime);
        this.lastUpdateSimTime = simTime;
        this.lastUpdateRealTime = realTime;
    }
    /**
     * Executes an update.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    doUpdate(simTime) {
        this.updateSensitivity();
        this.updateIntruderPredictions(simTime);
        this.updateIntruderArrays();
        this.updateFilteredIntruderAlertLevels(simTime);
        this.updateResolutionAdvisory(simTime);
    }
    /**
     * Updates the TCA predictions for all intruders tracked by this system.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateIntruderPredictions(simTime) {
        this.ownAirplane.update(simTime);
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersSorted[i];
            const sensitivity = this.sensitivity.selectParameters(intruder);
            intruder.updatePrediction(simTime, this.ownAirplane, sensitivity);
        }
    }
    /**
     * Updates the arrays of intruders tracked by this system.
     */
    updateIntruderArrays() {
        this.intrudersSorted.sort(this.intruderComparator.bind(this));
        const oldCulled = this.intrudersFiltered;
        this.intrudersFiltered = [];
        const len = this.intrudersSorted.length;
        for (let i = 0; i < len && this.intrudersFiltered.length < this.maxIntruderCount; i++) {
            const intruder = this.intrudersSorted[i];
            if (intruder.isPredictionValid && this.filterIntruder(intruder)) {
                this.intrudersFiltered.push(intruder);
                if (!oldCulled.includes(intruder)) {
                    this.initIntruder(intruder);
                }
            }
            else {
                if (oldCulled.includes(intruder)) {
                    this.cleanUpIntruder(intruder);
                }
            }
        }
    }
    /**
     * Filters an intruder.
     * @param intruder An intruder.
     * @returns Whether the intruder should be tracked by this TCAS.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    filterIntruder(intruder) {
        return true;
    }
    /**
     * Updates the alert levels for all intruders tracked by this system that have not been filtered out.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateFilteredIntruderAlertLevels(simTime) {
        let taCount = 0, raCount = 0;
        const len = this.intrudersFiltered.length;
        for (let i = 0; i < len; i++) {
            const intruder = this.intrudersFiltered[i];
            this.updateIntruderAlertLevel(simTime, intruder);
            switch (intruder.alertLevel.get()) {
                case TcasAlertLevel.TrafficAdvisory:
                    taCount++;
                    break;
                case TcasAlertLevel.ResolutionAdvisory:
                    raCount++;
                    break;
            }
        }
        this.eventPublisher.pub('tcas_ta_intruder_count', taCount, false, true);
        this.eventPublisher.pub('tcas_ra_intruder_count', raCount, false, true);
    }
    /**
     * Updates an intruder's alert level.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     */
    updateIntruderAlertLevel(simTime, intruder) {
        const currentAlertLevel = intruder.alertLevel.get();
        if (intruder.tcaRA.isValid && intruder.tcaRA.isThreat) {
            if (this.canIssueResolutionAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.ResolutionAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory && !this.canCancelResolutionAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ResolutionAdvisory
            && (!intruder.tcaRA.isValid || !intruder.tcaRA.isThreat)
            && !this.canCancelResolutionAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.tcaTA.isValid && intruder.tcaTA.isThreat) {
            if (this.canIssueTrafficAdvisory(simTime, intruder)) {
                intruder.alertLevel.set(TcasAlertLevel.TrafficAdvisory);
                return;
            }
            else if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory && !this.canCancelTrafficAdvisory(simTime, intruder)) {
                return;
            }
        }
        if (currentAlertLevel === TcasAlertLevel.TrafficAdvisory
            && (!intruder.tcaTA.isValid || !intruder.tcaTA.isThreat)
            && !this.canCancelTrafficAdvisory(simTime, intruder)) {
            return;
        }
        if (intruder.isPredictionValid) {
            const parametersPA = this.sensitivity.selectParameters(intruder).parametersPA;
            const radius = parametersPA.protectedRadius;
            const height = parametersPA.protectedHeight;
            if (!radius.isNaN() && !height.isNaN() && this.canIssueProximityAdvisory(simTime, intruder)) {
                intruder.predictSeparation(simTime, this.paSeparationCache.horizontal, this.paSeparationCache.vertical);
                if (this.paSeparationCache.horizontal.compare(parametersPA.protectedRadius) <= 0
                    && this.paSeparationCache.vertical.compare(parametersPA.protectedHeight) <= 0) {
                    intruder.alertLevel.set(TcasAlertLevel.ProximityAdvisory);
                    return;
                }
            }
        }
        if (currentAlertLevel === TcasAlertLevel.ProximityAdvisory && !this.canCancelProximityAdvisory(simTime, intruder)) {
            return;
        }
        intruder.alertLevel.set(TcasAlertLevel.None);
    }
    /**
     * Checks whether a resolution advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() === TcasOperatingMode.TA_RA
            && intruder.tcaRA.isValid
            && intruder.tcaRA.tcpa.number > 0
            && this.resolutionAdvisoryHost.canIssueResolutionAdvisory(simTime, intruder);
    }
    /**
     * Checks whether a resolution advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a resolution advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelResolutionAdvisory(simTime, intruder) {
        return this.operatingModeSub.get() !== TcasOperatingMode.TA_RA
            || this.resolutionAdvisoryHost.canCancelResolutionAdvisory(simTime);
    }
    /**
     * Checks whether a traffic advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a traffic advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a traffic advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelTrafficAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be issued for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be issued for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canIssueProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Checks whether a proximity advisory can be canceled for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder An intruder.
     * @returns Whether a proximity advisory can be canceled for the intruder.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canCancelProximityAdvisory(simTime, intruder) {
        return true;
    }
    /**
     * Updates this TCAS's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updateResolutionAdvisory(simTime) {
        if (this.operatingModeSub.get() === TcasOperatingMode.TA_RA) {
            this.resolutionAdvisoryHost.update(simTime, this.sensitivity.selectRAAlim(this.intrudersRA), this.intrudersRA);
        }
        else {
            this.resolutionAdvisoryHost.cancel(simTime);
        }
    }
    /**
     * Executes initialization code when an intruder is added.
     * @param intruder The newly added intruder.
     */
    initIntruder(intruder) {
        this.alertLevelSubs.set(intruder, intruder.alertLevel.sub(this.onAlertLevelChanged.bind(this, intruder)));
        this.eventPublisher.pub('tcas_intruder_added', intruder, false, false);
    }
    /**
     * Executes cleanup code when an intruder is removed.
     * @param intruder The intruder that was removed.
     */
    cleanUpIntruder(intruder) {
        var _a;
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.delete(intruder);
        }
        (_a = this.alertLevelSubs.get(intruder)) === null || _a === void 0 ? void 0 : _a.destroy();
        this.eventPublisher.pub('tcas_intruder_removed', intruder, false, false);
    }
    /**
     * A callback which is called when an intruder's alert level changes.
     * @param intruder The intruder whose alert level changed.
     */
    onAlertLevelChanged(intruder) {
        if (intruder.alertLevel.get() === TcasAlertLevel.ResolutionAdvisory) {
            this.intrudersRA.add(intruder);
        }
        else {
            this.intrudersRA.delete(intruder);
        }
        this.eventPublisher.pub('tcas_intruder_alert_changed', intruder, false, false);
    }
}
Tcas.DEFAULT_RA_OPTIONS = {
    initialResponseTime: UnitType.SECOND.createNumber(5),
    initialAcceleration: UnitType.G_ACCEL.createNumber(0.25),
    subsequentResponseTime: UnitType.SECOND.createNumber(2.5),
    subsequentAcceleration: UnitType.G_ACCEL.createNumber(0.35)
};
/**
 * An airplane managed by TCAS.
 */
class TcasAirplane {
    constructor() {
        this._position = new GeoPoint(0, 0);
        /** The position of this airplane at the time of the most recent update. */
        this.position = this._position.readonly;
        /** The altitude of this airplane at the time of the most recent update. */
        this._altitude = UnitType.FOOT.createNumber(0);
        this.altitude = this._altitude.readonly;
        this._groundTrack = 0;
        /** The ground speed of this airplane at the time of the most recent update. */
        this._groundSpeed = UnitType.KNOT.createNumber(0);
        this.groundSpeed = this._groundSpeed.readonly;
        /** The vertical speed of this airplane at the time of the most recent update. */
        this._verticalSpeed = UnitType.FPM.createNumber(0);
        this.verticalSpeed = this._verticalSpeed.readonly;
        /**
         * The 3D position vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters. The coordinate system is an Euclidean approximation of the geodetic space around the own airplane such
         * that the z-coordinate represents orthometric height and the x- and y-coordinates represent an east-
         * counterclockwise equirectangular projection of latitude and longitude, with the origin at the location of the own
         * airplane.
         */
        this.positionVec = new Float64Array(3);
        /**
         * The 3D velocity vector of this airplane at the time of the last update. Each component is expressed in units of
         * meters per second. The coordinate system is defined the same as for position vectors.
         */
        this.velocityVec = new Float64Array(3);
        this.lastUpdateTime = 0;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The true ground track of this airplane at the time of the most recent update. */
    get groundTrack() {
        return this._groundTrack;
    }
}
/**
 * The own airplane managed by TCAS.
 */
class OwnAirplane extends TcasAirplane {
    /**
     * Constructor.
     * @param subs Subscribables which provide data related to this airplane.
     */
    constructor(subs) {
        super();
        this.subs = subs;
        /** The radar altitude of this airplane at the time of the most recent update. */
        this._radarAltitude = UnitType.FOOT.createNumber(0);
        this.radarAltitude = this._radarAltitude.readonly;
        this._isOnGround = false;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this airplane is on the ground. */
    get isOnGround() {
        return this._isOnGround;
    }
    /**
     * Calculates the predicted 3D position vector of this airplane at a specified time based on the most recent
     * available data. Each component of the vector is expressed in units of meters, and the origin lies at the most
     * recent updated position of this airplane.
     * @param simTime The sim time at which to calculate the position, as a UNIX timestamp in milliseconds.
     * @param out A Float64Array object to which to write the result.
     * @returns The predicted position vector of this airplane at the specified time.
     */
    predictPosition(simTime, out) {
        const dt = (simTime - this.lastUpdateTime) / 1000;
        return Vec3Math.add(this.positionVec, Vec3Math.multScalar(this.velocityVec, dt, out), out);
    }
    /**
     * Updates this airplane's position and velocity data.
     * @param simTime The current sim time, as a UNIX millisecond timestamp.
     */
    update(simTime) {
        this.updateParameters();
        this.updateVectors();
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this airplane's position, altitude, ground track, ground speed, vertical speed, and whether it is on the ground.
     */
    updateParameters() {
        this._position.set(this.subs.position.get());
        this._altitude.set(this.subs.altitude.get());
        this._groundTrack = this.subs.groundTrack.get();
        this._groundSpeed.set(this.subs.groundSpeed.get());
        this._verticalSpeed.set(this.subs.verticalSpeed.get());
        this._radarAltitude.set(this.subs.radarAltitude.get());
        this._isOnGround = this.subs.isOnGround.get();
    }
    /**
     * Updates this airplane's position and velocity vectors.
     */
    updateVectors() {
        Vec2Math.setFromPolar(this._groundSpeed.asUnit(UnitType.MPS), (90 - this._groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this._verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
    }
}
/**
 * An abstract implementation of {@link TcasIntruder}.
 */
class AbstractTcasIntruder extends TcasAirplane {
    /**
     * Constructor.
     * @param contact The traffic contact associated with this intruder.
     */
    constructor(contact) {
        super();
        this.contact = contact;
        this.alertLevel = Subject.create(TcasAlertLevel.None);
        /** The 3D position vector of this intruder relative to own airplane. */
        this.relativePositionVec = new Float64Array(3);
        /** The 3D velocity vector of this intruder relative to own airplane. */
        this.relativeVelocityVec = new Float64Array(3);
        this._isPredictionValid = false;
        /** @inheritdoc */
        this.tcaTA = new TcasTcaPredictionClass(this);
        /** @inheritdoc */
        this.tcaRA = new TcasTcaPredictionClass(this);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether there is a valid prediction for time of closest approach between this intruder and own airplane. */
    get isPredictionValid() {
        return this._isPredictionValid;
    }
    /** @inheritdoc */
    predictDisplacement(simTime, out) {
        if (!this._isPredictionValid) {
            return Vec3Math.set(NaN, NaN, NaN, out);
        }
        const dt = (simTime - this.contact.lastContactTime) / 1000;
        return Vec3Math.add(this.relativePositionVec, Vec3Math.multScalar(this.relativeVelocityVec, dt, out), out);
    }
    /** @inheritdoc */
    predictSeparation(simTime, horizontalOut, verticalOut) {
        if (!this._isPredictionValid) {
            horizontalOut.set(NaN);
            verticalOut.set(NaN);
            return;
        }
        const displacement = this.predictDisplacement(simTime, AbstractTcasIntruder.vec3Cache[0]);
        AbstractTcasIntruder.displacementToHorizontalSeparation(displacement, horizontalOut);
        AbstractTcasIntruder.displacementToVerticalSeparation(displacement, verticalOut);
    }
    /**
     * Updates this intruder's predicted TCA and related data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane Own airplane.
     * @param sensitivity The TCAS sensitivity parameters to use when calculating predictions.
     */
    updatePrediction(simTime, ownAirplane, sensitivity) {
        this.updateParameters(simTime, ownAirplane);
        if (this.isPredictionValid) {
            const taParams = sensitivity.parametersTA;
            const raParams = sensitivity.parametersRA;
            this.tcaTA.update(simTime, taParams.tau, taParams.protectedRadius, taParams.protectedHeight, taParams.hmd);
            this.tcaRA.update(simTime, raParams.tau, raParams.protectedRadius, raParams.protectedHeight, raParams.hmd);
        }
        else {
            this.invalidatePredictions();
        }
        this.lastUpdateTime = simTime;
    }
    /**
     * Updates this intruder's position and velocity data.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updateParameters(simTime, ownAirplane) {
        if (isNaN(this.contact.groundTrack) || this.contact.groundSpeed.compare(AbstractTcasIntruder.MIN_GROUND_SPEED) < 0) {
            this._isPredictionValid = false;
            this._position.set(NaN, NaN);
            this._altitude.set(NaN);
            this._groundTrack = NaN;
            this._groundSpeed.set(NaN);
            this._verticalSpeed.set(NaN);
            Vec3Math.set(NaN, NaN, NaN, this.positionVec);
            Vec3Math.set(NaN, NaN, NaN, this.velocityVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativePositionVec);
            Vec3Math.set(NaN, NaN, NaN, this.relativeVelocityVec);
        }
        else {
            this.updatePosition(simTime, ownAirplane);
            this.updateVelocity(ownAirplane);
            this._groundSpeed.set(this.contact.groundSpeed);
            this._verticalSpeed.set(this.contact.verticalSpeed);
            this._isPredictionValid = true;
        }
    }
    /**
     * Updates this intruder's position.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplane The own airplane.
     */
    updatePosition(simTime, ownAirplane) {
        this.contact.predict(simTime, this._position, this._altitude);
        this._groundTrack = this._position.equals(this.contact.lastPosition) ? this.contact.groundTrack : this._position.bearingFrom(this.contact.lastPosition);
        const distance = UnitType.GA_RADIAN.convertTo(this._position.distance(ownAirplane.position), UnitType.METER);
        const bearing = ownAirplane.position.bearingTo(this._position);
        Vec2Math.setFromPolar(distance, (90 - bearing) * Avionics.Utils.DEG2RAD, this.positionVec);
        const verticalPosition = this._altitude.asUnit(UnitType.METER) - ownAirplane.altitude.asUnit(UnitType.METER);
        this.positionVec[2] = verticalPosition;
        Vec3Math.sub(this.positionVec, ownAirplane.positionVec, this.relativePositionVec);
    }
    /**
     * Updates this intruder's velocity.
     * @param ownAirplane The own airplane.
     */
    updateVelocity(ownAirplane) {
        Vec2Math.setFromPolar(this.contact.groundSpeed.asUnit(UnitType.MPS), (90 - this.contact.groundTrack) * Avionics.Utils.DEG2RAD, this.velocityVec);
        const verticalVelocity = this.contact.verticalSpeed.asUnit(UnitType.MPS);
        this.velocityVec[2] = verticalVelocity;
        Vec3Math.sub(this.velocityVec, ownAirplane.velocityVec, this.relativeVelocityVec);
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidatePredictions() {
        this.tcaTA.invalidate();
        this.tcaRA.invalidate();
    }
    /**
     * Converts a 3D displacement vector to a horizontal separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The horizontal separation distance corresponding to the displacement vector.
     */
    static displacementToHorizontalSeparation(displacement, out) {
        return out.set(Math.hypot(displacement[0], displacement[1]), UnitType.METER);
    }
    /**
     * Converts a 3D displacement vector to a vertical separation distance.
     * @param displacement A displacement vector, in meters.
     * @param out A NumberUnit object to which to write the result.
     * @returns The vertical separation distance corresponding to the displacement vector.
     */
    static displacementToVerticalSeparation(displacement, out) {
        return out.set(Math.abs(displacement[2]), UnitType.METER);
    }
}
AbstractTcasIntruder.MIN_GROUND_SPEED = UnitType.KNOT.createNumber(30);
AbstractTcasIntruder.vec3Cache = [new Float64Array(3), new Float64Array(3)];
/**
 * An default implementation of {@link TcasIntruder}.
 */
class DefaultTcasIntruder extends AbstractTcasIntruder {
}
/**
 * A time-of-closest-approach prediction made by TCAS.
 */
class TcasTcaPredictionClass {
    /**
     * Constructor.
     * @param intruder The intruder associated with this prediction.
     */
    constructor(intruder) {
        this.intruder = intruder;
        this._isValid = false;
        this._time = NaN;
        this._tcpa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcpa = this._tcpa.readonly;
        this._tcoa = UnitType.SECOND.createNumber(NaN);
        /** @inheritdoc */
        this.tcoa = this._tcoa.readonly;
        this._isThreat = false;
        /** @inheritdoc */
        this.cpaDisplacement = new Float64Array(3);
        this._cpaHorizontalSep = UnitType.NMILE.createNumber(0);
        /** @inheritdoc */
        this.cpaHorizontalSep = this._cpaHorizontalSep.readonly;
        this._cpaVerticalSep = UnitType.FOOT.createNumber(0);
        /** @inheritdoc */
        this.cpaVerticalSep = this._cpaVerticalSep.readonly;
        this._cpaNorm = NaN;
    }
    /** @inheritdoc */
    get isValid() {
        return this._isValid;
    }
    /** @inheritdoc */
    get time() {
        return this._time;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get isThreat() {
        return this._isThreat;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** @inheritdoc */
    get cpaNorm() {
        return this._cpaNorm;
    }
    /**
     * Updates the time-to-closest-approach (TCA) and related data of this intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param tau The maximum lookahead time.
     * @param dmod The radius of the own airplane's protected volume.
     * @param zthr The half-height of the own airplane's protected volume.
     * @param hmd The distance threshold for the horizontal miss distance filter. If not defined, the HMD filter will
     * not be applied.
     */
    update(simTime, tau, dmod, zthr, hmd) {
        var _a;
        this._time = simTime;
        if (tau.isNaN() || dmod.isNaN() || zthr.isNaN() || ((_a = hmd === null || hmd === void 0 ? void 0 : hmd.isNaN()) !== null && _a !== void 0 ? _a : false)) {
            this.invalidate();
            return;
        }
        // Source: Munoz, CA and Narkawicz, AJ. "A TCAS-II Resolution Advisory Detection Algorithm."
        // https://ntrs.nasa.gov/api/citations/20140002736/downloads/20140002736.pdf
        const tauSeconds = tau.asUnit(UnitType.SECOND);
        const s = this.intruder.relativePositionVec;
        const v = this.intruder.relativeVelocityVec;
        const sHoriz = Vec2Math.set(s[0], s[1], TcasTcaPredictionClass.vec2Cache[0]);
        const vHoriz = Vec2Math.set(v[0], v[1], TcasTcaPredictionClass.vec2Cache[1]);
        const h = zthr.asUnit(UnitType.METER);
        const r = dmod.asUnit(UnitType.METER);
        const vHorizSquared = Vec2Math.dot(vHoriz, vHoriz);
        const sHorizSquared = Vec2Math.dot(sHoriz, sHoriz);
        const dotSHorizVHoriz = Vec2Math.dot(vHoriz, sHoriz);
        const rSquared = r * r;
        // Time to closest horizontal approach
        const tcpa = vHorizSquared === 0 ? 0 : -dotSHorizVHoriz / vHorizSquared;
        // Modified tau
        const tauMod = dotSHorizVHoriz >= 0 ? Infinity : (rSquared - sHorizSquared) / dotSHorizVHoriz;
        // Time to co-altitude
        const tcoa = -s[2] / v[2];
        const isHorizontalThreat = sHorizSquared <= rSquared || tauMod <= tauSeconds;
        const isVerticalThreat = Math.abs(s[2]) <= h || (tcoa >= 0 && tcoa <= tauSeconds);
        let passHmdFilter = true;
        if (hmd !== undefined && isHorizontalThreat && isVerticalThreat) {
            const d = hmd.asUnit(UnitType.METER);
            const dSquared = d * d;
            if (vHorizSquared === 0) {
                passHmdFilter = sHorizSquared <= dSquared;
            }
            else {
                const delta = dSquared * vHorizSquared - Vec2Math.dot(sHoriz, Vec2Math.normal(vHoriz, TcasTcaPredictionClass.vec2Cache[1]));
                if (delta < 0) {
                    passHmdFilter = false;
                }
                else {
                    const a = vHorizSquared;
                    const b = 2 * dotSHorizVHoriz;
                    const c = sHorizSquared - dSquared;
                    const discriminant = b * b - 4 * a * c;
                    if (discriminant < 0) {
                        passHmdFilter = false;
                    }
                    else {
                        passHmdFilter = (-b + Math.sqrt(discriminant)) / (2 * a) >= 0;
                    }
                }
            }
        }
        this._isThreat = isHorizontalThreat && isVerticalThreat && passHmdFilter;
        this._tcpa.set(tcpa);
        this._tcoa.set(tcoa);
        TcasTcaPredictionClass.calculateDisplacementVector(s, v, tcpa, this.cpaDisplacement);
        AbstractTcasIntruder.displacementToHorizontalSeparation(this.cpaDisplacement, this._cpaHorizontalSep);
        AbstractTcasIntruder.displacementToVerticalSeparation(this.cpaDisplacement, this._cpaVerticalSep);
        this._cpaNorm = TcasTcaPredictionClass.calculateCylindricalNorm(this.cpaDisplacement, r, h);
        this._isValid = true;
    }
    /**
     * Invalidates this intruder's predicted TCA and related data.
     */
    invalidate() {
        this._isValid = false;
        this._isThreat = false;
        this._tcpa.set(NaN);
        this._tcoa.set(NaN);
        Vec3Math.set(NaN, NaN, NaN, this.cpaDisplacement);
        this._cpaHorizontalSep.set(NaN);
        this._cpaVerticalSep.set(NaN);
        this._cpaNorm = NaN;
    }
    /**
     * Calculates a time-offset displacement vector given an initial displacement, a velocity vector, and elapsed time.
     * @param initial The initial displacement vector.
     * @param velocity A velocity vector.
     * @param elapsedTime The elapsed time.
     * @param out A Float64Array object to which to write the result.
     * @returns The time-offset displacement vector.
     */
    static calculateDisplacementVector(initial, velocity, elapsedTime, out) {
        return Vec3Math.add(initial, Vec3Math.multScalar(velocity, elapsedTime, out), out);
    }
    /**
     * Calculates a cylindrical norm.
     * @param vector A displacement vector.
     * @param radius The radius of the protected zone.
     * @param halfHeight The half-height of the protected zone.
     * @returns A cylindrical norm.
     */
    static calculateCylindricalNorm(vector, radius, halfHeight) {
        const horizLength = Math.hypot(vector[0], vector[1]);
        return Math.max(Math.abs(vector[2]) / halfHeight, horizLength / radius);
    }
}
TcasTcaPredictionClass.vec2Cache = [new Float64Array(2), new Float64Array(2), new Float64Array(2)];
/**
 * An implementation of {@link TcasResolutionAdvisoryHost}.
 */
class TcasResolutionAdvisoryHostClass {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param options Options to adjust how the host should calculate resolution advisories.
     * @param ownAirplane The own airplane.
     */
    constructor(bus, options, ownAirplane) {
        this.options = options;
        this.ownAirplane = ownAirplane;
        this.initialResponseTimeSeconds = this.options.initialResponseTime.asUnit(UnitType.SECOND);
        this.initialAccelMps = this.options.initialAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.subsequentResponseTimeSeconds = this.options.subsequentResponseTime.asUnit(UnitType.SECOND);
        this.subsequentAccelMps = this.options.subsequentAcceleration.asUnit(UnitType.MPS_PER_SEC);
        this.intruders = new Set();
        this.intruderArray = [];
        this._maxVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.maxVerticalSpeed = this._maxVerticalSpeed.readonly;
        this._minVerticalSpeed = UnitType.FPM.createNumber(NaN);
        /** @inheritdoc */
        this.minVerticalSpeed = this._minVerticalSpeed.readonly;
        this._flags = 0;
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._secondaryType = null;
        this._primaryFlags = 0;
        this._secondaryFlags = 0;
        this.vsConstraints = [];
        this.lastStateChangeTime = 0;
        this.stateChangeDelay = 0;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher = bus.getPublisher();
    }
    /** @inheritdoc */
    get flags() {
        return this._flags;
    }
    /** @inheritdoc */
    get primaryType() {
        return this._primaryType;
    }
    /** @inheritdoc */
    get secondaryType() {
        return this._secondaryType;
    }
    /** @inheritdoc */
    get primaryFlags() {
        return this._primaryFlags;
    }
    /** @inheritdoc */
    get secondaryFlags() {
        return this._secondaryFlags;
    }
    /**
     * Checks whether this host can issue a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param intruder The query intruder.
     * @returns Whether this host can issue a resolution advisory for an intruder.
     */
    canIssueResolutionAdvisory(simTime, intruder) {
        // Inhibit resolution advisories for intruders whose time to closest horizontal approach is less than or equal to
        // zero (indicating the closest point of approach has already been passed) and whose horizontal separation from the
        // own airplane is increasing.
        if (intruder.tcaRA.tcpa.number <= 0 && Vec2Math.dot(intruder.relativeVelocityVec, intruder.relativePositionVec) > 0) {
            return false;
        }
        if (this._primaryType !== TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Checks whether this host can cancel a resolution advisory for an intruder.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @returns Whether this host can cancel a resolution advisory for an intruder.
     */
    canCancelResolutionAdvisory(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear) {
            return true;
        }
        const lastStateChangeTime = Math.min(simTime, this.lastStateChangeTime);
        return simTime - lastStateChangeTime >= this.stateChangeDelay;
    }
    /**
     * Updates this host's resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param alim The required vertical separation between own airplane and intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    update(simTime, alim, intruders) {
        if (this.intruderArray.length === 0 && intruders.size === 0) {
            return;
        }
        if (simTime < this.lastStateChangeTime) {
            this.lastStateChangeTime = simTime;
        }
        if (simTime - this.lastStateChangeTime < this.stateChangeDelay) {
            return;
        }
        if (intruders.size === 0) {
            this.cancel(simTime);
        }
        else {
            const isInitial = this._primaryType === TcasResolutionAdvisoryType.Clear;
            const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
            const alimMeters = alim.asUnit(UnitType.METER);
            const responseTimeSeconds = this.isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds;
            const responseTimeSecondsRemaining = isInitial
                ? responseTimeSeconds
                : MathUtils.clamp(responseTimeSeconds - (simTime - this.lastStateChangeTime) / 1000, 0, responseTimeSeconds);
            const accelMps = this.isInitial ? this.initialAccelMps : this.subsequentAccelMps;
            this.updateIntruders(intruders);
            this.updateVsConstraints(alimMeters, responseTimeSecondsRemaining, accelMps);
            if (isInitial) {
                this.selectInitialState(simTime, ownAirplaneVsMps);
            }
            else {
                if (BitFlags.isAny(this._primaryFlags, TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Descend)) {
                    this.updatePositive(simTime);
                }
                else if (this._secondaryType === null) {
                    this.updateNegative(simTime, ownAirplaneVsMps);
                }
                else {
                    this.updateComposite(simTime, ownAirplaneVsMps);
                }
            }
        }
    }
    /**
     * Updates this host's resolution advisory's array of active intruders.
     * @param intruders The set of active intruders to be tracked by the resolution advisory.
     */
    updateIntruders(intruders) {
        // Remove one sense reversal used for every intruder that was removed from the RA.
        for (let i = 0; i < this.intruderArray.length; i++) {
            if (!intruders.has(this.intruderArray[i])) {
                this.senseReversalCount = Math.max(this.senseReversalCount - 1, 0);
            }
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        for (const intruder of intruders) {
            this.intruders.add(intruder);
            this.intruderArray.push(intruder);
        }
        this.intruderArray.sort(TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC);
    }
    /**
     * Updates the vertical speed constraints associated with the intruders participating in this host's current
     * resolution advisory.
     * @param alimMeters The value of ALIM (the minimum desired vertical separation between the own airplane and an
     * intruder at time of closest approach), in meters.
     * @param responseTimeSeconds The predicted amount of time, in seconds, for the own airplane to respond to the most
     * recently issued resolution advisory, relative to the present.
     * @param accelMps The predicted vertical acceleration, in meters per second squared, of the own airplane when
     * responding to the most recently issued resolution advisory.
     */
    updateVsConstraints(alimMeters, responseTimeSeconds, accelMps) {
        var _a;
        var _b;
        const ownAirplaneVsMps = this.ownAirplane.verticalSpeed.asUnit(UnitType.MPS);
        for (let i = 0; i < this.intruderArray.length; i++) {
            const intruder = this.intruderArray[i];
            let above = -Infinity;
            let below = Infinity;
            if (intruder.tcaRA.isValid) {
                const t0 = intruder.tcaRA.time;
                const tcpaSeconds = intruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
                const tcpaTime = intruder.tcaRA.time + tcpaSeconds * 1000;
                const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                const intruderTcaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + intruder.tcaRA.cpaDisplacement[2];
                const ownAirplaneAltTcaMeters = this.ownAirplane.predictPosition(tcpaTime, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
                // The altitude own airplane needs to be above in order to pass above the intruder with ALIM vertical separation at CPA.
                const aboveAltTargetMeters = intruderTcaAltMeters + alimMeters;
                // The altitude own airplane needs to be below in order to pass below the intruder with ALIM vertical separation at CPA.
                const belowAltTargetMeters = intruderTcaAltMeters - alimMeters;
                const aboveAlimSense = Math.sign(aboveAltTargetMeters - ownAirplaneAltTcaMeters);
                const belowAlimSense = Math.sign(belowAltTargetMeters - ownAirplaneAltTcaMeters);
                if (aboveAlimSense === 1) {
                    // Own airplane needs to adjust vertical speed in the positive direction in order to pass above the intruder with
                    // ALIM vertical separation at CPA.
                    above = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, aboveAltTargetMeters)
                        : NaN;
                    if (isNaN(above)) {
                        above = Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass above the intruder with ALIM vertical separation at CPA.
                    above = tcpaSeconds > 0
                        ? (aboveAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : -Infinity;
                }
                if (belowAlimSense === -1) {
                    // Own airplane needs to adjust vertical speed in the negative direction in order to pass below the intruder with
                    // ALIM vertical separation at CPA
                    below = responseTimeSeconds < tcpaSeconds
                        ? TcasResolutionAdvisoryHostClass.calculateVSToTargetAlt(tcpaSeconds, ownAirplaneAltMeters, ownAirplaneVsMps, responseTimeSeconds, accelMps, belowAltTargetMeters)
                        : NaN;
                    if (isNaN(below)) {
                        below = -Infinity;
                    }
                }
                else {
                    // Own airplane is already on track to pass below the intruder with ALIM vertical separation at CPA.
                    below = tcpaSeconds > 0
                        ? (belowAltTargetMeters - ownAirplaneAltMeters) / tcpaSeconds
                        : Infinity;
                }
            }
            const constraint = (_a = (_b = this.vsConstraints)[i]) !== null && _a !== void 0 ? _a : (_b[i] = { above: 0, below: 0 });
            constraint.above = above;
            constraint.below = below;
        }
        this.vsConstraints.length = this.intruderArray.length;
    }
    /**
     * Selects an initial state for a new resolution advisory.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    selectInitialState(simTime, ownAirplaneVsMps) {
        // We need to first select either upward or downward sense.
        // The minimum vertical speed own airplane can target while still achieving ALIM separation ABOVE all intruders
        let minUpSenseVsMps = this.getUpSenseRequiredMinVs();
        // The maximum vertical speed own airplane can target while still achieving ALIM separation BELOW all intruders
        let maxDownSenseVsMps = this.getDownSenseRequiredMaxVs();
        // The strongest initial upward and downward sense RAs are CLIMB and DESCEND, respectively (or their crossing/maintain
        // variants, but all have the same vertical speed target).
        let doesUpSenseAchieveAlim = minUpSenseVsMps <= TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        let doesDownSenseAchieveAlim = maxDownSenseVsMps >= -TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS;
        const doesUpSenseRequireClimb = minUpSenseVsMps > 0;
        const doesDownSenseRequireDescend = maxDownSenseVsMps < 0;
        const canClimb = this.options.allowClimb(simTime);
        const canDescend = this.options.allowDescend(simTime);
        const isUpSenseInhibited = doesUpSenseRequireClimb && !canClimb;
        const isDownSenseInhibited = doesDownSenseRequireDescend && !canDescend;
        minUpSenseVsMps = isUpSenseInhibited ? 0 : minUpSenseVsMps;
        maxDownSenseVsMps = isDownSenseInhibited ? 0 : maxDownSenseVsMps;
        let sense;
        let senseIsCrossing = false;
        let doesSenseAchieveAlim = false;
        let senseRequiredVs = 0;
        // If one sense RA achieves ALIM separation and the other does not, choose the one that achieves ALIM separation.
        if (doesUpSenseAchieveAlim && !doesDownSenseAchieveAlim) {
            sense = 1;
        }
        else if (!doesUpSenseAchieveAlim && doesDownSenseAchieveAlim) {
            sense = -1;
        }
        else {
            // If both or neither sense RA achieves ALIM separation, choose the non-crossing sense. Only the closest intruder
            // is evaluated, since in a multi-intruder RA there is the opportunity to reverse sense with each intruder.
            const closestIntruder = this.intruderArray[0];
            const t0 = closestIntruder.tcaRA.time;
            const tcpaSeconds = closestIntruder.tcaRA.tcpa.asUnit(UnitType.SECOND);
            const ownAirplaneAltMeters = this.ownAirplane.predictPosition(t0, TcasResolutionAdvisoryHostClass.vec3Cache[0])[2];
            const intruderTcpaAltMeters = ownAirplaneAltMeters + tcpaSeconds * ownAirplaneVsMps + closestIntruder.tcaRA.cpaDisplacement[2];
            const crossingSense = Math.sign(intruderTcpaAltMeters - ownAirplaneAltMeters);
            if (crossingSense === -1 && !isUpSenseInhibited) {
                sense = 1;
            }
            else if (crossingSense === 1 && !isDownSenseInhibited) {
                sense = -1;
            }
            else {
                // If neither sense is crossing or the non-crossing sense is inhibited, choose the one that is not inhibited.
                if (!isUpSenseInhibited && isDownSenseInhibited) {
                    sense = 1;
                }
                else if (isUpSenseInhibited && !isDownSenseInhibited) {
                    sense = -1;
                }
                else {
                    // If neither or both senses are inhibited, choose the one that gives the greatest potential separation at
                    // CPA (i.e. the one that requires the least change in vertical speed). Again, only the closest intruder is evaluated.
                    if (Math.abs(minUpSenseVsMps - ownAirplaneVsMps) < Math.abs(maxDownSenseVsMps - ownAirplaneVsMps)) {
                        sense = 1;
                    }
                    else {
                        sense = -1;
                    }
                }
                senseIsCrossing = sense === crossingSense;
            }
        }
        doesUpSenseAchieveAlim = isUpSenseInhibited ? false : doesUpSenseAchieveAlim;
        doesDownSenseAchieveAlim = isDownSenseInhibited ? false : doesDownSenseAchieveAlim;
        doesSenseAchieveAlim = sense === 1 ? doesUpSenseAchieveAlim : doesDownSenseAchieveAlim;
        senseRequiredVs = sense === 1 ? minUpSenseVsMps : maxDownSenseVsMps;
        // For multi-intruder RAs, there is the option to choose an initial composite RA which combines two negative RAs of
        // opposite senses.
        if (this.intruderArray.length > 1) {
            // Because the composite RA always includes a vertical speed of 0 within its vertical speed target range, it
            // achieves ALIM separation from all intruders if and only if a vertical speed of 0 does.
            const doesCompositeAchieveAlim = this.vsConstraints.every(constraint => constraint.above <= 0 || constraint.below >= 0);
            // If the composite RA achieves ALIM separation from all intruders and the selected up/down sense RA does not,
            // choose the composite RA.
            if (doesCompositeAchieveAlim && !doesSenseAchieveAlim) {
                sense = 0;
                doesSenseAchieveAlim = doesCompositeAchieveAlim;
            }
            else if (doesCompositeAchieveAlim === doesSenseAchieveAlim) {
                // If both or neither the composite RA or the selected up/down sense RA achieves ALIM separation from all
                // intruders, choose the composite RA if the up/down sense RA is crossing.
                if (senseIsCrossing) {
                    sense = 0;
                    doesSenseAchieveAlim = doesCompositeAchieveAlim;
                }
                else {
                    // If both or neither the composite RA or the selected up/down sense RA is crossing, choose the one that
                    // provides the greatest potential vertical separation at CPA. Again, only the closest intruder is
                    // evaluated.
                    if (Math.abs(ownAirplaneVsMps) < Math.abs(senseRequiredVs - ownAirplaneVsMps)) {
                        sense = 0;
                        doesSenseAchieveAlim = doesCompositeAchieveAlim;
                    }
                }
            }
        }
        // Now that we have selected the sense, we need to choose the appropriate initial RA type.
        let primaryType;
        let secondaryType = null;
        switch (sense) {
            case 0: // Composite RA
                if (doesSenseAchieveAlim) {
                    // Find the vertical speed limits required to achieve ALIM separation.
                    const maxVsMps = this.getCompositeRequiredMaxVs();
                    const minVsMps = this.getCompositeRequiredMinVs();
                    if (ownAirplaneVsMps > maxVsMps) {
                        // Downward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                    }
                    else if (ownAirplaneVsMps < minVsMps) {
                        // Upward sense, corrective
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                    else {
                        // Preventative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minVsMps);
                        secondaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxVsMps);
                    }
                }
                else {
                    primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    secondaryType = TcasResolutionAdvisoryType.DoNotClimb0;
                }
                break;
            case 1: // Upward sense single RA
                if (ownAirplaneVsMps < minUpSenseVsMps) {
                    // Corrective
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingClimb : TcasResolutionAdvisoryType.Climb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceDescent;
                    }
                }
                else {
                    // Preventative
                    if (minUpSenseVsMps > 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainClimb : TcasResolutionAdvisoryType.MaintainClimb;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotDescendType(minUpSenseVsMps);
                    }
                }
                break;
            case -1: // Downward sense single RA
                if (ownAirplaneVsMps > maxDownSenseVsMps) {
                    // Corrective
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingDescend : TcasResolutionAdvisoryType.Descend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryType.ReduceClimb;
                    }
                }
                else {
                    // Preventative
                    if (maxDownSenseVsMps < 0) {
                        // Positive
                        primaryType = senseIsCrossing ? TcasResolutionAdvisoryType.CrossingMaintainDescend : TcasResolutionAdvisoryType.MaintainDescend;
                    }
                    else {
                        // Negative
                        primaryType = TcasResolutionAdvisoryHostClass.getDoNotClimbType(maxDownSenseVsMps);
                    }
                }
                break;
        }
        this.setState(simTime, primaryType, secondaryType, true);
    }
    /**
     * Updates an existing positive resolution advisory. Positive resolution advisories include the CLIMB and DESCEND and
     * related types (CROSSING, MAINTAIN, INCREASE, REVERSAL).
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    updatePositive(simTime) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        const isIncrease = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Increase);
        // Check if we are inhibited, if so -> convert the current RA to its negative preventative counterpart.
        const isInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
        if (isInhibited) {
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.DoNotDescend0 : TcasResolutionAdvisoryType.DoNotClimb0, null);
            return;
        }
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, attempt to
        // weaken the RA. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            // If weakening to a REDUCE CLIMB/DESCENT RA would still provide ALIM separation, do so.
            if (requiredVsMps * sense <= 0) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
            }
        }
        else {
            // Check if strengthening to an INCREASE CLIMB/DESCENT RA would provide ALIM separation
            const isStrengthenInhibited = sense === 1 ? !this.options.allowIncreaseClimb(simTime) : !this.options.allowIncreaseDescent(simTime);
            let strengthen = !isIncrease && !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen && this.senseReversalCount < this.intruderArray.length) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isIncrease && !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.IncreaseClimb : TcasResolutionAdvisoryType.IncreaseDescend, null);
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
            }
        }
    }
    /**
     * Updates an existing negative resolution advisory. Negative resolution advisories include the REDUCE CLIMB/DESCENT
     * and DO NOT CLIMB/DESCEND types.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     */
    updateNegative(simTime, ownAirplaneVsMps) {
        const sense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        // Check if we are currently on track to achieve ALIM separation from all intruders. If we are, we do nothing since
        // negative RAs cannot be weakened. If we are not, attempt to strengthen the RA or trigger a sense reversal.
        const currentTargetVsMps = sense === 1 ? this._minVerticalSpeed.asUnit(UnitType.MPS) : this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredVsMps = sense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
        const willAchieveAlim = (currentTargetVsMps - requiredVsMps) * sense >= 0;
        if (willAchieveAlim) {
            return;
        }
        const requirePositive = requiredVsMps * sense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = sense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense - requiredVsMps) * sense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (sense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = sense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * sense + reversalRequiredVsMps) * sense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // negative RA we can.
        }
        if ((ownAirplaneVsMps - requiredVsMps) * sense < 0) {
            // We need to issue a corrective negative RA.
            this.setState(simTime, sense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb, null);
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            this.setState(simTime, sense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(requiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(requiredVsMps), null);
        }
    }
    /**
     * Updates an existing composite resolution advisory. Composite resolution advisories consist of a (corrective or
     * preventative) negative resolution advisory combined with a negative preventative resolution advisory of the
     * opposite sense.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param ownAirplaneVsMps The current vertical speed of the own airplane, in meters per second.
     * @throws Error if a composite resolution advisory is not active.
     */
    updateComposite(simTime, ownAirplaneVsMps) {
        if (this._secondaryType === null) {
            throw new Error('TcasResolutionAdvisoryClass: attempted to update a composite RA when one was not active');
        }
        const currentMinVsMps = this._minVerticalSpeed.asUnit(UnitType.MPS);
        const currentMaxVsMps = this._maxVerticalSpeed.asUnit(UnitType.MPS);
        const requiredMinVsMps = this.getCompositeRequiredMinVs();
        const requiredMaxVsMps = this.getCompositeRequiredMaxVs();
        const primarySense = BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.UpSense) ? 1 : -1;
        let primaryCurrentVsMps, primaryRequiredVsMps, secondaryCurrentVsMps, secondaryRequiredVsMps;
        if (primarySense === 1) {
            primaryCurrentVsMps = currentMinVsMps;
            primaryRequiredVsMps = requiredMinVsMps;
            secondaryCurrentVsMps = currentMaxVsMps;
            secondaryRequiredVsMps = requiredMaxVsMps;
        }
        else {
            primaryCurrentVsMps = currentMaxVsMps;
            primaryRequiredVsMps = requiredMaxVsMps;
            secondaryCurrentVsMps = currentMinVsMps;
            secondaryRequiredVsMps = requiredMinVsMps;
        }
        const willPrimaryAchieveAlim = (primaryCurrentVsMps - primaryRequiredVsMps) * primarySense >= 0;
        const willSecondaryAchieveAlim = (secondaryCurrentVsMps - secondaryRequiredVsMps) * -primarySense >= 0;
        const requirePositive = !willPrimaryAchieveAlim && primaryRequiredVsMps * primarySense > 0
            || !willSecondaryAchieveAlim && secondaryRequiredVsMps * -primarySense > 0;
        if (requirePositive) {
            // We need to strengthen to a positive RA in order to achieve ALIM separation from all intruders.
            const isStrengthenInhibited = primarySense === 1 ? !this.options.allowClimb(simTime) : !this.options.allowDescend(simTime);
            const positiveRequiredVsMps = primarySense === 1 ? this.getUpSenseRequiredMinVs() : this.getDownSenseRequiredMaxVs();
            let strengthen = !isStrengthenInhibited && (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense - positiveRequiredVsMps) * primarySense >= 0;
            let reverseSense = false;
            if (!strengthen
                && this.senseReversalCount < this.intruderArray.length
                && (primarySense === 1 ? this.options.allowDescend(simTime) : this.options.allowClimb(simTime))) {
                // Check if a sense reversal would provide ALIM separation
                const reversalRequiredVsMps = primarySense === 1 ? this.getDownSenseRequiredMaxVs() : this.getUpSenseRequiredMinVs();
                reverseSense = (TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS * primarySense + reversalRequiredVsMps) * primarySense >= 0;
            }
            strengthen = !isStrengthenInhibited && !reverseSense;
            if (strengthen) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.Climb : TcasResolutionAdvisoryType.Descend, null);
                return;
            }
            else if (reverseSense) {
                this.setState(simTime, primarySense === 1 ? TcasResolutionAdvisoryType.ReversalDescend : TcasResolutionAdvisoryType.ReversalClimb, null);
                return;
            }
            // If we can't strengthen to a positive RA or issue a sense reversal, fall back to issuing the most restrictive
            // pair of negative RAs we can.
        }
        let primaryType;
        if ((ownAirplaneVsMps - primaryRequiredVsMps) * primarySense < 0) {
            // We need to issue a corrective negative RA.
            primaryType = primarySense === 1 ? TcasResolutionAdvisoryType.ReduceDescent : TcasResolutionAdvisoryType.ReduceClimb;
        }
        else {
            // We can strengthen to a more restrictive preventative negative RA.
            primaryType = primarySense === 1
                ? TcasResolutionAdvisoryHostClass.getDoNotDescendType(primaryRequiredVsMps)
                : TcasResolutionAdvisoryHostClass.getDoNotClimbType(primaryRequiredVsMps);
        }
        const secondaryType = primarySense === 1
            ? TcasResolutionAdvisoryHostClass.getDoNotClimbType(secondaryRequiredVsMps)
            : TcasResolutionAdvisoryHostClass.getDoNotDescendType(secondaryRequiredVsMps);
        this.setState(simTime, primaryType, secondaryType);
    }
    /**
     * Sets the state of this host's current resolution advisory. If the specified state is equal to the current state
     * of the resolution advisory, this method does nothing. If the state is successfully set, the `tcas_ra_issued`
     * event will be published if `isInitial` is `true`, or the `tcas_ra_updated` event if `isInitial` is `false`.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     * @param primaryType The primary type of the resolution advisory.
     * @param secondaryType The secondary type of the resolution advisory.
     * @param isInitial Whether the state to set is for an initial resolution advisory.
     */
    setState(simTime, primaryType, secondaryType, isInitial = false) {
        if (primaryType === this._primaryType && secondaryType === this._secondaryType) {
            return;
        }
        let minSpeed, maxSpeed;
        const primaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[primaryType];
        this._primaryType = primaryType;
        this._primaryFlags = primaryTypeDef.flags;
        this._secondaryType = secondaryType;
        if (secondaryType !== null) {
            const secondaryTypeDef = TcasResolutionAdvisoryHostClass.TYPE_DEFS[secondaryType];
            this._secondaryFlags = secondaryTypeDef.flags;
            minSpeed = Math.max(primaryTypeDef.minVerticalSpeed, secondaryTypeDef.minVerticalSpeed);
            maxSpeed = Math.min(primaryTypeDef.maxVerticalSpeed, secondaryTypeDef.maxVerticalSpeed);
        }
        else {
            this._secondaryFlags = 0;
            minSpeed = primaryTypeDef.minVerticalSpeed;
            maxSpeed = primaryTypeDef.maxVerticalSpeed;
        }
        this._minVerticalSpeed.set(isFinite(minSpeed) ? minSpeed : NaN);
        this._maxVerticalSpeed.set(isFinite(maxSpeed) ? maxSpeed : NaN);
        this.isInitial = isInitial;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE
            + (isInitial ? this.initialResponseTimeSeconds : this.subsequentResponseTimeSeconds) * 1000;
        if (BitFlags.isAll(this._primaryFlags, TcasResolutionAdvisoryFlags.Reversal)) {
            this.senseReversalCount++;
        }
        if (isInitial) {
            this.publisher.pub('tcas_ra_issued', this, false, false);
        }
        else {
            this.publisher.pub('tcas_ra_updated', this, false, false);
        }
    }
    /**
     * Cancels this host's current resolution advisory. If there is no currently active resolution advisory, this
     * method does nothing. If the resolution advisory is successfully cancelled, the `tcas_ra_canceled` event will be
     * published.
     * @param simTime The current sim time, as a UNIX timestamp in milliseconds.
     */
    cancel(simTime) {
        if (this._primaryType === TcasResolutionAdvisoryType.Clear && this._secondaryType === null) {
            return;
        }
        this.intruders.clear();
        this.intruderArray.length = 0;
        this._maxVerticalSpeed.set(NaN);
        this._minVerticalSpeed.set(NaN);
        this._primaryType = TcasResolutionAdvisoryType.Clear;
        this._primaryFlags = 0;
        this._secondaryType = null;
        this._secondaryFlags = 0;
        this.lastStateChangeTime = simTime;
        this.stateChangeDelay = TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE;
        this.isInitial = true;
        this.senseReversalCount = 0;
        this.publisher.pub('tcas_ra_canceled', undefined, false, false);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * above all current RA intruders.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation above all current RA intruders.
     */
    getUpSenseRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => Math.max(min, constraint.above), -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * below all current RA intruders.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation below all current RA intruders.
     */
    getDownSenseRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => Math.min(max, constraint.below), Infinity);
    }
    /**
     * Gets the required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required minimum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMinVs() {
        return this.vsConstraints.reduce((min, constraint) => constraint.above <= 0 ? Math.max(min, constraint.above) : min, -Infinity);
    }
    /**
     * Gets the required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM separation
     * from all current RA intruders during a composite advisory.
     * @returns The required maximum vertical speed, in meters per second, for the own airplane to achieve ALIM
     * separation from all current RA intruders during a composite advisory.
     */
    getCompositeRequiredMaxVs() {
        return this.vsConstraints.reduce((max, constraint) => constraint.below >= 0 ? Math.min(max, constraint.below) : max, Infinity);
    }
    /**
     * Calculates the vertical speed required to achieve a desired altitude target at time of closest approach.
     * @param tcpa The time to closest approach from the present, in seconds.
     * @param currentAlt The current altitude of the own airplane, in meters.
     * @param vs The current vertical speed of the own airplane, in meters per second.
     * @param responseTime The response time of the own airplane, in seconds.
     * @param accel The acceleration of the own airplane, in meters per second squared.
     * @param targetAlt The target altitude of the own airplane at time of closest approach, in meters.
     * @returns The vertical speed, in meters per second, required to achieve a desired altitude target at time of
     * closest approach. A value of `NaN` indicates the altitude target cannot be reached with the specified parameters.
     */
    static calculateVSToTargetAlt(tcpa, currentAlt, vs, responseTime, accel, targetAlt) {
        const signedAccel = accel * Math.sign(targetAlt - (currentAlt + vs * tcpa));
        if (signedAccel === 0) {
            return vs;
        }
        const y0 = currentAlt + vs * responseTime;
        const tc = tcpa - responseTime;
        const a = signedAccel / 2;
        const b = -signedAccel * tc;
        const c = targetAlt - y0 - vs * tc;
        const discriminant = b * b - 4 * a * c;
        if (discriminant < 0) {
            return NaN;
        }
        const sqrtDiscr = Math.sqrt(discriminant);
        const t1 = (-b + sqrtDiscr) / (2 * a);
        const t2 = (-b - sqrtDiscr) / (2 * a);
        if (t1 <= tc && t1 >= 0) {
            return vs + signedAccel * t1;
        }
        if (t2 <= tc && t2 >= 0) {
            return vs + signedAccel * t2;
        }
        return NaN;
    }
    /**
     * Gets the least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for a given minimum
     * vertical speed requirement.
     * @param minVsMps A minimum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT DESCEND resolution advisory type appropriate to issue for the specified
     * minimum vertical speed requirement.
     */
    static getDoNotDescendType(minVsMps) {
        if (minVsMps > -500) {
            return TcasResolutionAdvisoryType.DoNotDescend0;
        }
        else if (minVsMps > -1000) {
            return TcasResolutionAdvisoryType.DoNotDescend500;
        }
        else if (minVsMps > -1500) {
            return TcasResolutionAdvisoryType.DoNotDescend1000;
        }
        else if (minVsMps > -2000) {
            return TcasResolutionAdvisoryType.DoNotDescend1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotDescend2000;
        }
    }
    /**
     * Gets the least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for a given maximum
     * vertical speed requirement.
     * @param maxVsMps A maximum vertical speed requirement, in meters per second.
     * @returns The least restrictive DO NOT CLIMB resolution advisory type appropriate to issue for the specified
     * maximum vertical speed requirement.
     */
    static getDoNotClimbType(maxVsMps) {
        if (maxVsMps < 500) {
            return TcasResolutionAdvisoryType.DoNotClimb0;
        }
        else if (maxVsMps < 1000) {
            return TcasResolutionAdvisoryType.DoNotClimb500;
        }
        else if (maxVsMps < 1500) {
            return TcasResolutionAdvisoryType.DoNotClimb1000;
        }
        else if (maxVsMps < 2000) {
            return TcasResolutionAdvisoryType.DoNotClimb1500;
        }
        else {
            return TcasResolutionAdvisoryType.DoNotClimb2000;
        }
    }
}
/** The base amount of delay between state changes, in milliseconds, before predicted response time is taken into account. */
TcasResolutionAdvisoryHostClass.STATE_CHANGE_DELAY_BASE = 5000;
TcasResolutionAdvisoryHostClass.CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(1500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INC_CLIMB_DESC_VS_MPS = UnitType.FPM.convertTo(2500, UnitType.MPS);
TcasResolutionAdvisoryHostClass.INTRUDER_SORT_FUNC = (a, b) => {
    const tcpaComparison = a.tcaRA.tcpa.compare(b.tcaRA.tcpa);
    if (tcpaComparison < 0) {
        return -1;
    }
    else if (tcpaComparison > 0) {
        return 1;
    }
    else if (a.tcaRA.cpaNorm < b.tcaRA.cpaNorm) {
        return -1;
    }
    else if (a.tcaRA.cpaNorm > b.tcaRA.cpaNorm) {
        return 1;
    }
    else {
        return 0;
    }
};
TcasResolutionAdvisoryHostClass.TYPE_DEFS = {
    [TcasResolutionAdvisoryType.Clear]: {
        flags: 0,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Climb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.MaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.CrossingClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.CrossingMaintainClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 4400
    },
    [TcasResolutionAdvisoryType.IncreaseClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 2500,
        maxVerticalSpeed: 3000
    },
    [TcasResolutionAdvisoryType.ReversalClimb]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.Climb | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 1500,
        maxVerticalSpeed: 2000
    },
    [TcasResolutionAdvisoryType.ReduceDescent]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.ReduceDescent | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend0]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: 0,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend1500]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -1500,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.DoNotDescend2000]: {
        flags: TcasResolutionAdvisoryFlags.UpSense | TcasResolutionAdvisoryFlags.DoNotDescend,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: Infinity
    },
    [TcasResolutionAdvisoryType.Descend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.MaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.CrossingMaintainDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Crossing,
        minVerticalSpeed: -4400,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.IncreaseDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Increase | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -3000,
        maxVerticalSpeed: -2500
    },
    [TcasResolutionAdvisoryType.ReversalDescend]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.Descend | TcasResolutionAdvisoryFlags.Reversal | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -2000,
        maxVerticalSpeed: -1500
    },
    [TcasResolutionAdvisoryType.ReduceClimb]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.ReduceClimb | TcasResolutionAdvisoryFlags.Corrective,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb0]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 0
    },
    [TcasResolutionAdvisoryType.DoNotClimb500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 500
    },
    [TcasResolutionAdvisoryType.DoNotClimb1000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1000
    },
    [TcasResolutionAdvisoryType.DoNotClimb1500]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 1500
    },
    [TcasResolutionAdvisoryType.DoNotClimb2000]: {
        flags: TcasResolutionAdvisoryFlags.DownSense | TcasResolutionAdvisoryFlags.DoNotClimb,
        minVerticalSpeed: -Infinity,
        maxVerticalSpeed: 2000
    },
};
TcasResolutionAdvisoryHostClass.vec3Cache = [new Float64Array(3)];

/**
 * Standard TCAS-II sensitivity parameters.
 */
class TcasIISensitivityParameters {
    /**
     * Selects a sensitivity level for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns The sensitivity level for the specified environment.
     */
    selectLevel(altitude, radarAltitude) {
        const altFeet = altitude.asUnit(UnitType.FOOT);
        const radarAltFeet = radarAltitude.asUnit(UnitType.FOOT);
        let level;
        if (radarAltFeet > 2350) {
            if (altFeet > 42000) {
                level = 6;
            }
            else if (altFeet > 20000) {
                level = 5;
            }
            else if (altFeet > 10000) {
                level = 4;
            }
            else if (altFeet > 5000) {
                level = 3;
            }
            else {
                level = 2;
            }
        }
        else if (radarAltFeet > 1000) {
            level = 1;
        }
        else {
            level = 0;
        }
        return level;
    }
    /**
     * Selects Proximity Advisory sensitivity parameters.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Proximity Advisory sensitivity parameters.
     */
    selectPA(
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    altitude, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    radarAltitude) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Selects Traffic Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Traffic Advisory sensitivity parameters for the specified environment.
     */
    selectTA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.TA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects Resolution Advisory sensitivity parameters for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns Resolution Advisory sensitivity parameters for the specified environment.
     */
    selectRA(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)];
    }
    /**
     * Selects a Resolution Advisory ALIM for a specified environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     * @returns A Resolution Advisory ALIM for the specified environment.
     */
    selectRAAlim(altitude, radarAltitude) {
        return TcasIISensitivityParameters.RA_LEVELS[this.selectLevel(altitude, radarAltitude)].alim;
    }
    /**
     * Gets Proximity Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Proximity Advisory sensitivity parameters for the given sensitivity level.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPA(level) {
        return TcasIISensitivityParameters.PA;
    }
    /**
     * Gets Traffic Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Traffic Advisory sensitivity parameters for the given sensitivity level.
     */
    getTA(level) {
        return TcasIISensitivityParameters.TA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.TA_LEVELS.length - 1)];
    }
    /**
     * Gets Resolution Advisory sensitivity parameters for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns Resolution Advisory sensitivity parameters for the given sensitivity level.
     */
    getRA(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)];
    }
    /**
     * Gets a Resolution Advisory ALIM for a given sensitivity level.
     * @param level A sensitivity level.
     * @returns A Resolution Advisory ALIM for the given sensitivity level.
     */
    getRAAlim(level) {
        return TcasIISensitivityParameters.RA_LEVELS[MathUtils.clamp(level, 0, TcasIISensitivityParameters.RA_LEVELS.length - 1)].alim;
    }
}
TcasIISensitivityParameters.PA = {
    protectedRadius: UnitType.NMILE.createNumber(6),
    protectedHeight: UnitType.FOOT.createNumber(1200)
};
TcasIISensitivityParameters.TA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.33),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.48),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(40),
        protectedRadius: UnitType.NMILE.createNumber(0.75),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(45),
        protectedRadius: UnitType.NMILE.createNumber(1),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(850)
    },
    {
        tau: UnitType.SECOND.createNumber(48),
        protectedRadius: UnitType.NMILE.createNumber(1.3),
        protectedHeight: UnitType.FOOT.createNumber(1200)
    }
];
TcasIISensitivityParameters.RA_LEVELS = [
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(15),
        protectedRadius: UnitType.NMILE.createNumber(0.2),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.4)
    },
    {
        tau: UnitType.SECOND.createNumber(20),
        protectedRadius: UnitType.NMILE.createNumber(0.35),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(300),
        hmd: UnitType.NMILE.createNumber(0.57)
    },
    {
        tau: UnitType.SECOND.createNumber(25),
        protectedRadius: UnitType.NMILE.createNumber(0.55),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(350),
        hmd: UnitType.NMILE.createNumber(0.74)
    },
    {
        tau: UnitType.SECOND.createNumber(30),
        protectedRadius: UnitType.NMILE.createNumber(0.8),
        protectedHeight: UnitType.FOOT.createNumber(600),
        alim: UnitType.FOOT.createNumber(400),
        hmd: UnitType.NMILE.createNumber(0.82)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(700),
        alim: UnitType.FOOT.createNumber(600),
        hmd: UnitType.NMILE.createNumber(0.98)
    },
    {
        tau: UnitType.SECOND.createNumber(35),
        protectedRadius: UnitType.NMILE.createNumber(1.1),
        protectedHeight: UnitType.FOOT.createNumber(800),
        alim: UnitType.FOOT.createNumber(700),
        hmd: UnitType.NMILE.createNumber(0.98)
    }
];
/**
 * An implementation of {@link TCASSensitivity} which provides sensitivity parameters as defined in the official
 * TCAS II specification.
 */
class TcasIISensitivity {
    constructor() {
        this.sensitivity = new TcasIISensitivityParameters();
        this.level = 0;
        this.params = {
            parametersPA: this.sensitivity.getPA(0),
            parametersTA: this.sensitivity.getTA(0),
            parametersRA: this.sensitivity.getRA(0)
        };
    }
    /** @inheritdoc */
    selectParameters() {
        return this.params;
    }
    /** @inheritdoc */
    selectRAAlim() {
        return this.sensitivity.getRAAlim(this.level);
    }
    /**
     * Updates sensitivity level based on the current environment.
     * @param altitude The indicated altitude of the own airplane.
     * @param radarAltitude The radar altitude of the own airplane.
     */
    updateLevel(altitude, radarAltitude) {
        this.level = this.sensitivity.selectLevel(altitude, radarAltitude);
        this.params.parametersPA = this.sensitivity.getPA(this.level);
        this.params.parametersTA = this.sensitivity.getTA(this.level);
        this.params.parametersRA = this.sensitivity.getRA(this.level);
    }
}

var APVerticalModes;
(function (APVerticalModes) {
    APVerticalModes[APVerticalModes["NONE"] = 0] = "NONE";
    APVerticalModes[APVerticalModes["PITCH"] = 1] = "PITCH";
    APVerticalModes[APVerticalModes["VS"] = 2] = "VS";
    APVerticalModes[APVerticalModes["FLC"] = 3] = "FLC";
    APVerticalModes[APVerticalModes["ALT"] = 4] = "ALT";
    APVerticalModes[APVerticalModes["PATH"] = 5] = "PATH";
    APVerticalModes[APVerticalModes["GP"] = 6] = "GP";
    APVerticalModes[APVerticalModes["GS"] = 7] = "GS";
    APVerticalModes[APVerticalModes["CAP"] = 8] = "CAP";
    APVerticalModes[APVerticalModes["TO"] = 9] = "TO";
    APVerticalModes[APVerticalModes["GA"] = 10] = "GA";
    APVerticalModes[APVerticalModes["FPA"] = 11] = "FPA";
    APVerticalModes[APVerticalModes["FLARE"] = 12] = "FLARE";
})(APVerticalModes || (APVerticalModes = {}));
var APLateralModes;
(function (APLateralModes) {
    APLateralModes[APLateralModes["NONE"] = 0] = "NONE";
    APLateralModes[APLateralModes["ROLL"] = 1] = "ROLL";
    APLateralModes[APLateralModes["LEVEL"] = 2] = "LEVEL";
    APLateralModes[APLateralModes["GPSS"] = 3] = "GPSS";
    APLateralModes[APLateralModes["HEADING"] = 4] = "HEADING";
    APLateralModes[APLateralModes["VOR"] = 5] = "VOR";
    APLateralModes[APLateralModes["LOC"] = 6] = "LOC";
    APLateralModes[APLateralModes["BC"] = 7] = "BC";
    APLateralModes[APLateralModes["ROLLOUT"] = 8] = "ROLLOUT";
    APLateralModes[APLateralModes["NAV"] = 9] = "NAV";
    APLateralModes[APLateralModes["TO"] = 10] = "TO";
    APLateralModes[APLateralModes["GA"] = 11] = "GA";
    APLateralModes[APLateralModes["HEADING_HOLD"] = 12] = "HEADING_HOLD";
    APLateralModes[APLateralModes["TRACK"] = 13] = "TRACK";
    APLateralModes[APLateralModes["TRACK_HOLD"] = 14] = "TRACK_HOLD";
    APLateralModes[APLateralModes["FMS_LOC"] = 15] = "FMS_LOC";
    APLateralModes[APLateralModes["TO_LOC"] = 16] = "TO_LOC";
})(APLateralModes || (APLateralModes = {}));
var APAltitudeModes;
(function (APAltitudeModes) {
    APAltitudeModes[APAltitudeModes["NONE"] = 0] = "NONE";
    APAltitudeModes[APAltitudeModes["ALTS"] = 1] = "ALTS";
    APAltitudeModes[APAltitudeModes["ALTV"] = 2] = "ALTV";
})(APAltitudeModes || (APAltitudeModes = {}));

/**
 * A Utility Class for VNAV
 */
class VNavUtils {
    /**
     * Checks if a constraint is a user-created constraint.
     * @param lateralLeg The Lateral Flight Plan Leg.
     * @returns If this constraint is a user-created constraint.
     */
    static isUserConstraint(lateralLeg) {
        if (lateralLeg.verticalData.altDesc !== lateralLeg.leg.altDesc
            || lateralLeg.verticalData.altitude1 !== lateralLeg.leg.altitude1
            || lateralLeg.verticalData.altitude2 !== lateralLeg.leg.altitude2) {
            return true;
        }
        return false;
    }
    /**
     * Gets the required vertical speed to meet an altitude constraint.
     * @param distance The distance to the constraint, in nautical miles.
     * @param targetAltitude The target altitude for the constraint, in feet.
     * @param currentAltitude The current altitude, in feet.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The required vertical speed, in feet per minute, to meet the altitude constraint.
     */
    static getRequiredVs(distance, targetAltitude, currentAltitude, groundSpeed) {
        const delta = targetAltitude - currentAltitude;
        const minutesToConstraint = distance / groundSpeed * 60;
        return delta / minutesToConstraint;
    }
    /**
     * Gets the vertical speed required to maintain a given flight path angle and groundspeed.
     * @param fpa The flight path angle, in degrees. Positive angles represent an ascending flight path.
     * @param groundspeed The groundspeed, in knots.
     * @returns The vertical speed required to maintain the specified flight path angle and groundspeed.
     */
    static getVerticalSpeedFromFpa(fpa, groundspeed) {
        return UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT) * Math.tan(fpa * Avionics.Utils.DEG2RAD);
    }
    /**
     * Gets the equivalent flight path angle for a given vertical speed and groundspeed. For this calculation, positive
     * flight path angles represent an ascending flight path.
     * @param vs The vertical speed, in feet per minute.
     * @param groundspeed The groundspeed, in knots.
     * @returns The flight path angle equivalent to the specified vertical speed and ground speed.
     */
    static getFpaFromVerticalSpeed(vs, groundspeed) {
        return this.getFpa(UnitType.NMILE.convertTo(groundspeed / 60, UnitType.FOOT), vs);
    }
    /**
     * Gets the flight path angle required to travel a given lateral distance and altitude. Positive flight path angles
     * represent an ascending flight path. By convention, the flight path angle required to travel zero altitude equals
     * zero degrees for all distances.
     * @param distance The lateral distance to travel, in the same units as `altitude`.
     * @param altitude The altitude to travel, in the same units as `distance`.
     * @returns The flight path angle, in degrees, required to travel the specified altitude and distance.
     */
    static getFpa(distance, altitude) {
        if (altitude === 0) {
            return 0;
        }
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
    /**
     * Gets the change in altitude along a flight path angle for a given lateral distance traveled.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param distance The lateral distance traveled.
     * @returns The change in altitude along the specified flight path angle for the specified lateral distance traveled,
     * expressed in the same units as `distance`.
     */
    static altitudeForDistance(fpa, distance) {
        return Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN)) * distance;
    }
    /**
     * Gets the lateral distance traveled along a flight path angle for a given change in altitude.
     * @param fpa The flight path angle, in degrees. Positive values represent an ascending flight path.
     * @param altitude The change in the altitude.
     * @returns The lateral distance traveled along the specified flight path angle for the specified change in altitude,
     * expressed in the same units as `altitude`.
     */
    static distanceForAltitude(fpa, altitude) {
        return altitude / Math.tan(UnitType.DEGREE.convertTo(fpa, UnitType.RADIAN));
    }
    /**
     * Gets the missed approach leg index.
     * @param plan The flight plan.
     * @returns The Destination leg global leg index.
     */
    static getMissedApproachLegIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    return l;
                }
            }
        }
        return Math.max(0, plan.length - 1);
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan.
     */
    static getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Finds and returns the FAF index in the plan.
     * @param lateralPlan The lateral flight plan.
     * @param iterator The FlightPlanLegIterator instance.
     * @returns The FAF index in the lateral flight plan.
     */
    static getFafIndexReverse(lateralPlan, iterator) {
        let fafIndex = -1;
        iterator.iterateReverse(lateralPlan, cursor => {
            if (fafIndex === -1 && cursor.legDefinition && (cursor.legDefinition.leg.fixTypeFlags & FixTypeFlags.FAF)) {
                fafIndex = cursor.legIndex + cursor.segment.offset;
            }
        });
        fafIndex = fafIndex > -1 ? fafIndex : fafIndex = Math.max(0, lateralPlan.length - 1);
        return fafIndex;
    }
    /**
     * Gets the index of the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint that contains the specified flight plan leg, or `-1` if one could not
     * be found.
     */
    static getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
            if (verticalPlan.constraints[c].index >= globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint that contains the specified flight plan leg, or `undefined` if one could not be
     * found.
     */
    static getConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets the index of the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The index of the VNAV constraint immediately prior to the constraint that contains the specified flight
     * plan leg, or `-1` if one could nto be found.
     */
    static getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex) {
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            if (verticalPlan.constraints[c].index < globalLegIndex) {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint immediately prior to the constraint that contains a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the flight plan leg.
     * @returns The VNAV constraint immediately prior to the constraint that contains the specified flight plan leg, or
     * `undefined` if one could nto be found.
     */
    static getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex) {
        return verticalPlan.constraints[VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex)];
    }
    /**
     * Gets and returns whether the input leg index is a path end.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex is the global leg index to check.
     * @returns whether the input leg index is a path end.
     */
    static getIsPathEnd(verticalPlan, globalLegIndex) {
        const constraintIndex = verticalPlan.constraints.findIndex(c => c.index === globalLegIndex);
        if (constraintIndex > -1 && verticalPlan.constraints[constraintIndex].isPathEnd) {
            return true;
        }
        return false;
    }
    /**
     * Gets the global leg index for the constraint containing an indexed leg.
     * @param verticalPlan The vertical plan.
     * @param globalLegIndex A global leg index.
     * @returns The global leg index for the constraint containing the leg at the specified global index, or -1 if one
     * could not be found.
     */
    static getConstraintLegIndexFromLegIndex(verticalPlan, globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.getConstraintFromLegIndex(verticalPlan, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1;
    }
    /**
     * Gets a constraint segment distance from the constraint legs.
     * @param constraint The constraint to calculate a distance for.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromConstraint(constraint) {
        let distance = 0;
        for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
            distance += constraint.legs[legIndex].distance;
        }
        return distance;
    }
    /**
     * Gets a constraint segment distance from the Vertical Plan legs.
     * @param constraint The constraint to calculate a distance for.
     * @param previousConstraint The constraint that preceds the constraint we are calculating the distance for.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns The constraint distance, in meters.
     */
    static getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan) {
        let distance = 0;
        const startGlobalIndex = previousConstraint !== undefined ? previousConstraint.index + 1 : 0;
        for (let i = startGlobalIndex; i <= constraint.index; i++) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, i);
            distance += verticalLeg.distance;
        }
        return distance;
    }
    /**
     * Gets the distance from the current location in the plan to the constraint.
     * @param constraint The vnav constraint to calculate the distance to.
     * @param lateralPlan The lateral flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The current distance along leg.
     * @returns the distance to the constraint, or positive infinity if a discontinuity exists between the ppos and the constraint.
     */
    static getDistanceToConstraint(constraint, lateralPlan, activeLegIndex, distanceAlongLeg) {
        if (activeLegIndex > constraint.index) {
            return 0;
        }
        let distance = 0;
        let index = activeLegIndex;
        for (const leg of lateralPlan.legs(false, activeLegIndex)) {
            if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type)) {
                return Number.POSITIVE_INFINITY;
            }
            else if (leg.calculated !== undefined) {
                distance += leg.calculated.distanceWithTransitions;
            }
            if (++index > constraint.index) {
                break;
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets VNAV Constraint Details from a constraint.
     * @param constraint The constraint to get details from.
     * @param out The object to which write the results.
     * @returns The VNav Constraint Details.
     */
    static getConstraintDetails(constraint, out) {
        if (constraint.maxAltitude === constraint.minAltitude) {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        else if (constraint.maxAltitude < Number.POSITIVE_INFINITY || constraint.minAltitude > Number.NEGATIVE_INFINITY) {
            switch (constraint.type) {
                case 'climb':
                case 'missed':
                    if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    break;
                default:
                    if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                        out.type = AltitudeRestrictionType.AtOrAbove;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
                    }
                    else {
                        out.type = AltitudeRestrictionType.AtOrBelow;
                        out.altitude = Math.round(UnitType.METER.convertTo(constraint.maxAltitude, UnitType.FOOT));
                    }
            }
        }
        else {
            out.type = AltitudeRestrictionType.At;
            out.altitude = Math.round(UnitType.METER.convertTo(constraint.minAltitude, UnitType.FOOT));
        }
        return out;
    }
    /**
     * Gets and returns the vertical direct constraint based on an input index.
     * @param verticalPlan The vertical flight plan.
     * @param selectedGlobalLegIndex The global leg index selected for vertical direct.
     * @param activeLegIndex The active leg index.
     * @returns The Vnav Constraint for the vertical direct or undefined.
     */
    static getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeLegIndex) {
        if (verticalPlan.constraints.length > 0) {
            if (selectedGlobalLegIndex < activeLegIndex) {
                return VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLegIndex);
            }
            for (let c = verticalPlan.constraints.length - 1; c >= 0; c--) {
                const constraint = verticalPlan.constraints[c];
                if (constraint.index === selectedGlobalLegIndex || (c === verticalPlan.constraints.length - 1 && selectedGlobalLegIndex < constraint.index)) {
                    return constraint;
                }
                else if (c < verticalPlan.constraints.length - 1 && constraint.index > selectedGlobalLegIndex) {
                    return verticalPlan.constraints[c + 1];
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the index of the next descent constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next descent constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextDescentConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next climb constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next climb constraint at or after the specified flight plan leg, or `-1` if one could
     * not be found.
     */
    static getNextClimbConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'climb') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the index of the next missed approach constraint at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The index of the next missed approach constraint at or after the specified flight plan leg, or `-1` if
     * one could not be found.
     */
    static getNextMaprConstraintIndex(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed') {
                return c;
            }
        }
        return -1;
    }
    /**
     * Gets the next descent constraint with a defined minimum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint with a defined minimum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextDescentTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if ((constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') && constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next descent constraint minimum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next descent constraint defined minimum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextDescentTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.minAltitude : undefined;
    }
    /**
     * Gets the next climb constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint with a defined maximum altitude at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint) {
            if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return currentConstraint;
            }
            else if (currentConstraint.type === 'climb' && currentConstraint.maxAltitude === Number.POSITIVE_INFINITY) {
                const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const lastIndexToCheck = verticalPlan.firstDescentConstraintLegIndex !== undefined ?
                    VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex) : 0;
                for (let c = currentConstraintIndex - 1; c >= lastIndexToCheck; c--) {
                    const constraint = verticalPlan.constraints[c];
                    if (constraint.type === 'climb' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                        return constraint;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the current climb constraint, if one exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The current climb constraint, or `undefined` if no such constraint exists.
     */
    static getCurrentClimbConstraint(verticalPlan, globalLegIndex) {
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint && currentConstraint.type === 'climb') {
            return currentConstraint;
        }
        return undefined;
    }
    /**
     * Gets the next climb constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next climb constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextClimbTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextClimbTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the next missed approach constraint with a defined maximum altitude at or after a flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint with a defined maximum altitude at or after the specified flight
     * plan leg, or `undefined` if no such constraint exists.
     */
    static getNextMaprTargetConstraint(verticalPlan, globalLegIndex) {
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
        for (let c = currentConstraintIndex; c >= 0; c--) {
            const constraint = verticalPlan.constraints[c];
            if (constraint.type === 'missed' && constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                return constraint;
            }
        }
        return undefined;
    }
    /**
     * Gets the next missed approach constraint maximum altitude at or after a flight plan leg, or undefined if none exists.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the flight plan leg to find the constraint for.
     * @returns The next missed approach constraint defined maximum altitude in meters at or after the specified flight plan leg, or
     * `undefined` if no such constraint exists.
     */
    static getNextMaprTargetAltitude(verticalPlan, globalLegIndex) {
        const constraint = VNavUtils.getNextMaprTargetConstraint(verticalPlan, globalLegIndex);
        return constraint !== undefined ? constraint.maxAltitude : undefined;
    }
    /**
     * Gets the VNAV desired altitude.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index to get the target for.
     * @param distanceAlongLeg The distance along the leg the aircraft is presently.
     * @returns The current VNAV desired altitude.
     */
    static getDesiredAltitude(verticalPlan, globalLegIndex, distanceAlongLeg) {
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (priorConstraint && priorConstraint.nextVnavEligibleLegIndex && globalLegIndex < priorConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint.targetAltitude;
        }
        const leg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
        return leg.altitude + VNavUtils.altitudeForDistance(leg.fpa, leg.distance - distanceAlongLeg);
    }
    /**
     * Gets and returns the FAF altitude.
     * @param verticalPlan The vertical flight plan.
     * @returns the FAF constraint altitude.
     */
    static getFafAltitude(verticalPlan) {
        if (verticalPlan.fafLegIndex !== undefined) {
            return VNavUtils.getVerticalLegFromPlan(verticalPlan, verticalPlan.fafLegIndex).altitude;
        }
        return undefined;
    }
    /**
     * Gets the VNAV TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    static getTodBodDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentAltitude, currentVS, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.distanceFromBod = 0;
        out.currentConstraintLegIndex = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active constraint contains a VNAV-ineligible leg after the active leg.
            || ((activeConstraint === null || activeConstraint === void 0 ? void 0 : activeConstraint.nextVnavEligibleLegIndex) !== undefined && activeConstraint.nextVnavEligibleLegIndex > activeLegIndex)) {
            return out;
        }
        out.currentConstraintLegIndex = activeConstraint.index;
        // Find the next BOD, which will be at the end of the earliest non-flat descent constraint subsequent to and
        // including the active constraint that ends in a level-off at a lower altitude than the aircraft's current
        // altitude. Note that we are guaranteed to not go through a VNAV discontinuity, since all constraints that end in
        // a discontinuity also end in a level-off.
        // lag altitude by ~3 seconds so that we aren't continuously pushing TOD in front of the plane while descending.
        const altitude = currentAltitude - currentVS / 20;
        let bodConstraintIndex, bodConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            if (constraint.fpa > 0 && ((_a = constraint.legs[0]) === null || _a === void 0 ? void 0 : _a.isBod) && constraint.targetAltitude <= altitude) {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            return out;
        }
        out.bodLegIndex = bodConstraint.index;
        // Find the TOD associated with the BOD. To do this, we need to first find the earliest non-flat descent constraint
        // between the active constraint and the BOD constraint (inclusive) that is connected to the BOD constraint with no
        // intervening flat constraints or VNAV path discontinuities and whose target altitude less than the aircraft's
        // current altitude.
        let todConstraintIndex = bodConstraintIndex;
        for (let i = todConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const prevConstraint = verticalPlan.constraints[i + 1];
            if (!prevConstraint
                || prevConstraint.index < activeLegIndex
                || prevConstraint.type === 'climb'
                || prevConstraint.type === 'missed'
                || prevConstraint.targetAltitude > altitude
                || prevConstraint.fpa <= 0
                || prevConstraint.isPathEnd) {
                todConstraintIndex = i;
                break;
            }
        }
        const todConstraint = verticalPlan.constraints[todConstraintIndex];
        // Now that we have found the TOD constraint, we need to find the TOD leg: the leg on which the TOD actually lies.
        // To do this, we calculate the along-track distance from the end of the TOD constraint to the TOD, then iterate
        // through the legs in the constraint backwards while keeping track of the total along-track distance covered by
        // each leg.
        let distance = VNavUtils.distanceForAltitude(todConstraint.fpa, altitude - todConstraint.targetAltitude);
        let constraintIndex = todConstraintIndex;
        let todLegIndex = todConstraint.index;
        let todLegDistance = 0;
        let todLeg = todConstraint.legs[0];
        while (distance > 0 && constraintIndex < verticalPlan.constraints.length) {
            const constraint = verticalPlan.constraints[constraintIndex];
            // Remember that flight plan legs in a VNAV constraint appear in reverse order relative to how they are ordered
            // in the flight plan.
            for (let i = 0; i < constraint.legs.length; i++) {
                if (!constraint.legs[i].isEligible) {
                    // We've encounted a VNAV-ineligible leg. Since we cannot calculate a vertical path through this leg, we have
                    // to stop iterating now so that the TOD gets set to the most recent VNAV-eligible leg.
                    constraintIndex = verticalPlan.constraints.length;
                    break;
                }
                todLeg = constraint.legs[i];
                distance -= todLeg.distance;
                if (distance <= 0) {
                    todLegIndex = constraint.index - i;
                    todLegDistance = todLeg.distance + distance;
                    break;
                }
            }
            constraintIndex++;
        }
        if (distance > 0) {
            // If we still haven't found the TOD yet, set it to the beginning of the earliest VNAV leg that was iterated.
            todLegIndex = verticalPlan.segments[todLeg.segmentIndex].offset + todLeg.legIndex;
            todLegDistance = todLeg.distance;
        }
        out.todLegIndex = todLegIndex;
        out.todLegDistance = todLegDistance;
        // calculate distance to TOD/BOD
        let globalLegIndex = bodConstraint.index;
        let distanceToBOD = 0, distanceToTOD = 0;
        let hasReachedTOD = false;
        let isDone = false;
        for (let i = bodConstraintIndex; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            for (let j = 0; j < constraint.legs.length; j++) {
                const leg = constraint.legs[j];
                if (globalLegIndex === todLegIndex) {
                    distanceToTOD -= todLegDistance;
                    hasReachedTOD = true;
                }
                if (globalLegIndex > activeLegIndex) {
                    distanceToBOD += leg.distance;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance;
                    }
                }
                else if (globalLegIndex === activeLegIndex) {
                    distanceToBOD += leg.distance - distanceAlongLeg;
                    if (hasReachedTOD) {
                        distanceToTOD += leg.distance - distanceAlongLeg;
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= distanceAlongLeg;
                    }
                }
                else {
                    if (hasReachedTOD) {
                        isDone = true;
                    }
                    else {
                        distanceToTOD -= leg.distance;
                    }
                }
                if (isDone) {
                    break;
                }
                else {
                    globalLegIndex--;
                }
            }
            if (isDone) {
                break;
            }
        }
        out.distanceFromBod = distanceToBOD;
        out.distanceFromTod = distanceToTOD;
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC details.
     */
    static getTocBocDetails(verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, out) {
        var _a, _b;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        const activeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, activeLegIndex);
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no BOC/TOC if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... the active VNAV constraint is not a climb-type constraint.
            || (activeConstraint.type !== 'climb' && activeConstraint.type !== 'missed')) {
            return out;
        }
        // Find the TOC. To do this, we need to first find the earliest climb constraint subsequent to and including the
        // active constraint that has a maximum altitude (i.e. is an AT, AT OR BELOW, or BETWEEN constraint). Additionally,
        // the TOC must not be separated from the active constraint by a descent-type constraint.
        let tocConstraintIndex, tocConstraint;
        for (let i = activeConstraintIndex; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (isFinite(constraint.maxAltitude)) {
                tocConstraintIndex = i;
                tocConstraint = constraint;
                break;
            }
        }
        // If there is no next TOC, there also can be no next BOC since the next BOC must follow the next TOC.
        if (!tocConstraint) {
            return out;
        }
        out.tocConstraintIndex = tocConstraintIndex;
        out.tocAltitude = tocConstraint.maxAltitude;
        // Calculate distance to TOC.
        const deltaAltitude = tocConstraint.maxAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies.
        const activeLeg = activeConstraint.legs[activeConstraint.index - activeLegIndex];
        let tocLegIndex;
        let currentConstraintIndex = activeConstraintIndex;
        let currentConstraint;
        let currentConstraintLegIndex = activeConstraint.index - activeLegIndex;
        let currentLeg = activeLeg;
        const activeLegDistanceRemaining = ((_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _a !== void 0 ? _a : 0) - distanceAlongLeg;
        if (distanceRemaining > activeLegDistanceRemaining) {
            distanceRemaining -= activeLegDistanceRemaining;
            if (currentConstraintLegIndex <= 0) {
                --currentConstraintIndex;
            }
            else {
                currentLeg = activeConstraint.legs[--currentConstraintLegIndex];
            }
            while (currentConstraintIndex >= tocConstraintIndex) {
                currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                currentLeg = currentConstraint.legs[currentConstraintLegIndex];
                if (currentLeg !== undefined) {
                    if (distanceRemaining > currentLeg.distance) {
                        out.distanceFromToc += currentLeg.distance;
                        distanceRemaining -= currentLeg.distance;
                    }
                    else {
                        out.distanceFromToc += distanceRemaining;
                        tocLegIndex = currentConstraint.index - currentConstraintLegIndex;
                        distanceRemaining -= currentLeg.distance;
                        break;
                    }
                }
                if (currentConstraintLegIndex <= 0) {
                    --currentConstraintIndex;
                }
                else {
                    currentLeg = currentConstraint.legs[--currentConstraintLegIndex];
                }
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last leg of the TOC constraint.
            out.tocLegIndex = tocConstraint.index;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        // Find the next BOC, which is located at the beginning of the earliest climb constraint subsequent to (and not
        // including) the TOC constraint with a maximum altitude greater than the TOC constraint. Additionally, the BOC
        // must not be separated from the TOC constraint by a descent-type constraint.
        let lastClimbConstraintIndex = tocConstraintIndex;
        let bocConstraintIndex, bocConstraint;
        for (let i = tocConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a descent constraint, immediately terminate the search.
            if (constraint.type !== 'climb' && constraint.type !== 'missed') {
                break;
            }
            if (constraint.maxAltitude > tocConstraint.maxAltitude) {
                bocConstraintIndex = i;
                bocConstraint = constraint;
                break;
            }
            lastClimbConstraintIndex = i;
        }
        let bocDistanceStopConstraintIndex = undefined;
        if (bocConstraint) {
            out.bocLegIndex = bocConstraint.index - (bocConstraint.legs.length - 1);
            bocDistanceStopConstraintIndex = bocConstraintIndex;
        }
        else {
            // If we did not find a climb constraint subsequent to the TOC constraint with a maximum altitude greater than the
            // the TOC constraint, then the BOC will be located at the last climb constraint.
            const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
            if (lastClimbConstraint && lastClimbConstraint.index + 1 < verticalPlan.length) {
                out.bocLegIndex = lastClimbConstraint.index + 1;
                bocDistanceStopConstraintIndex = lastClimbConstraintIndex - 1;
            }
        }
        // Calculate distance to BOC
        if (bocDistanceStopConstraintIndex !== undefined) {
            let distanceToEndOfActiveConstraint = ((_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.distance) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
            for (let i = Math.min(activeConstraint.index - activeLegIndex, activeConstraint.legs.length) - 1; i >= 0; i--) {
                distanceToEndOfActiveConstraint += activeConstraint.legs[i].distance;
            }
            out.distanceFromBoc = distanceToEndOfActiveConstraint;
            for (let i = activeConstraintIndex - 1; i > bocDistanceStopConstraintIndex; i--) {
                out.distanceFromBoc += verticalPlan.constraints[i].distance;
            }
        }
        return out;
    }
    /**
     * Gets the VNAV TOC/BOC to cruise altitude details for a vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param activeLegIndex The current active leg index.
     * @param distanceAlongLeg The distance the plane is along the current leg in meters.
     * @param currentGroundSpeed The current ground speed, in knots.
     * @param currentAltitude The current indicated altitude in meters.
     * @param currentVS The current vertical speed in meters per minute.
     * @param cruiseAltitude The cruise altitude, in meters.
     * @param out The object to which to write the TOC/BOC details.
     * @returns The VNAV TOC/BOC to cruise altitude details.
     */
    static getCruiseTocBocDetails(lateralPlan, verticalPlan, activeLegIndex, distanceAlongLeg, currentGroundSpeed, currentAltitude, currentVS, cruiseAltitude, out) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        out.bocLegIndex = -1;
        out.tocLegIndex = -1;
        out.tocLegDistance = 0;
        out.distanceFromBoc = 0;
        out.distanceFromToc = 0;
        out.tocConstraintIndex = -1;
        out.tocAltitude = -1;
        // Find the last climb constraint
        const lastClimbConstraintIndex = VNavUtils.getLastClimbConstraintIndex(verticalPlan);
        const lastClimbConstraint = verticalPlan.constraints[lastClimbConstraintIndex];
        const firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        // If the active leg is past the first descent constraint, both cruise BOC and cruise TOC are undefined.
        if (firstDescentConstraint && activeLegIndex > firstDescentConstraint.index) {
            return out;
        }
        const activeLeg = lateralPlan.tryGetLeg(activeLegIndex);
        const activeLegDistanceRemaining = ((_b = (_a = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0) - distanceAlongLeg;
        // Cruise BOC will always be located at the beginning of the first leg after the last climb constraint. If there
        // are no climb constraints in the plan, then cruise BOC is undefined.
        if (lastClimbConstraint && lastClimbConstraint.index < lateralPlan.length - 1 && activeLegIndex <= lastClimbConstraint.index) {
            const lastClimbConstraintLeg = lateralPlan.tryGetLeg(lastClimbConstraint.index);
            out.bocLegIndex = lastClimbConstraint.index + 1;
            out.distanceFromBoc = activeLegDistanceRemaining
                + ((_d = (_c = lastClimbConstraintLeg === null || lastClimbConstraintLeg === void 0 ? void 0 : lastClimbConstraintLeg.calculated) === null || _c === void 0 ? void 0 : _c.cumulativeDistanceWithTransitions) !== null && _d !== void 0 ? _d : 0) - ((_f = (_e = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0);
        }
        // Calculate distance to TOC.
        const deltaAltitude = cruiseAltitude - currentAltitude;
        const timeToTocMin = deltaAltitude / Math.max(0, currentVS);
        let distanceRemaining = currentGroundSpeed === 0 ? 0 : timeToTocMin * UnitType.KNOT.convertTo(currentGroundSpeed, UnitType.MPM);
        // Find the leg on which the TOC lies. The TOC is restricted to legs prior to the first descent constraint.
        let tocLegIndex;
        const lastLegIndex = (_g = firstDescentConstraint === null || firstDescentConstraint === void 0 ? void 0 : firstDescentConstraint.index) !== null && _g !== void 0 ? _g : lateralPlan.length - 1;
        if (distanceRemaining > activeLegDistanceRemaining) {
            let legIndex = activeLegIndex + 1;
            for (const leg of lateralPlan.legs(false, legIndex, lastLegIndex + 1)) {
                const legDistance = (_j = (_h = leg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                if (distanceRemaining > legDistance) {
                    out.distanceFromToc += legDistance;
                    distanceRemaining -= legDistance;
                }
                else {
                    out.distanceFromToc += distanceRemaining;
                    tocLegIndex = legIndex;
                    distanceRemaining -= legDistance;
                    break;
                }
                legIndex++;
            }
        }
        else {
            out.distanceFromToc = distanceRemaining;
            tocLegIndex = activeLegIndex;
            distanceRemaining -= activeLegDistanceRemaining;
        }
        if (tocLegIndex === undefined) {
            // If we still haven't found the TOC yet, set it to the end of the last viable leg.
            out.tocLegIndex = lastLegIndex;
            out.tocLegDistance = 0;
        }
        else {
            out.tocLegIndex = tocLegIndex;
            out.tocLegDistance = -distanceRemaining;
        }
        out.tocAltitude = cruiseAltitude;
        return out;
    }
    /**
     * Checks whether or not the vertical plan has a leg at a given globalLegIndex.
     * @param verticalPlan The Vertical Flight Plan.
     * @param globalLegIndex The global leg index to check.
     * @returns True if the leg exists.
     */
    static verticalPlanHasLeg(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset] !== undefined;
            }
        }
        return false;
    }
    /**
     * Gets a VNAV leg from a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global leg index of the leg to get.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromPlan(verticalPlan, globalLegIndex) {
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            if (segment !== undefined && globalLegIndex >= segment.offset && globalLegIndex < segment.offset + segment.legs.length) {
                return segment.legs[globalLegIndex - segment.offset];
            }
        }
        throw new Error(`Leg with index ${globalLegIndex} not found`);
    }
    /**
     * Gets a VNAV leg from the plan from a specified segment.
     * @param verticalPlan The vertical flight plan.
     * @param segmentIndex The segment index of the leg to get.
     * @param legIndex The index of the leg to get within the specified segment.
     * @returns The requested VNAV leg.
     * @throws Not found if the index is not valid.
     */
    static getVerticalLegFromSegmentInPlan(verticalPlan, segmentIndex, legIndex) {
        const segment = verticalPlan.segments[segmentIndex];
        const leg = segment.legs[legIndex];
        if (segment && leg) {
            return leg;
        }
        else {
            throw new Error(`Leg from vertical plan ${verticalPlan.planIndex} segment ${segmentIndex} index ${legIndex} not found`);
        }
    }
    /**
     * Gets the constraint for a vertical direct based on an input global leg index.
     * @param verticalPlan The vertical flight plan.
     * @param activeGlobalLegIndex The current active global leg index.
     * @param selectedGlobalLegIndex The input global leg index selected.
     * @returns The constraint, or undefined if none exists.
     */
    static getConstraintForVerticalDirect(verticalPlan, activeGlobalLegIndex, selectedGlobalLegIndex) {
        return VNavUtils.getVerticalDirectConstraintFromIndex(verticalPlan, selectedGlobalLegIndex, activeGlobalLegIndex);
    }
    /**
     * Gets the VNAV segments from the calculated VNAV plan.
     * @param verticalPlan The vertical flight plan.
     * @returns The vnav segments.
     * @throws Not found if the index is not valid.
     */
    static getVerticalSegmentsFromPlan(verticalPlan) {
        return verticalPlan.segments;
    }
    /**
     * Gets whether a lateral plan leg is a hold or procedure turn.
     * @param lateralLeg The Lateral Leg in the flight plan (LegDefinition).
     * @returns Whether the leg is a hold or procedure turn.
     */
    static isLegTypeHoldOrProcedureTurn(lateralLeg) {
        if (lateralLeg.leg !== undefined) {
            switch (lateralLeg.leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    return true;
            }
        }
        return false;
    }
    /**
     * Creates a new empty vertical flight plan constraint.
     * @param index The leg index of the constraint.
     * @param minAltitude The bottom altitude of the constraint.
     * @param maxAltitude THe top altitude of the constraint.
     * @param name The name of the leg for the constraint.
     * @param type The type of constraint.
     * @returns A new empty constraint.
     */
    static createConstraint(index, minAltitude, maxAltitude, name, type = 'descent') {
        return {
            index,
            minAltitude,
            maxAltitude,
            targetAltitude: 0,
            name,
            isTarget: false,
            isPathEnd: false,
            distance: 0,
            fpa: 0,
            legs: [],
            type,
            isBeyondFaf: false
        };
    }
    /**
     * Creates a new vertical flight plan leg.
     * @param segmentIndex The segment index for the leg.
     * @param legIndex The index of the leg within the segment.
     * @param name The name of the leg.
     * @param distance The leg distance.
     * @returns A new VNAV plan leg.
     */
    static createLeg(segmentIndex, legIndex, name, distance = 0) {
        return {
            segmentIndex,
            legIndex,
            fpa: 0,
            altitude: 0,
            isUserDefined: false,
            isDirectToTarget: false,
            distance: distance,
            isEligible: true,
            isBod: false,
            isAdvisory: true,
            name
        };
    }
    /**
     * Finds the index of the first climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getFirstClimbConstraintIndex(verticalPlan) {
        for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the last climb constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last climb constraint in the specified vertical plan, or `-1` if the plan has no
     * climb constraints.
     */
    static getLastClimbConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            if (verticalPlan.constraints[i].type === 'climb') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Finds the index of the first descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the first descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getFirstDescentConstraintIndex(verticalPlan) {
        let index = -1;
        for (let c = 0; c < verticalPlan.constraints.length; c++) {
            const type = verticalPlan.constraints[c].type;
            if (type === 'descent' || type === 'manual') {
                index = c;
            }
            if (type === 'direct') {
                return c;
            }
        }
        return index;
    }
    /**
     * Finds the index of the last descent constraint in a vertical plan.
     * @param verticalPlan A vertical flight plan.
     * @returns The index of the last descent constraint in the specified vertical plan, or `-1` if the plan has no
     * descent constraints.
     */
    static getLastDescentConstraintIndex(verticalPlan) {
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const type = verticalPlan.constraints[i].type;
            if (type === 'descent' || type === 'direct' || type === 'manual') {
                return i;
            }
        }
        return -1;
    }
    /**
     * Checks whether two speed constraints are equal.
     * @param a The first speed constraint.
     * @param b The second speed constraint.
     * @returns Whether the two speed constraints are equal.
     */
    static speedConstraintEquals(a, b) {
        return a.speedDesc === b.speedDesc && a.speed === b.speed && a.speedUnit === b.speedUnit;
    }
    /**
     * Checks whether two altitude constraint details are equal.
     * @param a The first altitude constraint details.
     * @param b The second altitude constraint details.
     * @returns Whether the two altitude constraint details are equal.
     */
    static altitudeConstraintDetailsEquals(a, b) {
        return a.type === b.type && a.altitude === b.altitude;
    }
    /**
     * Checks whether two speed constraint details are equal.
     * @param a The first speed constraint details.
     * @param b The second speed constraint details.
     * @returns Whether the two speed constraint details are equal.
     */
    static speedConstraintDetailsEquals(a, b) {
        return a.distanceToNextSpeedConstraint === b.distanceToNextSpeedConstraint
            && VNavUtils.speedConstraintEquals(a.currentSpeedConstraint, b.currentSpeedConstraint)
            && VNavUtils.speedConstraintEquals(a.nextSpeedConstraint, b.nextSpeedConstraint);
    }
    /**
     * Computes the path error distance that should be used given the groundspeed.
     * @param groundSpeed The current groundspeed, in knots.
     * @returns The path error distance to use.
     */
    static getPathErrorDistance(groundSpeed) {
        if (groundSpeed <= 190) {
            return 100;
        }
        else if (groundSpeed >= 210) {
            return 250;
        }
        else {
            return 100 + (((groundSpeed - 190) / 20) * 150);
        }
    }
}

/**
 * An autopilot driver to set pitch and bank values in the sim AP.
 *
 * This driver follows the sim's convention for negative and positive values:
 * AUTOPILOT BANK HOLD REF/PLANE BANK DEGREES: negative = right, positive = left
 * AUTOPILOT PITCH HOLD REF/PLANE PITCH DEGREES: negative = up, positive = down
 * INCIDENCE ALPHA: negative = down, positive = up
 * AMBIENT WIND Y: negative = down, positive = up
 */
class AutopilotDriver {
    /**
     * Creates an instance of this Autopilot Driver.
     * @param bus An instance of the Event Bus.
     * @param apValues Autopilot values from this driver's parent autopilot.
     * @param apMasterOn Whether the AP is engaged.
     * @param options Options for this driver.
     */
    constructor(bus, apValues, apMasterOn, options) {
        var _a, _b, _c;
        this.apValues = apValues;
        this.apMasterOn = apMasterOn;
        this.currentPitchRef = 0;
        this.currentBankRef = 0;
        this.rudderBankFactor = 0.3;
        this.maxRudderDeflection = 25;
        this.autoCoordinationEnabled = false;
        this.rudderSet = 0;
        this.verticalWindSmoother = new ExpSmoother(AutopilotDriver.VERTICAL_WIND_SMOOTHING_TAU);
        this.verticalWindAverageValue = 0;
        this.onGround = ConsumerSubject.create(null, true);
        this.raHeight = ConsumerValue.create(null, null);
        if (options === null || options === void 0 ? void 0 : options.setInternalFlightDirector) {
            this.fdPublisher = bus.getPublisher();
        }
        this.pitchServoRate = (_a = options === null || options === void 0 ? void 0 : options.pitchServoRate) !== null && _a !== void 0 ? _a : AutopilotDriver.PITCH_SERVO_RATE;
        this.pitchServo = new LinearServo(this.pitchServoRate);
        this.currentPitchRef = SimVar.GetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree);
        this.bankServoRate = (_b = options === null || options === void 0 ? void 0 : options.bankServoRate) !== null && _b !== void 0 ? _b : AutopilotDriver.BANK_SERVO_RATE;
        this.bankServo = new LinearServo(this.bankServoRate);
        this.currentBankRef = SimVar.GetSimVarValue('AUTOPILOT BANK HOLD REF', SimVarValueType.Degree);
        if (options === null || options === void 0 ? void 0 : options.autoCoordinationEnabled) {
            if (options.rudderBankFactor !== undefined) {
                this.rudderBankFactor = options.rudderBankFactor;
            }
            if (options.maxRudderDeflection !== undefined) {
                this.maxRudderDeflection = options.maxRudderDeflection;
            }
            this.autoCoordinationEnabled = true;
            this.onGround.setConsumer(bus.getSubscriber().on('on_ground'));
            this.raHeight.setConsumer(bus.getSubscriber().on('radio_alt'));
            this.apMasterOn.sub(isOn => {
                if (!isOn) {
                    this.resetRudder();
                }
            });
            this.onGround.sub(onGround => {
                if (onGround) {
                    this.resetRudder();
                }
            });
        }
        if (options === null || options === void 0 ? void 0 : options.zeroRollHeight) {
            this.zeroRollHeight = options.zeroRollHeight;
        }
        this.rudderServoRate = ((_c = options === null || options === void 0 ? void 0 : options.rudderServoRate) !== null && _c !== void 0 ? _c : AutopilotDriver.RUDDER_SERVO_RATE) / this.maxRudderDeflection * 16384;
        this.rudderServo = new LinearServo(this.rudderServoRate);
        this.apValues.simRate.sub(this.onSimRateChanged.bind(this), true);
    }
    /**
     * Responds to when the simulation rate changes.
     * @param simRate The new simulation rate.
     */
    onSimRateChanged(simRate) {
        this.pitchServo.rate = this.pitchServoRate * simRate;
        this.bankServo.rate = this.bankServoRate * simRate;
        this.rudderServo.rate = this.rudderServoRate * simRate;
    }
    /**
     * Update loop to keep Ambient Wind Y constantly updated.
     */
    update() {
        const verticalWind = SimVar.GetSimVarValue('AMBIENT WIND Y', SimVarValueType.FPM);
        const time = Date.now();
        if (this._lastVerticalWindTime === undefined) {
            this.verticalWindAverageValue = this.verticalWindSmoother.reset(verticalWind);
        }
        else {
            this.verticalWindAverageValue = this.verticalWindSmoother.next(verticalWind, time - this._lastVerticalWindTime);
        }
        this._lastVerticalWindTime = time;
        if (this.autoCoordinationEnabled && this.apMasterOn.get() === true && this.onGround.get() === false) {
            this.manageAutoRudder();
        }
    }
    /**
     * Drives the commanded autopilot bank angle toward a desired value using a linear servo.
     * @param bank The desired bank angle, in degrees. Positive values indicate left bank.
     * @param rate The rate at which to drive the commanded bank angle, in degrees per second. Defaults to the bank
     * servo's default rate.
     */
    driveBank(bank, rate) {
        if (isFinite(bank)) {
            const currentTime = Date.now();
            if (this._lastBankSetTime !== undefined) {
                const deltaTime = currentTime - this._lastBankSetTime;
                if (deltaTime > 1000) {
                    this.bankServo.reset();
                }
            }
            else {
                this.bankServo.reset();
            }
            this._lastBankSetTime = currentTime;
            this.setBank(this.bankServo.drive(this.currentBankRef, bank, currentTime, rate), false);
        }
        else {
            console.warn('AutopilotDriver: Non-finite bank angle was attempted to be set.');
        }
    }
    /**
     * Sets the commanded autopilot bank angle, in degrees.
     * @param bank The commanded bank angle, in degrees. Positive values indicate left bank.
     * @param resetServo Whether to reset the bank servo. Defaults to `true`.
     */
    setBank(bank, resetServo = true) {
        var _a;
        if (this.zeroRollHeight !== undefined) {
            const raHeight = this.raHeight.get();
            if (raHeight !== null && raHeight < this.zeroRollHeight) {
                bank = 0;
            }
        }
        if (isFinite(bank)) {
            this.currentBankRef = bank;
            SimVar.SetSimVarValue('AUTOPILOT BANK HOLD REF', SimVarValueType.Degree, this.currentBankRef);
            (_a = this.fdPublisher) === null || _a === void 0 ? void 0 : _a.pub('fd_target_bank', this.currentBankRef, true, true);
        }
        else {
            console.warn('AutopilotDriver: Non-finite bank angle was attempted to be set.');
        }
        if (resetServo) {
            this._lastBankSetTime = undefined;
        }
    }
    /**
     * Drives the commanded autopilot pitch angle toward a desired value using a linear servo while optionally correcting
     * for angle of attack and vertical wind.
     * @param pitch The desired pitch angle, in degrees. Positive values indicate downward pitch.
     * @param adjustForAoa Whether to adjust the commanded pitch angle for angle of attack. If `true`, the provided pitch
     * angle is treated as a desired flight path angle and a new commanded pitch angle will be calculated to produce the
     * desired FPA given the airplane's current angle of attack. This correction can be used in conjunction with the
     * vertical wind correction. Defaults to `false`.
     * @param adjustForVerticalWind Whether to adjust the commanded pitch angle for vertical wind velocity. If `true`,
     * the provided pitch angle is treated as a desired flight path angle and a new commanded pitch angle will be
     * calculated to produce the desired FPA given the current vertical wind component. This correction can be used in
     * conjunction with the angle of attack correction. Defaults to `false`.
     * @param rate The rate at which to drive the commanded pitch angle, in degrees per second. Defaults to the pitch
     * servo's default rate.
     */
    drivePitch(pitch, adjustForAoa = false, adjustForVerticalWind = false, rate) {
        if (isFinite(pitch)) {
            //pitch = -5 we want a 5 degree FPA up
            if (adjustForVerticalWind) {
                // with an updraft, we get a down correction value
                // if pitch were normal (+ === up), we would add the correction 5 + (-1) = 4 (pitch adjusted down because of updraft)
                // since pitch is actually inverse (- === up), we want to subtract the correction value -5 - (-1) = -4
                pitch -= this.getVerticalWindCorrection();
            }
            if (adjustForAoa) {
                // if we want to fly an FPA of +5 degrees, we need to add our AOA to our FPA for the desired pitch.
                // if our AOA is 1 degree, we want to set our pitch to 5 + 1 = 6 degrees to achieve a 5 degree FPA.
                // since pitch is inverse and AOA is not, we want to subtract the aoa value -5 - (+1) = -6 (6 degree up pitch)
                // if we are wanting to fly an FPA of -3 degrees, and our AOA is +1 degree, we would set +3 - (+1) = 2 (2 degree down pitch)
                pitch -= SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
            }
            const currentTime = Date.now();
            if (this._lastPitchSetTime !== undefined) {
                const deltaTime = currentTime - this._lastPitchSetTime;
                if (deltaTime > 1000) {
                    this.pitchServo.reset();
                }
            }
            else {
                this.pitchServo.reset();
            }
            this._lastPitchSetTime = currentTime;
            this.setPitch(this.pitchServo.drive(this.currentPitchRef, pitch, currentTime, rate), false);
        }
        else {
            console.warn('AutopilotDriver: Non-finite pitch angle was attempted to be set.');
        }
    }
    /**
     * Sets the commanded autopilot pitch angle, in degrees.
     * @param pitch The commanded pitch angle, in degrees. Positive values indicate downward pitch.
     * @param resetServo Whether to reset the pitch servo. Defaults to `true`.
     */
    setPitch(pitch, resetServo = true) {
        var _a;
        if (isFinite(pitch)) {
            this.currentPitchRef = pitch;
            SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD REF', SimVarValueType.Degree, this.currentPitchRef);
            (_a = this.fdPublisher) === null || _a === void 0 ? void 0 : _a.pub('fd_target_pitch', this.currentPitchRef, true, true);
        }
        else {
            console.warn('AutopilotDriver: Non-finite pitch angle was attempted to be set.');
        }
        if (resetServo) {
            this._lastPitchSetTime = undefined;
        }
    }
    /**
     * Gets the vertical wind correction in degrees.
     * @returns The vertical wind correction in degrees.
     */
    getVerticalWindCorrection() {
        // Wind correction FPA will be the FPA required to negate the vertical wind (so negative verticalWindAverageValue)
        return VNavUtils.getFpa(SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.FPM), -this.verticalWindAverageValue);
    }
    /**
     * Manages the Auto Rudder in Autopilot.
     */
    manageAutoRudder() {
        this.rudderSet = this.rudderServo.drive(this.rudderSet, (this.rudderBankFactor * this.currentBankRef / this.maxRudderDeflection) * 16384);
        SimVar.SetSimVarValue('K:AXIS_RUDDER_SET', SimVarValueType.Number, this.rudderSet);
    }
    /**
     * Resets the rudder to 0.
     */
    resetRudder() {
        SimVar.SetSimVarValue('K:AXIS_RUDDER_SET', SimVarValueType.Number, 0);
        this.rudderServo.reset();
    }
}
AutopilotDriver.PITCH_SERVO_RATE = 5; // degrees per second
AutopilotDriver.BANK_SERVO_RATE = 10; // degrees per second
AutopilotDriver.RUDDER_SERVO_RATE = 1; // degrees per second
AutopilotDriver.VERTICAL_WIND_SMOOTHING_TAU = 500 / Math.LN2;

/**
 * The current vertical navigation state.
 */
var VNavState;
(function (VNavState) {
    /** VNAV Disabled. */
    VNavState[VNavState["Disabled"] = 0] = "Disabled";
    /** VNAV Enabled and Inactive. */
    VNavState[VNavState["Enabled_Inactive"] = 1] = "Enabled_Inactive";
    /** VNAV Enabled and Active. */
    VNavState[VNavState["Enabled_Active"] = 2] = "Enabled_Active";
})(VNavState || (VNavState = {}));
/**
 * The current VNAV path mode.
 */
var VNavPathMode;
(function (VNavPathMode) {
    /** VNAV path is not active. */
    VNavPathMode[VNavPathMode["None"] = 0] = "None";
    /** VNAV path is armed for capture. */
    VNavPathMode[VNavPathMode["PathArmed"] = 1] = "PathArmed";
    /** VNAV path is actively navigating. */
    VNavPathMode[VNavPathMode["PathActive"] = 2] = "PathActive";
    /** The current VNAV path is not valid. */
    VNavPathMode[VNavPathMode["PathInvalid"] = 3] = "PathInvalid";
})(VNavPathMode || (VNavPathMode = {}));
/**
 * The current Approach Guidance Mode.
 */
var ApproachGuidanceMode;
(function (ApproachGuidanceMode) {
    /** VNAV is not currently following approach guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["None"] = 0] = "None";
    /** VNAV has armed ILS glideslope guidance for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSArmed"] = 1] = "GSArmed";
    /** VNAV is actively following ILS glideslope guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GSActive"] = 2] = "GSActive";
    /** VNAV RNAV glidepath guidance is armed for capture. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPArmed"] = 3] = "GPArmed";
    /** VNAV is actively follow RNAV glidepath guidance. */
    ApproachGuidanceMode[ApproachGuidanceMode["GPActive"] = 4] = "GPActive";
})(ApproachGuidanceMode || (ApproachGuidanceMode = {}));
/**
 * The current VNAV altitude capture type.
 */
var VNavAltCaptureType;
(function (VNavAltCaptureType) {
    /** Altitude capture is not armed. */
    VNavAltCaptureType[VNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    VNavAltCaptureType[VNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    VNavAltCaptureType[VNavAltCaptureType["VNAV"] = 2] = "VNAV";
})(VNavAltCaptureType || (VNavAltCaptureType = {}));
/**
 * The current state of VNAV availability from the director.
 */
var VNavAvailability;
(function (VNavAvailability) {
    VNavAvailability["Available"] = "Available";
    VNavAvailability["InvalidLegs"] = "InvalidLegs";
})(VNavAvailability || (VNavAvailability = {}));

/**
 * The state of a given plane director.
 */
var DirectorState;
(function (DirectorState) {
    /** The plane director is not currently armed or active. */
    DirectorState["Inactive"] = "Inactive";
    /** The plane director is currently armed. */
    DirectorState["Armed"] = "Armed";
    /** The plane director is currently active. */
    DirectorState["Active"] = "Active";
})(DirectorState || (DirectorState = {}));
/* eslint-disable @typescript-eslint/no-empty-function */
/**
 * A plane director that provides no behavior.
 */
class EmptyDirector {
    constructor() {
        /** No-op. */
        this.onActivate = () => { };
        /** No-op */
        this.onArm = () => { };
        this.state = DirectorState.Inactive;
    }
    /** No-op. */
    activate() { }
    /** No-op. */
    deactivate() { }
    /** No-op. */
    update() { }
    /** No-op. */
    arm() { }
}
/** An instance of the empty plane director. */
EmptyDirector.instance = new EmptyDirector();

/**
 * A director that removes all vertical guidance from the autopilot system.
 */
class APNoneVerticalDirector {
    constructor() {
        /** @inheritdoc */
        this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    activate() {
        this.state = DirectorState.Active;
        Coherent.call('apSetAutopilotMode', MSFSAPStates.Alt, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.AltArm, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.FLC, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.VS, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.Pitch, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.GS, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.GSArm, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.TOGAPitch, 0);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
    }
    /** @inheritdoc */
    arm() {
        if (this.state === DirectorState.Inactive) {
            this.activate();
        }
    }
    /** @inheritdoc */
    deactivate() {
        this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    update() {
        /** No-op */
    }
}
/**
 * A director that removes all lateral guidance from the autopilot system.
 */
class APNoneLateralDirector {
    constructor() {
        /** @inheritdoc */
        this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    activate() {
        this.state = DirectorState.Active;
        Coherent.call('apSetAutopilotMode', MSFSAPStates.Bank, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.Heading, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.Nav, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.NavArm, 0);
        Coherent.call('apSetAutopilotMode', MSFSAPStates.WingLevel, 0);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
    }
    /** @inheritdoc */
    arm() {
        if (this.state === DirectorState.Inactive) {
            this.activate();
        }
    }
    /** @inheritdoc */
    deactivate() {
        this.state = DirectorState.Inactive;
    }
    /** @inheritdoc */
    update() {
        /** No-op */
    }
}

/// <reference types="@microsoft/msfs-types/coherent/apcontroller" />
/**
 * An Autopilot.
 */
class Autopilot {
    /**
     * Creates an instance of the Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     */
    constructor(bus, flightPlanner, config, stateManager) {
        var _a;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.config = config;
        this.stateManager = stateManager;
        this.cdiSource = { type: NavSourceType.Nav, index: 0 };
        this.lateralModes = new Map();
        this.verticalModes = new Map();
        this.verticalAltitudeArmed = APAltitudeModes.NONE;
        this.verticalApproachArmed = APVerticalModes.NONE;
        this.altCapArmed = false;
        this.lateralModeFailed = false;
        this.inClimb = false;
        this.currentAltitude = 0;
        this.vnavCaptureType = VNavAltCaptureType.None;
        this.flightPlanSynced = false;
        /** Can be set to false in child classes to override behavior for certain aircraft. */
        this.requireApproachIsActiveForNavToNav = true;
        this.apValues = {
            simRate: Subject.create(0),
            selectedAltitude: Subject.create(0),
            selectedVerticalSpeed: Subject.create(0),
            selectedFlightPathAngle: Subject.create(0),
            selectedIas: Subject.create(0),
            selectedMach: Subject.create(0),
            isSelectedSpeedInMach: Subject.create(false),
            selectedPitch: Subject.create(0),
            maxBankId: Subject.create(0),
            maxBankAngle: Subject.create(30),
            selectedHeading: Subject.create(0),
            capturedAltitude: Subject.create(0),
            approachIsActive: Subject.create(false),
            approachHasGP: Subject.create(false),
            nav1HasGs: Subject.create(false),
            nav2HasGs: Subject.create(false),
            nav3HasGs: Subject.create(false),
            nav4HasGs: Subject.create(false),
            lateralActive: Subject.create(APLateralModes.NONE),
            verticalActive: Subject.create(APVerticalModes.NONE),
            lateralArmed: Subject.create(APLateralModes.NONE),
            verticalArmed: Subject.create(APVerticalModes.NONE),
            apApproachModeOn: Subject.create(false)
        };
        this.autopilotInitialized = false;
        this.apValues.maxBankAngle.set(config.defaultMaxBankAngle);
        this.directors = this.createDirectors(config);
        this.vnavManager = config.createVNavManager(this.apValues);
        this.navToNavManager = config.createNavToNavManager(this.apValues);
        this.variableBankManager = config.createVariableBankManager(this.apValues);
        this.apValues.navToNavLocArm = (_a = this.navToNavManager) === null || _a === void 0 ? void 0 : _a.canLocArm.bind(this.navToNavManager);
        this.stateManager.stateManagerInitialized.sub((v) => {
            if (v) {
                this.autopilotInitialized = true;
            }
            else {
                this.autopilotInitialized = false;
            }
            this.onInitialized();
        });
        if (this.config.initializeStateManagerOnFirstFlightPlanSync || this.config.initializeStateManagerOnFirstFlightPlanSync === undefined) {
            this.flightPlanner.flightPlanSynced.on((sender, v) => {
                if (!this.flightPlanSynced && v) {
                    this.stateManager.stateManagerInitialized.set(false);
                    this.stateManager.initialize(true);
                    this.flightPlanSynced = true;
                }
            });
        }
        this.apDriver = new AutopilotDriver(this.bus, this.apValues, this.stateManager.apMasterOn, this.config.autopilotDriverOptions);
        this.initLateralModes();
        this.initVerticalModes();
        this.initNavToNavManager();
        this.initVNavManager();
        this.monitorEvents();
    }
    /**
     * Creates this autopilot's directors.
     * @param config This autopilot's configuration.
     * @returns This autopilot's directors.
     */
    createDirectors(config) {
        var _a;
        return {
            headingDirector: config.createHeadingDirector(this.apValues),
            headingHoldDirector: config.createHeadingHoldDirector(this.apValues),
            trackDirector: config.createTrackDirector(this.apValues),
            trackHoldDirector: config.createTrackHoldDirector(this.apValues),
            rollDirector: config.createRollDirector(this.apValues),
            wingLevelerDirector: config.createWingLevelerDirector(this.apValues),
            gpssDirector: config.createGpssDirector(this.apValues),
            vorDirector: config.createVorDirector(this.apValues),
            locDirector: config.createLocDirector(this.apValues),
            bcDirector: config.createBcDirector(this.apValues),
            rolloutDirector: config.createRolloutDirector(),
            pitchDirector: config.createPitchDirector(this.apValues),
            vsDirector: config.createVsDirector(this.apValues),
            fpaDirector: config.createFpaDirector(this.apValues),
            flcDirector: config.createFlcDirector(this.apValues),
            altHoldDirector: config.createAltHoldDirector(this.apValues),
            altCapDirector: config.createAltCapDirector(this.apValues),
            vnavPathDirector: config.createVNavPathDirector(this.apValues),
            gpDirector: config.createGpDirector(this.apValues),
            gsDirector: config.createGsDirector(this.apValues),
            toVerticalDirector: config.createToVerticalDirector(this.apValues),
            gaVerticalDirector: config.createGaVerticalDirector(this.apValues),
            toLateralDirector: config.createToLateralDirector(this.apValues),
            gaLateralDirector: config.createGaLateralDirector(this.apValues),
            flareDirector: config.createFlareDirector(),
            fmsLocLateralDirector: config.createFmsLocLateralDirector(this.apValues),
            takeoffLocLateralDirector: (_a = config.createTakeoffLocLateralDirector) === null || _a === void 0 ? void 0 : _a.call(config, this.apValues),
        };
    }
    /**
     * Update method for the Autopilot.
     */
    update() {
        if (this.autopilotInitialized) {
            this.onBeforeUpdate();
            this.apDriver.update();
            this.checkModes();
            this.manageAltitudeCapture();
            this.updateModes();
            this.onAfterUpdate();
        }
    }
    /**
     * This method runs each update cycle before the update occurs.
     */
    onBeforeUpdate() {
        // noop
    }
    /**
     * This method runs each update cycle after the update occurs.
     */
    onAfterUpdate() {
        // noop
    }
    /**
     * This method runs whenever the initialized state of the Autopilot changes.
     */
    onInitialized() {
        // noop
    }
    /**
     * Handles input from the State Manager when a lateral mode button is pressed.
     * @param data is the AP Lateral Mode Event Data
     */
    lateralPressed(data) {
        var _a, _b, _c, _d;
        const mode = data.mode;
        if (mode !== APLateralModes.NAV && !this.lateralModes.has(mode)) {
            return;
        }
        const set = data.set;
        if (set === undefined || set === false) {
            if (this.isLateralModeActivatedOrArmed(mode)) {
                return;
            }
        }
        if (set === undefined || set === true) {
            if (this.config.autoEngageFd !== false && !this.stateManager.isFlightDirectorOn.get()) {
                this.stateManager.setFlightDirector(true);
            }
            else if (this.config.autoEngageFd === false && !this.stateManager.isFlightDirectorOn.get() && !this.stateManager.apMasterOn.get()) {
                return;
            }
            switch (mode) {
                case APLateralModes.NONE:
                    break;
                case APLateralModes.LEVEL:
                case APLateralModes.ROLL:
                case APLateralModes.HEADING:
                case APLateralModes.HEADING_HOLD:
                case APLateralModes.TRACK:
                case APLateralModes.TRACK_HOLD:
                case APLateralModes.LOC:
                case APLateralModes.BC:
                case APLateralModes.FMS_LOC:
                    (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
                    break;
                case APLateralModes.NAV:
                    if (this.cdiSource.type === NavSourceType.Gps) {
                        (_b = this.lateralModes.get(APLateralModes.GPSS)) === null || _b === void 0 ? void 0 : _b.arm();
                    }
                    else {
                        (_c = this.lateralModes.get(APLateralModes.VOR)) === null || _c === void 0 ? void 0 : _c.arm();
                        (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
                    }
                    break;
            }
        }
    }
    /**
     * Handles input from the State Manager when a vertical mode button is pressed.
     * @param data is the AP Vertical Mode Event Data
     */
    verticalPressed(data) {
        var _a, _b, _c, _d, _e;
        const mode = data.mode;
        if (!this.verticalModes.has(mode)) {
            return;
        }
        const set = data.set;
        if ((set === undefined || set === false) && mode !== APVerticalModes.TO) {
            if (this.deactivateArmedOrActiveVerticalMode(mode)) {
                return;
            }
        }
        if (set === undefined || set === true) {
            if (this.config.autoEngageFd !== false && !this.stateManager.isFlightDirectorOn.get()) {
                this.stateManager.setFlightDirector(true);
            }
            else if (this.config.autoEngageFd === false && !this.stateManager.isFlightDirectorOn.get() && !this.stateManager.apMasterOn.get()) {
                return;
            }
            switch (mode) {
                case APVerticalModes.NONE:
                case APVerticalModes.PATH:
                    break;
                case APVerticalModes.ALT:
                    if (((_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.state) !== VNavState.Enabled_Active ||
                        (this.vnavManager && this.vnavManager.state === VNavState.Enabled_Active && this.vnavManager.canVerticalModeActivate(mode))) {
                        this.setAltHold();
                    }
                    break;
                case APVerticalModes.PITCH:
                case APVerticalModes.VS:
                case APVerticalModes.FPA:
                case APVerticalModes.FLC:
                    if (((_b = this.vnavManager) === null || _b === void 0 ? void 0 : _b.state) === VNavState.Enabled_Active && !this.vnavManager.canVerticalModeActivate(mode)) {
                        // If the VNav Manager is active, don't activate the mode until VNav Approves.
                        (_c = this.verticalModes.get(mode)) === null || _c === void 0 ? void 0 : _c.arm();
                    }
                    else {
                        (_d = this.verticalModes.get(mode)) === null || _d === void 0 ? void 0 : _d.activate();
                    }
                    break;
                case APVerticalModes.GP:
                case APVerticalModes.GS:
                    (_e = this.verticalModes.get(mode)) === null || _e === void 0 ? void 0 : _e.arm();
                    break;
                case APVerticalModes.TO:
                case APVerticalModes.GA:
                    this.togaPressed();
            }
        }
    }
    /**
     * Checks if a mode is active or armed and optionally deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    isLateralModeActivatedOrArmed(mode) {
        var _a, _b, _c, _d, _e, _f;
        const { lateralActive, lateralArmed } = this.apValues;
        switch (mode) {
            case lateralActive.get():
                (_a = this.lateralModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
                (_b = this.lateralModes.get(this.getDefaultLateralMode())) === null || _b === void 0 ? void 0 : _b.arm();
                return true;
            case lateralArmed.get():
                (_c = this.lateralModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
                lateralArmed.set(APLateralModes.NONE);
                return true;
            case APLateralModes.NAV: {
                const activeNavMode = lateralActive.get() === APLateralModes.LOC ? APLateralModes.LOC
                    : lateralActive.get() === APLateralModes.VOR ? APLateralModes.VOR
                        : lateralActive.get() === APLateralModes.GPSS ? APLateralModes.GPSS
                            : lateralActive.get() === APLateralModes.FMS_LOC ? APLateralModes.FMS_LOC
                                : APLateralModes.NONE;
                if (activeNavMode !== APLateralModes.NONE) {
                    if (this.config.onlyDisarmLnavOnOffEvent === undefined || !this.config.onlyDisarmLnavOnOffEvent) {
                        (_d = this.lateralModes.get(activeNavMode)) === null || _d === void 0 ? void 0 : _d.deactivate();
                        (_e = this.lateralModes.get(this.getDefaultLateralMode())) === null || _e === void 0 ? void 0 : _e.arm();
                        lateralActive.set(this.getDefaultLateralMode());
                    }
                }
                const armedNavMode = lateralArmed.get() === APLateralModes.LOC ? APLateralModes.LOC
                    : lateralArmed.get() === APLateralModes.VOR ? APLateralModes.VOR
                        : lateralArmed.get() === APLateralModes.GPSS ? APLateralModes.GPSS
                            : lateralArmed.get() === APLateralModes.FMS_LOC ? APLateralModes.FMS_LOC
                                : APLateralModes.NONE;
                if (armedNavMode !== APLateralModes.NONE) {
                    (_f = this.lateralModes.get(armedNavMode)) === null || _f === void 0 ? void 0 : _f.deactivate();
                    lateralArmed.set(APLateralModes.NONE);
                }
                if (armedNavMode !== APLateralModes.NONE || activeNavMode !== APLateralModes.NONE) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Checks if a mode is active or armed and deactivates it.
     * @param mode is the AP Mode to check.
     * @returns whether this mode was active or armed and subsequently disabled.
     */
    deactivateArmedOrActiveVerticalMode(mode) {
        var _a, _b, _c, _d;
        const { verticalActive, verticalArmed } = this.apValues;
        switch (mode) {
            case verticalActive.get():
                (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.deactivate();
                verticalActive.set(this.getDefaultVerticalMode());
                (_b = this.verticalModes.get(verticalActive.get())) === null || _b === void 0 ? void 0 : _b.arm();
                return true;
            case verticalArmed.get():
                if (mode !== APVerticalModes.ALT) {
                    (_c = this.verticalModes.get(mode)) === null || _c === void 0 ? void 0 : _c.deactivate();
                    verticalArmed.set(APVerticalModes.NONE);
                    return true;
                }
                break;
            case this.verticalApproachArmed:
                (_d = this.verticalModes.get(mode)) === null || _d === void 0 ? void 0 : _d.deactivate();
                this.verticalApproachArmed = APVerticalModes.NONE;
                return true;
        }
        return false;
    }
    /**
     * Handles input from the State Manager when the APPR button is pressed.
     * @param set is whether this event commands a specific set
     */
    approachPressed(set) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if ((set === undefined || set === false) && this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GP)) {
            (_a = this.lateralModes.get(APLateralModes.GPSS)) === null || _a === void 0 ? void 0 : _a.deactivate();
            return;
        }
        if ((set === undefined || set === false) && this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GS)) {
            (_b = this.lateralModes.get(APLateralModes.LOC)) === null || _b === void 0 ? void 0 : _b.deactivate();
            return;
        }
        if (set === undefined || set === true) {
            switch (this.getArmableApproachType()) {
                case APLateralModes.LOC:
                    if (((_c = this.lateralModes.get(APLateralModes.LOC)) === null || _c === void 0 ? void 0 : _c.state) === DirectorState.Inactive) {
                        (_d = this.lateralModes.get(APLateralModes.LOC)) === null || _d === void 0 ? void 0 : _d.arm();
                    }
                    (_e = this.verticalModes.get(APVerticalModes.GS)) === null || _e === void 0 ? void 0 : _e.arm();
                    break;
                case APLateralModes.GPSS:
                    if (((_f = this.lateralModes.get(APLateralModes.GPSS)) === null || _f === void 0 ? void 0 : _f.state) === DirectorState.Inactive) {
                        (_g = this.lateralModes.get(APLateralModes.GPSS)) === null || _g === void 0 ? void 0 : _g.arm();
                    }
                    (_h = this.verticalModes.get(APVerticalModes.GP)) === null || _h === void 0 ? void 0 : _h.arm();
                    break;
            }
        }
    }
    /**
     * Handles input from the State Manager when the TOGA button is pressed
     * (K event AUTO_THROTTLE_TO_GA)
     */
    togaPressed() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        const hasToMode = this.verticalModes.has(APVerticalModes.TO) && this.lateralModes.has(APLateralModes.TO);
        const hasGaMode = this.verticalModes.has(APVerticalModes.GA) && this.lateralModes.has(APLateralModes.GA);
        const verticalActive = this.apValues.verticalActive.get();
        const lateralActive = this.apValues.lateralActive.get();
        let toGaWasActive = false;
        if (hasToMode && hasGaMode) {
            if (verticalActive === APVerticalModes.TO || verticalActive === APVerticalModes.GA) {
                (_a = this.verticalModes.get(verticalActive)) === null || _a === void 0 ? void 0 : _a.deactivate();
                toGaWasActive = true;
            }
            if (lateralActive === APLateralModes.GA || lateralActive === APLateralModes.TO) {
                (_b = this.lateralModes.get(lateralActive)) === null || _b === void 0 ? void 0 : _b.deactivate();
                toGaWasActive = true;
            }
            if (!toGaWasActive) {
                if (Simplane.getIsGrounded()) {
                    (_c = this.verticalModes.get(APVerticalModes.TO)) === null || _c === void 0 ? void 0 : _c.arm();
                    (_d = this.lateralModes.get(APLateralModes.TO)) === null || _d === void 0 ? void 0 : _d.arm();
                }
                else {
                    SimVar.SetSimVarValue('K:AUTOPILOT_OFF', 'number', 0);
                    (_e = this.verticalModes.get(APVerticalModes.GA)) === null || _e === void 0 ? void 0 : _e.arm();
                    (_f = this.lateralModes.get(APLateralModes.GA)) === null || _f === void 0 ? void 0 : _f.arm();
                }
            }
        }
        else if (hasToMode) {
            if (verticalActive === APVerticalModes.TO) {
                (_g = this.verticalModes.get(APVerticalModes.TO)) === null || _g === void 0 ? void 0 : _g.deactivate();
                toGaWasActive = true;
            }
            if (lateralActive === APLateralModes.TO) {
                (_h = this.lateralModes.get(APLateralModes.TO)) === null || _h === void 0 ? void 0 : _h.deactivate();
                toGaWasActive = true;
            }
            if (!toGaWasActive) {
                (_j = this.verticalModes.get(APVerticalModes.TO)) === null || _j === void 0 ? void 0 : _j.arm();
                (_k = this.lateralModes.get(APLateralModes.TO)) === null || _k === void 0 ? void 0 : _k.arm();
            }
        }
    }
    /**
     * Returns the AP Lateral Mode that can be armed.
     * @returns The AP Lateral Mode that can be armed.
     */
    getArmableApproachType() {
        switch (this.cdiSource.type) {
            case NavSourceType.Nav:
                if (this.cdiSource.index === 1 && this.apValues.nav1HasGs.get()) {
                    return APLateralModes.LOC;
                }
                else if (this.cdiSource.index === 2 && this.apValues.nav2HasGs.get()) {
                    return APLateralModes.LOC;
                }
                else if (this.cdiSource.index === 3 && this.apValues.nav3HasGs.get()) {
                    return APLateralModes.LOC;
                }
                else if (this.cdiSource.index === 4 && this.apValues.nav4HasGs.get()) {
                    return APLateralModes.LOC;
                }
                break;
            case NavSourceType.Gps:
                if (this.apValues.approachIsActive.get() && this.apValues.approachHasGP.get()) {
                    return APLateralModes.GPSS;
                }
                else if (this.navToNavManager && this.navToNavManager.canLocArm()) {
                    return APLateralModes.LOC;
                }
        }
        return APLateralModes.NONE;
    }
    /**
     * Callback to set the lateral active mode.
     * @param mode is the mode being set.
     */
    setLateralActive(mode) {
        const { lateralActive, lateralArmed } = this.apValues;
        this.checkRollModeActive();
        if (lateralArmed.get() === mode) {
            lateralArmed.set(APLateralModes.NONE);
        }
        if (mode !== lateralActive.get()) {
            const currentMode = this.lateralModes.get(lateralActive.get());
            currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            lateralActive.set(mode);
        }
    }
    /**
     * Callback to set the lateral armed mode.
     * @param mode is the mode being set.
     */
    setLateralArmed(mode) {
        const { lateralArmed } = this.apValues;
        const currentMode = this.lateralModes.get(lateralArmed.get());
        currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        lateralArmed.set(mode);
    }
    /**
     * Callback to set the vertical active mode.
     * @param mode is the mode being set.
     */
    setVerticalActive(mode) {
        const { verticalActive, verticalArmed } = this.apValues;
        this.checkPitchModeActive();
        if (verticalArmed.get() === mode) {
            verticalArmed.set(APVerticalModes.NONE);
        }
        else if (this.verticalApproachArmed === mode) {
            this.verticalApproachArmed = APVerticalModes.NONE;
        }
        if (mode !== verticalActive.get()) {
            const currentMode = this.verticalModes.get(verticalActive.get());
            if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
                currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            }
            verticalActive.set(mode);
        }
    }
    /**
     * Callback to set the vertical armed mode.
     * @param mode is the mode being set.
     */
    setVerticalArmed(mode) {
        const { verticalArmed } = this.apValues;
        if (mode !== verticalArmed.get()) {
            const currentMode = this.verticalModes.get(verticalArmed.get());
            if ((currentMode === null || currentMode === void 0 ? void 0 : currentMode.state) !== DirectorState.Inactive) {
                currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            }
        }
        verticalArmed.set(mode);
    }
    /**
     * Callback to set the vertical approach armed mode.
     * @param mode is the mode being set.
     */
    setVerticalApproachArmed(mode) {
        const currentMode = this.verticalModes.get(this.verticalApproachArmed);
        currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
        this.verticalApproachArmed = mode;
    }
    /**
     * Method called when the ALT button is pressed.
     */
    setAltHold() {
        var _a;
        if (this.verticalModes.has(APVerticalModes.ALT)) {
            const currentAlt = 10 * (this.inClimb ? Math.ceil(this.currentAltitude / 10) : Math.floor(this.currentAltitude / 10));
            this.apValues.capturedAltitude.set(currentAlt);
            (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.activate();
        }
    }
    /**
     * Initializes the Autopilot with the available lateral modes from the config.
     */
    initLateralModes() {
        if (this.directors.rollDirector) {
            this.lateralModes.set(APLateralModes.ROLL, this.directors.rollDirector);
            this.directors.rollDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.ROLL);
            };
        }
        if (this.directors.wingLevelerDirector) {
            this.lateralModes.set(APLateralModes.LEVEL, this.directors.wingLevelerDirector);
            this.directors.wingLevelerDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.LEVEL);
            };
        }
        if (this.directors.headingDirector) {
            this.lateralModes.set(APLateralModes.HEADING, this.directors.headingDirector);
            this.directors.headingDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.HEADING);
            };
        }
        if (this.directors.headingHoldDirector) {
            this.lateralModes.set(APLateralModes.HEADING_HOLD, this.directors.headingHoldDirector);
            this.directors.headingHoldDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.HEADING_HOLD);
            };
        }
        if (this.directors.trackDirector) {
            this.lateralModes.set(APLateralModes.TRACK, this.directors.trackDirector);
            this.directors.trackDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.TRACK);
            };
        }
        if (this.directors.trackHoldDirector) {
            this.lateralModes.set(APLateralModes.TRACK_HOLD, this.directors.trackHoldDirector);
            this.directors.trackHoldDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.TRACK_HOLD);
            };
        }
        if (this.directors.gpssDirector) {
            this.lateralModes.set(APLateralModes.GPSS, this.directors.gpssDirector);
            this.directors.gpssDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.GPSS);
            };
            this.directors.gpssDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.GPSS);
            };
        }
        if (this.directors.vorDirector) {
            this.lateralModes.set(APLateralModes.VOR, this.directors.vorDirector);
            this.directors.vorDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.VOR);
            };
            this.directors.vorDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.VOR);
            };
        }
        if (this.directors.locDirector) {
            this.lateralModes.set(APLateralModes.LOC, this.directors.locDirector);
            this.directors.locDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.LOC);
            };
            this.directors.locDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.LOC);
            };
        }
        if (this.directors.bcDirector) {
            this.lateralModes.set(APLateralModes.BC, this.directors.bcDirector);
            this.directors.bcDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.BC);
            };
            this.directors.bcDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.BC);
            };
        }
        if (this.directors.rolloutDirector) {
            this.lateralModes.set(APLateralModes.ROLLOUT, this.directors.rolloutDirector);
            this.directors.rolloutDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.ROLLOUT);
            };
            this.directors.rolloutDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.ROLLOUT);
            };
        }
        if (this.directors.toLateralDirector) {
            this.lateralModes.set(APLateralModes.TO, this.directors.toLateralDirector);
            this.directors.toLateralDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.TO);
            };
        }
        if (this.directors.gaLateralDirector) {
            this.lateralModes.set(APLateralModes.GA, this.directors.gaLateralDirector);
            this.directors.gaLateralDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.GA);
            };
        }
        if (this.directors.fmsLocLateralDirector) {
            this.lateralModes.set(APLateralModes.FMS_LOC, this.directors.fmsLocLateralDirector);
            this.directors.fmsLocLateralDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.FMS_LOC);
            };
            this.directors.fmsLocLateralDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.FMS_LOC);
            };
        }
        if (this.directors.takeoffLocLateralDirector) {
            this.lateralModes.set(APLateralModes.TO_LOC, this.directors.takeoffLocLateralDirector);
            this.directors.takeoffLocLateralDirector.onArm = () => {
                this.setLateralArmed(APLateralModes.TO_LOC);
            };
            this.directors.takeoffLocLateralDirector.onActivate = () => {
                this.setLateralActive(APLateralModes.TO_LOC);
            };
        }
        this.lateralModes.forEach(director => {
            director.setBank = this.apDriver.setBank.bind(this.apDriver);
            director.driveBank = this.apDriver.driveBank.bind(this.apDriver);
        });
        const noneDirector = new APNoneLateralDirector();
        noneDirector.onActivate = () => this.setLateralActive(APLateralModes.NONE);
        this.lateralModes.set(APLateralModes.NONE, noneDirector);
    }
    /**
     * Initializes the Autopilot with the available Nav To Nav Manager.
     */
    initNavToNavManager() {
        if (this.navToNavManager) {
            this.navToNavManager.onTransferred = () => {
                var _a;
                if (this.apValues.lateralActive.get() === APLateralModes.GPSS) {
                    (_a = this.lateralModes.get(APLateralModes.LOC)) === null || _a === void 0 ? void 0 : _a.activate();
                }
            };
        }
    }
    /**
     * Initializes the Autopilot with the available VNav Manager.
     */
    initVNavManager() {
        if (this.vnavManager) {
            this.vnavManager.armMode = (mode) => {
                var _a;
                const armedMode = this.apValues.verticalArmed.get();
                if (mode === APVerticalModes.NONE && (armedMode === APVerticalModes.PATH || armedMode === APVerticalModes.FLC)) {
                    this.setVerticalArmed(mode);
                }
                else {
                    (_a = this.verticalModes.get(mode)) === null || _a === void 0 ? void 0 : _a.arm();
                }
            };
            this.vnavManager.activateMode = (mode) => {
                var _a, _b;
                if (mode === APVerticalModes.NONE && this.apValues.verticalActive.get() === APVerticalModes.PATH) {
                    (_a = this.verticalModes.get(this.getDefaultVerticalMode())) === null || _a === void 0 ? void 0 : _a.activate();
                }
                else {
                    (_b = this.verticalModes.get(mode)) === null || _b === void 0 ? void 0 : _b.activate();
                }
            };
        }
    }
    /**
     * Initializes the Autopilot with the available vertical modes from the config.
     */
    initVerticalModes() {
        if (this.directors.pitchDirector) {
            this.verticalModes.set(APVerticalModes.PITCH, this.directors.pitchDirector);
            this.directors.pitchDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.PITCH);
            };
        }
        if (this.directors.vsDirector) {
            this.verticalModes.set(APVerticalModes.VS, this.directors.vsDirector);
            this.directors.vsDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.VS);
            };
        }
        if (this.directors.fpaDirector) {
            this.verticalModes.set(APVerticalModes.FPA, this.directors.fpaDirector);
            this.directors.fpaDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.FPA);
            };
        }
        if (this.directors.flcDirector) {
            this.verticalModes.set(APVerticalModes.FLC, this.directors.flcDirector);
            this.directors.flcDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.FLC);
            };
            this.directors.flcDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.FLC);
            };
        }
        if (this.directors.altHoldDirector) {
            this.verticalModes.set(APVerticalModes.ALT, this.directors.altHoldDirector);
            this.directors.altHoldDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.ALT);
            };
            this.directors.altHoldDirector.onActivate = () => {
                this.altCapArmed = false;
                this.setVerticalActive(APVerticalModes.ALT);
            };
        }
        if (this.directors.altCapDirector) {
            this.verticalModes.set(APVerticalModes.CAP, this.directors.altCapDirector);
            this.directors.altCapDirector.onArm = () => {
                var _a;
                this.altCapArmed = true;
                const verticalArmed = this.apValues.verticalArmed.get();
                if (verticalArmed === APVerticalModes.ALT) {
                    (_a = this.verticalModes.get(verticalArmed)) === null || _a === void 0 ? void 0 : _a.deactivate();
                }
            };
            this.directors.altCapDirector.onActivate = () => {
                var _a;
                this.altCapArmed = false;
                this.setVerticalActive(APVerticalModes.CAP);
                (_a = this.verticalModes.get(APVerticalModes.ALT)) === null || _a === void 0 ? void 0 : _a.arm();
            };
        }
        if (this.directors.vnavPathDirector) {
            this.verticalModes.set(APVerticalModes.PATH, this.directors.vnavPathDirector);
            this.directors.vnavPathDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.PATH);
            };
            this.directors.vnavPathDirector.onDeactivate = () => {
                var _a;
                (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.onPathDirectorDeactivated();
            };
            this.directors.vnavPathDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.PATH);
            };
        }
        if (this.directors.gpDirector) {
            this.verticalModes.set(APVerticalModes.GP, this.directors.gpDirector);
            this.directors.gpDirector.onArm = () => {
                this.setVerticalApproachArmed(APVerticalModes.GP);
            };
            this.directors.gpDirector.onActivate = () => {
                var _a;
                (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.tryDeactivate(APVerticalModes.NONE);
                this.setVerticalActive(APVerticalModes.GP);
                this.setVerticalArmed(APVerticalModes.NONE);
            };
        }
        if (this.directors.gsDirector) {
            this.verticalModes.set(APVerticalModes.GS, this.directors.gsDirector);
            this.directors.gsDirector.onArm = () => {
                this.setVerticalApproachArmed(APVerticalModes.GS);
            };
            this.directors.gsDirector.onActivate = () => {
                var _a;
                this.setVerticalActive(APVerticalModes.GS);
                (_a = this.verticalModes.get(APVerticalModes.PATH)) === null || _a === void 0 ? void 0 : _a.deactivate();
                this.setVerticalArmed(APVerticalModes.NONE);
                this.setVerticalApproachArmed(APVerticalModes.NONE);
            };
        }
        if (this.directors.flareDirector) {
            this.verticalModes.set(APVerticalModes.FLARE, this.directors.flareDirector);
            this.directors.flareDirector.onArm = () => {
                this.setVerticalArmed(APVerticalModes.FLARE);
                // this.lateralModes.get(APLateralModes.ROLLOUT)?.arm();
            };
            this.directors.flareDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.FLARE);
                // this.lateralModes.get(APLateralModes.ROLLOUT)?.activate();
                this.setVerticalArmed(APVerticalModes.NONE);
                this.setVerticalApproachArmed(APVerticalModes.NONE);
            };
        }
        if (this.directors.toVerticalDirector) {
            this.verticalModes.set(APVerticalModes.TO, this.directors.toVerticalDirector);
            this.directors.toVerticalDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.TO);
            };
        }
        if (this.directors.gaVerticalDirector) {
            this.verticalModes.set(APVerticalModes.GA, this.directors.gaVerticalDirector);
            this.directors.gaVerticalDirector.onActivate = () => {
                this.setVerticalActive(APVerticalModes.GA);
            };
        }
        this.verticalModes.forEach(director => {
            director.drivePitch = this.apDriver.drivePitch.bind(this.apDriver);
            director.setPitch = this.apDriver.setPitch.bind(this.apDriver);
        });
        const noneDirector = new APNoneVerticalDirector();
        noneDirector.onActivate = () => this.setVerticalActive(APVerticalModes.NONE);
        this.verticalModes.set(APVerticalModes.NONE, noneDirector);
    }
    /**
     * Checks if all the active and armed modes are still in their proper state
     * and takes corrective action if not.
     */
    checkModes() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.lateralModeFailed) {
            this.lateralModeFailed = false;
        }
        if (!this.stateManager.apMasterOn.get() && !this.stateManager.isFlightDirectorOn.get()) {
            return;
        }
        const { lateralActive, lateralArmed, verticalActive, verticalArmed } = this.apValues;
        if (!this.lateralModes.has(lateralActive.get()) || ((_a = this.lateralModes.get(lateralActive.get())) === null || _a === void 0 ? void 0 : _a.state) !== DirectorState.Active) {
            if (lateralActive.get() !== APLateralModes.NONE) {
                this.lateralModeFailed = true;
            }
            (_b = this.lateralModes.get(this.getDefaultLateralMode())) === null || _b === void 0 ? void 0 : _b.arm();
        }
        if (lateralArmed.get() !== APLateralModes.NONE
            && (!this.lateralModes.has(lateralArmed.get()) || ((_c = this.lateralModes.get(lateralArmed.get())) === null || _c === void 0 ? void 0 : _c.state) !== DirectorState.Armed)) {
            this.setLateralArmed(APLateralModes.NONE);
        }
        if (!this.verticalModes.has(verticalActive.get()) || ((_d = this.verticalModes.get(verticalActive.get())) === null || _d === void 0 ? void 0 : _d.state) !== DirectorState.Active) {
            (_e = this.verticalModes.get(this.getDefaultVerticalMode())) === null || _e === void 0 ? void 0 : _e.arm();
        }
        if (verticalArmed.get() !== APVerticalModes.NONE
            && (!this.verticalModes.has(verticalArmed.get()) || ((_f = this.verticalModes.get(verticalArmed.get())) === null || _f === void 0 ? void 0 : _f.state) !== DirectorState.Armed)) {
            this.setVerticalArmed(APVerticalModes.NONE);
        }
        if (this.verticalApproachArmed !== APVerticalModes.NONE &&
            (!this.verticalModes.has(this.verticalApproachArmed) || ((_g = this.verticalModes.get(this.verticalApproachArmed)) === null || _g === void 0 ? void 0 : _g.state) !== DirectorState.Armed)) {
            this.setVerticalApproachArmed(APVerticalModes.NONE);
        }
    }
    /**
     * Runs update on each of the active and armed modes.
     */
    updateModes() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const { lateralActive, lateralArmed, verticalActive, verticalArmed } = this.apValues;
        if (lateralActive.get() !== APLateralModes.NONE && lateralActive.get() !== APLateralModes.GPSS && this.lateralModes.has(lateralActive.get())) {
            (_a = this.lateralModes.get(lateralActive.get())) === null || _a === void 0 ? void 0 : _a.update();
        }
        if (lateralArmed.get() !== APLateralModes.NONE && lateralArmed.get() !== APLateralModes.GPSS && this.lateralModes.has(lateralArmed.get())) {
            (_b = this.lateralModes.get(lateralArmed.get())) === null || _b === void 0 ? void 0 : _b.update();
        }
        if (verticalActive.get() !== APVerticalModes.NONE && this.verticalModes.has(verticalActive.get())) {
            (_c = this.verticalModes.get(verticalActive.get())) === null || _c === void 0 ? void 0 : _c.update();
        }
        if (verticalArmed.get() !== APVerticalModes.NONE && this.verticalModes.has(verticalArmed.get())) {
            (_d = this.verticalModes.get(verticalArmed.get())) === null || _d === void 0 ? void 0 : _d.update();
        }
        if (this.verticalApproachArmed !== APVerticalModes.NONE && this.verticalModes.has(this.verticalApproachArmed)) {
            (_e = this.verticalModes.get(this.verticalApproachArmed)) === null || _e === void 0 ? void 0 : _e.update();
        }
        if (this.altCapArmed) {
            (_f = this.verticalModes.get(APVerticalModes.CAP)) === null || _f === void 0 ? void 0 : _f.update();
        }
        //while vnav and vnav director are one in the same we always want to
        //run the vnav update cycle no matter the director state
        (_g = this.vnavManager) === null || _g === void 0 ? void 0 : _g.update();
        //while lnav and lnav director are one in the same we always want to
        //run the lnav update cycle no matter the director state
        (_h = this.lateralModes.get(APLateralModes.GPSS)) === null || _h === void 0 ? void 0 : _h.update();
    }
    /**
     * Checks and sets the proper armed altitude mode.
     */
    manageAltitudeCapture() {
        var _a, _b, _c;
        let altCapType = APAltitudeModes.NONE;
        let armAltCap = false;
        switch (this.apValues.verticalActive.get()) {
            case APVerticalModes.VS:
            case APVerticalModes.FPA:
            case APVerticalModes.FLC:
            case APVerticalModes.PITCH:
            case APVerticalModes.TO:
            case APVerticalModes.GA:
                if (this.inClimb && this.apValues.selectedAltitude.get() > this.currentAltitude) {
                    altCapType = APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                else if (!this.inClimb && this.apValues.selectedAltitude.get() < this.currentAltitude) {
                    altCapType = APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                break;
            case APVerticalModes.PATH: {
                if (!this.inClimb) {
                    altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
                }
                break;
            }
            case APVerticalModes.CAP:
                altCapType = this.verticalAltitudeArmed;
                break;
        }
        if (this.verticalAltitudeArmed !== altCapType) {
            this.verticalAltitudeArmed = altCapType;
        }
        if (armAltCap && (!this.altCapArmed || ((_a = this.verticalModes.get(APVerticalModes.CAP)) === null || _a === void 0 ? void 0 : _a.state) === DirectorState.Inactive)) {
            (_b = this.verticalModes.get(APVerticalModes.CAP)) === null || _b === void 0 ? void 0 : _b.arm();
        }
        else if (!armAltCap && this.altCapArmed) {
            (_c = this.verticalModes.get(APVerticalModes.CAP)) === null || _c === void 0 ? void 0 : _c.deactivate();
            this.altCapArmed = false;
        }
    }
    /**
     * Monitors subevents and bus events.
     */
    monitorEvents() {
        var _a;
        this.stateManager.lateralPressed.on((sender, data) => {
            if (this.autopilotInitialized && data !== undefined) {
                this.lateralPressed(data);
            }
        });
        this.stateManager.verticalPressed.on((sender, data) => {
            if (this.autopilotInitialized && data !== undefined) {
                this.verticalPressed(data);
            }
        });
        this.stateManager.approachPressed.on((sender, data) => {
            if (this.autopilotInitialized) {
                this.approachPressed(data);
            }
        });
        this.stateManager.vnavPressed.on((sender, data) => {
            var _a, _b;
            if (this.autopilotInitialized) {
                if (data === true) {
                    (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.tryActivate();
                }
                else {
                    (_b = this.vnavManager) === null || _b === void 0 ? void 0 : _b.tryDeactivate();
                }
            }
        });
        // Sets up the subs for selected speed, selected mach and selected is mach.
        this.monitorApSpeedValues();
        const clock = this.bus.getSubscriber();
        clock.on('simRate').withPrecision(0).handle(this.apValues.simRate.set.bind(this.apValues.simRate));
        const ap = this.bus.getSubscriber();
        ap.on(`ap_altitude_selected_${(_a = this.config.altitudeHoldSlotIndex) !== null && _a !== void 0 ? _a : 1}`).withPrecision(0).handle((alt) => {
            this.apValues.selectedAltitude.set(alt);
        });
        ap.on('ap_heading_selected').withPrecision(0).handle((hdg) => {
            this.apValues.selectedHeading.set(hdg);
        });
        ap.on('ap_pitch_selected').withPrecision(1).handle((pitch) => {
            this.apValues.selectedPitch.set(pitch);
        });
        ap.on('ap_vs_selected').withPrecision(0).handle((ias) => {
            this.apValues.selectedVerticalSpeed.set(ias);
        });
        ap.on('ap_fpa_selected').withPrecision(1).handle((fpa) => {
            this.apValues.selectedFlightPathAngle.set(fpa);
        });
        ap.on('ap_max_bank_id').handle(id => {
            this.apValues.maxBankId.set(id);
        });
        const nav = this.bus.getSubscriber();
        nav.on('cdi_select').handle((src) => {
            this.cdiSource = src;
        });
        const navproc = this.bus.getSubscriber();
        navproc.on('nav_glideslope_1').whenChanged().handle((hasgs) => {
            this.apValues.nav1HasGs.set(hasgs);
        });
        navproc.on('nav_glideslope_2').whenChanged().handle((hasgs) => {
            this.apValues.nav2HasGs.set(hasgs);
        });
        navproc.on('nav_glideslope_3').whenChanged().handle((hasgs) => {
            this.apValues.nav3HasGs.set(hasgs);
        });
        navproc.on('nav_glideslope_4').whenChanged().handle((hasgs) => {
            this.apValues.nav4HasGs.set(hasgs);
        });
        const adc = this.bus.getSubscriber();
        adc.on('vertical_speed').withPrecision(0).handle((vs) => {
            this.inClimb = vs < 1 ? false : true;
        });
        adc.on('indicated_alt').withPrecision(0).handle(alt => {
            this.currentAltitude = alt;
        });
        const vnav = this.bus.getSubscriber();
        vnav.on('vnav_altitude_capture_type').whenChanged().handle((v) => {
            this.vnavCaptureType = v;
        });
        this.stateManager.apMasterOn.sub(() => {
            if (this.autopilotInitialized) {
                this.handleApFdStateChange();
            }
        });
        this.stateManager.isFlightDirectorOn.sub(() => {
            if (this.autopilotInitialized) {
                this.handleApFdStateChange();
            }
        });
        this.bus.getSubscriber().on('approach_available').handle(available => {
            this.apValues.approachIsActive.set(available);
        });
    }
    /**
     * Overridable method for setting the selected speed values for the A/P to follow.
     */
    monitorApSpeedValues() {
        const ap = this.bus.getSubscriber();
        ap.on('ap_ias_selected').withPrecision(0).handle((ias) => {
            this.apValues.selectedIas.set(ias);
        });
        ap.on('ap_mach_selected').withPrecision(3).handle((mach) => {
            this.apValues.selectedMach.set(mach);
        });
        ap.on('ap_selected_speed_is_mach').whenChanged().handle((inMach) => {
            this.apValues.isSelectedSpeedInMach.set(inMach);
        });
    }
    /**
     * Additional events to be monitored (to be overridden).
     */
    monitorAdditionalEvents() {
        //noop
    }
    /**
     * Manages the FD state and the modes when AP/FD are off.
     */
    handleApFdStateChange() {
        const ap = this.stateManager.apMasterOn.get();
        const fd = this.stateManager.isFlightDirectorOn.get();
        if (ap && !fd && this.config.autoEngageFd !== false) {
            this.stateManager.setFlightDirector(true);
        }
        else if (!ap && !fd) {
            this.lateralModes.forEach((mode) => {
                if (mode.state !== DirectorState.Inactive) {
                    mode.deactivate();
                }
            });
            this.verticalModes.forEach((mode) => {
                if (mode.state !== DirectorState.Inactive) {
                    mode.deactivate();
                }
            });
            this.apValues.lateralActive.set(APLateralModes.NONE);
            this.apValues.lateralArmed.set(APLateralModes.NONE);
            this.apValues.verticalActive.set(APVerticalModes.NONE);
            this.apValues.verticalArmed.set(APVerticalModes.NONE);
            this.verticalApproachArmed = APVerticalModes.NONE;
            this.verticalAltitudeArmed = APAltitudeModes.NONE;
            this.altCapArmed = false;
        }
    }
    /**
     * Sets a sim AP mode.
     * @param mode The mode to set.
     * @param enabled Whether or not the mode is enabled or disabled.
     */
    setSimAP(mode, enabled) {
        Coherent.call('apSetAutopilotMode', mode, enabled ? 1 : 0);
    }
    /**
     * Checks if the sim AP is in roll mode and sets it if not.
     */
    checkRollModeActive() {
        if (!APController.apGetAutopilotModeActive(MSFSAPStates.Bank)) {
            // console.log('checkRollModeActive had to set Bank mode');
            this.setSimAP(MSFSAPStates.Bank, true);
        }
    }
    /**
     * Checks if the sim AP is in pitch mode and sets it if not.
     */
    checkPitchModeActive() {
        if (!APController.apGetAutopilotModeActive(MSFSAPStates.Pitch)) {
            // console.log('checkPitchModeActive had to set Pitch mode');
            this.setSimAP(MSFSAPStates.Pitch, true);
        }
    }
    /**
     * Get the default lateral mode from APConfig
     * @returns default lateral mode
     */
    getDefaultLateralMode() {
        if (typeof this.config.defaultLateralMode === 'number') {
            return this.config.defaultLateralMode;
        }
        else {
            return this.config.defaultLateralMode();
        }
    }
    /**
     * Get the default vertical mode from APConfig
     * @returns default vertical mode
     */
    getDefaultVerticalMode() {
        if (typeof this.config.defaultVerticalMode === 'number') {
            return this.config.defaultVerticalMode;
        }
        else {
            return this.config.defaultVerticalMode();
        }
    }
}

/**
 * LNAV transition modes.
 */
var LNavTransitionMode;
(function (LNavTransitionMode) {
    /** LNAV is attempting to track a non-transition vector. */
    LNavTransitionMode[LNavTransitionMode["None"] = 0] = "None";
    /** LNAV is attempting to track an ingress vector. */
    LNavTransitionMode[LNavTransitionMode["Ingress"] = 1] = "Ingress";
    /** LNAV is attempting to track an egress vector. */
    LNavTransitionMode[LNavTransitionMode["Egress"] = 2] = "Egress";
    /**
     * LNAV is attempting to track a non-transition vector prior to where the ingress transition joins the base flight
     * path after deactivating suspend mode.
     */
    LNavTransitionMode[LNavTransitionMode["Unsuspend"] = 3] = "Unsuspend";
})(LNavTransitionMode || (LNavTransitionMode = {}));
/**
 * Sim var names for LNAV data.
 */
var LNavVars;
(function (LNavVars) {
    /** The current desired track, in degrees true. */
    LNavVars["DTK"] = "L:WTAP_LNav_DTK";
    /**
     * The current crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavVars["XTK"] = "L:WTAP_LNav_XTK";
    /** Whether LNAV is tracking a path. */
    LNavVars["IsTracking"] = "L:WTAP_LNav_Is_Tracking";
    /** The global leg index of the flight plan leg LNAV is currently tracking. */
    LNavVars["TrackedLegIndex"] = "L:WTAP_LNav_Tracked_Leg_Index";
    /** The currently active LNAV transition mode. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    LNavVars["TransitionMode"] = "L:WTAP_LNav_Transition_Mode";
    /** The index of the vector LNAV is currently tracking. */
    LNavVars["TrackedVectorIndex"] = "L:WTAP_LNav_Tracked_Vector_Index";
    /** The current course LNAV is attempting to steer, in degrees true. */
    LNavVars["CourseToSteer"] = "L:WTAP_LNav_Course_To_Steer";
    /** Whether LNAV sequencing is suspended. */
    LNavVars["IsSuspended"] = "L:WTAP_LNav_Is_Suspended";
    /**
     * The along-track distance from the start of the currently tracked leg to the plane's present position. A negative
     * distance indicates the plane is before the start of the leg.
     */
    LNavVars["LegDistanceAlong"] = "L:WTAP_LNav_Leg_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked leg. A negative distance indicates the plane is past
     * the end of the leg.
     */
    LNavVars["LegDistanceRemaining"] = "L:WTAP_LNav_Leg_Distance_Remaining";
    /**
     * The along-track distance from the start of the currently tracked vector to the plane's present position. A
     * negative distance indicates the plane is before the start of the vector.
     */
    LNavVars["VectorDistanceAlong"] = "L:WTAP_LNav_Vector_Distance_Along";
    /**
     * The along-track distance remaining in the currently tracked vector. A negative distance indicates the plane is
     * past the end of the vector.
     */
    LNavVars["VectorDistanceRemaining"] = "L:WTAP_LNav_Vector_Distance_Remaining";
    /**
     * The along-track distance from the current vector end where LNAV will sequence to the next vector.
     * A positive value means the vector will be sequenced this distance prior to the vector end.
     */
    LNavVars["VectorAnticipationDistance"] = "L:WTAP_LNav_Vector_Anticipation_Distance";
    /** The current along-track ground speed of the airplane. */
    LNavVars["AlongTrackSpeed"] = "L:WTAP_LNav_Along_Track_Speed";
})(LNavVars || (LNavVars = {}));
/**
 * A publisher for LNAV sim var events.
 */
class LNavSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavSimVarPublisher.simvars, bus);
    }
}
LNavSimVarPublisher.simvars = new Map([
    ['lnav_dtk', { name: LNavVars.DTK, type: SimVarValueType.Degree }],
    ['lnav_xtk', { name: LNavVars.XTK, type: SimVarValueType.NM }],
    ['lnav_is_tracking', { name: LNavVars.IsTracking, type: SimVarValueType.Bool }],
    ['lnav_tracked_leg_index', { name: LNavVars.TrackedLegIndex, type: SimVarValueType.Number }],
    ['lnav_transition_mode', { name: LNavVars.TransitionMode, type: SimVarValueType.Number }],
    ['lnav_tracked_vector_index', { name: LNavVars.TrackedVectorIndex, type: SimVarValueType.Number }],
    ['lnav_course_to_steer', { name: LNavVars.CourseToSteer, type: SimVarValueType.Degree }],
    ['lnav_is_suspended', { name: LNavVars.IsSuspended, type: SimVarValueType.Bool }],
    ['lnav_leg_distance_along', { name: LNavVars.LegDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_leg_distance_remaining', { name: LNavVars.LegDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_distance_along', { name: LNavVars.VectorDistanceAlong, type: SimVarValueType.NM }],
    ['lnav_vector_distance_remaining', { name: LNavVars.VectorDistanceRemaining, type: SimVarValueType.NM }],
    ['lnav_vector_anticipation_distance', { name: LNavVars.VectorAnticipationDistance, type: SimVarValueType.NM }],
    ['lnav_along_track_speed', { name: LNavVars.AlongTrackSpeed, type: SimVarValueType.Knots }]
]);

/**
 * Utility class for working with LNAV.
 */
class LNavUtils {
    /**
     * Gets the flight path vectors to navigate for a leg and a given transition mode.
     * @param calc The calculations for a flight plan leg.
     * @param mode A transition mode.
     * @param isSuspended Whether sequencing is suspended.
     * @returns The flight path vectors to navigate for the given leg and transition mode.
     */
    static getVectorsForTransitionMode(calc, mode, isSuspended) {
        switch (mode) {
            case LNavTransitionMode.None:
                return isSuspended ? calc.flightPath : calc.ingressToEgress;
            case LNavTransitionMode.Ingress:
                return calc.ingress;
            case LNavTransitionMode.Egress:
                return calc.egress;
            case LNavTransitionMode.Unsuspend:
                return calc.flightPath;
        }
    }
    /**
     * Checks whether two LNAV tracking states are equal.
     * @param a The first state.
     * @param b The second state.
     * @returns Whether the two LNAV tracking states are equal.
     */
    static lnavTrackingStateEquals(a, b) {
        return a.isTracking === b.isTracking
            && a.globalLegIndex === b.globalLegIndex
            && a.transitionMode === b.transitionMode
            && a.vectorIndex === b.vectorIndex
            && a.isSuspended === b.isSuspended;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * An altitude capture autopilot director.
 */
class APAltCapDirector {
    /**
     * Creates an instance of the APAltCapDirector.
     * @param apValues Autopilot data for this director.
     * @param options Optional options object with these:
     * --> shouldActivate: An optional function which returns true if the capturing shall be activated. If not
     * defined, a default function is used.
     * --> captureAltitude: An optional function which calculates desired pitch angles to capture a target altitude. If not
     * defined, a default function is used.
     */
    constructor(apValues, options) {
        this.apValues = apValues;
        this.initialFpa = 0;
        this.captureAltitude = APAltCapDirector.captureAltitude;
        this.shouldActivate = APAltCapDirector.shouldActivate;
        this.state = DirectorState.Inactive;
        if ((options === null || options === void 0 ? void 0 : options.captureAltitude) !== undefined) {
            this.captureAltitude = options.captureAltitude;
        }
        if ((options === null || options === void 0 ? void 0 : options.shouldActivate) !== undefined) {
            this.shouldActivate = options.shouldActivate;
        }
    }
    /**
     * Activates this director.
     * @param vs Optionally, the current vertical speed, in FPM.
     * @param alt Optionally, the current indicated altitude, in Feet.
     */
    activate(vs, alt) {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.setCaptureFpa(vs !== undefined ? vs : SimVar.GetSimVarValue('VERTICAL SPEED', SimVarValueType.FPM), alt !== undefined ? alt : SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet));
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        this.state = DirectorState.Armed;
        if (this.onArm !== undefined) {
            this.onArm();
        }
    }
    /**
     * Deactivates this director.
     * @param captured is whether the altitude was captured.
     */
    deactivate(captured = false) {
        this.state = DirectorState.Inactive;
        if (!captured) {
            SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', false);
        }
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.drivePitch && this.drivePitch(-this.captureAltitude(this.apValues.capturedAltitude.get(), SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet), this.initialFpa, SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots)), true, true);
        }
        else if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
        const selectedAltitude = this.apValues.selectedAltitude.get();
        const vs = SimVar.GetSimVarValue('VERTICAL SPEED', SimVarValueType.FPM);
        const alt = SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet);
        if (this.shouldActivate(vs, selectedAltitude, alt)) {
            this.apValues.capturedAltitude.set(Math.round(selectedAltitude));
            this.activate(vs, alt);
        }
    }
    /**
     * A function which returns true if the capturing shall be activated
     * @param vs Current vertical speed in [ft/min]
     * @param targetAltitude Target altitude [ft]
     * @param currentAltitude Current altitude [ft]
     * @returns True if the capturing shall be activated
     */
    static shouldActivate(vs, targetAltitude, currentAltitude) {
        return (Math.abs(targetAltitude - currentAltitude) <= Math.abs(vs / 6));
    }
    /**
     * Sets the initial capture FPA from the current vs value when capture is initiated.
     * @param vs The current vertical speed, in FPM.
     * @param alt The current indicated altitude, in Feet.
     */
    setCaptureFpa(vs, alt) {
        const altCapDeviation = alt - this.apValues.selectedAltitude.get();
        if (altCapDeviation < 0) {
            vs = Math.max(400, vs);
        }
        else {
            vs = Math.min(-400, vs);
        }
        const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.FPM);
        this.initialFpa = VNavUtils.getFpa(tas, vs);
    }
    /**
     * Calculates a desired pitch angle, in degrees, to capture a target altitude.
     * @param targetAltitude The altitude to capture, in feet.
     * @param indicatedAltitude The current indicated altitude, in feet.
     * @param initialFpa The flight path angle of the airplane, in degrees, when altitude capture was first activated.
     * Positive values indicate a descending path.
     * @param tas The current true airspeed of the airplane, in knots.
     * @returns The desired pitch angle, in degrees, to capture the specified altitude. Positive values indicate nose-up
     * pitch.
     */
    static captureAltitude(targetAltitude, indicatedAltitude, initialFpa, tas) {
        const initialFpaAbs = Math.abs(initialFpa);
        let deltaAltitude = targetAltitude - indicatedAltitude;
        if (deltaAltitude >= 0 && deltaAltitude < 10) {
            deltaAltitude = 10;
        }
        else if (deltaAltitude < 0 && deltaAltitude > -10) {
            deltaAltitude = -10;
        }
        const desiredClosureTime = MathUtils.lerp(Math.abs(deltaAltitude), 100, 1000, 5, 10, true, true);
        const desiredVs = deltaAltitude / (desiredClosureTime / 60);
        const desiredFpa = MathUtils.clamp(Math.asin(desiredVs / UnitType.KNOT.convertTo(tas, UnitType.FPM)) * Avionics.Utils.RAD2DEG, -initialFpaAbs, initialFpaAbs);
        return MathUtils.clamp(desiredFpa, -15, 15);
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * An altitude hold autopilot director.
 */
class APAltDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(apValues) {
        this.capturedAltitude = 0;
        this.setCapturedAltitude = (alt) => {
            this.capturedAltitude = Math.round(alt);
        };
        this.state = DirectorState.Inactive;
        this.capturedAltitudeSub = apValues.capturedAltitude.sub(this.setCapturedAltitude, true);
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.capturedAltitudeSub.resume(true);
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.capturedAltitudeSub.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        this.resumeSubs();
        this.state = DirectorState.Armed;
        if (this.onArm !== undefined) {
            this.onArm();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.holdAltitude(this.capturedAltitude);
        }
        if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
    }
    /**
     * Attempts to activate altitude capture.
     */
    tryActivate() {
        const deviationFromTarget = Math.abs(this.capturedAltitude - SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet));
        if (deviationFromTarget <= 20) {
            this.activate();
        }
    }
    /**
     * Holds a captured altitude.
     * @param targetAltitude is the captured targed altitude
     */
    holdAltitude(targetAltitude) {
        const deltaAlt = SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet) - targetAltitude;
        let setVerticalSpeed = 0;
        const correction = MathUtils.clamp(10 * Math.abs(deltaAlt), 100, 500);
        if (deltaAlt > 10) {
            setVerticalSpeed = 0 - correction;
        }
        else if (deltaAlt < -10) {
            setVerticalSpeed = correction;
        }
        this.drivePitch && this.drivePitch(this.getDesiredPitch(setVerticalSpeed), true, true);
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @param vs target vertical speed.
     * @returns The desired pitch angle.
     */
    getDesiredPitch(vs) {
        const desiredPitch = VNavUtils.getFpa(SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.FPM), vs);
        return -NavMath.clamp(desiredPitch, -10, 10);
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A Generic FLC computer to be used in directors that require FLC logic.
 */
class GenericFlcComputer {
    /**
     * Creates an instance of GenericFlcComputer.
     * @param pidControllerOptions The PID controller settings for this computer.
     */
    constructor(pidControllerOptions) {
        this._isActive = false;
        this._targetIas = 0;
        this._climbMode = false;
        this._pitchTarget = Subject.create(null);
        /** The current pitch target calculated by this computer, in degrees. Positive values indicate downward pitch. */
        this.pitchTarget = this._pitchTarget;
        this._lastTime = 0;
        this.filter = new ExpSmoother(2.5);
        // this.pitchController = new PidController(2, 0, 0, 15, -15);
        this.pitchController = new PidController(pidControllerOptions.kP, pidControllerOptions.kI, pidControllerOptions.kD, pidControllerOptions.maxOut, pidControllerOptions.minOut, pidControllerOptions.maxI, pidControllerOptions.minI);
    }
    /**
     * Gets if this computer is active
     * @returns if this computer is active.
     */
    get isActive() {
        return this._isActive;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This computer's target speed, in knots indicated airspeed. */
    get targetIas() {
        return this._targetIas;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * Whether this computer is in climb mode. In climb mode, the computer will not target a pitch that would cause the
     * airplane to descend. When not in climb mode, the computer will not target a pitch that would cause the airplane to
     * climb.
     */
    get isClimbMode() {
        return this._climbMode;
    }
    /**
     * Activates this computer.
     * @param climbMode Whether to force climb mode on (`true`) or off (`false`) on activation. If undefined, the climb
     * mode state will remain unchanged.
     */
    activate(climbMode) {
        this._isActive = true;
        if (climbMode !== undefined) {
            this._climbMode = climbMode;
        }
        this.initialize();
    }
    /**
     * Turns climb mode on or off.
     * @param setToClimbMode Whether climb mode should be turned on.
     */
    setClimbMode(setToClimbMode) {
        this._climbMode = setToClimbMode;
    }
    /**
     * Sets the target speed for this computer, in knots indicated airspeed.
     * @param ias The target speed to set, in knots indicated airspeed.
     */
    setTargetSpeed(ias) {
        this._targetIas = ias;
    }
    /**
     * Deactivates this computer.
     */
    deactivate() {
        this._isActive = false;
        this._pitchTarget.set(null);
    }
    /**
     * Initializes this director on activation.
     */
    initialize() {
        this._lastTime = 0;
        this.pitchController.reset();
        this.filter.reset();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this._isActive) {
            // negate the output value to conform with sim standard.
            this._pitchTarget.set(-this.getDesiredPitch());
        }
        else {
            this._pitchTarget.set(null);
        }
    }
    /**
     * Gets a desired pitch when airborne to maintain a given speed.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        const time = performance.now() / 1000;
        let dt = time - this._lastTime;
        if (this._lastTime === 0) {
            dt = 0;
        }
        const currentIas = SimVar.GetSimVarValue('AIRSPEED INDICATED:1', SimVarValueType.Knots);
        // remember PLANE PITCH DEGREES returns a negative value for up
        const currentPitch = -SimVar.GetSimVarValue('PLANE PITCH DEGREES', SimVarValueType.Degree);
        //step 1 - we want to find the IAS error from target and set a target acceleration
        const iasError = currentIas - this._targetIas;
        const targetAcceleration = MathUtils.clamp(iasError / 5, -2, 2) * -1;
        //step 2 - we want to find the current acceleration, feed that to the pid to manage to the target acceleration
        const acceleration = UnitType.FOOT.convertTo(SimVar.GetSimVarValue('ACCELERATION BODY Z', 'feet per second squared'), UnitType.NMILE) * 3600;
        const accelerationError = acceleration - targetAcceleration;
        const pitchCorrection = this.pitchController.getOutput(dt, accelerationError);
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        this._lastTime = time;
        let targetPitch = isNaN(pitchCorrection) ? currentPitch - aoa : (currentPitch - aoa) + pitchCorrection;
        targetPitch = this.filter.next(targetPitch, dt);
        if (this._climbMode) {
            return Math.max(targetPitch + aoa, aoa);
        }
        else {
            return Math.min(targetPitch + aoa, aoa);
        }
    }
}

/**
 * A Flight Level Change autopilot director.
 */
class APFLCDirector {
    /**
     * Creates a new instance of APFLCDirector.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxPitchUpAngle`: `15`
     * * `maxPitchDownAngle`: `15`
     * * `setSpeedOnActivation`: A function which sets the selected IAS or mach target to the airplane's current IAS or
     * mach, depending on whether IAS or mach is currently being targeted.
     */
    constructor(apValues, options) {
        var _a, _b, _c;
        this.apValues = apValues;
        this.setSpeedCommand = {
            ias: undefined,
            mach: undefined,
            isSelectedSpeedInMach: undefined
        };
        const maxPitchUpAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxPitchUpAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxPitchUpAngleOpt) {
            case 'number':
                this.maxPitchUpAngleFunc = () => maxPitchUpAngleOpt;
                break;
            case 'function':
                this.maxPitchUpAngleFunc = maxPitchUpAngleOpt;
                break;
            default:
                this.maxPitchUpAngleFunc = () => 15;
        }
        const maxPitchDownAngleOpt = (_b = options === null || options === void 0 ? void 0 : options.maxPitchDownAngle) !== null && _b !== void 0 ? _b : undefined;
        switch (typeof maxPitchDownAngleOpt) {
            case 'number':
                this.maxPitchDownAngleFunc = () => maxPitchDownAngleOpt;
                break;
            case 'function':
                this.maxPitchDownAngleFunc = maxPitchDownAngleOpt;
                break;
            default:
                this.maxPitchDownAngleFunc = () => 15;
        }
        this.setSpeedOnActivationFunc = (_c = options === null || options === void 0 ? void 0 : options.setSpeedOnActivation) !== null && _c !== void 0 ? _c : APFLCDirector.defaultSetSpeedOnActivation;
        this.state = DirectorState.Inactive;
        this.flcComputer = new GenericFlcComputer({ kP: 2, kI: 0, kD: 0, maxOut: 90, minOut: -90 });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        this.onActivate && this.onActivate();
        // Handle setting selected speed on activation.
        this.setSpeedCommand.ias = undefined;
        this.setSpeedCommand.mach = undefined;
        this.setSpeedCommand.isSelectedSpeedInMach = undefined;
        this.setSpeedOnActivationFunc(SimVar.GetSimVarValue('AIRSPEED INDICATED:1', SimVarValueType.Knots), SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number), this.apValues.isSelectedSpeedInMach.get(), this.setSpeedCommand);
        if (this.setSpeedCommand.ias !== undefined) {
            SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', SimVarValueType.Number, this.setSpeedCommand.ias);
        }
        if (this.setSpeedCommand.mach !== undefined) {
            SimVar.SetSimVarValue('K:AP_MACH_VAR_SET', SimVarValueType.Number, Math.round(this.setSpeedCommand.mach * 100));
        }
        if (this.setSpeedCommand.isSelectedSpeedInMach !== undefined) {
            SimVar.SetSimVarValue(this.setSpeedCommand.isSelectedSpeedInMach ? 'K:AP_MANAGED_SPEED_IN_MACH_ON' : 'K:AP_MANAGED_SPEED_IN_MACH_OFF', SimVarValueType.Number, 0);
        }
        // Activate sim FLC hold and initialize FLC computer climb mode state
        SimVar.SetSimVarValue('AUTOPILOT FLIGHT LEVEL CHANGE', 'Bool', true);
        const currentAltitude = SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet);
        this.flcComputer.activate(this.apValues.selectedAltitude.get() > currentAltitude);
    }
    /**
     * Arms this director.
     * This director can be armed, but it will never automatically activate and remain in the armed state.
     * Therefore we do not resume subs until activation.
     */
    arm() {
        this.state = DirectorState.Armed;
        this.onArm && this.onArm();
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT FLIGHT LEVEL CHANGE', 'Bool', false);
        this.flcComputer.deactivate();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state !== DirectorState.Active) {
            return;
        }
        const currentAltitude = SimVar.GetSimVarValue('INDICATED ALTITUDE', SimVarValueType.Feet);
        this.flcComputer.setClimbMode(this.apValues.selectedAltitude.get() > currentAltitude);
        if (this.apValues.isSelectedSpeedInMach.get()) {
            const mach = this.apValues.selectedMach.get();
            let ias = Simplane.getMachToKias(mach);
            if (!isFinite(ias)) {
                // Sometimes getMachToKias returns a NaN value. If so, fall back to doing the conversion ourselves.
                ias = AeroMath.machToCas(mach, SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.HPA));
            }
            this.flcComputer.setTargetSpeed(ias);
        }
        else {
            this.flcComputer.setTargetSpeed(this.apValues.selectedIas.get());
        }
        this.flcComputer.update();
        const pitchTarget = this.flcComputer.pitchTarget.get();
        // The flcComputer takes care of the aoa adjustment since it needs aoa anyhow,
        // and there is no vertical wind correction for an FLC mode.
        pitchTarget !== null && this.drivePitch && this.drivePitch(MathUtils.clamp(pitchTarget, -this.maxPitchUpAngleFunc(), this.maxPitchDownAngleFunc()), false, false);
    }
    /**
     * Executes default logic for setting selected speed targets when the FLC director is activated. If the current
     * selected speed target is in IAS, then the selected IAS target will be set to the airplane's current indicated
     * airspeed. If the current selected speed target is in mach, then the selected mach target will be set to the
     * airplane's current mach number.
     * @param currentIas The airplane's current indicated airspeed, in knots.
     * @param currentMach The airplane's current mach number.
     * @param isSelectedSpeedInMach Whether the current selected speed target is in mach.
     * @param command The command to set selected speed targets.
     */
    static defaultSetSpeedOnActivation(currentIas, currentMach, isSelectedSpeedInMach, command) {
        if (isSelectedSpeedInMach) {
            command.mach = currentMach;
        }
        else {
            command.ias = currentIas;
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A flight path angle autopilot director.
 */
class APFPADirector {
    /**
     * Creates an instance of the FPA Director.
     * @param apValues are the ap selected values for the autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxFpa`: `undefined`
     */
    constructor(apValues, options) {
        var _a;
        this.apValues = apValues;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxFpaFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxFpaFunc = maxBankAngleOpt;
                break;
            default:
                this.maxFpaFunc = () => Infinity;
        }
        this.selectedFpa = this.apValues.selectedFlightPathAngle.map(fpa => {
            const maxFpa = this.maxFpaFunc();
            return -MathUtils.clamp(fpa, -maxFpa, maxFpa);
        });
        this.state = DirectorState.Inactive;
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.selectedFpa.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.selectedFpa.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        const fpa = this.getCurrentFpa();
        SimVar.SetSimVarValue('L:WT_AP_FPA_Target:1', 'degree', fpa);
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        this.resumeSubs();
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.drivePitch && this.drivePitch(this.selectedFpa.get(), true, true);
        }
    }
    /**
     * Gets the current aircraft FPA.
     * @returns The current aircraft FPA, in degrees.
     */
    getCurrentFpa() {
        const aoa = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree);
        const pitch = -SimVar.GetSimVarValue('PLANE PITCH DEGREES', SimVarValueType.Degree);
        return pitch - aoa;
    }
}

/**
 * Sim var names for VNAV data.
 */
var VNavVars;
(function (VNavVars) {
    /** The vertical deviation in feet. */
    VNavVars["VerticalDeviation"] = "L:WTAP_VNav_Vertical_Deviation";
    /** The VNAV target altitude in feet. */
    VNavVars["TargetAltitude"] = "L:WTAP_VNav_Target_Altitude";
    /** The VNAV path mode. */
    VNavVars["PathMode"] = "L:WTAP_VNav_Path_Mode";
    /** The VNAV State. */
    VNavVars["VNAVState"] = "L:WTAP_VNav_State";
    /** Whether a VNAV Path Exists for the current leg. */
    VNavVars["PathAvailable"] = "L:WTAP_VNav_Path_Available";
    /** The VNAV current altitude capture type. */
    VNavVars["CaptureType"] = "L:WTAP_VNav_Alt_Capture_Type";
    /** The distance to the next TOD in meters, or -1 if one does not exist. */
    VNavVars["TODDistance"] = "L:WTAP_VNav_Distance_To_TOD";
    /** The distance to the next BOD in meters, or -1 if one does not exist. */
    VNavVars["BODDistance"] = "L:WTAP_VNav_Distance_To_BOD";
    /** The index of the leg for the next TOD. */
    VNavVars["TODLegIndex"] = "L:WTAP_VNav_TOD_Leg_Index";
    /** The distance from the end of the TOD leg that the TOD is, in meters. */
    VNavVars["TODDistanceInLeg"] = "L:WTAP_VNav_TOD_Distance_In_Leg";
    /** The index of the leg for the next BOD. */
    VNavVars["BODLegIndex"] = "L:WTAP_VNav_BOD_Leg_Index";
    /** The distance to the next TOC in meters, or -1 if one does not exist. */
    VNavVars["TOCDistance"] = "L:WTAP_VNav_Distance_To_TOC";
    /** The distance to the next BOC in meters, or -1 if one does not exist. */
    VNavVars["BOCDistance"] = "L:WTAP_VNav_Distance_To_BOC";
    /** The index of the leg for the next TOC. */
    VNavVars["TOCLegIndex"] = "L:WTAP_VNav_TOC_Leg_Index";
    /** The distance from the end of the TOC leg that the TOC is, in meters. */
    VNavVars["TOCDistanceInLeg"] = "L:WTAP_VNav_TOC_Distance_In_Leg";
    /** The index of the leg for the next BOC. */
    VNavVars["BOCLegIndex"] = "L:WTAP_VNav_BOC_Leg_Index";
    /** The index of the leg for the next constraint. */
    VNavVars["CurrentConstraintLegIndex"] = "L:WTAP_VNav_Constraint_Leg_Index";
    /** The current constraint altitude, in feet. */
    VNavVars["CurrentConstraintAltitude"] = "L:WTAP_VNav_Constraint_Altitude";
    /** The next constraint altitude, in feet. */
    VNavVars["NextConstraintAltitude"] = "L:WTAP_VNav_Next_Constraint_Altitude";
    /** The current required flight path angle, in degrees. */
    VNavVars["FPA"] = "L:WTAP_VNav_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["RequiredVS"] = "L:WTAP_VNAV_Required_VS";
    /** The VNAV approach guidance mode. */
    VNavVars["GPApproachMode"] = "L:WTAP_GP_Approach_Mode";
    /** The current LPV vertical deviation in feet. */
    VNavVars["GPVerticalDeviation"] = "L:WTAP_GP_Vertical_Deviation";
    /** The current remaining LPV distance in meters. */
    VNavVars["GPDistance"] = "L:WTAP_GP_Distance";
    /** The current LPV FPA, in degrees. */
    VNavVars["GPFpa"] = "L:WTAP_GP_FPA";
    /** The required VS to the current constraint, in FPM. */
    VNavVars["GPRequiredVS"] = "L:WTAP_GP_Required_VS";
    /** The approach glidepath service level. */
    VNavVars["GPServiceLevel"] = "L:WTAP_GP_Service_Level";
})(VNavVars || (VNavVars = {}));
/** A publisher for VNAV sim var events. */
class VNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(VNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
VNavSimVarPublisher.simvars = new Map([
    ['vnav_vertical_deviation', { name: VNavVars.VerticalDeviation, type: SimVarValueType.Feet }],
    ['vnav_target_altitude', { name: VNavVars.TargetAltitude, type: SimVarValueType.Feet }],
    ['vnav_path_mode', { name: VNavVars.PathMode, type: SimVarValueType.Number }],
    ['vnav_path_available', { name: VNavVars.PathAvailable, type: SimVarValueType.Bool }],
    ['vnav_state', { name: VNavVars.VNAVState, type: SimVarValueType.Number }],
    ['vnav_altitude_capture_type', { name: VNavVars.CaptureType, type: SimVarValueType.Number }],
    ['vnav_tod_distance', { name: VNavVars.TODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_leg_distance', { name: VNavVars.TODDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_bod_distance', { name: VNavVars.BODDistance, type: SimVarValueType.Meters }],
    ['vnav_tod_global_leg_index', { name: VNavVars.TODLegIndex, type: SimVarValueType.Number }],
    ['vnav_bod_global_leg_index', { name: VNavVars.BODLegIndex, type: SimVarValueType.Number }],
    ['vnav_toc_distance', { name: VNavVars.TOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_leg_distance', { name: VNavVars.TOCDistanceInLeg, type: SimVarValueType.Meters }],
    ['vnav_boc_distance', { name: VNavVars.BOCDistance, type: SimVarValueType.Meters }],
    ['vnav_toc_global_leg_index', { name: VNavVars.TOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_boc_global_leg_index', { name: VNavVars.BOCLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_global_leg_index', { name: VNavVars.CurrentConstraintLegIndex, type: SimVarValueType.Number }],
    ['vnav_constraint_altitude', { name: VNavVars.CurrentConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_next_constraint_altitude', { name: VNavVars.NextConstraintAltitude, type: SimVarValueType.Feet }],
    ['vnav_fpa', { name: VNavVars.FPA, type: SimVarValueType.Degree }],
    ['vnav_required_vs', { name: VNavVars.RequiredVS, type: SimVarValueType.FPM }],
    ['gp_approach_mode', { name: VNavVars.GPApproachMode, type: SimVarValueType.Number }],
    ['gp_vertical_deviation', { name: VNavVars.GPVerticalDeviation, type: SimVarValueType.Feet }],
    ['gp_distance', { name: VNavVars.GPDistance, type: SimVarValueType.Feet }],
    ['gp_fpa', { name: VNavVars.GPFpa, type: SimVarValueType.Degree }],
    ['gp_required_vs', { name: VNavVars.GPRequiredVS, type: SimVarValueType.FPM }],
    ['gp_service_level', { name: VNavVars.GPServiceLevel, type: SimVarValueType.Number }]
]);

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A glideslope autopilot director.
 */
class APGSDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues is the APValues object from the Autopilot.
     * @param options APGSDirector options.
     */
    constructor(bus, apValues, options) {
        var _a, _b, _c;
        this.bus = bus;
        this.apValues = apValues;
        this.sub = this.bus.getSubscriber();
        this.glideslope = ConsumerValue.create(null, { isValid: false, deviation: 0, gsAngle: 0, source: { index: 0, type: NavSourceType.Nav } });
        this.navLocation = new GeoPoint(NaN, NaN);
        this.state = DirectorState.Inactive;
        if (options === null || options === void 0 ? void 0 : options.forceNavSource) {
            this.navLocationSub = this.sub.on(`nav_radio_gs_location_${options.forceNavSource}`).handle(lla => this.navLocation.set(lla.lat, lla.long));
            this.glideslope.setConsumer(this.sub.on(`nav_radio_glideslope_${options.forceNavSource}`));
        }
        else {
            this.navLocationSub = this.sub.on('nav_radio_active_gs_location').handle(lla => this.navLocation.set(lla.lat, lla.long));
            this.glideslope.setConsumer(this.sub.on('nav_radio_active_glideslope'));
        }
        this.angleClosureRateFunc = (_a = options === null || options === void 0 ? void 0 : options.angleClosureRate) !== null && _a !== void 0 ? _a : APGSDirector.defaultAngleClosureRate;
        this.vsTargetFunc = options === null || options === void 0 ? void 0 : options.vsTarget;
        const vsUnit = this.vsTargetFunc ? UnitType.FPM : UnitType.MPS;
        this.minVs = UnitType.FPM.convertTo((_b = options === null || options === void 0 ? void 0 : options.minVs) !== null && _b !== void 0 ? _b : -3000, vsUnit);
        this.maxVs = UnitType.FPM.convertTo((_c = options === null || options === void 0 ? void 0 : options.maxVs) !== null && _c !== void 0 ? _c : 0, vsUnit);
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.navLocationSub.resume(true);
        this.glideslope.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.navLocationSub.pause();
        this.glideslope.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GSActive);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
    }
    /**
     * Arms this director.
     */
    arm() {
        this.resumeSubs();
        if (this.canArm() && this.state === DirectorState.Inactive) {
            this.state = DirectorState.Armed;
            SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GSArmed);
            if (this.onArm !== undefined) {
                this.onArm();
            }
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', true);
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
            SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.None);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Armed) {
            const glideslope = this.glideslope.get();
            if (this.apValues.lateralActive.get() === APLateralModes.LOC && this.glideslope !== undefined &&
                glideslope.isValid && glideslope.deviation <= 0.1 && glideslope.deviation >= -0.1) {
                this.activate();
            }
            if (!this.canArm()) {
                this.deactivate();
            }
        }
        if (this.state === DirectorState.Active) {
            if (this.apValues.lateralActive.get() !== APLateralModes.LOC) {
                this.deactivate();
            }
            this.trackGlideslope();
        }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
        const glideslope = this.glideslope.get();
        if ((this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) || (glideslope !== undefined && glideslope.isValid)) {
            return true;
        }
        return false;
    }
    /**
     * Tracks the Glideslope.
     */
    trackGlideslope() {
        const glideslope = this.glideslope.get();
        const location = this.navLocation;
        if (glideslope !== undefined && glideslope.isValid && !isNaN(location.lat + location.lon)) {
            const distanceM = UnitType.GA_RADIAN.convertTo(location.distance(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree)), UnitType.METER);
            // We want the height of the plane above the glideslope antenna, which we can calculate from distance,
            // glideslope angle, and glideslope error.
            const heightM = distanceM * Math.tan((glideslope.gsAngle + glideslope.deviation) * Avionics.Utils.DEG2RAD);
            const groundSpeedMps = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.MetersPerSecond);
            const vsMps = SimVar.GetSimVarValue('VERTICAL SPEED', SimVarValueType.MetersPerSecond);
            const hypotSq = distanceM * distanceM + heightM * heightM;
            const heightTimesGs = heightM * groundSpeedMps;
            const currentAngleRate = (vsMps * distanceM + heightTimesGs) / hypotSq;
            let targetVs;
            let unit;
            if (this.vsTargetFunc) {
                targetVs = this.vsTargetFunc(glideslope.deviation, glideslope.gsAngle, currentAngleRate, distanceM, heightM, groundSpeedMps, vsMps);
                unit = SimVarValueType.FPM;
            }
            else {
                const desiredClosureRate = this.angleClosureRateFunc(glideslope.deviation, glideslope.gsAngle, currentAngleRate, distanceM, heightM, groundSpeedMps, vsMps);
                const desiredAngleRate = Math.sign(glideslope.deviation) * -1 * desiredClosureRate;
                targetVs = (Avionics.Utils.DEG2RAD * desiredAngleRate * hypotSq - heightTimesGs) / distanceM;
                unit = SimVarValueType.MetersPerSecond;
            }
            targetVs = MathUtils.clamp(targetVs, this.minVs, this.maxVs);
            const pitchForVerticalSpeed = Math.asin(MathUtils.clamp(targetVs / SimVar.GetSimVarValue('AIRSPEED TRUE', unit), -1, 1)) * Avionics.Utils.RAD2DEG;
            const targetPitch = MathUtils.clamp(pitchForVerticalSpeed, -8, 3);
            this.drivePitch && this.drivePitch(-targetPitch, true, true);
        }
        else {
            this.deactivate();
        }
    }
    /**
     * A default function which calculates a desired angle closure rate, in degrees per second, to track a glideslope. The angle
     * closure rate is the rate of reduction of glideslope angle error. Positive values reduce glideslope angle error while
     * negative values increase glideslope angle error.
     * @param gsAngleError The glideslope angle error, in degrees, defined as the difference between the angle from the
     * glideslope antenna to the airplane and the glideslope angle. Positive values indicate deviation of the airplane
     * above the glideslope.
     * @returns The desired angle closure rate, in degrees per second, toward the glideslope.
     */
    static defaultAngleClosureRate(gsAngleError) {
        // We will target 0.1 degrees per second by default at full-scale deviation, decreasing linearly down to 0 at no
        // deviation. This is equivalent to a constant time-to-intercept of 7 seconds at full-scale deviation or less.
        return MathUtils.lerp(Math.abs(gsAngleError), 0, 0.7, 0, 0.1, true, true);
    }
}

/**
 * A heading autopilot director.
 */
class APHdgDirector {
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, options) {
        var _a, _b, _c;
        this.apValues = apValues;
        this.currentHeading = ConsumerValue.create(null, 0);
        this.toGaHeading = 0;
        this.lastHeadingDiff = undefined;
        this.lockedTurnDirection = undefined;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.turnReversalThreshold = (_b = options === null || options === void 0 ? void 0 : options.turnReversalThreshold) !== null && _b !== void 0 ? _b : 0;
        this.isToGaMode = (_c = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _c !== void 0 ? _c : false;
        this.currentHeading.setConsumer(bus.getSubscriber().on('hdg_deg').withPrecision(1));
        this.pauseSubs();
        this.state = DirectorState.Inactive;
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.currentHeading.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.currentHeading.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        if (!this.isToGaMode) {
            SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', true);
        }
        else {
            this.toGaHeading = this.currentHeading.get();
        }
        this.state = DirectorState.Active;
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    async deactivate() {
        this.pauseSubs();
        if (!this.isToGaMode) {
            await SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', false);
        }
        this.state = DirectorState.Inactive;
        this.lastHeadingDiff = undefined;
        this.lockedTurnDirection = undefined;
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            let bank;
            if (this.isToGaMode) {
                if (Simplane.getIsGrounded()) {
                    this.toGaHeading = this.currentHeading.get();
                }
                bank = this.desiredBank(this.toGaHeading);
            }
            else {
                bank = this.desiredBank(this.apValues.selectedHeading.get());
            }
            this.driveBankFunc(bank);
        }
    }
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    desiredBank(targetHeading) {
        const currentHeading = this.currentHeading.get();
        const headingDiff = MathUtils.diffAngleDeg(currentHeading, targetHeading);
        let turnDirection = undefined;
        let directionalHeadingDiff;
        if (this.lockedTurnDirection !== undefined) {
            turnDirection = this.lockedTurnDirection;
            directionalHeadingDiff = turnDirection === 'left' ? (360 - headingDiff) % 360 : headingDiff;
            if (directionalHeadingDiff >= this.turnReversalThreshold) {
                turnDirection = undefined;
            }
            else if (this.lastHeadingDiff !== undefined) {
                // Check if the heading difference passed through zero in the positive to negative direction since the last
                // update. If so, we may need to issue a turn reversal.
                const headingDiffDelta = (MathUtils.diffAngleDeg(this.lastHeadingDiff, directionalHeadingDiff) + 180) % 360 - 180; // -180 to +180
                if (this.lastHeadingDiff + headingDiffDelta < 0) {
                    turnDirection = undefined;
                }
            }
        }
        if (turnDirection === undefined) {
            turnDirection = NavMath.getTurnDirection(currentHeading, targetHeading);
            directionalHeadingDiff = turnDirection === 'left' ? (360 - headingDiff) % 360 : headingDiff;
        }
        if (this.turnReversalThreshold > 180) {
            this.lockedTurnDirection = turnDirection;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.lastHeadingDiff = directionalHeadingDiff;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let baseBank = Math.min(1.25 * directionalHeadingDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
}

/**
 * An autopilot heading hold director.
 * Levels the wings upon activation, and then holds the captured heading
 */
class APHdgHoldDirector {
    /**
     * Creates an instance of the heading hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, options) {
        var _a;
        this.apValues = apValues;
        this.currentHeading = 0;
        this.currentBank = 0;
        /** heading captured at wings level, or null if not yet captured */
        this.capturedHeading = null;
        this.currentBankSub = bus.getSubscriber().on('roll_deg').withPrecision(1).handle((bank) => this.currentBank = bank);
        this.currentHeadingSub = bus.getSubscriber().on('hdg_deg').withPrecision(0).handle((h) => this.currentHeading = h);
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.state = DirectorState.Inactive;
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.currentHeadingSub.resume(true);
        this.currentBankSub.resume(true);
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.currentHeadingSub.pause();
        this.currentBankSub.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        this.capturedHeading = null;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            if (this.capturedHeading === null && Math.abs(this.currentBank) < APHdgHoldDirector.MIN_BANK_THRESHOLD) {
                this.capturedHeading = this.currentHeading;
            }
            this.driveBankFunc(this.capturedHeading !== null ? this.desiredBank(this.capturedHeading) : 0);
        }
    }
    /**
     * Gets a desired bank from a Target Selected Heading.
     * @param targetHeading The target heading.
     * @returns The desired bank angle.
     */
    desiredBank(targetHeading) {
        const turnDirection = NavMath.getTurnDirection(this.currentHeading, targetHeading);
        const headingDiff = Math.abs(NavMath.diffAngle(this.currentHeading, targetHeading));
        let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
}
/** bank angle below which we capture the heading */
APHdgHoldDirector.MIN_BANK_THRESHOLD = 1;

/**
 * A Nav/Loc autopilot director.
 */
class APNavDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param mode The APLateralMode for this instance of the director.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, mode, options) {
        var _a, _b;
        this.bus = bus;
        this.apValues = apValues;
        this.mode = mode;
        this.sub = this.bus.getSubscriber();
        this.obs = ConsumerValue.create(null, { heading: 0, source: { index: 0, type: NavSourceType.Nav } });
        this.cdi = ConsumerValue.create(null, { source: { index: 0, type: NavSourceType.Nav }, deviation: null });
        this.loc = ConsumerValue.create(null, { isValid: false, course: 0, source: { index: 0, type: NavSourceType.Nav } });
        this.deviationSimVar = 'NAV CDI:1';
        this.radialErrorSimVar = 'NAV RADIAL ERROR:1';
        this.magVar = ConsumerValue.create(null, 0);
        this.navLocation = new GeoPoint(NaN, NaN);
        this.isNavLock = Subject.create(false);
        this.state = DirectorState.Inactive;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
        this.disableArming = (_b = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _b !== void 0 ? _b : false;
        this.forceNavSource = options === null || options === void 0 ? void 0 : options.forceNavSource;
        this.isNavLock.sub((newState) => {
            if (SimVar.GetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool') !== newState) {
                SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', newState);
            }
        });
        if (this.forceNavSource !== undefined) {
            this.navSource = {
                index: this.forceNavSource,
                type: NavSourceType.Nav,
            };
            this.obs.setConsumer(this.sub.on(`nav_radio_obs_${this.forceNavSource}`));
            this.cdi.setConsumer(this.sub.on(`nav_radio_cdi_${this.forceNavSource}`));
            this.loc.setConsumer(this.sub.on(`nav_radio_localizer_${this.forceNavSource}`));
            this.magVar.setConsumer(this.sub.on(`nav_radio_magvar_${this.forceNavSource}`));
            this.navLocationSub = this.sub.on(`nav_radio_nav_location_${this.forceNavSource}`).handle(lla => this.navLocation.set(lla.lat, lla.long));
            this.deviationSimVar = `NAV CDI:${this.forceNavSource}`;
            this.radialErrorSimVar = `NAV RADIAL ERROR:${this.forceNavSource}`;
        }
        else {
            this.navSource = {
                index: 0,
                type: NavSourceType.Nav,
            };
            this.sub.on('cdi_select').handle(source => {
                this.navSource = source;
                if (source.type === NavSourceType.Nav) {
                    this.deviationSimVar = `NAV CDI:${source.index}`;
                    this.radialErrorSimVar = `NAV RADIAL ERROR:${source.index}`;
                }
            });
            this.obs.setConsumer(this.sub.on('nav_radio_active_obs_setting'));
            this.cdi.setConsumer(this.sub.on('nav_radio_active_cdi_deviation'));
            this.loc.setConsumer(this.sub.on('nav_radio_active_localizer'));
            this.magVar.setConsumer(this.sub.on('nav_radio_active_magvar'));
            this.navLocationSub = this.sub.on('nav_radio_active_nav_location').handle(lla => this.navLocation.set(lla.lat, lla.long));
        }
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.navLocationSub.resume(true);
        this.cdi.resume();
        this.loc.resume();
        this.magVar.resume();
        this.obs.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.navLocationSub.pause();
        this.cdi.pause();
        this.loc.pause();
        this.magVar.pause();
        this.obs.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.setNavLock(true);
        this.state = DirectorState.Active;
    }
    /**
     * Arms this director.
     */
    arm() {
        this.resumeSubs();
        if (this.state === DirectorState.Inactive && this.canArm()) {
            this.state = DirectorState.Armed;
            if (this.onArm !== undefined) {
                this.onArm();
            }
            this.setNavLock(true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.setNavLock(false);
        this.pauseSubs();
    }
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState) {
        this.isNavLock.set(newState);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Armed) {
            if (!this.canArm()) {
                this.deactivate();
            }
            else if (this.disableArming || this.canActivate()) {
                this.activate();
            }
        }
        if (this.state === DirectorState.Active) {
            if (!this.canRemainActive()) {
                this.deactivate();
            }
            else {
                const desiredBank = this.desiredBank();
                if (isFinite(desiredBank)) {
                    this.driveBankFunc(desiredBank);
                }
            }
        }
    }
    /**
     * Checks whether this director can be armed.
     * @returns Whether this director can be armed.
     */
    canArm() {
        const cdi = this.cdi.get();
        const loc = this.loc.get();
        const obs = this.obs.get();
        const typeIsCorrect = this.navSource.type === NavSourceType.Nav;
        if (this.mode === APLateralModes.LOC && typeIsCorrect) {
            if (this.navSource.index === cdi.source.index && loc.isValid && this.navSource.index === loc.source.index) {
                return true;
            }
        }
        if (this.mode === APLateralModes.VOR && typeIsCorrect) {
            if (this.navSource.index === cdi.source.index && !loc.isValid && this.navSource.index === obs.source.index) {
                return true;
            }
        }
        if (this.mode === APLateralModes.LOC && this.apValues.navToNavLocArm && this.apValues.navToNavLocArm()) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether this director can be activated from an armed state.
     * @returns Whether this director can be activated from an armed state.
     */
    canActivate() {
        var _a;
        const cdi = this.cdi.get();
        const loc = this.loc.get();
        const obs = this.obs.get();
        const typeIsCorrect = this.navSource.type === NavSourceType.Nav;
        const index = this.navSource.index;
        const indexIsCorrect = index == cdi.source.index
            && ((loc.isValid && index == loc.source.index) || (!loc.isValid && index == obs.source.index));
        if (typeIsCorrect && indexIsCorrect && cdi.deviation !== null && Math.abs(cdi.deviation) < 127 && (loc.isValid || obs.heading !== null)) {
            const dtk = loc.isValid ? loc.course * Avionics.Utils.RAD2DEG : obs.heading;
            if (dtk === null || dtk === undefined) {
                return false;
            }
            const headingDiff = NavMath.diffAngle(SimVar.GetSimVarValue('PLANE HEADING DEGREES MAGNETIC', SimVarValueType.Degree), dtk);
            const isLoc = (_a = loc.isValid) !== null && _a !== void 0 ? _a : false;
            const sensitivity = isLoc ? 1 : .6;
            if (Math.abs(cdi.deviation * sensitivity) < 127 && Math.abs(headingDiff) < 110) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks whether this director can remain active.
     * @returns Whether this director can remain active.
     */
    canRemainActive() {
        if (this.navSource.type !== NavSourceType.Nav) {
            return false;
        }
        const cdi = this.cdi.get();
        const loc = this.loc.get();
        if (this.mode === APLateralModes.LOC) {
            if (this.navSource.index === cdi.source.index && loc.isValid && this.navSource.index == loc.source.index) {
                return true;
            }
        }
        else if (this.mode === APLateralModes.VOR) {
            if (this.navSource.index === cdi.source.index && !loc.isValid && this.navSource.index == this.obs.get().source.index) {
                return true;
            }
        }
        return false;
    }
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    desiredBank() {
        var _a;
        const cdi = this.cdi.get();
        const loc = this.loc.get();
        const obs = this.obs.get();
        const isLoc = (_a = loc.isValid) !== null && _a !== void 0 ? _a : false;
        const hasValidDeviation = cdi.deviation !== null && Math.abs(cdi.deviation) < 127;
        const hasValidObs = obs.heading !== null;
        let zoneOfConfusion = false;
        if (isLoc && !hasValidDeviation) {
            this.deactivate();
            return NaN;
        }
        const distanceToSource = this.getNavDistance();
        if (!isLoc && (!hasValidDeviation || !hasValidObs)) {
            if (!this.isInZoneOfConfusion(distanceToSource, cdi.deviation)) {
                this.deactivate();
                return NaN;
            }
            else {
                zoneOfConfusion = true;
            }
        }
        if (zoneOfConfusion || cdi.deviation !== null) {
            const courseMag = isLoc ? loc.course * Avionics.Utils.RAD2DEG : obs.heading;
            if (courseMag === null || courseMag === undefined) {
                this.deactivate();
                return NaN;
            }
            const radialError = SimVar.GetSimVarValue(this.radialErrorSimVar, SimVarValueType.Radians);
            const xtk = zoneOfConfusion ? 0 : distanceToSource * Math.sin(-radialError);
            let absInterceptAngle = 0;
            if (this.lateralInterceptCurve !== undefined) {
                absInterceptAngle = this.lateralInterceptCurve(distanceToSource, SimVar.GetSimVarValue(this.deviationSimVar, SimVarValueType.Number) / 127, xtk, SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots), isLoc);
            }
            else {
                absInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + (Math.abs(xtk) * 50), 45);
                if (absInterceptAngle <= 2.5) {
                    absInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
                }
            }
            const interceptAngle = xtk > 0 ? -absInterceptAngle : absInterceptAngle;
            const desiredTrack = NavMath.normalizeHeading(MagVar.magneticToTrue(courseMag, this.magVar.get()) + interceptAngle);
            const trueTrack = GNSSPublisher.getInstantaneousTrack();
            const turnDirection = NavMath.getTurnDirection(trueTrack, desiredTrack);
            const trackDiff = Math.abs(NavMath.diffAngle(trueTrack, desiredTrack));
            let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
            baseBank *= (turnDirection === 'left' ? 1 : -1);
            return baseBank;
        }
        this.deactivate();
        return NaN;
    }
    /**
     * Gets the lateral distance from PPOS to the nav signal.
     * @returns The distance value in nautical miles.
     */
    getNavDistance() {
        if (!isNaN(this.navLocation.lat)) {
            return UnitType.GA_RADIAN.convertTo(this.navLocation.distance(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree)), UnitType.NMILE);
        }
        else {
            return 5;
        }
    }
    /**
     * Checks whether the airplane is in the zone of confusion.
     * @param distanceToSource The distance from the airplane to the tuned station, in nautical miles.
     * @param deviation The course deviation reported by the tuned station, or `null` if deviation is not available.
     * @returns Whether the airplane is in the zone of confusion.
     */
    isInZoneOfConfusion(distanceToSource, deviation) {
        return distanceToSource < 2 && deviation !== null;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * An autopilot pitch director.
 */
class APPitchDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues are the AP Values subjects.
     * @param pitchIncrement is the pitch increment, in degrees, to use when the user presses the pitch inc/dec keys (default: 0.5)
     * @param minPitch is the negative minimum pitch angle, in degrees, to clamp the pitch to. (default: -15)
     * @param maxPitch is the positive maximum pitch angle, in degrees, to clamp the pitch to. (default: 20)
     */
    constructor(bus, apValues, pitchIncrement = 0.5, minPitch = -15, maxPitch = 20) {
        this.apValues = apValues;
        this.pitchIncrement = pitchIncrement;
        this.minPitch = minPitch;
        this.maxPitch = maxPitch;
        this.selectedPitch = 0;
        this.state = DirectorState.Inactive;
        this.apValues.selectedPitch.sub((p) => {
            this.selectedPitch = p;
            if (this.state == DirectorState.Active) {
                // send it in again to make sure its clamped
                this.setPitch && this.setPitch(p);
            }
        });
        // setup inc/dec event intercept
        KeyEventManager.getManager(bus).then(manager => {
            this.keyEventManager = manager;
            manager.interceptKey('AP_PITCH_REF_INC_UP', false);
            manager.interceptKey('AP_PITCH_REF_INC_DN', false);
            const keySub = bus.getSubscriber();
            keySub.on('key_intercept').handle(this.onKeyIntercepted.bind(this));
        });
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        const currentPitch = SimVar.GetSimVarValue('PLANE PITCH DEGREES', SimVarValueType.Degree);
        this.setPitch && this.setPitch(MathUtils.clamp(currentPitch, -this.maxPitch, -this.minPitch));
        SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', false);
    }
    /**
     * Responds to key intercepted events.
     * @param k the key event data
     */
    onKeyIntercepted(k) {
        switch (k.key) {
            case 'AP_PITCH_REF_INC_UP':
            case 'AP_PITCH_REF_INC_DN':
                this.setPitch && this.setPitch(this.selectedPitch + (k.key === 'AP_PITCH_REF_INC_UP' ? -this.pitchIncrement : this.pitchIncrement));
                break;
            default:
                return;
        }
    }
    /**
     * Updates this director.
     */
    update() {
        //noop
    }
}

/**
 * An autopilot roll director.
 */
class APRollDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param apValues The AP Values.
     * @param options Options to configure the new director.
     */
    constructor(apValues, options) {
        var _a;
        this.apValues = apValues;
        this.currentBankRef = 0;
        this.desiredBank = 0;
        this.actualBank = 0;
        const minBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.minBankAngle) !== null && _a !== void 0 ? _a : 0;
        if (typeof minBankAngleOpt === 'number') {
            this.minBankAngleFunc = () => minBankAngleOpt;
        }
        else {
            this.minBankAngleFunc = minBankAngleOpt;
        }
        const maxBankAngleOpt = options === null || options === void 0 ? void 0 : options.maxBankAngle;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        this.actualBank = SimVar.GetSimVarValue('PLANE BANK DEGREES', SimVarValueType.Degree);
        this.currentBankRef = this.actualBank;
        const maxBank = this.maxBankAngleFunc();
        const minBank = this.minBankAngleFunc();
        if (Math.abs(this.currentBankRef) < minBank) {
            this.desiredBank = 0;
        }
        else {
            this.desiredBank = MathUtils.clamp(this.currentBankRef, -maxBank, maxBank);
        }
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT BANK HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.desiredBank = 0;
        SimVar.SetSimVarValue('AUTOPILOT BANK HOLD', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.driveBankFunc(this.desiredBank);
        }
    }
}

/**
 * A heading autopilot director.
 */
class APTrkDirector {
    /**
     * Creates a new instance of APHdgDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, options) {
        var _a, _b, _c;
        this.bus = bus;
        this.apValues = apValues;
        this.toGaTrack = 0;
        this.magVar = ConsumerValue.create(null, 0);
        this.lastTrackDiff = undefined;
        this.lockedTurnDirection = undefined;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.turnReversalThreshold = (_b = options === null || options === void 0 ? void 0 : options.turnReversalThreshold) !== null && _b !== void 0 ? _b : 0;
        this.isToGaMode = (_c = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _c !== void 0 ? _c : false;
        this.state = DirectorState.Inactive;
        this.magVar.setConsumer(this.bus.getSubscriber().on('magvar'));
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.magVar.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.magVar.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        if (!this.isToGaMode) {
            SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', true);
        }
        else {
            this.toGaTrack = this.getMagneticTrack();
        }
        this.state = DirectorState.Active;
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    async deactivate() {
        if (!this.isToGaMode) {
            await SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', false);
        }
        this.state = DirectorState.Inactive;
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            let bank = 0;
            if (this.isToGaMode) {
                if (Simplane.getIsGrounded()) {
                    this.toGaTrack = this.getMagneticTrack();
                }
                else {
                    bank = this.desiredBank(this.toGaTrack);
                }
            }
            else {
                bank = this.desiredBank(this.apValues.selectedHeading.get());
            }
            this.driveBankFunc(bank);
        }
    }
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    desiredBank(targetTrack) {
        const currentTrack = this.getMagneticTrack();
        const trackDiff = MathUtils.diffAngleDeg(currentTrack, targetTrack);
        let turnDirection = undefined;
        let directionalTrackDiff;
        if (this.lockedTurnDirection !== undefined) {
            turnDirection = this.lockedTurnDirection;
            directionalTrackDiff = turnDirection === 'left' ? (360 - trackDiff) % 360 : trackDiff;
            if (directionalTrackDiff >= this.turnReversalThreshold) {
                turnDirection = undefined;
            }
            else if (this.lastTrackDiff !== undefined) {
                // Check if the track difference passed through zero in the positive to negative direction since the last
                // update. If so, we may need to issue a turn reversal.
                const trackDiffDelta = (MathUtils.diffAngleDeg(this.lastTrackDiff, directionalTrackDiff) + 180) % 360 - 180; // -180 to +180
                if (this.lastTrackDiff + trackDiffDelta < 0) {
                    turnDirection = undefined;
                }
            }
        }
        if (turnDirection === undefined) {
            turnDirection = NavMath.getTurnDirection(currentTrack, targetTrack);
            directionalTrackDiff = turnDirection === 'left' ? (360 - trackDiff) % 360 : trackDiff;
        }
        if (this.turnReversalThreshold > 180) {
            this.lockedTurnDirection = turnDirection;
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.lastTrackDiff = directionalTrackDiff;
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        let baseBank = Math.min(1.25 * directionalTrackDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
    /**
     * Gets the instantanious magnetic track.
     * @returns Magnetic Track, in degrees.
     */
    getMagneticTrack() {
        const trueTrack = GNSSPublisher.getInstantaneousTrack();
        return NavMath.normalizeHeading(trueTrack - this.magVar.get());
    }
}

/**
 * An autopilot track hold director.
 * Levels the wings upon activation, and then holds the captured track
 */
class APTrkHoldDirector {
    /**
     * Creates an instance of the track hold director.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `isToGaMode`: `false`
     */
    constructor(bus, apValues, options) {
        var _a;
        this.bus = bus;
        this.apValues = apValues;
        this.magVar = ConsumerValue.create(null, 0);
        /** track captured at wings level, or null if not yet captured */
        this.capturedTrack = null;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.state = DirectorState.Inactive;
        this.magVar.setConsumer(this.bus.getSubscriber().on('magvar'));
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.magVar.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.magVar.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        this.capturedTrack = null;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT HEADING LOCK', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            if (this.capturedTrack === null) {
                const currentBank = SimVar.GetSimVarValue('PLANE BANK DEGREES', SimVarValueType.Degree);
                if (Math.abs(currentBank) < APTrkHoldDirector.MIN_BANK_THRESHOLD) {
                    this.capturedTrack = this.getMagneticTrack();
                }
            }
            this.driveBankFunc(this.capturedTrack !== null ? this.desiredBank(this.capturedTrack) : 0);
        }
    }
    /**
     * Gets a desired bank from a Target Selected Track.
     * @param targetTrack The target track.
     * @returns The desired bank angle.
     */
    desiredBank(targetTrack) {
        const magneticTrack = this.getMagneticTrack();
        const turnDirection = NavMath.getTurnDirection(magneticTrack, targetTrack);
        const trackDiff = Math.abs(NavMath.diffAngle(magneticTrack, targetTrack));
        let baseBank = Math.min(1.25 * trackDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
    /**
     * Gets the instantanious magnetic track.
     * @returns Magnetic Track, in degrees.
     */
    getMagneticTrack() {
        const trueTrack = GNSSPublisher.getInstantaneousTrack();
        return NavMath.normalizeHeading(trueTrack - this.magVar.get());
    }
}
/** bank angle below which we capture the track */
APTrkHoldDirector.MIN_BANK_THRESHOLD = 1;

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A vertical speed autopilot director.
 */
class APVSDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param apValues are the ap selected values for the autopilot.
     * @param vsIncrement The number that vertical speed can be incremented by, in feet per minute.
     * Upon activation, the actual vs will be rounded using this increment.
     * If undefined, the value will not be rounded before passed to the sim. Defaults to undefined.
     */
    constructor(apValues, vsIncrement = undefined) {
        this.apValues = apValues;
        this.vsIncrement = vsIncrement;
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        const currentVs = this.vsIncrement === undefined
            ? Simplane.getVerticalSpeed()
            : MathUtils.round(Simplane.getVerticalSpeed(), this.vsIncrement);
        Coherent.call('AP_VS_VAR_SET_ENGLISH', 1, currentVs);
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue('AUTOPILOT VERTICAL HOLD', 'Bool', false);
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.drivePitch && this.drivePitch(this.getDesiredPitch(), true, true);
        }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        const tas = SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.Knots);
        const desiredPitch = this.getFpa(UnitType.NMILE.convertTo(tas / 60, UnitType.FOOT), this.apValues.selectedVerticalSpeed.get());
        return -MathUtils.clamp(isNaN(desiredPitch) ? 0 : desiredPitch, -15, 15);
    }
    /**
     * Gets a desired fpa.
     * @param distance is the distance traveled per minute.
     * @param altitude is the vertical speed per minute.
     * @returns The desired pitch angle.
     */
    getFpa(distance, altitude) {
        return UnitType.RADIAN.convertTo(Math.atan(altitude / distance), UnitType.DEGREE);
    }
}

/**
 * A bank angle controller that maintains a constant radius turn.
 */
class ArcTurnController {
    constructor() {
        this.bankController = new PidController(1.5, 0, 0, 15, -15);
        this.precessionController = new PidController(0.025, 0, 0, 300, -300);
        this.filter = new ExpSmoother(500);
    }
    /**
     * Gets the bank angle output for a given radius error.
     * @param radiusError The radius error.
     * @returns The bank angle output.
     */
    getOutput(radiusError) {
        var _a;
        const currentTime = new Date().appTime();
        let bankAngle = 0;
        if (this.previousRadiusError !== undefined && this.previousTime !== undefined) {
            const dTime = currentTime - this.previousTime;
            const input = ((radiusError - this.previousRadiusError) / dTime) * 1000;
            const precessionRate = isNaN((_a = this.filter.last()) !== null && _a !== void 0 ? _a : NaN)
                ? this.filter.reset(input)
                : this.filter.next(input, dTime);
            const targetPrecessionRate = -this.precessionController.getOutput(dTime, radiusError);
            const precessionError = targetPrecessionRate - precessionRate;
            bankAngle = this.bankController.getOutput(dTime, precessionError);
        }
        this.previousTime = currentTime;
        this.previousRadiusError = radiusError;
        return -bankAngle;
    }
    /**
     * Resets the controller.
     */
    reset() {
        this.previousTime = undefined;
        this.previousRadiusError = undefined;
        this.precessionController.reset();
        this.bankController.reset();
        this.filter.reset();
    }
}

/**
 * A class that handles lateral navigation.
 */
class LNavDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues The AP Values.
     * @param flightPlanner The flight planner to use with this instance.
     * @param obsDirector The OBS Director.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, flightPlanner, obsDirector, options) {
        var _a, _b, _c, _d, _e;
        this.bus = bus;
        this.apValues = apValues;
        this.flightPlanner = flightPlanner;
        this.obsDirector = obsDirector;
        this.vec3Cache = [new Float64Array(3), new Float64Array(3)];
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.publisher = this.bus.getPublisher();
        this.aircraftState = {
            tas: 0,
            gs: 0,
            track: 0,
            magvar: 0,
            windSpeed: 0,
            windDirection: 0,
            planePos: new GeoPoint(0, 0),
            hdgTrue: 0,
            altAgl: 0,
            bank: 0
        };
        this.currentLeg = undefined;
        this.currentVector = undefined;
        this.dtk = 0;
        this.xtk = 0;
        this.bearingToVectorEnd = 0;
        this.courseToSteer = 0;
        this.alongVectorDistance = 0;
        this.vectorDistanceRemaining = 0;
        this.vectorAnticipationDistance = 0;
        this.alongTrackSpeed = 0;
        this.anticipationVector = undefined;
        this.anticipationDtk = 0;
        this.anticipationXtk = 0;
        this.anticipationBearingToVectorEnd = 0;
        this.inhibitNextSequence = false;
        this.currentState = {
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: false,
            inhibitedSuspendLegIndex: -1,
            resetVectorsOnSuspendEnd: false,
            isMissedApproachActive: false
        };
        this.anticipationState = {
            globalLegIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            isSuspended: false,
            inhibitedSuspendLegIndex: -1,
            resetVectorsOnSuspendEnd: false,
            isMissedApproachActive: false
        };
        this.currentBankAngleState = {
            arcController: new ArcTurnController(),
            isInterceptingFromArmedState: false,
            trackAtActivation: 0,
            desiredBankAngle: 0
        };
        this.lnavData = ObjectSubject.create({
            dtk: 0,
            xtk: 0,
            trackingState: {
                isTracking: false,
                globalLegIndex: 0,
                transitionMode: LNavTransitionMode.None,
                vectorIndex: 0,
                isSuspended: false
            },
            isTracking: false,
            legIndex: 0,
            transitionMode: LNavTransitionMode.None,
            vectorIndex: 0,
            courseToSteer: 0,
            isSuspended: false,
            alongLegDistance: 0,
            legDistanceRemaining: 0,
            alongVectorDistance: 0,
            vectorDistanceRemaining: 0,
            vectorAnticipationDistance: 0,
            alongTrackSpeed: 0
        });
        this.isObsDirectorTracking = false;
        this.canArm = false;
        this.awaitCalculateId = 0;
        this.isAwaitingCalculate = false;
        this.isAwaitingCalculatePublished = false;
        this.isNavLock = Subject.create(false);
        this.lnavDataHandler = (obj, key, value) => {
            switch (key) {
                case 'dtk':
                    SimVar.SetSimVarValue(LNavVars.DTK, SimVarValueType.Degree, value);
                    break;
                case 'xtk':
                    SimVar.SetSimVarValue(LNavVars.XTK, SimVarValueType.NM, value);
                    break;
                case 'isTracking':
                    SimVar.SetSimVarValue(LNavVars.IsTracking, SimVarValueType.Bool, value);
                    break;
                case 'legIndex':
                    SimVar.SetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number, value);
                    break;
                case 'transitionMode':
                    SimVar.SetSimVarValue(LNavVars.TransitionMode, SimVarValueType.Number, value);
                    break;
                case 'vectorIndex':
                    SimVar.SetSimVarValue(LNavVars.TrackedVectorIndex, SimVarValueType.Number, value);
                    break;
                case 'courseToSteer':
                    SimVar.SetSimVarValue(LNavVars.CourseToSteer, SimVarValueType.Degree, value);
                    break;
                case 'isSuspended':
                    SimVar.SetSimVarValue(LNavVars.IsSuspended, SimVarValueType.Bool, value);
                    break;
                case 'alongLegDistance':
                    SimVar.SetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM, value);
                    break;
                case 'legDistanceRemaining':
                    SimVar.SetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM, value);
                    break;
                case 'alongVectorDistance':
                    SimVar.SetSimVarValue(LNavVars.VectorDistanceAlong, SimVarValueType.NM, value);
                    break;
                case 'vectorDistanceRemaining':
                    SimVar.SetSimVarValue(LNavVars.VectorDistanceRemaining, SimVarValueType.NM, value);
                    break;
                case 'vectorAnticipationDistance':
                    SimVar.SetSimVarValue(LNavVars.VectorAnticipationDistance, SimVarValueType.NM, value);
                    break;
                case 'alongTrackSpeed':
                    SimVar.SetSimVarValue(LNavVars.AlongTrackSpeed, SimVarValueType.Knots, value);
                    break;
                case 'trackingState':
                    this.publisher.pub('lnav_tracking_state', value, true, true);
                    break;
            }
        };
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
        this.hasVectorAnticipation = (_b = options === null || options === void 0 ? void 0 : options.hasVectorAnticipation) !== null && _b !== void 0 ? _b : false;
        this.minimumActivationAltitude = options === null || options === void 0 ? void 0 : options.minimumActivationAltitude;
        this.disableArming = (_c = options === null || options === void 0 ? void 0 : options.disableArming) !== null && _c !== void 0 ? _c : false;
        this.disableAutoSuspendAtMissedApproachPoint = (_d = options === null || options === void 0 ? void 0 : options.disableAutoSuspendAtMissedApproachPoint) !== null && _d !== void 0 ? _d : false;
        this.vectorAnticipationBankRate = (_e = options === null || options === void 0 ? void 0 : options.vectorAnticipationBankRate) !== null && _e !== void 0 ? _e : 5;
        const sub = bus.getSubscriber();
        this.lnavData.sub(this.lnavDataHandler, true);
        sub.on('ambient_wind_velocity').handle(w => this.aircraftState.windSpeed = w);
        sub.on('ambient_wind_direction').handle(wd => this.aircraftState.windDirection = wd);
        sub.on('tas').handle(tas => this.aircraftState.tas = tas);
        sub.on('hdg_deg_true').handle(hdg => this.aircraftState.hdgTrue = hdg);
        sub.on('ground_speed').handle(gs => this.aircraftState.gs = gs);
        sub.on('radio_alt').handle(alt => this.aircraftState.altAgl = alt);
        sub.on('roll_deg').handle(roll => this.aircraftState.bank = roll);
        const nav = this.bus.getSubscriber();
        nav.on('cdi_select').handle((src) => {
            if (this.state !== DirectorState.Inactive && src.type !== NavSourceType.Gps) {
                this.deactivate();
            }
        });
        sub.on('suspend_sequencing').handle(suspend => {
            const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
            if (flightPlan) {
                // We are receiving an explicit command to suspend, so clear any suspend inhibits.
                if (suspend) {
                    this.currentState.inhibitedSuspendLegIndex = -1;
                }
                this.trySetSuspended(flightPlan, this.currentState, suspend, this.currentState, false, false);
            }
        });
        sub.on('activate_missed_approach').handle((v) => {
            this.currentState.isMissedApproachActive = v;
        });
        sub.on('lnav_inhibit_next_sequence').handle(inhibit => {
            this.inhibitNextSequence = inhibit;
            if (inhibit) {
                this.currentState.inhibitedSuspendLegIndex = -1;
            }
        });
        sub.on('fplActiveLegChange').handle(e => {
            if (e.planIndex === this.flightPlanner.activePlanIndex && e.type === ActiveLegType.Lateral) {
                this.currentState.inhibitedSuspendLegIndex = -1;
                this.resetVectors();
            }
        });
        sub.on('fplIndexChanged').handle(() => {
            this.resetVectors();
        });
        sub.on('fplCopied').handle((e) => {
            if (e.targetPlanIndex === this.flightPlanner.activePlanIndex) {
                this.resetVectors();
            }
        });
        sub.on('gps-position').handle(lla => {
            this.aircraftState.planePos.set(lla.lat, lla.long);
        });
        sub.on('track_deg_true').handle(t => this.aircraftState.track = t);
        sub.on('magvar').handle(m => this.aircraftState.magvar = m);
        this.isNavLock.sub((newState) => {
            if (SimVar.GetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool') !== newState) {
                SimVar.SetSimVarValue('AUTOPILOT NAV1 LOCK', 'Bool', newState);
            }
        });
        if (this.obsDirector !== undefined) {
            this.obsDirector.driveBank = this.obsDriveBank.bind(this);
        }
        this.state = DirectorState.Inactive;
        this.isAwaitingCalculatePublished = this.isAwaitingCalculate;
        this.publisher.pub('lnav_is_awaiting_calc', this.isAwaitingCalculate, true, true);
    }
    /**
     * Resets the current vectors and transition mode.
     */
    resetVectors() {
        this.currentState.vectorIndex = 0;
        this.currentState.transitionMode = LNavTransitionMode.Ingress;
        this.inhibitNextSequence = false;
        this.awaitCalculate();
    }
    /**
     * Activates the LNAV director.
     */
    activate() {
        this.currentBankAngleState.isInterceptingFromArmedState = !this.disableArming;
        this.currentBankAngleState.trackAtActivation = this.aircraftState.track;
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.setNavLock(true);
    }
    /**
     * Arms the LNAV director.
     */
    arm() {
        if (this.state === DirectorState.Inactive) {
            this.currentBankAngleState.isInterceptingFromArmedState = false;
            if (this.canArm) {
                this.state = DirectorState.Armed;
                if (this.onArm !== undefined) {
                    this.onArm();
                }
                this.setNavLock(true);
            }
        }
    }
    /**
     * Deactivates the LNAV director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        if (this.obsDirector && this.obsDirector.state !== DirectorState.Inactive) {
            this.obsDirector.deactivate();
        }
        this.currentBankAngleState.isInterceptingFromArmedState = false;
        this.setNavLock(false);
    }
    /**
     * Sets the NAV1 Lock state.
     * @param newState The new state of the NAV1 lock.
     */
    setNavLock(newState) {
        this.isNavLock.set(newState);
    }
    /**
     * Updates the lateral director.
     */
    update() {
        var _a;
        if (this.isAwaitingCalculatePublished !== this.isAwaitingCalculate) {
            this.isAwaitingCalculatePublished = this.isAwaitingCalculate;
            this.publisher.pub('lnav_is_awaiting_calc', this.isAwaitingCalculate, true, true);
        }
        let clearInhibitNextSequence = false;
        const flightPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
        this.currentState.globalLegIndex = flightPlan ? flightPlan.activeLateralLeg : 0;
        let isTracking = !!flightPlan && this.currentState.globalLegIndex <= flightPlan.length - 1;
        if (flightPlan && isTracking) {
            if (this.isAwaitingCalculate) {
                return;
            }
            this.currentLeg = flightPlan.getLeg(this.currentState.globalLegIndex);
            // We don't want to clear the inhibit next sequence flag until the active leg has been calculated
            // since we never sequence through non-calculated legs.
            clearInhibitNextSequence = !!this.currentLeg.calculated;
            this.calculateTracking(flightPlan);
            if (this.isAwaitingCalculate) {
                return;
            }
            if (this.hasVectorAnticipation) {
                this.updateVectorAnticipation(flightPlan);
            }
            isTracking = this.currentState.globalLegIndex < flightPlan.length
                && this.currentVector !== undefined
                && this.currentVector.radius > LNavDirector.ANGULAR_TOLERANCE
                && this.currentVector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
            if (isTracking) {
                const calcs = this.currentLeg.calculated;
                if (this.obsDirector) {
                    this.obsDirector.setLeg(this.currentState.globalLegIndex, this.currentLeg);
                    if (this.obsDirector.obsActive) {
                        this.currentState.isSuspended = true;
                        this.currentState.inhibitedSuspendLegIndex = this.currentState.globalLegIndex;
                        if (!this.isObsDirectorTracking) {
                            this.lnavData.unsub(this.lnavDataHandler);
                            this.isObsDirectorTracking = true;
                            this.obsDirector.startTracking();
                        }
                        if (this.state === DirectorState.Active && this.obsDirector.state !== DirectorState.Active) {
                            this.obsDirector.activate();
                            this.setNavLock(true);
                        }
                        if (this.state === DirectorState.Armed && this.obsDirector.canActivate()) {
                            this.obsDirector.activate();
                            this.state = DirectorState.Active;
                            if (this.onActivate !== undefined) {
                                this.onActivate();
                            }
                            this.setNavLock(true);
                        }
                        this.obsDirector.update();
                        return;
                    }
                }
                isTracking = calcs !== undefined;
                if (this.state !== DirectorState.Inactive) {
                    this.navigateFlightPath();
                }
            }
        }
        else {
            // We can't be suspended if there is no flight plan or the active leg is past the end of the flight plan.
            this.currentState.isSuspended = false;
            clearInhibitNextSequence = true;
        }
        // If we have reached this point and isObsDirectorTracking is true, then it means that OBS was just deactivated.
        if (this.isObsDirectorTracking) {
            this.currentState.isSuspended = false;
        }
        this.canArm = isTracking;
        this.lnavData.set('isTracking', isTracking);
        this.lnavData.set('isSuspended', this.currentState.isSuspended);
        if (isTracking) {
            const trackingState = this.lnavData.get().trackingState;
            if (trackingState.isTracking !== isTracking
                || trackingState.globalLegIndex !== this.currentState.globalLegIndex
                || trackingState.transitionMode !== this.currentState.transitionMode
                || trackingState.vectorIndex !== this.currentState.vectorIndex
                || trackingState.isSuspended !== this.currentState.isSuspended) {
                this.lnavData.set('trackingState', {
                    isTracking: isTracking,
                    globalLegIndex: this.currentState.globalLegIndex,
                    transitionMode: this.currentState.transitionMode,
                    vectorIndex: this.currentState.vectorIndex,
                    isSuspended: this.currentState.isSuspended
                });
            }
            this.lnavData.set('dtk', this.dtk);
            this.lnavData.set('xtk', this.xtk);
            this.lnavData.set('legIndex', this.currentState.globalLegIndex);
            this.lnavData.set('vectorIndex', this.currentState.vectorIndex);
            this.lnavData.set('transitionMode', this.currentState.transitionMode);
            this.lnavData.set('courseToSteer', this.courseToSteer);
            this.lnavData.set('alongVectorDistance', this.alongVectorDistance);
            this.lnavData.set('vectorDistanceRemaining', this.vectorDistanceRemaining);
            this.lnavData.set('vectorAnticipationDistance', this.vectorAnticipationDistance);
            this.lnavData.set('alongTrackSpeed', this.alongTrackSpeed);
            this.lnavData.set('alongLegDistance', this.getAlongLegDistance(flightPlan, this.currentState, this.alongVectorDistance));
            this.lnavData.set('legDistanceRemaining', this.getLegDistanceRemaining(flightPlan, this.currentState, this.vectorDistanceRemaining));
        }
        else {
            this.currentLeg = undefined;
            this.currentVector = undefined;
            const trackingState = this.lnavData.get().trackingState;
            if (trackingState.isTracking
                || trackingState.globalLegIndex !== 0
                || trackingState.transitionMode !== LNavTransitionMode.None
                || trackingState.vectorIndex !== 0
                || trackingState.isSuspended !== this.currentState.isSuspended) {
                this.lnavData.set('trackingState', {
                    isTracking: false,
                    globalLegIndex: 0,
                    transitionMode: LNavTransitionMode.None,
                    vectorIndex: 0,
                    isSuspended: this.currentState.isSuspended
                });
            }
            this.lnavData.set('dtk', 0);
            this.lnavData.set('xtk', 0);
            this.lnavData.set('legIndex', 0);
            this.lnavData.set('vectorIndex', 0);
            this.lnavData.set('transitionMode', LNavTransitionMode.None);
            this.lnavData.set('courseToSteer', 0);
            this.lnavData.set('alongLegDistance', 0);
            this.lnavData.set('vectorDistanceRemaining', 0);
            this.lnavData.set('alongVectorDistance', 0);
            this.lnavData.set('legDistanceRemaining', 0);
            this.lnavData.set('vectorAnticipationDistance', 0);
            this.lnavData.set('alongTrackSpeed', 0);
        }
        // If we have reached this point and isObsDirectorTracking is true, then it means that OBS was just deactivated.
        if (this.isObsDirectorTracking) {
            (_a = this.obsDirector) === null || _a === void 0 ? void 0 : _a.stopTracking();
            this.lnavData.sub(this.lnavDataHandler, true);
            this.isObsDirectorTracking = false;
        }
        if (this.state === DirectorState.Armed) {
            this.tryActivate();
        }
        this.inhibitNextSequence && (this.inhibitNextSequence = !clearInhibitNextSequence);
    }
    /**
     * Navigates the currently tracked flight path.
     */
    navigateFlightPath() {
        let bankAngle;
        if (this.anticipationVector
            && this.vectorAnticipationDistance > 0
            && this.vectorDistanceRemaining <= this.vectorAnticipationDistance
            // Do not fly the anticipated vector if our current-vector crosstrack error is greater than the anticipated
            // vector's radius. This keeps us from flying the wrong "side" of an anticipated vector.
            && Math.abs(this.xtk) < UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE)) {
            this.updateBankAngle(this.anticipationVector, this.anticipationDtk, this.anticipationXtk, this.anticipationBearingToVectorEnd, this.currentBankAngleState);
            bankAngle = this.currentBankAngleState.desiredBankAngle;
        }
        if (bankAngle === undefined) {
            if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
                return;
            }
            this.updateBankAngle(this.currentVector, this.dtk, this.xtk, this.bearingToVectorEnd, this.currentBankAngleState);
            bankAngle = this.currentBankAngleState.desiredBankAngle;
        }
        if (this.state === DirectorState.Active) {
            this.driveBankFunc(bankAngle);
        }
    }
    /**
     * Updates a bank angle state for a tracked flight path vector.
     * @param vector The tracked flight path vector.
     * @param dtk The desired track, in degrees true.
     * @param xtk The cross-track error, in nautical miles.
     * @param bearingToVectorEnd The bearing from the airplane to the end of the tracked vector, in degrees true.
     * @param bankAngleState The bank angle state to udpate.
     * @returns The updated bank angle state.
     */
    updateBankAngle(vector, dtk, xtk, bearingToVectorEnd, bankAngleState) {
        let absInterceptAngle;
        let naturalAbsInterceptAngle = 0;
        if (this.lateralInterceptCurve !== undefined) {
            naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.aircraftState.tas);
        }
        else {
            naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + (Math.abs(xtk) * 50), 45);
            if (naturalAbsInterceptAngle <= 2.5) {
                naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
            }
        }
        if (bankAngleState.isInterceptingFromArmedState) {
            absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
            if (absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5 || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))) {
                absInterceptAngle = naturalAbsInterceptAngle;
                bankAngleState.isInterceptingFromArmedState = false;
            }
        }
        else {
            absInterceptAngle = naturalAbsInterceptAngle;
        }
        const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
        bankAngleState.desiredBankAngle = this.desiredBank(courseToSteer);
        if (vector !== undefined && !FlightPathUtils.isVectorGreatCircle(vector)) {
            this.adjustBankAngleForArc(vector, bankAngleState);
        }
        return bankAngleState;
    }
    /**
     * Gets a desired bank from a desired track.
     * @param desiredTrack The desired track.
     * @returns The desired bank angle.
     */
    desiredBank(desiredTrack) {
        const turnDirection = NavMath.getTurnDirection(this.aircraftState.track, desiredTrack);
        const headingDiff = Math.abs(NavMath.diffAngle(this.aircraftState.track, desiredTrack));
        let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
    /**
     * Adjusts a bank angle state's desired bank angle for arc vectors.
     * @param vector The arc vector to adjust for.
     * @param bankAngleState The bank angle state to adjust.
     * @returns The adjusted bank angle state.
     */
    adjustBankAngleForArc(vector, bankAngleState) {
        const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
        const turnDirection = FlightPathUtils.getTurnDirectionFromCircle(circle);
        const radius = UnitType.GA_RADIAN.convertTo(FlightPathUtils.getTurnRadiusFromCircle(circle), UnitType.METER);
        const relativeWindHeading = NavMath.normalizeHeading(this.aircraftState.windDirection - this.aircraftState.hdgTrue);
        const headwind = this.aircraftState.windSpeed * Math.cos(relativeWindHeading * Avionics.Utils.DEG2RAD);
        const distance = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.METER);
        const bankAdjustment = bankAngleState.arcController.getOutput(distance);
        const turnBankAngle = NavMath.bankAngle(this.aircraftState.tas - headwind, radius) * (turnDirection === 'left' ? 1 : -1);
        const turnRadius = NavMath.turnRadius(this.aircraftState.tas - headwind, 25);
        const bankBlendFactor = Math.max(1 - (Math.abs(UnitType.NMILE.convertTo(this.xtk, UnitType.METER)) / turnRadius), 0);
        const maxBank = this.maxBankAngleFunc();
        bankAngleState.desiredBankAngle = MathUtils.clamp((bankAngleState.desiredBankAngle * (1 - bankBlendFactor)) + (turnBankAngle * bankBlendFactor) + bankAdjustment, -maxBank, maxBank);
        return bankAngleState;
    }
    /**
     * Calculates the tracking from the current leg.
     * @param plan The active flight plan.
     */
    calculateTracking(plan) {
        var _a, _b;
        let didAdvance;
        do {
            didAdvance = false;
            if (!this.currentLeg) {
                break;
            }
            // Don't really need to fly the intial leg?
            if (this.currentLeg.leg.type === LegType.IF && this.currentState.globalLegIndex === 0 && plan.length > 1) {
                this.currentLeg = plan.getLeg(++this.currentState.globalLegIndex);
                plan.setCalculatingLeg(this.currentState.globalLegIndex);
                plan.setLateralLeg(this.currentState.globalLegIndex);
                continue;
            }
            const transitionMode = this.currentState.transitionMode;
            const legIndex = this.currentState.globalLegIndex;
            const vectorIndex = this.currentState.vectorIndex;
            const isSuspended = this.currentState.isSuspended;
            const calcs = this.currentLeg.calculated;
            if (calcs) {
                const vectors = LNavUtils.getVectorsForTransitionMode(calcs, this.currentState.transitionMode, this.currentState.isSuspended);
                const vector = vectors[this.currentState.vectorIndex];
                const isVectorValid = vector && vector.radius > LNavDirector.ANGULAR_TOLERANCE && vector.distance > LNavDirector.ANGULAR_TOLERANCE_METERS;
                const isUnsuspendInvalid = this.currentState.transitionMode === LNavTransitionMode.Unsuspend
                    && (calcs.ingress.length === 0 || calcs.flightPath[calcs.ingressJoinIndex] === undefined);
                if (isVectorValid && !isUnsuspendInvalid) {
                    const planePos = this.aircraftState.planePos;
                    const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                    const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                    let endLat, endLon;
                    let end;
                    let vectorDistanceNM;
                    // If we are in unsuspend mode and tracking the vector at which the ingress transition joins the base flight
                    // path, then we treat the point at which the ingress joins the vector as the de-facto end of the vector,
                    // because at that point we want to sequence into the ingress-to-egress vector array. In all other cases,
                    // we use the entire length of the tracked vector.
                    if (transitionMode === LNavTransitionMode.Unsuspend && vectorIndex === calcs.ingressJoinIndex && calcs.ingress.length > 0) {
                        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
                        endLat = lastIngressVector.endLat;
                        endLon = lastIngressVector.endLon;
                        end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
                        vectorDistanceNM = UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.NMILE);
                    }
                    else {
                        endLat = vector.endLat;
                        endLon = vector.endLon;
                        end = GeoPoint.sphericalToCartesian(endLat, endLon, this.vec3Cache[1]);
                        vectorDistanceNM = UnitType.METER.convertTo(vector.distance, UnitType.NMILE);
                    }
                    this.xtk = UnitType.GA_RADIAN.convertTo(circle.distance(planePos), UnitType.NMILE);
                    this.dtk = circle.bearingAt(planePos, Math.PI);
                    this.bearingToVectorEnd = planePos.bearingTo(endLat, endLon);
                    const alongTrackSpeed = FlightPathUtils.projectVelocityToCircle(this.aircraftState.gs, planePos, this.aircraftState.track, circle);
                    this.alongTrackSpeed = isNaN(alongTrackSpeed) ? this.aircraftState.gs : alongTrackSpeed;
                    const normDist = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, planePos);
                    this.alongVectorDistance = normDist * vectorDistanceNM;
                    this.vectorDistanceRemaining = (1 - normDist) * vectorDistanceNM;
                    if (normDist > 1) {
                        this.advanceToNextVector(plan, this.currentState, true, this.currentState);
                    }
                }
                else {
                    this.alongVectorDistance = 0;
                    this.vectorDistanceRemaining = 0;
                    this.vectorAnticipationDistance = 0;
                    this.advanceToNextVector(plan, this.currentState, true, this.currentState);
                }
                didAdvance = transitionMode !== this.currentState.transitionMode
                    || legIndex !== this.currentState.globalLegIndex
                    || vectorIndex !== this.currentState.vectorIndex
                    || isSuspended !== this.currentState.isSuspended;
                if (legIndex !== this.currentState.globalLegIndex) {
                    this.currentLeg = (_a = plan.tryGetLeg(this.currentState.globalLegIndex)) !== null && _a !== void 0 ? _a : undefined;
                    plan.setCalculatingLeg(this.currentState.globalLegIndex);
                    plan.setLateralLeg(this.currentState.globalLegIndex);
                }
            }
        } while (!this.isAwaitingCalculate && didAdvance && this.currentState.globalLegIndex <= plan.length - 1);
        if (this.currentState.transitionMode === LNavTransitionMode.Egress
            && this.currentState.globalLegIndex + 1 < plan.length
            && plan.activeCalculatingLeg !== this.currentState.globalLegIndex + 1) {
            plan.setCalculatingLeg(this.currentState.globalLegIndex + 1);
        }
        this.currentVector = ((_b = this.currentLeg) === null || _b === void 0 ? void 0 : _b.calculated)
            ? LNavUtils.getVectorsForTransitionMode(this.currentLeg.calculated, this.currentState.transitionMode, this.currentState.isSuspended)[this.currentState.vectorIndex]
            : undefined;
    }
    /**
     * Updates this director's vector anticipation data, including the anticipation distance, DTK and XTK for the
     * anticipated vector, and bearing from the airplane to the end of the anticipated vector.
     * @param plan The active flight plan.
     */
    updateVectorAnticipation(plan) {
        var _a;
        this.anticipationVector = undefined;
        this.vectorAnticipationDistance = 0;
        this.anticipationDtk = 0;
        this.anticipationXtk = 0;
        this.anticipationBearingToVectorEnd = 0;
        if (!this.currentVector || this.currentVector.radius === 0 || this.currentVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
            return;
        }
        // Find the vector that will be tracked after we sequence past the current one.
        this.advanceToNextVector(plan, this.currentState, false, this.anticipationState);
        const anticipationCalcs = (_a = plan.tryGetLeg(this.anticipationState.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
        if (!anticipationCalcs) {
            return;
        }
        const anticipationVectors = LNavUtils.getVectorsForTransitionMode(anticipationCalcs, this.anticipationState.transitionMode, this.anticipationState.isSuspended);
        this.anticipationVector = anticipationVectors[this.anticipationState.vectorIndex];
        if (!this.anticipationVector
            || this.anticipationVector === this.currentVector
            || this.anticipationVector.radius === 0
            || this.anticipationVector.distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
            this.anticipationVector = undefined;
            return;
        }
        const circle = FlightPathUtils.setGeoCircleFromVector(this.anticipationVector, this.geoCircleCache[0]);
        this.anticipationXtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.aircraftState.planePos), UnitType.NMILE);
        this.anticipationDtk = circle.bearingAt(this.aircraftState.planePos, Math.PI);
        this.anticipationBearingToVectorEnd = this.aircraftState.planePos.bearingTo(this.anticipationVector.endLat, this.anticipationVector.endLon);
        // Find the bank angles that are required to keep the airplane following the current and anticipated vectors
        // assuming zero XTK error and wind. Then approximate how long it will take the airplane to roll from one to the
        // other -> this will be the anticipation time. Finally, convert the anticipation time to a distance by multiplying
        // by along-track speed.
        const maxBankAngle = this.maxBankAngleFunc();
        const currentVectorIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.currentVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
        const anticipationIdealBankAngle = MathUtils.clamp(LNavDirector.getVectorIdealBankAngle(this.anticipationVector, this.aircraftState.gs), -maxBankAngle, maxBankAngle);
        const deltaBank = Math.abs(currentVectorIdealBankAngle - anticipationIdealBankAngle);
        const rollTimeSeconds = deltaBank / this.vectorAnticipationBankRate;
        this.vectorAnticipationDistance = Math.min(rollTimeSeconds / 3600 * this.alongTrackSpeed, 
        // Limit vector anticipation to the radius of the anticipated vector so that we don't start flying anticipated
        // arc/turn vectors too early with a large XTK error and veer off in the wrong direction.
        UnitType.GA_RADIAN.convertTo(FlightPathUtils.getVectorTurnRadius(this.anticipationVector), UnitType.NMILE));
    }
    /**
     * Applies suspends that apply at the end of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying end-of-leg suspends.
     */
    applyEndOfLegSuspends(plan, state, out) {
        if (state !== out) {
            LNavDirector.copyStateInfo(state, out);
        }
        const leg = plan.tryGetLeg(state.globalLegIndex);
        if (!leg) {
            return out;
        }
        // Do not allow suspend on thru discontinuities.
        const inhibitNextSequence = this.inhibitNextSequence
            && leg.leg.type !== LegType.ThruDiscontinuity;
        if (leg.leg.type === LegType.FM || leg.leg.type === LegType.VM || leg.leg.type === LegType.Discontinuity) {
            return this.trySetSuspended(plan, state, true, out, true, false);
        }
        else if (inhibitNextSequence) {
            return this.trySetSuspended(plan, state, true, out, false, true);
        }
        else if (state.globalLegIndex < plan.length - 1) {
            const nextLeg = plan.getLeg(state.globalLegIndex + 1);
            if (!this.disableAutoSuspendAtMissedApproachPoint
                && !state.isMissedApproachActive
                && (leg.leg.fixTypeFlags === FixTypeFlags.MAP
                    || (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach) && BitFlags.isAll(nextLeg.flags, LegDefinitionFlags.MissedApproach)))) {
                return this.trySetSuspended(plan, state, true, out, true, false);
            }
        }
        return out;
    }
    /**
     * Applies suspends that apply at the beginning of a leg.
     * @param plan The active flight plan.
     * @param state The current LNAV state.
     * @param out The LNAV state to which to write.
     * @returns The LNAV state after applying start-of-leg suspends.
     */
    applyStartOfLegSuspends(plan, state, out) {
        if (state !== out) {
            LNavDirector.copyStateInfo(state, out);
        }
        const leg = plan.getLeg(state.globalLegIndex);
        if (!leg) {
            return out;
        }
        if (leg.leg.type === LegType.HM || state.globalLegIndex === plan.length - 1) {
            return this.trySetSuspended(plan, state, true, out, false, false);
        }
        return out;
    }
    /**
     * Advances an LNAV state to the next trackable vector.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param awaitCalculateOnNextLeg Whether to await leg calculations when advancing to the next leg. If `true`, the
     * state will only advance as far as the first vector of the next leg.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next trackable vector.
     */
    advanceToNextVector(plan, state, awaitCalculateOnNextLeg, out) {
        var _a, _b, _c, _d, _e, _f;
        if (state !== out) {
            LNavDirector.copyStateInfo(state, out);
        }
        let leg = plan.tryGetLeg(state.globalLegIndex);
        if (!leg) {
            return out;
        }
        let legIndex = state.globalLegIndex;
        let transitionMode = state.transitionMode;
        let isSuspended = state.isSuspended;
        let vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : undefined;
        let vectorIndex = state.vectorIndex + 1;
        let vectorEndIndex = (_a = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _a !== void 0 ? _a : 0;
        let didAdvance = false;
        let isDone = false;
        // If we are in unsuspended mode, we are tracking the base flight path vector array, and we want to switch to the
        // ingress-to-egress array when we reach the vector at which the ingress transition joins the base flight path.
        if (transitionMode === LNavTransitionMode.Unsuspend && leg.calculated) {
            if (leg.calculated.ingressJoinIndex < 0) {
                vectorEndIndex = 0;
            }
            else {
                const ingress = leg.calculated.ingress;
                const ingressJoinVector = leg.calculated.flightPath[leg.calculated.ingressJoinIndex];
                // If the ingress joins the base flight path at the beginning of the joined vector, then we want to switch to
                // the ingress-to-egress array once we reach the joined vector. Otherwise, we want to switch when we pass the
                // joined vector.
                if (ingress.length > 0
                    && ingressJoinVector
                    && GeoPoint.equals(ingress[ingress.length - 1].endLat, ingress[ingress.length - 1].endLon, ingressJoinVector.startLat, ingressJoinVector.startLon)) {
                    vectorEndIndex = leg.calculated.ingressJoinIndex;
                }
                else {
                    vectorEndIndex = leg.calculated.ingressJoinIndex + 1;
                }
            }
        }
        // Continue advancing until we reach a vector with non-zero radius and distance.
        while (!vectors || vectorIndex >= vectorEndIndex || vectors[vectorIndex].radius === 0 || vectors[vectorIndex].distance <= LNavDirector.ANGULAR_TOLERANCE_METERS) {
            switch (transitionMode) {
                case LNavTransitionMode.Ingress:
                    transitionMode = LNavTransitionMode.None;
                    vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : undefined;
                    vectorIndex = Math.max(0, isSuspended ? (_c = (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.ingressJoinIndex) !== null && _c !== void 0 ? _c : 0 : 0);
                    didAdvance = true;
                    break;
                case LNavTransitionMode.Unsuspend:
                    transitionMode = LNavTransitionMode.None;
                    vectors = (_d = leg.calculated) === null || _d === void 0 ? void 0 : _d.ingressToEgress;
                    vectorIndex = 0;
                    didAdvance = true;
                    break;
                case LNavTransitionMode.None:
                    if (!isSuspended) {
                        transitionMode = LNavTransitionMode.Egress;
                        vectors = leg.calculated ? LNavUtils.getVectorsForTransitionMode(leg.calculated, transitionMode, isSuspended) : undefined;
                        vectorIndex = 0;
                        didAdvance = true;
                    }
                    else if (leg.leg.type === LegType.HM) {
                        vectors = (_e = leg.calculated) === null || _e === void 0 ? void 0 : _e.flightPath;
                        vectorIndex = 0;
                        didAdvance = true;
                    }
                    else {
                        if (!didAdvance && vectors) {
                            vectorIndex = Math.max(0, vectors.length - 1);
                        }
                        isDone = true;
                    }
                    break;
                case LNavTransitionMode.Egress:
                    out.globalLegIndex = legIndex;
                    out.transitionMode = transitionMode;
                    out.vectorIndex = vectorIndex;
                    out.isSuspended = isSuspended;
                    this.advanceToNextLeg(plan, out, out);
                    // If we are awaiting calculate when advancing to the next leg or if we can't advance to the next leg,
                    // we are done since either way we cannot advance any farther.
                    if (awaitCalculateOnNextLeg || out.globalLegIndex === legIndex) {
                        return out;
                    }
                    leg = plan.tryGetLeg(out.globalLegIndex);
                    if (!(leg === null || leg === void 0 ? void 0 : leg.calculated)) {
                        // If the next leg is not calculated yet, we can't advance any farther because we don't know what the
                        // vectors will be when the leg is calculated.
                        return out;
                    }
                    else {
                        legIndex = out.globalLegIndex;
                        transitionMode = out.transitionMode;
                        vectors = LNavUtils.getVectorsForTransitionMode(leg.calculated, out.transitionMode, out.isSuspended);
                        vectorIndex = out.vectorIndex;
                        isSuspended = out.isSuspended;
                        didAdvance = false;
                    }
            }
            if (isDone) {
                break;
            }
            vectorEndIndex = (_f = vectors === null || vectors === void 0 ? void 0 : vectors.length) !== null && _f !== void 0 ? _f : 0;
        }
        out.globalLegIndex = legIndex;
        out.transitionMode = transitionMode;
        out.vectorIndex = vectorIndex;
        out.isSuspended = isSuspended;
        return out;
    }
    /**
     * Advances an LNAV state to the next leg.
     * @param plan The active flight plan.
     * @param state The state from which to advance.
     * @param out The state to which to write the results.
     * @returns The LNAV state after advancing to the next leg.
     */
    advanceToNextLeg(plan, state, out) {
        var _a, _b, _c;
        this.applyEndOfLegSuspends(plan, state, out);
        if (!out.isSuspended) {
            if (out.globalLegIndex + 1 >= plan.length) {
                out.transitionMode = LNavTransitionMode.None;
                out.vectorIndex = Math.max(0, ((_c = (_b = (_a = plan.tryGetLeg(out.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) !== null && _c !== void 0 ? _c : 0) - 1);
                return out;
            }
            out.globalLegIndex++;
            out.transitionMode = LNavTransitionMode.Ingress;
            out.vectorIndex = 0;
            out.inhibitedSuspendLegIndex = -1;
            this.applyStartOfLegSuspends(plan, out, out);
        }
        return out;
    }
    /**
     * Attempts to activate/deactivate suspend on an LNAV state.
     * @param plan The active flight plan.
     * @param state The state for which to set suspended.
     * @param suspend The suspended state to set.
     * @param out The state to which to write the results.
     * @param inhibitResuspend Whether to inhibit resuspend of the suspended leg once suspend ends on that leg. Ignored
     * if `suspend` is `false`. Defaults to `false`.
     * @param resetVectorsOnSuspendEnd Whether to reset the tracked vector to the beginning of the suspended leg once
     * suspend ends on that leg. Ignored if `suspend` is `false`. Defaults to `false`.
     * @returns The LNAV state after the suspend state has been set.
     */
    trySetSuspended(plan, state, suspend, out, inhibitResuspend = false, resetVectorsOnSuspendEnd = false) {
        var _a;
        if (state !== out) {
            LNavDirector.copyStateInfo(state, out);
        }
        if (suspend && state.globalLegIndex === state.inhibitedSuspendLegIndex) {
            return out;
        }
        if (suspend) {
            out.inhibitedSuspendLegIndex = inhibitResuspend ? state.globalLegIndex : -1;
            out.resetVectorsOnSuspendEnd = resetVectorsOnSuspendEnd;
        }
        if (state.isSuspended !== suspend) {
            out.isSuspended = suspend;
            if (!suspend && state.resetVectorsOnSuspendEnd) {
                out.transitionMode = LNavTransitionMode.None;
                out.vectorIndex = 0;
                out.resetVectorsOnSuspendEnd = false;
            }
            else {
                const leg = plan.tryGetLeg(state.globalLegIndex);
                const legCalc = leg === null || leg === void 0 ? void 0 : leg.calculated;
                const ingressJoinVector = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath[legCalc.ingressJoinIndex];
                if (legCalc
                    && state.transitionMode === LNavTransitionMode.None
                    && legCalc.ingressJoinIndex >= 0
                    && ingressJoinVector
                    && legCalc.ingress.length > 0) {
                    // Because we are switching between tracking the base flight path vector array and the ingress-to-egress
                    // array, we need to reconcile the vector index.
                    const lastIngressVector = legCalc.ingress[legCalc.ingress.length - 1];
                    let vectors;
                    let offset;
                    if (suspend) {
                        // Unsuspended -> Suspended.
                        vectors = legCalc.flightPath;
                        if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                            offset = legCalc.ingressJoinIndex + 1;
                        }
                        else {
                            offset = legCalc.ingressJoinIndex;
                        }
                    }
                    else {
                        // Suspended -> Unsuspended.
                        let pastIngressJoin = state.vectorIndex > legCalc.ingressJoinIndex;
                        if (!pastIngressJoin && state.vectorIndex === legCalc.ingressJoinIndex && legCalc.flightPath[legCalc.ingressJoinIndex]) {
                            const vector = legCalc.flightPath[legCalc.ingressJoinIndex];
                            const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                            const start = GeoPoint.sphericalToCartesian(vector.startLat, vector.startLon, this.vec3Cache[0]);
                            const end = GeoPoint.sphericalToCartesian(ingressJoinVector.endLat, ingressJoinVector.endLon, this.vec3Cache[1]);
                            pastIngressJoin = FlightPathUtils.getAlongArcNormalizedDistance(circle, start, end, this.aircraftState.planePos) >= 1;
                        }
                        if (pastIngressJoin) {
                            vectors = legCalc.ingressToEgress;
                            if (GeoPoint.equals(lastIngressVector.endLat, lastIngressVector.endLon, ingressJoinVector.endLat, ingressJoinVector.endLon)) {
                                offset = -(legCalc.ingressJoinIndex + 1);
                            }
                            else {
                                offset = -legCalc.ingressJoinIndex;
                            }
                        }
                        else {
                            vectors = legCalc.flightPath;
                            offset = 0;
                            out.transitionMode = LNavTransitionMode.Unsuspend;
                        }
                    }
                    // Not using Utils.Clamp() because I need it to clamp to >=0 last.
                    out.vectorIndex = Math.max(0, Math.min(state.vectorIndex + offset, vectors.length - 1));
                }
                // If we are in unsuspend mode and have become suspended again, change the transition mode back to none. Vector
                // index stays the same because we are tracking the base flight path vector array both before and after.
                if (suspend && state.transitionMode === LNavTransitionMode.Unsuspend) {
                    out.transitionMode = LNavTransitionMode.None;
                }
                if (suspend && state.transitionMode === LNavTransitionMode.Egress) {
                    out.transitionMode = LNavTransitionMode.None;
                    out.vectorIndex = Math.max(0, ((_a = legCalc === null || legCalc === void 0 ? void 0 : legCalc.flightPath.length) !== null && _a !== void 0 ? _a : 1) - 1);
                }
            }
        }
        return out;
    }
    /**
     * Tries to activate when armed.
     */
    tryActivate() {
        if (this.disableArming) {
            this.activate();
            return;
        }
        if (this.minimumActivationAltitude === undefined || this.aircraftState.altAgl >= this.minimumActivationAltitude) {
            const headingDiff = NavMath.diffAngle(this.aircraftState.track, this.dtk);
            if (Math.abs(this.xtk) < 0.6 && Math.abs(headingDiff) < 110) {
                this.activate();
            }
        }
    }
    /**
     * Awaits a flight plan calculation. Starts a calculation of the active flight plan and suspends all tracking and
     * sequencing until the calculation is finished. If this method is called while a previous execution is still
     * awaiting, the new await takes precedence.
     */
    async awaitCalculate() {
        if (!this.flightPlanner.hasActiveFlightPlan()) {
            return;
        }
        this.isAwaitingCalculate = true;
        const id = ++this.awaitCalculateId;
        const plan = this.flightPlanner.getActiveFlightPlan();
        try {
            await plan.calculate();
        }
        catch ( /* continue */_a) { /* continue */ }
        if (id !== this.awaitCalculateId) {
            return;
        }
        this.isAwaitingCalculate = false;
    }
    /**
     * Gets an along-track distance from the start of a tracked flight plan leg given a distance along a tracked vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param alongVectorDistance The along-track distance from the start of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the start of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    getAlongLegDistance(plan, state, alongVectorDistance) {
        var _a;
        const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
        if (!calcs) {
            return 0;
        }
        let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, false);
        const vector = vectors[state.vectorIndex];
        if (!vector) {
            return 0;
        }
        let distanceAlong = 0;
        for (let i = state.vectorIndex - 1; i >= 0; i--) {
            distanceAlong += vectors[i].distance;
        }
        switch (state.transitionMode) {
            case LNavTransitionMode.Egress:
                vectors = calcs.ingressToEgress;
                for (let i = vectors.length - 1; i >= 0; i--) {
                    distanceAlong += vectors[i].distance;
                }
            // eslint-disable-next-line no-fallthrough
            case LNavTransitionMode.None:
            case LNavTransitionMode.Unsuspend:
                vectors = calcs.ingress;
                for (let i = vectors.length - 1; i >= 0; i--) {
                    distanceAlong += vectors[i].distance;
                }
        }
        if (state.transitionMode === LNavTransitionMode.Unsuspend) {
            const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
            const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
            if (ingressJoinVector && lastIngressVector) {
                // If we are in unsuspend mode and a valid ingress transition exists, then we need to subtract the distance
                // from the start of the current vector to where the ingress transition joins the base flight path.
                for (let i = state.vectorIndex; i < calcs.ingressJoinIndex; i++) {
                    distanceAlong -= vectors[i].distance;
                }
                // If the current vector is before or equal to the vector at which the ingress joins the base flight path, we
                // need to subtract the distance from the start of the joined vector to where the ingress joins.
                if (state.vectorIndex <= calcs.ingressJoinIndex) {
                    const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
                    const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
                    const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
                    distanceAlong -= UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
                }
            }
        }
        return UnitType.METER.convertTo(distanceAlong, UnitType.NMILE) + alongVectorDistance;
    }
    /**
     * Gets an along-track distance from the end of a tracked flight plan leg given a distance remaining along a tracked
     * vector.
     * @param plan The active flight plan.
     * @param state The LNAV state.
     * @param vectorDistanceRemaining The along-track distance from the end of the tracked vector, in nautical miles.
     * @returns The along-track distance, in nautical miles, from the end of the specified flight plan leg given the
     * specified state and along-vector distance.
     */
    getLegDistanceRemaining(plan, state, vectorDistanceRemaining) {
        var _a;
        const calcs = (_a = plan.tryGetLeg(state.globalLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
        if (!calcs) {
            return 0;
        }
        let vectors = LNavUtils.getVectorsForTransitionMode(calcs, state.transitionMode, state.isSuspended);
        const vector = vectors[state.vectorIndex];
        if (!vector) {
            return 0;
        }
        let vectorIndex = state.vectorIndex;
        let distanceRemaining = 0;
        if (state.transitionMode === LNavTransitionMode.Unsuspend) {
            const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
            const ingressJoinVector = calcs.flightPath[calcs.ingressJoinIndex];
            if (ingressJoinVector && lastIngressVector) {
                // If we are in unsuspend mode and a valid ingress transition exists, then we need to add the distance from
                // the end of the current vector to where the ingress transition joins the base flight path.
                for (let i = state.vectorIndex + 1; i < calcs.ingressJoinIndex; i++) {
                    distanceRemaining += vectors[i].distance;
                }
                // If the current vector is before the vector at which the ingress joins the base flight path, we need to
                // add the distance from the start of the joined vector to where the ingress joins.
                if (state.vectorIndex < calcs.ingressJoinIndex) {
                    const circle = FlightPathUtils.setGeoCircleFromVector(ingressJoinVector, this.geoCircleCache[0]);
                    const start = GeoPoint.sphericalToCartesian(ingressJoinVector.startLat, ingressJoinVector.startLon, this.vec3Cache[0]);
                    const end = GeoPoint.sphericalToCartesian(lastIngressVector.endLat, lastIngressVector.endLon, this.vec3Cache[1]);
                    distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(start, end, Math.PI), UnitType.METER);
                }
                // Reset the vector index to -1 so that we add the distance of all the ingress-to-egress vectors (it will be
                // incremented to 0 below).
                vectorIndex = -1;
            }
            vectors = calcs.ingressToEgress;
        }
        for (let i = vectorIndex + 1; i < vectors.length; i++) {
            distanceRemaining += vectors[i].distance;
        }
        switch (state.transitionMode) {
            case LNavTransitionMode.Ingress:
                vectors = LNavUtils.getVectorsForTransitionMode(calcs, LNavTransitionMode.None, state.isSuspended);
                for (let i = Math.max(0, state.isSuspended ? calcs.ingressJoinIndex : 0); i < vectors.length; i++) {
                    const currentVector = vectors[i];
                    if (state.isSuspended && i === calcs.ingressJoinIndex) {
                        const lastIngressVector = calcs.ingress[calcs.ingress.length - 1];
                        if (lastIngressVector) {
                            const circle = FlightPathUtils.setGeoCircleFromVector(currentVector, this.geoCircleCache[0]);
                            distanceRemaining += UnitType.GA_RADIAN.convertTo(circle.distanceAlong(this.geoPointCache[0].set(lastIngressVector.endLat, lastIngressVector.endLon), this.geoPointCache[1].set(currentVector.endLat, currentVector.endLon), Math.PI), UnitType.METER);
                            continue;
                        }
                    }
                    distanceRemaining += currentVector.distance;
                }
            // eslint-disable-next-line no-fallthrough
            case LNavTransitionMode.None:
            case LNavTransitionMode.Unsuspend:
                if (!state.isSuspended) {
                    vectors = calcs.egress;
                    for (let i = 0; i < vectors.length; i++) {
                        distanceRemaining += vectors[i].distance;
                    }
                }
        }
        return UnitType.METER.convertTo(distanceRemaining, UnitType.NMILE) + vectorDistanceRemaining;
    }
    /**
     * Copies one LNAV state object to another.
     * @param source The LNAV state from which to copy.
     * @param target The LNAV state to which to copy.
     * @returns The target LNAV state of the copy operation.
     */
    static copyStateInfo(source, target) {
        target.globalLegIndex = source.globalLegIndex;
        target.transitionMode = source.transitionMode;
        target.vectorIndex = source.vectorIndex;
        target.isSuspended = source.isSuspended;
        target.inhibitedSuspendLegIndex = source.inhibitedSuspendLegIndex;
        target.resetVectorsOnSuspendEnd = source.resetVectorsOnSuspendEnd;
        target.isMissedApproachActive = source.isMissedApproachActive;
        return target;
    }
    /**
     * Gets the ideal bank angle, in degrees, to follow a flight path vector under conditions of no cross-track error
     * and no wind, at a given ground speed.
     * @param vector The flight path vector to follow.
     * @param groundSpeed Ground speed, in knots.
     * @returns The ideal bank angle, in degrees, to follow the specified flight path vector at the specified ground
     * speed.
     */
    static getVectorIdealBankAngle(vector, groundSpeed) {
        if (FlightPathUtils.isVectorGreatCircle(vector)) {
            return 0;
        }
        if (vector.radius < MathUtils.HALF_PI) {
            // left turn
            return NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(vector.radius, UnitType.METER));
        }
        else {
            // right turn
            return -NavMath.bankAngle(groundSpeed, UnitType.GA_RADIAN.convertTo(Math.PI - vector.radius, UnitType.METER));
        }
    }
    /**
     * A method to support the OBS director's `driveBank()` method.
     * @param bank The desired bank angle, in degrees. Positive values indicate left bank.
     * @param rate The rate at which to drive the commanded bank angle, in degrees per second. If not defined, a default
     * rate will be used.
     */
    obsDriveBank(bank, rate) {
        this.driveBank && this.driveBank(bank, rate);
    }
}
LNavDirector.ANGULAR_TOLERANCE = GeoCircle.ANGULAR_TOLERANCE;
LNavDirector.ANGULAR_TOLERANCE_METERS = UnitType.GA_RADIAN.convertTo(GeoCircle.ANGULAR_TOLERANCE, UnitType.METER);

/**
 * An autopilot wing leveler director.
 */
class APLvlDirector {
    /**
     * Creates an instance of the wing leveler.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director.
     */
    constructor(bus, apValues, options) {
        var _a;
        this.bus = bus;
        this.apValues = apValues;
        const bankRateOpt = options === null || options === void 0 ? void 0 : options.bankRate;
        switch (typeof bankRateOpt) {
            case 'number':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt * this.apValues.simRate.get());
                    }
                };
                break;
            case 'function':
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank, bankRateOpt() * this.apValues.simRate.get());
                    }
                };
                break;
            default:
                this.driveBankFunc = bank => {
                    if (isFinite(bank) && this.driveBank) {
                        this.driveBank(bank);
                    }
                };
        }
        this.isToGaMode = (_a = options === null || options === void 0 ? void 0 : options.isToGaMode) !== null && _a !== void 0 ? _a : false;
        this.state = DirectorState.Inactive;
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        if (!this.isToGaMode) {
            SimVar.SetSimVarValue('AUTOPILOT WING LEVELER', 'Bool', true);
        }
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        if (!this.isToGaMode) {
            SimVar.SetSimVarValue('AUTOPILOT WING LEVELER', 'Bool', false);
        }
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.driveBankFunc(0);
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A VNAV Path autopilot director.
 */
class APVNavPathDirector {
    /**
     * Creates an instance of the APVNavPathDirector.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        this.deviation = ConsumerValue.create(null, Number.MAX_SAFE_INTEGER);
        this.fpa = ConsumerValue.create(null, 0);
        this.verticalWindAverage = new SimpleMovingAverage(10);
        this.state = DirectorState.Inactive;
        const sub = bus.getSubscriber();
        this.deviation.setConsumer(sub.on('vnav_vertical_deviation').whenChanged());
        this.fpa.setConsumer(sub.on('vnav_fpa').whenChanged());
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.deviation.resume();
        this.fpa.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.deviation.pause();
        this.fpa.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        SimVar.SetSimVarValue('AUTOPILOT PITCH HOLD', 'Bool', 0);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
    }
    /**
     * Arms this director.
     */
    arm() {
        this.resumeSubs();
        if (this.state === DirectorState.Inactive) {
            this.state = DirectorState.Armed;
            if (this.onArm !== undefined) {
                this.onArm();
            }
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.onDeactivate && this.onDeactivate();
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (this.state === DirectorState.Active) {
            this.drivePitch && this.drivePitch(this.getDesiredPitch(), true, true);
        }
    }
    /**
     * Gets a desired pitch from the FPA, AOA and Deviation.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        // fpa value is positive for down
        const fpa = this.fpa.get();
        const groundSpeed = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots);
        const fpaPercentage = Math.max(this.deviation.get() / (VNavUtils.getPathErrorDistance(groundSpeed) * -1), -1) + 1;
        // We limit desired pitch to avoid divebombing if something like a flight plan change suddenly puts you way above the path
        return Math.min(MathUtils.clamp(fpa * fpaPercentage, -1, fpa + 3), 10);
    }
}

/**
 * Handles the calculation of a Glide Path.
 */
class GlidePathCalculator {
    /**
     * Creates an instance of the GlidePathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary plan index to use for calculating GlidePath.
     */
    constructor(bus, flightPlanner, primaryPlanIndex) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        this.mapLegIndex = 0;
        this.fafLegIndex = 0;
        this.planePos = new GeoPoint(0, 0);
        this.glidepathFpa = 0;
        this.flightPlanIterator = new FlightPlanLegIterator();
        this.onPlanChanged = () => {
            if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                this.mapLegIndex = VNavUtils.getMissedApproachLegIndex(plan);
                const faf = VNavUtils.getFafIndex(plan);
                this.fafLegIndex = faf !== undefined ? faf : Math.max(0, plan.length - 1);
            }
        };
        this.onPlanCalculated = () => {
            if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                this.calcGlidepathFpa(plan);
            }
        };
        const fpl = bus.getSubscriber();
        fpl.on('fplCopied').handle(e => e.planIndex === 0 || e.targetPlanIndex === 0 && this.onPlanChanged());
        fpl.on('fplCreated').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplLegChange').handle(e => {
            if (e.planIndex === 0) {
                this.onPlanChanged();
            }
        });
        fpl.on('fplLoaded').handle(e => e.planIndex === 0 && this.onPlanChanged());
        fpl.on('fplSegmentChange').handle(e => {
            if (e.planIndex === 0) {
                this.onPlanChanged();
            }
        });
        fpl.on('fplIndexChanged').handle(() => this.onPlanChanged());
        fpl.on('fplCalculated').handle(e => e.planIndex === 0 && this.onPlanCalculated());
        const gnss = this.bus.getSubscriber();
        gnss.on('gps-position').handle(lla => {
            this.planePos.set(lla.lat, lla.long);
            //this.currentGpsAltitude = UnitType.METER.convertTo(lla.alt, UnitType.FOOT);
        });
        //gnss.on('ground_speed').handle(gs => this.currentGroundSpeed = gs);
    }
    /**
     * Gets the current Glidepath distance in meters.
     * @param index The global index of the active leg.
     * @param distanceAlongLeg The aircraft's current distance along the active leg, in meters.
     * @returns The current Glidepath distance in meters.
     */
    getGlidepathDistance(index, distanceAlongLeg) {
        var _a, _b;
        let globalLegIndex = 0;
        let distance = 0;
        const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
        const destLeg = plan.getLeg(this.mapLegIndex);
        if (index <= this.mapLegIndex) {
            for (let segmentIndex = 0; segmentIndex < plan.segmentCount; segmentIndex++) {
                const segment = plan.getSegment(segmentIndex);
                for (let legIndex = 0; legIndex < segment.legs.length; legIndex++) {
                    const leg = segment.legs[legIndex];
                    if (leg.calculated !== undefined && globalLegIndex <= this.mapLegIndex) {
                        if (index === globalLegIndex) {
                            distance += ((_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) - distanceAlongLeg;
                        }
                        else if (globalLegIndex > index) {
                            distance += (_b = leg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions;
                        }
                    }
                    globalLegIndex++;
                }
            }
            if (ICAO.isFacility(destLeg.leg.fixIcao)
                && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
                && plan.procedureDetails.destinationRunway !== undefined
                && destLeg.calculated && destLeg.calculated.endLat !== undefined && destLeg.calculated.endLon !== undefined) {
                const runway = plan.procedureDetails.destinationRunway;
                const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
                if (index === this.mapLegIndex && (distanceAlongLeg >= (destLeg.calculated.distanceWithTransitions - 1))) {
                    const destEnd = new GeoPoint(destLeg.calculated.endLat, destLeg.calculated.endLon);
                    distance = UnitType.NMILE.convertTo(NavMath.alongTrack(runwayGeoPoint, destEnd, this.planePos), UnitType.METER);
                }
                else {
                    distance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
                }
            }
        }
        return distance;
    }
    /**
     * Gets the Glidepath desired altitude in meters.
     * @param distance The current Glidepath distance in meters.
     * @returns The current Glidepath desired altitude in meters.
     */
    getDesiredGlidepathAltitude(distance) {
        return this.getRunwayAltitude() + VNavUtils.altitudeForDistance(this.glidepathFpa, distance);
    }
    /**
     * Gets the Glidepath runway altitude in meters.
     * @returns The Glidepath runway altitude in meters.
     */
    getRunwayAltitude() {
        const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
        const destLeg = plan.getLeg(this.mapLegIndex);
        let destAltitude = destLeg.leg.altitude1;
        if (ICAO.isFacility(destLeg.leg.fixIcao)
            && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
            && plan.procedureDetails.destinationRunway !== undefined) {
            destAltitude = plan.procedureDetails.destinationRunway.elevation;
        }
        return destAltitude;
    }
    /**
     * Calculates the Glidepath flight path angle using the destination elevation
     * and FAF altitude restriction.
     * @param plan The plan to calculate from.
     */
    calcGlidepathFpa(plan) {
        if (plan.length < 2 || this.fafLegIndex > plan.length || this.mapLegIndex > plan.length) {
            return;
        }
        const fafLeg = plan.tryGetLeg(this.fafLegIndex);
        const destLeg = plan.tryGetLeg(this.mapLegIndex);
        if (!fafLeg || !destLeg) {
            return;
        }
        let fafToDestDistance = 0;
        for (let i = this.fafLegIndex + 1; i <= this.mapLegIndex; i++) {
            const leg = plan.getLeg(i);
            if (leg.calculated !== undefined) {
                fafToDestDistance += leg.calculated.distance;
            }
        }
        let destAltitude = destLeg.leg.altitude1;
        if (ICAO.isFacility(destLeg.leg.fixIcao)
            && ICAO.getFacilityType(destLeg.leg.fixIcao) !== FacilityType.RWY
            && plan.procedureDetails.destinationRunway !== undefined
            && destLeg.calculated && destLeg.calculated.endLat !== undefined && destLeg.calculated.endLon !== undefined) {
            const runway = plan.procedureDetails.destinationRunway;
            const runwayGeoPoint = new GeoPoint(runway.latitude, runway.longitude);
            destAltitude = runway.elevation;
            fafToDestDistance += UnitType.GA_RADIAN.convertTo(runwayGeoPoint.distance(destLeg.calculated.endLat, destLeg.calculated.endLon), UnitType.METER);
        }
        this.glidepathFpa = VNavUtils.getFpa(fafToDestDistance, fafLeg.leg.altitude1 - destAltitude);
    }
}

/**
 * Handles the calculation of the VNAV flight path for Path Smoothing VNAV Implementations.
 */
class SmoothingPathCalculator {
    /**
     * Creates an instance of SmoothingPathCalculator.
     * @param bus The EventBus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** The Vertical Flight Plans managed by this Path Calculator */
        this.verticalFlightPlans = [];
        /** @inheritdoc */
        this.planBuilt = new SubEvent();
        /** @inheritdoc */
        this.vnavCalculated = new SubEvent();
        this.legAltitudes = [0, 0];
        this.applyPathValuesResult = [undefined, 0];
        this.flightPathAngle = (_a = options === null || options === void 0 ? void 0 : options.defaultFpa) !== null && _a !== void 0 ? _a : SmoothingPathCalculator.DEFAULT_DEFAULT_FPA;
        this.minFlightPathAngle = (_b = options === null || options === void 0 ? void 0 : options.minFpa) !== null && _b !== void 0 ? _b : SmoothingPathCalculator.DEFAULT_MIN_FPA;
        this.maxFlightPathAngle = (_c = options === null || options === void 0 ? void 0 : options.maxFpa) !== null && _c !== void 0 ? _c : SmoothingPathCalculator.DEFAULT_MAX_FPA;
        this.forceFirstApproachAtConstraint = (_d = options === null || options === void 0 ? void 0 : options.forceFirstApproachAtConstraint) !== null && _d !== void 0 ? _d : false;
        this.directToLegOffset = (_e = options === null || options === void 0 ? void 0 : options.directToLegOffset) !== null && _e !== void 0 ? _e : SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET;
        this.isLegEligibleFunc = (_f = options === null || options === void 0 ? void 0 : options.isLegEligible) !== null && _f !== void 0 ? _f : SmoothingPathCalculator.isLegVnavEligible;
        this.shouldUseConstraintFunc = (_g = options === null || options === void 0 ? void 0 : options.shouldUseConstraint) !== null && _g !== void 0 ? _g : (() => true);
        this.invalidateClimbConstraintFunc = (_h = options === null || options === void 0 ? void 0 : options.invalidateClimbConstraint) !== null && _h !== void 0 ? _h : SmoothingPathCalculator.invalidateClimbConstraint;
        this.invalidateDescentConstraintFunc = (_j = options === null || options === void 0 ? void 0 : options.invalidateDescentConstraint) !== null && _j !== void 0 ? _j : SmoothingPathCalculator.invalidateDescentConstraint;
        const fpl = this.bus.getSubscriber();
        fpl.on('fplCreated').handle(e => this.createVerticalPlan(e.planIndex));
        fpl.on('fplCopied').handle(e => this.onPlanChanged(e.targetPlanIndex));
        fpl.on('fplLoaded').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplLegChange').handle(e => this.onPlanChanged(e.planIndex, e));
        fpl.on('fplSegmentChange').handle(e => this.onPlanChanged(e.planIndex, undefined, e));
        fpl.on('fplIndexChanged').handle(e => this.onPlanChanged(e.planIndex));
        fpl.on('fplCalculated').handle(e => this.onPlanCalculated(e));
        bus.getSubscriber().on('vnav_set_default_fpa').handle(this.setDefaultFpa.bind(this));
        bus.getSubscriber().on('vnav_set_vnav_direct_to').handle(data => {
            if (data.globalLegIndex < 0) {
                this.cancelVerticalDirect(data.planIndex);
            }
            else {
                this.activateVerticalDirect(data.planIndex, data.globalLegIndex, data.fpa);
            }
        });
    }
    /** @inheritdoc */
    getVerticalFlightPlan(planIndex) {
        var _a;
        var _b;
        return (_a = (_b = this.verticalFlightPlans)[planIndex]) !== null && _a !== void 0 ? _a : (_b[planIndex] = this.createVerticalPlan(planIndex));
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /** @inheritdoc */
    requestPathCompute(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex) && this.verticalFlightPlans[planIndex] !== undefined) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            this.computePathAndNotify(lateralPlan, verticalPlan);
            return true;
        }
        return false;
    }
    /**
     * Gets the index of the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The index of the VNAV constraint defining the target VNAV altitude for a flight plan leg, or `-1` if one
     * could not be found.
     */
    getTargetConstraintIndex(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            const currentConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraint && currentConstraint.nextVnavEligibleLegIndex !== undefined && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
                const priorConstraintIndex = VNavUtils.getPriorConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const priorConstraint = verticalPlan.constraints[priorConstraintIndex];
                if (priorConstraint && priorConstraint.type !== 'climb' && priorConstraint.type !== 'missed') {
                    return priorConstraintIndex;
                }
                else {
                    return -1;
                }
            }
            let i = verticalPlan.constraints.length - 1;
            while (i >= 0) {
                const constraint = verticalPlan.constraints[i];
                if (globalLegIndex <= constraint.index && constraint.isTarget && constraint.type !== 'climb' && constraint.type !== 'missed') {
                    return i;
                }
                i--;
            }
        }
        else {
            const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
            if (currentConstraintIndex >= 0) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isMissed = currentConstraint.type === 'missed';
                for (let i = currentConstraintIndex; i >= 0; i--) {
                    const constraint = verticalPlan.constraints[i];
                    if (constraint.type === 'climb' || (isMissed && constraint.type === 'missed')) {
                        if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                            return i;
                        }
                    }
                    else {
                        return -1;
                    }
                }
            }
        }
        return -1;
    }
    /**
     * Gets the VNAV constraint defining the target VNAV altitude for a flight plan leg.
     * @param planIndex The flight plan index.
     * @param globalLegIndex The global index of the flight plan leg.
     * @returns The VNAV constraint defining the target VNAV altitude for a flight plan leg, or `undefined` if one could
     * not be found.
     */
    getTargetConstraint(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        return verticalPlan.constraints[this.getTargetConstraintIndex(planIndex, globalLegIndex)];
    }
    /** @inheritdoc */
    getTargetAltitude(planIndex, globalLegIndex) {
        var _a, _b;
        if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Descent) {
            return (_a = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _a === void 0 ? void 0 : _a.targetAltitude;
        }
        else {
            return (_b = this.getTargetConstraint(planIndex, globalLegIndex)) === null || _b === void 0 ? void 0 : _b.maxAltitude;
        }
    }
    /** @inheritdoc */
    getFlightPhase(planIndex) {
        if (this.flightPlanner.hasFlightPlan(planIndex)) {
            const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
            const verticalPlan = this.getVerticalFlightPlan(planIndex);
            const globalLegIndex = VNavUtils.getConstraintLegIndexFromLegIndex(verticalPlan, lateralPlan.activeLateralLeg);
            if (globalLegIndex > -1) {
                const constraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
                switch (constraint === null || constraint === void 0 ? void 0 : constraint.type) {
                    case 'climb':
                    case 'missed':
                        return VerticalFlightPhase.Climb;
                }
            }
        }
        return VerticalFlightPhase.Descent;
    }
    /** @inheritdoc */
    getCurrentConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return undefined;
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            return priorConstraint === null || priorConstraint === void 0 ? void 0 : priorConstraint.targetAltitude;
        }
        else {
            return currentConstraint.targetAltitude;
        }
    }
    /** @inheritdoc */
    getCurrentConstraintDetails(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint === undefined) {
            return { type: AltitudeRestrictionType.Unused, altitude: 0 };
        }
        const priorConstraint = VNavUtils.getPriorConstraintFromLegIndex(verticalPlan, globalLegIndex);
        if (currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed'
            && currentConstraint.nextVnavEligibleLegIndex !== undefined
            && globalLegIndex < currentConstraint.nextVnavEligibleLegIndex) {
            if (priorConstraint) {
                return VNavUtils.getConstraintDetails(priorConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
            }
            else {
                return { type: AltitudeRestrictionType.Unused, altitude: 0 };
            }
        }
        else {
            return VNavUtils.getConstraintDetails(currentConstraint, { type: AltitudeRestrictionType.Unused, altitude: 0 });
        }
    }
    /** @inheritdoc */
    getNextConstraintAltitude(planIndex, globalLegIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, globalLegIndex);
        // added check for climb or descent for smoothing path calc
        if (currentConstraint !== undefined) {
            if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    return currentConstraint.maxAltitude;
                }
                else {
                    return currentConstraint.minAltitude;
                }
            }
            else {
                if (currentConstraint.minAltitude > Number.NEGATIVE_INFINITY) {
                    return currentConstraint.minAltitude;
                }
                else {
                    return currentConstraint.maxAltitude;
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    getNextRestrictionForFlightPhase(planIndex, activeLateralLeg) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, activeLateralLeg);
        if (currentConstraint) {
            const currentConstraintIndex = verticalPlan.constraints.indexOf(currentConstraint);
            if (currentConstraintIndex > -1) {
                if (this.getFlightPhase(planIndex) === VerticalFlightPhase.Climb) {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'climb' || constraint.type === 'missed') {
                            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
                else {
                    for (let i = currentConstraintIndex; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                            if (constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                                return constraint;
                            }
                        }
                        else {
                            return undefined;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** @inheritdoc */
    activateVerticalDirect(planIndex, constraintGlobalLegIndex, fpa) {
        if (constraintGlobalLegIndex < 0) {
            return;
        }
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        verticalPlan.verticalDirectIndex = constraintGlobalLegIndex;
        verticalPlan.verticalDirectFpa = fpa !== null && fpa !== void 0 ? fpa : this.flightPathAngle;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Cancels the existing VNAV direct-to for a vertical flight plan.
     * @param planIndex The index of the vertical flight plan for which to cancel the VNAV direct-to.
     */
    cancelVerticalDirect(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex === undefined) {
            return;
        }
        verticalPlan.verticalDirectIndex = undefined;
        verticalPlan.verticalDirectFpa = undefined;
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sets this calculator's default flight path angle.
     * @param fpa The new default flight path angle, in degrees. Increasingly positive values indicate steeper descents.
     */
    setDefaultFpa(fpa) {
        const newFpa = Math.max(0, fpa);
        if (newFpa !== this.flightPathAngle) {
            this.flightPathAngle = newFpa;
            for (let i = 0; i < this.verticalFlightPlans.length; i++) {
                const lateralPlan = this.flightPlanner.hasFlightPlan(i) ? this.flightPlanner.getFlightPlan(i) : undefined;
                const verticalPlan = this.verticalFlightPlans[i];
                if (lateralPlan && verticalPlan) {
                    this.computePathAndNotify(lateralPlan, verticalPlan);
                }
            }
        }
    }
    /**
     * Sets planChanged to true to flag that a plan change has been received over the bus.
     * @param planIndex The Plan Index that changed.
     * @param legChangeEvent The FlightPlanLegEvent, if any.
     * @param segmentChangeEvent The FlightPlanSegmentEvent, if any.
     */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.verticalDirectIndex !== undefined) {
            if (legChangeEvent !== undefined) {
                const globalIndex = plan.getSegment(legChangeEvent.segmentIndex).offset + legChangeEvent.legIndex;
                if (globalIndex <= verticalPlan.verticalDirectIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
            else if (segmentChangeEvent !== undefined) {
                const verticalDirectSegmentIndex = plan.getSegmentIndex(verticalPlan.verticalDirectIndex);
                if (segmentChangeEvent.segmentIndex <= verticalDirectSegmentIndex) {
                    verticalPlan.verticalDirectIndex = undefined;
                }
            }
        }
        verticalPlan.planChanged = true;
        verticalPlan.currentAlongLegDistance = undefined;
    }
    /**
     * Method fired on a flight plan change event to rebuild the vertical path.
     * @param event The Flight Plan Calculated Event
     */
    onPlanCalculated(event) {
        this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
    }
    /**
     * Builds a vertical flight plan if its corresponding lateral flight plan has been changed since the last rebuild,
     * then computes the vertical path sends events notifying subscribers that the plan was built and calculated.
     * @param planIndex The index of the plan to build and compute.
     */
    buildVerticalFlightPlanAndComputeAndNotify(planIndex) {
        const lateralPlan = this.flightPlanner.getFlightPlan(planIndex);
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.planChanged) {
            this.buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan);
        }
        this.computePathAndNotify(lateralPlan, verticalPlan);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was built or rebuilt.
     * @param planIndex The index of the plan that was built.
     */
    notifyBuilt(planIndex) {
        this.planBuilt.notify(this, planIndex);
    }
    /**
     * Sends an event notifying subscribers that a vertical flight plan was calculated.
     * @param planIndex The index of the plan that was calculated.
     */
    notifyCalculated(planIndex) {
        this.vnavCalculated.notify(this, planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan and sends an event notifying subscribers that the plan
     * was built.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlanAndNotify(lateralPlan, verticalPlan) {
        this.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.notifyBuilt(verticalPlan.planIndex);
    }
    /**
     * Builds a vertical flight plan from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPlan The vertical flight plan to build.
     */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        this.buildVerticalLegsAndConstraints(lateralPlan, verticalPlan);
        SmoothingPathCalculator.handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, this.directToLegOffset);
        verticalPlan.planChanged = false;
    }
    /**
     * Resets the Vertical Flight Plan, populates the vertical segments and legs, finds and builds the vertical constraints.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    buildVerticalLegsAndConstraints(lateralPlan, verticalPlan) {
        var _a, _b, _c, _d, _e, _f, _g;
        // Reset the constraints array.
        verticalPlan.constraints.length = 0;
        // Reset the segments array.
        verticalPlan.segments.length = 0;
        verticalPlan.destLegIndex = undefined;
        verticalPlan.firstDescentConstraintLegIndex = undefined;
        verticalPlan.lastDescentConstraintLegIndex = undefined;
        verticalPlan.missedApproachStartIndex = undefined;
        // Find the FAF in the lateral plan, if any.
        verticalPlan.fafLegIndex = VNavUtils.getFafIndex(lateralPlan);
        const directToTargetLegIndex = SmoothingPathCalculator.getDirectToTargetLegIndex(lateralPlan);
        let firstApproachGlobalLegIndex;
        // Iterate forward through the lateral plan to build the constraints
        for (const segment of lateralPlan.segments()) {
            // Add the plan segments to the VNav Path Calculator Segments
            verticalPlan.segments[segment.segmentIndex] = {
                offset: segment.offset,
                legs: []
            };
            if (segment.segmentType === FlightPlanSegmentType.Approach && firstApproachGlobalLegIndex === undefined) {
                firstApproachGlobalLegIndex = segment.offset;
            }
            for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                const globalLegIndex = segment.offset + segmentLegIndex;
                const lateralLeg = segment.legs[segmentLegIndex];
                const verticalLeg = VNavUtils.createLeg(segment.segmentIndex, segmentLegIndex, (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '', (_c = (_b = lateralLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : undefined);
                // Check if the leg is part of the missed approach, and set the missed approach start index.
                if (verticalPlan.missedApproachStartIndex === undefined
                    && segment.segmentType === FlightPlanSegmentType.Approach
                    && BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
                    verticalPlan.missedApproachStartIndex = globalLegIndex;
                }
                // Check if the leg contains a constraint
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                verticalLeg.isEligible = this.isLegEligibleFunc(lateralLeg);
                verticalLeg.distance = (_e = (_d = lateralLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                // Check if the leg precedes a defined vertical direct for this vertical flight plan.
                const legPrecedesVerticalDirectIndex = verticalPlan.verticalDirectIndex !== undefined && globalLegIndex < verticalPlan.verticalDirectIndex;
                const legPrecedesDirectTo = directToTargetLegIndex !== undefined && globalLegIndex < directToTargetLegIndex + this.directToLegOffset;
                if (constraintAltitudes !== undefined
                    && !legPrecedesVerticalDirectIndex
                    && !legPrecedesDirectTo
                    && this.shouldUseConstraintFunc(lateralPlan, lateralLeg, globalLegIndex, segment, segmentLegIndex)) {
                    verticalLeg.isUserDefined = VNavUtils.isUserConstraint(lateralLeg);
                    const verticalConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    // Add the new vertical constraint to the array of constraints in reverse order.
                    verticalPlan.constraints.unshift(verticalConstraint);
                }
                // Add the new vertical leg to the vertical flight plan
                verticalPlan.segments[segment.segmentIndex].legs.push(verticalLeg);
            }
        }
        verticalPlan.length = lateralPlan.length;
        if (this.forceFirstApproachAtConstraint && firstApproachGlobalLegIndex !== undefined) {
            const firstApproachConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, directToTargetLegIndex === firstApproachGlobalLegIndex ? directToTargetLegIndex + 3 : firstApproachGlobalLegIndex);
            if (firstApproachConstraint && firstApproachConstraint.type !== 'climb' && firstApproachConstraint.type !== 'missed') {
                SmoothingPathCalculator.forceAtConstraint(firstApproachConstraint);
            }
        }
        verticalPlan.firstDescentConstraintLegIndex = (_f = verticalPlan.constraints[VNavUtils.getFirstDescentConstraintIndex(verticalPlan)]) === null || _f === void 0 ? void 0 : _f.index;
        verticalPlan.lastDescentConstraintLegIndex = (_g = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _g === void 0 ? void 0 : _g.index;
    }
    /**
     * Builds a VNAV constraint for a lateral flight plan leg.
     * @param verticalPlan The vertical flight plan.
     * @param globalLegIndex The global index of the lateral flight plan leg for which to build the constraint.
     * @param lateralLeg The lateral flight plan leg for which to build the constraint.
     * @param constraintAltitudes The constraint altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @param name The name of the new constraint.
     * @returns A new VNAV constraint for the specified lateral flight plan leg.
     */
    buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, name) {
        var _a;
        const constraint = VNavUtils.createConstraint(globalLegIndex, constraintAltitudes[0], constraintAltitudes[1], name, BitFlags.isAll(lateralLeg.flags, LegDefinitionFlags.MissedApproach) ? 'missed' : lateralLeg.verticalData.phase === VerticalFlightPhase.Descent ? 'descent' : 'climb');
        constraint.isBeyondFaf = verticalPlan.fafLegIndex === undefined ? false : globalLegIndex > verticalPlan.fafLegIndex;
        // Check if this constraint is a vertical direct.
        if (verticalPlan.verticalDirectIndex === globalLegIndex) {
            constraint.fpa = (_a = verticalPlan.verticalDirectFpa) !== null && _a !== void 0 ? _a : this.flightPathAngle;
            constraint.type = 'direct';
        }
        const userFpa = lateralLeg.verticalData.fpa;
        if (userFpa !== undefined && constraint.type !== 'climb' && constraint.type !== 'missed') {
            constraint.fpa = userFpa;
            constraint.type = 'manual';
        }
        return constraint;
    }
    /**
     * Computes the vertical path for a flight plan and sends an event notifying subscribers that the plan was
     * calculated.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePathAndNotify(lateralPlan, verticalPlan) {
        this.computePath(lateralPlan, verticalPlan);
        this.notifyCalculated(lateralPlan.planIndex);
    }
    /**
     * Computes the vertical path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computePath(lateralPlan, verticalPlan) {
        this.computeDescentPath(lateralPlan, verticalPlan);
    }
    /**
     * Computes the descent path for a flight plan.
     * @param lateralPlan The lateral flight plan for which to compute a path.
     * @param verticalPlan The vertical flight plan for which to compute a path.
     */
    computeDescentPath(lateralPlan, verticalPlan) {
        this.fillLegDistances(lateralPlan, verticalPlan);
        // Updated leg distances could cause some invalidated constraints to become valid, so we will re-insert all
        // invalidated constraints and filter them again.
        this.reinsertInvalidConstraints(verticalPlan, lateralPlan);
        this.findAndRemoveInvalidConstraints(verticalPlan);
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        this.populateConstraints(verticalPlan);
        if (this.computeFlightPathAngles(verticalPlan)) {
            for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
                const constraint = verticalPlan.constraints[constraintIndex];
                if (constraint.type === 'descent' || constraint.type === 'direct' || constraint.type === 'manual') {
                    let altitude = constraint.targetAltitude;
                    let constraintIsBod = true;
                    if (constraintIndex > 0) {
                        const nextConstraint = verticalPlan.constraints[constraintIndex - 1];
                        if (nextConstraint !== undefined && nextConstraint.type !== 'climb') {
                            const constraintAltForDist = nextConstraint.targetAltitude + VNavUtils.altitudeForDistance(nextConstraint.fpa, nextConstraint.distance);
                            if ((nextConstraint.fpa > 0 && constraintAltForDist <= constraint.targetAltitude + 25) || constraint.fpa === 0) {
                                constraintIsBod = false;
                            }
                        }
                    }
                    if (constraint.index === verticalPlan.lastDescentConstraintLegIndex) {
                        constraint.isPathEnd = true;
                        constraint.isTarget = true;
                        constraintIsBod = true;
                    }
                    for (let legIndex = 0; legIndex < constraint.legs.length; legIndex++) {
                        const leg = constraint.legs[legIndex];
                        leg.fpa = constraint.fpa;
                        leg.altitude = altitude;
                        altitude += VNavUtils.altitudeForDistance(leg.fpa, leg.distance);
                        if (legIndex === 0) {
                            leg.isAdvisory = false;
                        }
                        else {
                            leg.isAdvisory = true;
                        }
                        if (legIndex === 0 && constraint.isTarget && constraintIsBod) {
                            leg.isBod = true;
                        }
                        else {
                            leg.isBod = false;
                        }
                    }
                }
            }
        }
    }
    /**
     * Fills the VNAV plan leg and constraint segment distances.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    fillLegDistances(lateralPlan, verticalPlan) {
        var _a, _b, _c;
        if (lateralPlan.length > 0) {
            for (const segment of lateralPlan.segments()) {
                if (segment) {
                    const vnavSegment = verticalPlan.segments[segment.segmentIndex];
                    for (let l = 0; l < segment.legs.length; l++) {
                        const leg = segment.legs[l];
                        if (leg && leg.calculated && leg.calculated.distanceWithTransitions) {
                            vnavSegment.legs[l].distance = leg.calculated.distanceWithTransitions;
                        }
                        else if (leg && leg.calculated && leg.calculated.endLat !== undefined && leg.calculated.endLon !== undefined) {
                            let prevLeg;
                            for (const checkLeg of lateralPlan.legs(true, segment.offset + l - 1)) {
                                if (((_a = checkLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== undefined && ((_b = checkLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) !== undefined) {
                                    prevLeg = checkLeg;
                                    break;
                                }
                            }
                            if (((_c = prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.calculated) === null || _c === void 0 ? void 0 : _c.endLat) && prevLeg.calculated.endLon) {
                                vnavSegment.legs[l].distance = UnitType.GA_RADIAN.convertTo(GeoPoint.distance(leg.calculated.endLat, leg.calculated.endLon, prevLeg.calculated.endLat, prevLeg.calculated.endLon), UnitType.METER);
                            }
                        }
                        else {
                            vnavSegment.legs[l].distance = 0;
                        }
                    }
                }
            }
        }
    }
    /**
     * Finds and removes invalid constraints from the vertical plan.
     * @param verticalPlan The Vertical Flight Plan.
     */
    findAndRemoveInvalidConstraints(verticalPlan) {
        var _a, _b, _c;
        let firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all constraints prior to the
        // direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? firstDescentConstraintIndex
            : verticalPlan.constraints.length - 1;
        let phase = 'climb';
        let priorMinAltitude = -Infinity;
        let priorMaxAltitude = Infinity;
        let distanceFromPriorMinAltitude = 0;
        let requiredFpa = 0;
        for (let i = startIndex; i >= 0; i--) {
            const currentConstraint = verticalPlan.constraints[i];
            const currentConstraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, verticalPlan.constraints[i + 1], verticalPlan);
            let currentPhase;
            switch (currentConstraint.type) {
                case 'climb':
                case 'missed':
                    currentPhase = currentConstraint.type;
                    break;
                default:
                    currentPhase = 'descent';
            }
            if (currentPhase !== phase) {
                // Reset prior altitudes when switching phases.
                phase = currentPhase;
                priorMinAltitude = -Infinity;
                priorMaxAltitude = Infinity;
                distanceFromPriorMinAltitude = currentConstraintDistance;
            }
            else {
                distanceFromPriorMinAltitude += currentConstraintDistance;
            }
            let isDescentConstraint;
            let shouldInvalidate;
            switch (phase) {
                case 'climb':
                case 'missed':
                    isDescentConstraint = false;
                    shouldInvalidate = this.invalidateClimbConstraintFunc(currentConstraint, i, verticalPlan.constraints, firstDescentConstraintIndex, priorMinAltitude, priorMaxAltitude);
                    break;
                default:
                    isDescentConstraint = true;
                    if (isFinite(priorMinAltitude) && isFinite(currentConstraint.maxAltitude)) {
                        requiredFpa = Math.max(0, -VNavUtils.getFpa(distanceFromPriorMinAltitude, currentConstraint.maxAltitude - priorMinAltitude));
                    }
                    else {
                        requiredFpa = 0;
                    }
                    shouldInvalidate = this.invalidateDescentConstraintFunc(currentConstraint, i, verticalPlan.constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, this.maxFlightPathAngle);
            }
            const constraintLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index);
            if (shouldInvalidate) {
                constraintLeg.invalidConstraintAltitude = currentConstraint.minAltitude !== Number.NEGATIVE_INFINITY ? currentConstraint.minAltitude : currentConstraint.maxAltitude;
                verticalPlan.constraints.splice(i, 1);
                // Need to subtract current constraint distance because it will get added again at the beginning of the next iteration.
                // (The next constraint inherits the legs that belonged to the current constraint after it is removed.)
                distanceFromPriorMinAltitude -= currentConstraintDistance;
                // If we invalidated the first descent constraint, we need to find the new one.
                if (isDescentConstraint && i === firstDescentConstraintIndex) {
                    firstDescentConstraintIndex = VNavUtils.getFirstDescentConstraintIndex(verticalPlan);
                    verticalPlan.firstDescentConstraintLegIndex = (_b = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _b === void 0 ? void 0 : _b.index;
                }
            }
            else {
                constraintLeg.invalidConstraintAltitude = undefined;
                if (isFinite(currentConstraint.minAltitude)) {
                    priorMinAltitude = currentConstraint.minAltitude;
                    distanceFromPriorMinAltitude = 0;
                }
                if (isFinite(currentConstraint.maxAltitude)) {
                    priorMaxAltitude = currentConstraint.maxAltitude;
                }
            }
        }
        // Update last descent leg in case we invalidated some descent constraints
        verticalPlan.lastDescentConstraintLegIndex = (_c = verticalPlan.constraints[VNavUtils.getLastDescentConstraintIndex(verticalPlan)]) === null || _c === void 0 ? void 0 : _c.index;
    }
    /**
     * Finds previously invalidated constraints and re-inserts them into the vertical flight plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     */
    reinsertInvalidConstraints(verticalPlan, lateralPlan) {
        var _a;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        // If there is a vertical direct-to active (and it has not been invalidated), skip all legs prior to and including
        // the direct-to.
        const startIndex = ((_a = verticalPlan.constraints[firstDescentConstraintIndex]) === null || _a === void 0 ? void 0 : _a.type) === 'direct'
            ? (verticalPlan.firstDescentConstraintLegIndex + 1)
            : 0;
        let globalLegIndex = startIndex;
        for (const lateralLeg of lateralPlan.legs(false, startIndex)) {
            const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
            if (verticalLeg.invalidConstraintAltitude !== undefined) {
                const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, globalLegIndex);
                const constraintAltitudes = SmoothingPathCalculator.getConstraintAltitudes(lateralLeg, this.legAltitudes);
                if (constraintAltitudes !== undefined) {
                    const proposedConstraint = this.buildConstraint(verticalPlan, globalLegIndex, lateralLeg, constraintAltitudes, verticalLeg.name);
                    verticalPlan.constraints.splice(constraintIndex + 1, 0, proposedConstraint);
                    // If we re-validated a descent constraint, we need to update the first/last descent constraint when appropriate.
                    if (proposedConstraint.type === 'descent'
                        || proposedConstraint.type === 'manual'
                        || proposedConstraint.type === 'direct'
                        || proposedConstraint.type === 'dest') {
                        if (verticalPlan.firstDescentConstraintLegIndex === undefined || globalLegIndex < verticalPlan.firstDescentConstraintLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = globalLegIndex;
                        }
                        if (verticalPlan.lastDescentConstraintLegIndex === undefined || globalLegIndex > verticalPlan.lastDescentConstraintLegIndex) {
                            verticalPlan.lastDescentConstraintLegIndex = globalLegIndex;
                        }
                    }
                }
            }
            globalLegIndex++;
        }
    }
    /**
     * Fills the VNAV plan constraint distances.
     * @param verticalPlan The Vertical Flight Plan.
     */
    populateConstraints(verticalPlan) {
        for (let constraintIndex = 0; constraintIndex < verticalPlan.constraints.length; constraintIndex++) {
            const constraint = verticalPlan.constraints[constraintIndex];
            const previousConstraint = verticalPlan.constraints[constraintIndex + 1];
            constraint.legs.length = 0;
            constraint.distance = VNavUtils.getConstraintDistanceFromLegs(constraint, previousConstraint, verticalPlan);
            let eligibleLegIndex;
            let ineligibleLegIndex;
            for (let globalLegIndex = constraint.index; globalLegIndex > (previousConstraint !== undefined ? previousConstraint.index : -1); globalLegIndex--) {
                const verticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, globalLegIndex);
                constraint.legs.push(verticalLeg);
                if (ineligibleLegIndex === undefined && verticalLeg.isEligible) {
                    eligibleLegIndex = globalLegIndex;
                }
                if (ineligibleLegIndex === undefined && !verticalLeg.isEligible) {
                    ineligibleLegIndex = globalLegIndex;
                }
            }
            if (ineligibleLegIndex !== undefined && eligibleLegIndex !== undefined) {
                constraint.nextVnavEligibleLegIndex = eligibleLegIndex;
            }
        }
    }
    /**
     * Computes the flight path angles for each constraint segment.
     * @param verticalPlan The Vertical Flight Plan.
     * @returns Whether the flight path angles were computed.
     */
    computeFlightPathAngles(verticalPlan) {
        // Iterate through all descent constraints in reverse flight plan order and attempt to assign one as a "target"
        // constraint, which is a constraint that anchors a constant FPA path connecting it to one or more prior
        // constraints.
        // Once a target constraint is found, the iteration continues as we attempt to build a constant FPA path backwards
        // from the target constraint that meets all the iterated constraints. Once we reach a constraint that cannot be
        // met with a constant FPA path from the target constraint that also meets all intermediate constraints, we assign
        // a new target constraint at the point where the FPA must change. Certain constraints must also be designated as
        // target constraints regardless of whether a constant FPA path through them is possible. In any case, once we
        // designate a new target constraint, the process is repeated until we run out of descent constraints.
        let currentTargetConstraint;
        let currentPathSegmentDistance = 0;
        let currentPathSegmentMinFpa = this.minFlightPathAngle;
        let currentPathSegmentMaxFpa = this.maxFlightPathAngle;
        let currentTargetConstraintHasFixedFpa = false;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const lastDescentConstraintIndex = verticalPlan.lastDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        if (firstDescentConstraintIndex < 0 || lastDescentConstraintIndex < 0) {
            // There are no descent constraints, so no FPAs to be calculated
            return false;
        }
        for (let targetConstraintIndex = lastDescentConstraintIndex; targetConstraintIndex <= firstDescentConstraintIndex; targetConstraintIndex++) {
            const constraint = verticalPlan.constraints[targetConstraintIndex];
            // If the current constraint is climb or missed, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                continue;
            }
            // If we haven't found a target constraint yet, attempt to make the current constraint the target constraint,
            // if it defines either a minimum or maximum altitude. The target altitude is preferentially set to the minimum
            // altitude, if it exists. If the current constraint has neither a minimum nor maximum altitude (which should
            // technically never happen), skip it.
            if (!currentTargetConstraint) {
                if (constraint.minAltitude > Number.NEGATIVE_INFINITY || constraint.maxAltitude < Number.POSITIVE_INFINITY) {
                    currentTargetConstraint = constraint;
                    currentTargetConstraint.targetAltitude = constraint.minAltitude > Number.NEGATIVE_INFINITY ? constraint.minAltitude : constraint.maxAltitude;
                    currentTargetConstraint.isTarget = true;
                }
                else {
                    continue;
                }
            }
            // Reset the method variables
            currentPathSegmentMinFpa = this.minFlightPathAngle;
            currentPathSegmentMaxFpa = this.maxFlightPathAngle;
            currentPathSegmentDistance = currentTargetConstraint.distance;
            const currentTargetConstraintIsFirstDescentConstraint = targetConstraintIndex === firstDescentConstraintIndex;
            if (currentTargetConstraintIsFirstDescentConstraint) {
                if (currentTargetConstraint.type === 'descent') {
                    // If this is the first descent constraint and it is not a direct or manual, set the FPA to the default value.
                    currentTargetConstraint.fpa = this.flightPathAngle;
                }
                // If currentTargetConstraintIsFirstDescentConstraint is true, then after this logic, we're done with this method.
                return true;
            }
            // If the current target constraint is a manual or direct type, then honor the FPA by not allowing any other FPAs.
            if (currentTargetConstraint.type === 'manual') {
                currentPathSegmentMinFpa = currentTargetConstraint.fpa;
                currentPathSegmentMaxFpa = currentTargetConstraint.fpa;
                currentTargetConstraintHasFixedFpa = true;
            }
            else {
                currentTargetConstraintHasFixedFpa = false;
            }
            let pathSegmentIsFlat = false;
            for (let currentConstraintIndex = targetConstraintIndex + 1; currentConstraintIndex <= firstDescentConstraintIndex; currentConstraintIndex++) {
                const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
                const isCurrentConstraintFirstDescent = currentConstraintIndex === firstDescentConstraintIndex;
                const isCurrentConstraintFaf = currentConstraint.index === verticalPlan.fafLegIndex;
                const isCurrentConstraintClimb = currentConstraint.type === 'climb' || currentConstraint.type === 'missed';
                const isCurrentConstraintManual = currentConstraint.type === 'manual';
                const isCurrentConstraintDirect = currentConstraint.type === 'direct';
                if (isCurrentConstraintClimb) {
                    // We have reached a climb constraint.
                    if (currentConstraintIndex - 1 > targetConstraintIndex) {
                        // There is at least one constraint between the existing target constraint and the current climb
                        // constraint. Attempt to extend the constant-FPA path through the constraint immediately following the
                        // current climb constraint (which is guaranteed to be a descent constraint).
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                        const maxAltitude = pathSegmentIsFlat ? currentTargetConstraint.targetAltitude : verticalPlan.constraints[currentConstraintIndex - 1].maxAltitude;
                        const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, maxAltitude, false);
                        if (terminatedIndex < currentConstraintIndex) {
                            // The path was terminated early, which means there is a new target constraint.
                            targetConstraintIndex = terminatedIndex - 1; // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                            currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                            break;
                        }
                    }
                    else {
                        // The existing target constraint immediately follows the current climb constraint. Treat the target
                        // constraint as if it were the first descent constraint and apply the default FPA. Note that we are
                        // guaranteed the target constraint is not a direct constraint.
                        currentTargetConstraint.fpa = this.flightPathAngle;
                    }
                    // Do not designate a new target constraint in order to allow the outer loop to find the new one.
                    targetConstraintIndex = currentConstraintIndex;
                    currentTargetConstraint = undefined;
                    break;
                }
                const minAltitude = currentConstraint.minAltitude;
                const maxAltitude = currentConstraint.maxAltitude;
                if (pathSegmentIsFlat && maxAltitude - currentTargetConstraint.targetAltitude > 0) {
                    // We are in a flat segment (all constraints with FPA = 0) and the current constraint would allow a
                    // non-zero FPA to the constraint immediately following it. Therefore, we set the new target constraint
                    // to the constraint immediately following the current one (because it is at the end of that constraint
                    // where the FPA can potentially change from non-zero to zero). Note that we are guaranteed that the
                    // new target constraint lies prior to the existing target constraint.
                    const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                    const newTargetConstraintIndex = currentConstraintIndex - 1;
                    SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, newTargetConstraintIndex, 
                    // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                    // constraints are equal to the flat segment altitude.
                    Infinity, this.applyPathValuesResult);
                    // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                    targetConstraintIndex = newTargetConstraintIndex - 1;
                    currentTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
                    currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                    currentTargetConstraint.isTarget = true;
                    break;
                }
                else if (!currentTargetConstraintHasFixedFpa && maxAltitude - currentTargetConstraint.targetAltitude <= 0) {
                    // The current constraint does not allow a non-zero FPA to the target constraint, and the target constraint
                    // does not have a fixed FPA. We will mark the current segment as flat and set the target constraint FPA to 0.
                    pathSegmentIsFlat = true;
                    currentTargetConstraint.fpa = 0;
                    if (isCurrentConstraintFirstDescent) {
                        // If the current constraint is the first descent constraint, then we need to make it the new target
                        // constraint because the first descent constraint is never flat.
                        const flatSegmentAltitude = currentTargetConstraint.targetAltitude;
                        SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, currentConstraintIndex, 
                        // Maximum altitude is not needed because we are guaranteed that the target altitudes of all smoothed
                        // constraints are equal to the flat segment altitude.
                        Infinity, this.applyPathValuesResult);
                        // reduce the targetConstraintIndex by 1 because the for loop will +1 it.
                        targetConstraintIndex = currentConstraintIndex - 1;
                        currentTargetConstraint = verticalPlan.constraints[currentConstraintIndex];
                        currentTargetConstraint.targetAltitude = flatSegmentAltitude;
                        currentTargetConstraint.isTarget = true;
                        break;
                    }
                    continue;
                }
                // Get the min and max FPA from the current target constraint to the current constraint.
                const minFpa = VNavUtils.getFpa(currentPathSegmentDistance, minAltitude - currentTargetConstraint.targetAltitude);
                const maxFpa = VNavUtils.getFpa(currentPathSegmentDistance, maxAltitude - currentTargetConstraint.targetAltitude);
                const isFpaOutOfBounds = minFpa > currentPathSegmentMaxFpa || maxFpa < currentPathSegmentMinFpa;
                // A new target constraint needs to be created under the following conditions:
                // - The current constraint cannot be met with a constant FPA path from the current target constraint within
                //   this calculator's FPA limits.
                // - The current constraint is the final approach fix.
                // - The current constraint is a vertical direct constraint.
                // - The current constraint is a manual constraint.
                if (isFpaOutOfBounds || isCurrentConstraintFaf || isCurrentConstraintManual || isCurrentConstraintDirect) {
                    // We need to choose a FPA for the constant-FPA smoothed path.
                    if (isFpaOutOfBounds) {
                        // If we are creating a new target constraint because the current constraint can't be met with a
                        // constant-FPA path, then we set the FPA of the smoothed path to the value that brings the new
                        // target constraint's target altitude as close to meeting the current constraint as possible.
                        if (minFpa > currentPathSegmentMaxFpa) {
                            currentTargetConstraint.fpa = currentPathSegmentMaxFpa;
                        }
                        else {
                            currentTargetConstraint.fpa = currentPathSegmentMinFpa;
                        }
                    }
                    else {
                        // If the new target constraint can be met with a constant-FPA path, then we choose a valid FPA that is
                        // as close to the calculator's default FPA as possible.
                        currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                        currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                        currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    }
                    // Find the next constraint with a max altitude
                    const nextMaxAltitude = SmoothingPathCalculator.findPriorMaxAltitude(verticalPlan, currentConstraintIndex, firstDescentConstraintIndex);
                    // Attempt to extend a constant-FPA path from the existing target constraint to the current constraint and
                    // make the current constraint the new target constraint.
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex, nextMaxAltitude, true);
                    targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                    currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                    break;
                }
                else if (isCurrentConstraintFirstDescent) {
                    // We have reached the first descent constraint without needing to create a new target constraint, so
                    // attempt to extend the constant-FPA path from the existing target constraint through the first descent
                    // constraint.
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentTargetConstraint.fpa = MathUtils.clamp(this.flightPathAngle, currentPathSegmentMinFpa, currentPathSegmentMaxFpa);
                    const terminatedIndex = this.terminateSmoothedPath(verticalPlan, targetConstraintIndex, currentConstraintIndex + 1, currentConstraint.maxAltitude, false);
                    if (terminatedIndex < currentConstraintIndex + 1) {
                        // The path was terminated early, which means there is a new target constraint.
                        targetConstraintIndex = terminatedIndex - 1; // reduce the nextTargetConstraintIndex by 1 because the for loop will +1 it.
                        currentTargetConstraint = verticalPlan.constraints[terminatedIndex];
                        break;
                    }
                    else {
                        // The path was not terminated early, so we are done.
                        return true;
                    }
                }
                else {
                    // Extend the current constant-FPA path and update the FPA limits
                    currentPathSegmentMinFpa = Math.max(minFpa, currentPathSegmentMinFpa);
                    currentPathSegmentMaxFpa = Math.min(maxFpa, currentPathSegmentMaxFpa);
                    currentPathSegmentDistance += currentConstraint.distance;
                }
            }
        }
        return true;
    }
    /**
     * Attempts to extend and terminate a constant-FPA path from an existing target constraint at another constraint,
     * applying flight path angles and target altitudes to each constraint along the path. The target constraint defines
     * the FPA of the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param terminatingConstraintIndex The index of the constraint at which to terminate the path.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param terminatingConstraintIsTarget Whether to designate the terminating constraint as a target constraint if the
     * path is not terminated early. If the path is terminated early, this argument is ignored and the constraint at
     * which the path was terminated early is always designated as a target constraint.
     * @returns The index of the constraint at which the constant-FPA path was actually terminated.
     */
    terminateSmoothedPath(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, terminatingConstraintIsTarget) {
        const [maxAltitudeViolatedIndex, smoothedSegmentDistance] = SmoothingPathCalculator.applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, terminatingConstraintIndex, maxAltitude, this.applyPathValuesResult);
        if (terminatingConstraintIsTarget || maxAltitudeViolatedIndex !== undefined) {
            // A constant-FPA path was not able to be extended from the existing target constraint to the first descent
            // constraint, so we need to designate a new target constraint where the path terminated.
            const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
            // Establish the proposed next target constraint target altitude
            const proposedNewTargetConstraintAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, smoothedSegmentDistance);
            const newTargetConstraintIndex = maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
            // Set the new target constraint values
            const newTargetConstraint = verticalPlan.constraints[newTargetConstraintIndex];
            newTargetConstraint.isTarget = true;
            newTargetConstraint.targetAltitude = MathUtils.clamp(proposedNewTargetConstraintAltitude, newTargetConstraint.minAltitude, Math.min(newTargetConstraint.maxAltitude, maxAltitude));
        }
        return maxAltitudeViolatedIndex !== null && maxAltitudeViolatedIndex !== void 0 ? maxAltitudeViolatedIndex : terminatingConstraintIndex;
    }
    /** @inheritdoc */
    getFirstDescentConstraintAltitude(planIndex) {
        const verticalPlan = this.getVerticalFlightPlan(planIndex);
        if (verticalPlan.constraints.length > 0) {
            for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                const constraint = verticalPlan.constraints[i];
                if (constraint.type !== 'climb') {
                    return constraint.targetAltitude;
                }
            }
        }
        return undefined;
    }
    // Start of buildVerticalFlightPlan helper methods
    /**
     * Gets the constraint altitudes for a lateral flight plan leg.
     * @param leg A lateral flight plan leg.
     * @param out The tuple to which to write the altitudes, as `[minimum_altitude, maximum_altitude]`.
     * @returns The constraint altitudes, in meters, for the specified flight plan leg, as
     * `[minimum_altitude, maximum_altitude]`, or `undefined` if the leg does not define any altitude constraints.
     */
    static getConstraintAltitudes(leg, out) {
        if (leg.verticalData !== undefined) {
            switch (leg.verticalData.altDesc) {
                case AltitudeRestrictionType.At:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.AtOrAbove:
                    out[0] = leg.verticalData.altitude1;
                    out[1] = Number.POSITIVE_INFINITY;
                    return out;
                case AltitudeRestrictionType.AtOrBelow:
                    out[0] = Number.NEGATIVE_INFINITY;
                    out[1] = leg.verticalData.altitude1;
                    return out;
                case AltitudeRestrictionType.Between:
                    out[0] = leg.verticalData.altitude2;
                    out[1] = leg.verticalData.altitude1;
                    return out;
            }
        }
        return undefined;
    }
    /**
     * Forces a constraint to an AT constraint.
     * @param constraint The constraint to force to an AT constraint.
     */
    static forceAtConstraint(constraint) {
        if (constraint.minAltitude !== constraint.maxAltitude) {
            if (constraint.minAltitude > Number.NEGATIVE_INFINITY) {
                constraint.maxAltitude = constraint.minAltitude;
            }
            else {
                constraint.minAltitude = constraint.maxAltitude;
            }
        }
    }
    /**
     * Gets the global index of a flight plan's lateral direct-to target leg.
     * @param lateralPlan A flight plan.
     * @returns The global index of the flight plan's lateral direct-to target leg, or `undefined` if the plan does not
     * have an existing lateral direct-to.
     */
    static getDirectToTargetLegIndex(lateralPlan) {
        const directToData = lateralPlan.directToData;
        if (lateralPlan.length > 0 && directToData.segmentIndex > -1 && directToData.segmentLegIndex > -1) {
            const segment = lateralPlan.tryGetSegment(directToData.segmentIndex);
            if (segment !== null) {
                return segment.offset + directToData.segmentLegIndex;
            }
        }
        return undefined;
    }
    /**
     * Checks if there is a lateral direct-to leg in the flight plan and if so, flags the corresponding vertical flight
     * plan leg as such and marks the first descent constraint
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalPlan The Vertical Flight Plan.
     * @param directToLegOffset The offset of the lateral direct-to leg from the direct-to target leg.
     */
    static handleDirectToLegInVerticalPlan(lateralPlan, verticalPlan, directToLegOffset) {
        // Check for a direct to in the lateral plan
        if (lateralPlan.directToData.segmentIndex > -1 && lateralPlan.directToData.segmentLegIndex > -1) {
            const directLateralLeg = lateralPlan.getLeg(lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
            if (BitFlags.isAll(directLateralLeg.flags, LegDefinitionFlags.DirectTo)) {
                const directVerticalLeg = VNavUtils.getVerticalLegFromSegmentInPlan(verticalPlan, lateralPlan.directToData.segmentIndex, lateralPlan.directToData.segmentLegIndex + directToLegOffset);
                directVerticalLeg.isDirectToTarget = true;
                const segment = verticalPlan.segments[lateralPlan.directToData.segmentIndex];
                if (segment !== undefined) {
                    const globalLegIndex = segment.offset + lateralPlan.directToData.segmentLegIndex + directToLegOffset;
                    for (let i = verticalPlan.constraints.length - 1; i >= 0; i--) {
                        const constraint = verticalPlan.constraints[i];
                        if (constraint.type !== 'climb' && constraint.type !== 'missed' && constraint.index >= globalLegIndex) {
                            verticalPlan.firstDescentConstraintLegIndex = constraint.index;
                            return;
                        }
                    }
                    verticalPlan.firstDescentConstraintLegIndex = undefined;
                }
            }
        }
    }
    /**
     * Checks whether a leg constraint is part of the missed approach.
     * @param lateralSegment The lateral flight plan segment to which the constraint's leg belongs.
     * @param lateralLeg The lateral flight plan leg to which the constraint belongs.
     * @returns Whether the leg constraint is part of the missed approach.
     */
    static isConstraintInMissedApproach(lateralSegment, lateralLeg) {
        if (lateralSegment.segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(lateralLeg.flags, LegDefinitionFlags.MissedApproach)) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constriant is a descent constraint and is higher than the prior descent leg constraint.
     * @param previousConstrant The previous VNav Constraint.
     * @param currentConstraint The current VNav Constraint.
     * @returns Whether the current constraint is higher than the previous constraint.
     */
    static isConstraintHigherThanPriorConstraint(previousConstrant, currentConstraint) {
        const currentMinWithPrecision = Math.round(currentConstraint.minAltitude * 10) / 10;
        const priorMaxWithPrecision = Math.round(previousConstrant.maxAltitude * 10) / 10;
        if (currentMinWithPrecision > priorMaxWithPrecision) {
            return true;
        }
        return false;
    }
    /**
     * Checks whether a leg constraint requires an FPA greater than the max allowed value.
     * @param previousConstrant The previous VNavConstraint.
     * @param currentConstraint The VNavConstraint being evaluated.
     * @param verticalPlan The vertical flight plan.
     * @param maxFpa The maximum FPA allowed.
     * @returns Whether this constraint requires an invalid FPA.
     */
    static doesConstraintRequireInvalidFpa(previousConstrant, currentConstraint, verticalPlan, maxFpa) {
        if (currentConstraint.maxAltitude < Number.POSITIVE_INFINITY && previousConstrant.minAltitude >= 0) {
            const constraintDistance = VNavUtils.getConstraintDistanceFromLegs(currentConstraint, previousConstrant, verticalPlan);
            const minFpaTempValue = VNavUtils.getFpa(constraintDistance, Math.abs(currentConstraint.maxAltitude - previousConstrant.minAltitude));
            if (minFpaTempValue > maxFpa) {
                return true;
            }
        }
        return false;
    }
    /**
     * The default function which checks whether a lateral flight plan leg is eligible for VNAV.
     * @param lateralLeg A lateral flight plan leg.
     * @returns Whether the specified leg is eligible for VNAV.
     */
    static isLegVnavEligible(lateralLeg) {
        switch (lateralLeg.leg.type) {
            case LegType.VM:
            case LegType.FM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * The default function which checks whether a climb constraint should be invalidated. This function always returns
     * `false`.
     * @returns Whether the specified climb constraint should be invalidated (always `false`).
     */
    static invalidateClimbConstraint() {
        return false;
    }
    /**
     * The default function which checks whether a descent constraint should be invalidated.
     * @param constraint A descent constraint.
     * @param index The index of the constraint to check.
     * @param constraints The array of VNAV constraints currently in the vertical flight plan.
     * @param priorMinAltitude The most recent minimum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param priorMaxAltitude The most recent maximum altitude, in meters, defined by a VNAV constraint prior to the
     * constraint to check. Only prior constraints connected to the constraint to check by a contiguous sequence of
     * descent constraints are included.
     * @param requiredFpa The minimum flight path angle, in degrees, required to meet the maximum altitude of the
     * constraint to check, assuming a descent starting from the constraint defining the most recent prior minimum
     * altitude. Positive values indicate a descending path. If there is no required FPA because there is no defined
     * prior minimum altitude or maximum altitude for the constraint to check, or if the constraint to check is higher
     * than the prior minimum altitude, then this value will equal zero.
     * @param maxFpa The maximum allowed flight path angle, in degrees. Positive values indicate a descending path.
     * @returns Whether the specified descent constraint should be invalidated.
     */
    static invalidateDescentConstraint(constraint, index, constraints, priorMinAltitude, priorMaxAltitude, requiredFpa, maxFpa) {
        return (isFinite(constraint.minAltitude) && MathUtils.round(constraint.minAltitude, 10) > MathUtils.round(priorMaxAltitude, 10)) || requiredFpa > maxFpa;
    }
    // Start of computeFlightPathAngles helper methods
    /**
     * Finds the maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to a
     * given constraint, among all constraints prior to and including (in flight plan order) the given constraint. If a
     * vertical direct constraint is among the candidates, its minimum altitude is used if it does not define a maximum
     * altitude.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the constraint for which to find the closest prior maximum altitude.
     * @param firstDescentConstraintIndex The index of the first descent constraint.
     * @returns The maximum altitude, in meters, of the constraint that defines a maximum altitude and is closest to the
     * specified constraint, among all constraints prior to and including (in flight plan order) the specified
     * constraint, or `Infinity` if there is no such altitude.
     */
    static findPriorMaxAltitude(verticalPlan, constraintIndex, firstDescentConstraintIndex) {
        for (let i = constraintIndex; i <= firstDescentConstraintIndex; i++) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.maxAltitude < Infinity) {
                return constraint.maxAltitude;
            }
            if (i === firstDescentConstraintIndex && constraint.type === 'direct') {
                if (constraint.minAltitude > -Infinity) {
                    return constraint.minAltitude;
                }
            }
        }
        return Infinity;
    }
    /**
     * Applies flight path angle and target altitude values to a sequence of constraints connected to a target constraint
     * by a constant-FPA path extending backwards from the target constraint. The target constraint defines the FPA of
     * the path.
     *
     * If the target altitude of one of the constraints in the sequence, as prescribed by the path, violates a maximum
     * altitude, the path will be terminated at the constraint immediately following (in flight plan order) the violating
     * constraint, and FPA and target altitudes will not be written to the terminating constraint or any prior
     * constraints.
     * @param verticalPlan The vertical flight plan.
     * @param targetConstraintIndex The index of the target constraint.
     * @param endConstraintIndex The index of the constraint at which the constant-FPA path ends, exclusive.
     * @param maxAltitude The maximum allowable target altitude, in meters.
     * @param out The tuple to which to write the result of the operation.
     * @returns `[index, distance]`, where `index` is the index of the constraint at which the path was terminated due to
     * violation of the maximum target altitude, or `undefined` if no constraint violated the maximum altitude, and
     * `distance` is the total distance of the path, in meters.
     */
    static applyPathValuesToSmoothedConstraints(verticalPlan, targetConstraintIndex, endConstraintIndex, maxAltitude, out) {
        const currentTargetConstraint = verticalPlan.constraints[targetConstraintIndex];
        let distance = currentTargetConstraint.distance;
        for (let i = targetConstraintIndex + 1; i < endConstraintIndex; i++) {
            const smoothedConstraint = verticalPlan.constraints[i];
            const targetAltitude = currentTargetConstraint.targetAltitude + VNavUtils.altitudeForDistance(currentTargetConstraint.fpa, distance);
            // The path can continue past the current constraint if the target altitude at the current constraint is less
            // than the maximum altitude.
            if (targetAltitude < maxAltitude) {
                smoothedConstraint.fpa = currentTargetConstraint.fpa;
                smoothedConstraint.targetAltitude = targetAltitude;
                distance += smoothedConstraint.distance;
            }
            else {
                out[0] = i;
                out[1] = distance;
                return out;
            }
        }
        out[0] = undefined;
        out[1] = distance;
        return out;
    }
}
SmoothingPathCalculator.DEFAULT_DEFAULT_FPA = 3;
SmoothingPathCalculator.DEFAULT_MIN_FPA = 1.5;
SmoothingPathCalculator.DEFAULT_MAX_FPA = 6;
SmoothingPathCalculator.DEFAULT_DIRECT_TO_LEG_OFFSET = 3;

/**
 * Sim var names for LNAV-related data.
 */
var LNavDataVars;
(function (LNavDataVars) {
    /** The current nominal desired track, in degrees true. */
    LNavDataVars["DTKTrue"] = "L:WT_LNavData_DTK_True";
    /** The current nominal desired track, in degrees magnetic. */
    LNavDataVars["DTKMagnetic"] = "L:WT_LNavData_DTK_Mag";
    /**
     * The current nominal crosstrack error. Negative values indicate deviation to the left, as viewed when facing in the
     * direction of the track. Positive values indicate deviation to the right.
     */
    LNavDataVars["XTK"] = "L:WT_LNavData_XTK";
    /** The current CDI scale. */
    LNavDataVars["CDIScale"] = "L:WT_LNavData_CDI_Scale";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees true. */
    LNavDataVars["WaypointBearingTrue"] = "L:WT_LNavData_Waypoint_Bearing_True";
    /** The nominal bearing to the next waypoint currently tracked by LNAV, in degrees magnetic. */
    LNavDataVars["WaypointBearingMagnetic"] = "L:WT_LNavData_Waypoint_Bearing_Mag";
    /** The nominal distance remaining to the next waypoint currently tracked by LNAV. */
    LNavDataVars["WaypointDistance"] = "L:WT_LNavData_Waypoint_Distance";
    /** The nominal distance remaining to the destination. */
    LNavDataVars["DestinationDistance"] = "L:WT_LNavData_Destination_Distance";
})(LNavDataVars || (LNavDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class LNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(LNavDataSimVarPublisher.simvars, bus);
    }
}
LNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }]
]);

/** AP Mode Types */
var APModeType;
(function (APModeType) {
    APModeType[APModeType["LATERAL"] = 0] = "LATERAL";
    APModeType[APModeType["VERTICAL"] = 1] = "VERTICAL";
    APModeType[APModeType["APPROACH"] = 2] = "APPROACH";
})(APModeType || (APModeType = {}));
/**
 * A class that manages the autopilot modes and autopilot mode states.
 */
class APStateManager {
    /**
     * Creates an instance of the APStateManager.
     * @param bus An instance of the event bus.
     * @param apConfig This autopilot's configuration.
     */
    constructor(bus, apConfig) {
        this.bus = bus;
        this.apConfig = apConfig;
        this.apListenerRegistered = false;
        this.managedModeSet = false;
        this.stateManagerInitialized = Subject.create(false);
        this.lateralPressed = new SubEvent();
        this.verticalPressed = new SubEvent();
        this.approachPressed = new SubEvent();
        this.vnavPressed = new SubEvent();
        this.apMasterOn = Subject.create(false);
        this._isFlightDirectorOn = Subject.create(false);
        this.isFlightDirectorOn = this._isFlightDirectorOn;
        this._isFlightDirectorCoPilotOn = Subject.create(false);
        this.isFlightDirectorCoPilotOn = this._isFlightDirectorCoPilotOn;
        KeyEventManager.getManager(bus).then(manager => {
            this.keyEventManager = manager;
            this.setupKeyIntercepts(manager);
            this.bus.getSubscriber().on('key_intercept').handle(this.handleKeyIntercepted.bind(this));
        });
        this.apListener = RegisterViewListener('JS_LISTENER_AUTOPILOT', () => {
            this.onAPListenerRegistered();
            this.apListenerRegistered = true;
        });
    }
    /**
     * A callback which is called when the autopilot listener has been registered.
     */
    onAPListenerRegistered() {
        const ap = this.bus.getSubscriber();
        ap.on('ap_lock_set').handle(lock => {
            if (lock === APLockType.VNav) {
                this.vnavPressed.notify(this, true);
            }
        });
        ap.on('ap_lock_release').handle(lock => {
            if (lock === APLockType.VNav) {
                this.vnavPressed.notify(this, false);
            }
        });
        ap.on('ap_master_status').handle(this.apMasterOn.set.bind(this.apMasterOn));
        ap.on('flight_director_is_active_1').whenChanged().handle((fd) => {
            this._isFlightDirectorOn.set(fd);
            this.setFlightDirector(fd);
        });
        ap.on('flight_director_is_active_2').whenChanged().handle((fd) => {
            this._isFlightDirectorCoPilotOn.set(fd);
            this.setFlightDirector(fd);
        });
    }
    /**
     * Checks whether the AP State Manager has completed listerner steps,
     * and if so, finishes initializing and then notifies Autopilot of the same.
     * @param force forces the initialize
     */
    initialize(force = false) {
        this.onBeforeInitialize();
        if (force || (this.keyEventManager && this.apListenerRegistered)) {
            this.setManagedMode(true).then(() => {
                var _a;
                SimVar.SetSimVarValue('AUTOPILOT ALTITUDE LOCK VAR', SimVarValueType.Feet, (_a = this.apConfig.altitudeHoldDefaultAltitude) !== null && _a !== void 0 ? _a : 0);
                this.initFlightDirector();
                this.stateManagerInitialized.set(true);
            });
        }
    }
    /** Initializes the flight director to a default value. */
    initFlightDirector() {
        this.setFlightDirector(false);
    }
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     */
    setFlightDirector(on) {
        // HINT: Delay this by a frame so we know about the actual FD state
        setTimeout(() => {
            if (on !== this.isFlightDirectorOn.get()) {
                SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 1);
                this._isFlightDirectorOn.set(on);
            }
            if (on !== this.isFlightDirectorCoPilotOn.get()) {
                SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 2);
                this._isFlightDirectorCoPilotOn.set(on);
            }
        }, 0);
    }
    /**
     * Sets Managed Mode.
     * @param set is wheter to set or unset managed mode.
     */
    async setManagedMode(set) {
        return new Promise(resolve => {
            setTimeout(() => {
                if (set) {
                    Coherent.call('apSetAutopilotMode', MSFSAPStates.AvionicsManaged, 1).then(() => resolve());
                }
                else {
                    Coherent.call('apSetAutopilotMode', MSFSAPStates.AvionicsManaged, 0).then(() => resolve());
                }
                this.managedModeSet = set;
            }, 1000);
        });
    }
    /**
     * Toggles VNAV L Var value.
     */
    toggleVnav() {
        const vnavXmlVarValue = SimVar.GetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool');
        SimVar.SetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool', vnavXmlVarValue ? 0 : 1);
    }
    /**
     * Sends AP Mode Events from the Intercept to the Autopilot.
     * @param type is the AP Mode Type for this event
     * @param mode is the mode to set/unset.
     * @param set is whether to actively set or unset this mode.
     */
    sendApModeEvent(type, mode, set) {
        switch (type) {
            case APModeType.LATERAL:
                if (mode !== undefined) {
                    this.lateralPressed.notify(this, { mode: mode, set: set });
                }
                break;
            case APModeType.VERTICAL:
                if (mode !== undefined) {
                    this.verticalPressed.notify(this, { mode: mode, set: set });
                }
                break;
            case APModeType.APPROACH:
                this.approachPressed.notify(this, set);
                break;
        }
    }
    /**
     * Method to override with steps to run before initialze method is run.
     */
    onBeforeInitialize() {
        //noop
    }
}

/**
 * Autothrottle target modes.
 */
var AutothrottleTargetMode;
(function (AutothrottleTargetMode) {
    /** No target. */
    AutothrottleTargetMode["None"] = "None";
    /** Autothrottle targets a specific airspeed. */
    AutothrottleTargetMode["Speed"] = "Speed";
    /** Autothrottle targets a specific engine power setting. */
    AutothrottleTargetMode["Power"] = "Power";
    /** Autothrottle targets a specific throttle lever position. */
    AutothrottleTargetMode["ThrottlePos"] = "ThrottlePos";
})(AutothrottleTargetMode || (AutothrottleTargetMode = {}));

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * An abstract implementation of an autothrottle system.
 *
 * The system contains a global speed controller and one power controller for each engine throttle. The speed
 * controller commands a synced engine power target for all throttles based on over/underspeed protection and the
 * selected speed target, if active. Each power controller commands a position for its individual throttle based on
 * overpower protection and power target, either from the speed controller or the selected power target, if active.
 */
class AbstractAutothrottle {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param airspeedIndex The index of the sim airspeed indicator from which this autothrottle should source airspeed
     * data.
     * @param throttleInfos Information on the throttles controlled by this autothrottle. Each entry in the array should
     * describe a single unique throttle. Order does not matter.
     * @param options Options with which to initialize this autothrottle.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for virtual throttle
     * levers. If not defined, position changes for virtual throttle levers will be requested using key events
     * (specifically the `THROTTLE[N]_SET` event).
     */
    constructor(bus, airspeedIndex, throttleInfos, options, throttleLeverManager) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.isOverspeedProtActive = Subject.create(false);
        this.isUnderspeedProtActive = Subject.create(false);
        this.isOverpowerProtActive = Subject.create(false);
        this.targetMode = Subject.create(AutothrottleTargetMode.None);
        this.selectedSpeedIsMach = Subject.create(false);
        this.selectedIas = Subject.create(0);
        this.selectedMach = Subject.create(0);
        this.selectedPower = Subject.create(0);
        this.selectedThrottlePos = Subject.create(0);
        this.maxIas = Subject.create(0);
        this.minIas = Subject.create(0);
        this.maxMach = Subject.create(0);
        this.minMach = Subject.create(0);
        this.maxPower = Subject.create(0);
        this.maxThrottlePos = Subject.create(1);
        this.minThrottlePos = Subject.create(0);
        this.lastSmoothedIas = undefined;
        this.lastTargetIas = undefined;
        this.lastOverspeedIas = undefined;
        this.lastUnderspeedIas = undefined;
        this.realTime = ConsumerSubject.create(this.bus.getSubscriber().on('realTime'), 0);
        this.updateTimer = null;
        this.lastUpdateTime = 0;
        this.updateHandler = this.update.bind(this);
        this.speedCommand = {
            selectedSpeedPowerTarget: undefined,
            overspeedProtPowerTarget: undefined,
            underspeedProtPowerTarget: undefined,
            isOverspeed: false,
            isUnderspeed: false
        };
        this.powerCommand = {
            speed: undefined,
            targetPos: undefined,
            isOverspeedProtEngaged: false,
            isUnderspeedProtEngaged: false,
            isOverpowerProtEngaged: false
        };
        this.isAlive = true;
        this.airspeedIndex = SubscribableUtils.toSubscribable(airspeedIndex, true);
        this.airspeedIndex.sub(index => { this.airspeedSimVar = `AIRSPEED INDICATED:${index}`; }, true);
        this.powerLookahead = SubscribableUtils.toSubscribable(options.powerLookahead, true);
        this.throttles = throttleInfos.map(info => {
            return this.createThrottle(bus, info, options.servoSpeed, options.powerSmoothingConstant, options.powerSmoothingVelocityConstant, this.powerLookahead, options.powerLookaheadSmoothingConstant, options.powerLookaheadSmoothingVelocityConstant, throttleLeverManager);
        });
        this.machToKiasSmoother = new ExpSmoother(options.speedSmoothingConstant);
        this.iasLookahead = SubscribableUtils.toSubscribable(options.speedLookahead, true);
        this.iasSmoother = new MultiExpSmoother(options.speedSmoothingConstant, options.speedSmoothingVelocityConstant);
        this.lookaheadIasSmoother = new MultiExpSmoother((_a = options.speedLookaheadSmoothingConstant) !== null && _a !== void 0 ? _a : options.speedSmoothingConstant, (_b = options.speedLookaheadSmoothingVelocityConstant) !== null && _b !== void 0 ? _b : options.speedSmoothingVelocityConstant);
        this.lastIasLookahead = this.iasLookahead.get();
        this.shouldTargetAccel = options.selectedSpeedAccelTarget !== undefined;
        this.selectedSpeedAccelTargetFunc = options.selectedSpeedAccelTarget;
        this.overspeedAccelTargetFunc = (_c = options.overspeedAccelTarget) !== null && _c !== void 0 ? _c : options.selectedSpeedAccelTarget;
        this.underspeedAccelTargetFunc = (_d = options.underspeedAccelTarget) !== null && _d !== void 0 ? _d : options.selectedSpeedAccelTarget;
        if (this.shouldTargetAccel) {
            this.accelSmoother = new MultiExpSmoother((_e = options.accelSmoothingConstant) !== null && _e !== void 0 ? _e : 0, options.accelSmoothingVelocityConstant);
            const accelTargetTau = (_f = options.accelTargetSmoothingConstant) !== null && _f !== void 0 ? _f : 0;
            this.selectedSpeedAccelTargetSmoother = new ExpSmoother(accelTargetTau);
            this.overspeedProtAccelTargetSmoother = new ExpSmoother(accelTargetTau);
            this.underspeedProtAccelTargetSmoother = new ExpSmoother(accelTargetTau);
        }
        this.selectedSpeedPid = AbstractAutothrottle.createPidFromParams(options.speedTargetPid);
        this.overspeedPid = AbstractAutothrottle.createPidFromParams((_g = options.overspeedPid) !== null && _g !== void 0 ? _g : options.speedTargetPid);
        this.underspeedPid = AbstractAutothrottle.createPidFromParams((_h = options.underspeedPid) !== null && _h !== void 0 ? _h : options.speedTargetPid);
        this.selectedPowerPids = {
            [1]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
            [2]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
            [3]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid),
            [4]: AbstractAutothrottle.createPidFromParams(options.powerTargetPid)
        };
        this.overpowerPids = {
            [1]: AbstractAutothrottle.createPidFromParams((_j = options.overpowerPid) !== null && _j !== void 0 ? _j : options.powerTargetPid),
            [2]: AbstractAutothrottle.createPidFromParams((_k = options.overpowerPid) !== null && _k !== void 0 ? _k : options.powerTargetPid),
            [3]: AbstractAutothrottle.createPidFromParams((_l = options.overpowerPid) !== null && _l !== void 0 ? _l : options.powerTargetPid),
            [4]: AbstractAutothrottle.createPidFromParams((_m = options.overpowerPid) !== null && _m !== void 0 ? _m : options.powerTargetPid)
        };
        this.speedTargetChangeThreshold = (_o = options.speedTargetChangeThreshold) !== null && _o !== void 0 ? _o : Infinity;
        this.overspeedChangeThreshold = (_p = options.overspeedChangeThreshold) !== null && _p !== void 0 ? _p : Infinity;
        this.underspeedChangeThreshold = (_q = options.underspeedChangeThreshold) !== null && _q !== void 0 ? _q : Infinity;
        this.selectedSpeedPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
        this.overspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
        this.underspeedProtPowerTargetSmoother = new ExpSmoother(options.powerTargetSmoothingConstant);
        this.hysteresis = Math.max(0, options.hysteresis);
        this.hysteresisRecord = {
            [1]: 0,
            [2]: 0,
            [3]: 0,
            [4]: 0,
        };
        // Publish data
        this.publisher.pub('at_master_is_active', false, true, true);
        this.isOverspeedProtActive.sub(val => this.publisher.pub('at_overspeed_prot_is_active', val, true, true), true);
        this.isUnderspeedProtActive.sub(val => this.publisher.pub('at_underspeed_prot_is_active', val, true, true), true);
        this.isOverpowerProtActive.sub(val => this.publisher.pub('at_overpower_prot_is_active', val, true, true), true);
        this.targetMode.sub(val => this.publisher.pub('at_target_mode', val, true, true), true);
        this.selectedIas.sub(val => this.publisher.pub('at_selected_ias', val, true, true), true);
        this.selectedMach.sub(val => this.publisher.pub('at_selected_mach', val, true, true), true);
        this.selectedSpeedIsMach.sub(val => this.publisher.pub('at_selected_speed_is_mach', val, true, true), true);
        this.selectedPower.sub(val => this.publisher.pub('at_selected_power', val, true, true), true);
        this.selectedThrottlePos.sub(val => this.publisher.pub('at_selected_throttle_pos', val, true, true), true);
        this.maxIas.sub(val => this.publisher.pub('at_max_ias', val, true, true), true);
        this.maxMach.sub(val => this.publisher.pub('at_max_mach', val, true, true), true);
        this.minIas.sub(val => this.publisher.pub('at_min_ias', val, true, true), true);
        this.minMach.sub(val => this.publisher.pub('at_min_mach', val, true, true), true);
        this.maxPower.sub(val => this.publisher.pub('at_max_power', val, true, true), true);
        this.maxThrottlePos.sub(val => this.publisher.pub('at_max_throttle_pos', val, true, true), true);
        this.minThrottlePos.sub(val => this.publisher.pub('at_min_throttle_pos', val, true, true), true);
    }
    /**
     * Sets whether this autothrottle's overspeed protection is active.
     * @param val Whether overspeed protection is active.
     */
    setOverspeedProtActive(val) {
        this.isOverspeedProtActive.set(val);
    }
    /**
     * Sets whether this autothrottle's underspeed protection is active.
     * @param val Whether underspeed protection is active.
     */
    setUnderspeedProtActive(val) {
        this.isUnderspeedProtActive.set(val);
    }
    /**
     * Sets whether this autothrottle's overpower protection is active.
     * @param val Whether overpower protection is active.
     */
    setOverpowerProtActive(val) {
        this.isOverpowerProtActive.set(val);
    }
    /**
     * Sets this autothrottle's target mode.
     * @param mode A target mode.
     */
    setTargetMode(mode) {
        this.targetMode.set(mode);
    }
    /**
     * Sets whether this autothrottle's selected speed target is a mach number.
     * @param val Whether the selected speed target is a mach number.
     */
    setSelectedSpeedIsMach(val) {
        this.selectedSpeedIsMach.set(val);
    }
    /**
     * Sets this autothrottle's selected indicated airspeed target, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setSelectedIas(ias) {
        this.selectedIas.set(ias);
    }
    /**
     * Sets this autothrottle's selected mach number target.
     * @param mach A mach number.
     */
    setSelectedMach(mach) {
        this.selectedMach.set(mach);
    }
    /**
     * Sets this autothrottle's selected engine power target.
     * @param power An engine power value.
     */
    setSelectedPower(power) {
        this.selectedPower.set(power);
    }
    /**
     * Sets this autothrottle's selected normalized throttle lever position target.
     * @param pos A normalized throttle lever position.
     */
    setSelectedThrottlePos(pos) {
        this.selectedThrottlePos.set(pos);
    }
    /**
     * Sets this autothrottle's maximum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMaxIas(ias) {
        this.maxIas.set(ias);
    }
    /**
     * Sets this autothrottle's minimum allowed indicated airspeed, in knots.
     * @param ias An indicated airspeed, in knots.
     */
    setMinIas(ias) {
        this.minIas.set(ias);
    }
    /**
     * Sets this autothrottle's maximum allowed mach number.
     * @param mach A mach number.
     */
    setMaxMach(mach) {
        this.maxMach.set(mach);
    }
    /**
     * Sets this autothrottle's minimum allowed mach number.
     * @param mach A mach number.
     */
    setMinMach(mach) {
        this.minMach.set(mach);
    }
    /**
     * Sets this autothrottle's maximum allowed engine power.
     * @param power An engine power value.
     */
    setMaxPower(power) {
        this.maxPower.set(power);
    }
    /**
     * Sets this autothrottle's maximum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMaxThrottlePos(pos) {
        this.maxThrottlePos.set(pos);
    }
    /**
     * Sets this autothrottle's minimum allowed normalized throttle lever position.
     * @param pos A normalized throttle lever position.
     */
    setMinThrottlePos(pos) {
        this.minThrottlePos.set(pos);
    }
    /**
     * Sets whether one of this autothrottle's throttle servos are active.
     * @param index The index of the throttle servo to activate/deactivate.
     * @param active Whether the servo should be activated.
     */
    setServoActive(index, active) {
        const throttle = this.throttles.find(query => query.index === index);
        if (throttle !== undefined) {
            throttle.isServoActive = active;
        }
    }
    /**
     * Turns this autothrottle on with a specified update frequency. If this autothrottle is already running, then it
     * will be turned off before turning on again with the specified frequency.
     * @param frequency The frequency, in hertz, at which this autothrottle will update.
     * @throws Error if this autothrottle has been destroyed.
     */
    start(frequency) {
        if (!this.isAlive) {
            throw new Error('AbstractAutothrottle: cannot start a dead autothrottle');
        }
        this.stop();
        this.publisher.pub('at_master_is_active', true, true, true);
        this.updateTimer = setInterval(this.updateHandler, 1000 / frequency);
    }
    /**
     * Turns this autothrottle off.
     * @throws Error if this autothrottle has been destroyed.
     */
    stop() {
        var _a, _b, _c, _d;
        if (!this.isAlive) {
            throw new Error('AbstractAutothrottle: cannot stop a dead autothrottle');
        }
        if (this.updateTimer === null) {
            return;
        }
        clearInterval(this.updateTimer);
        this.updateTimer = null;
        this.machToKiasSmoother.reset();
        this.iasSmoother.reset();
        this.lookaheadIasSmoother.reset();
        this.lastSmoothedIas = undefined;
        (_a = this.accelSmoother) === null || _a === void 0 ? void 0 : _a.reset();
        (_b = this.selectedSpeedAccelTargetSmoother) === null || _b === void 0 ? void 0 : _b.reset();
        (_c = this.overspeedProtAccelTargetSmoother) === null || _c === void 0 ? void 0 : _c.reset();
        (_d = this.underspeedProtAccelTargetSmoother) === null || _d === void 0 ? void 0 : _d.reset();
        this.selectedSpeedPid.reset();
        this.overspeedPid.reset();
        this.underspeedPid.reset();
        this.lastTargetIas = undefined;
        this.lastOverspeedIas = undefined;
        this.lastUnderspeedIas = undefined;
        this.selectedSpeedPowerTargetSmoother.reset();
        this.overspeedProtPowerTargetSmoother.reset();
        this.underspeedProtPowerTargetSmoother.reset();
        for (let i = 0; i < this.throttles.length; i++) {
            this.throttles[i].resetPowerSmoothing();
        }
        for (const index of AbstractAutothrottle.ALL_THROTTLE_INDEXES) {
            this.selectedPowerPids[index].reset();
            this.overpowerPids[index].reset();
            this.hysteresisRecord[index] = 0;
        }
        this.publisher.pub('at_master_is_active', false, true, true);
    }
    /**
     * Updates this autothrottle.
     */
    update() {
        const realTime = Date.now();
        const dt = (realTime - this.lastUpdateTime) / 1000;
        this.lastUpdateTime = realTime;
        // This shouldn't really ever happen, but just in case...
        if (dt <= 0) {
            return;
        }
        // Check if the current time has diverged from the event bus value by more than 1 second.
        // If it has, we are probably paused in the menu and should skip the update.
        if (realTime - this.realTime.get() >= 1000) {
            return;
        }
        // Update power and position of all throttles
        for (let i = 0; i < this.throttles.length; i++) {
            this.throttles[i].update(dt);
        }
        const targetMode = this.targetMode.get();
        // Obtain power target (if any) commanded by the speed controller.
        const speedCommand = this.calculateSpeedTargetPower(dt, this.speedCommand);
        const isOverpowerProtActive = this.isOverpowerProtActive.get();
        const isPowerTargetActive = targetMode === AutothrottleTargetMode.Power;
        const isThrottlePosTargetActive = targetMode === AutothrottleTargetMode.ThrottlePos;
        const minThrottlePos = this.minThrottlePos.get();
        const maxThrottlePos = this.maxThrottlePos.get();
        for (let i = 0; i < this.throttles.length; i++) {
            const throttle = this.throttles[i];
            if (throttle.isServoActive) {
                // Obtain throttle position adjustment commanded by the power controller.
                const powerCommand = this.calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, this.powerCommand);
                let targetPos = powerCommand.targetPos;
                let speed = powerCommand.speed;
                const isThrottlePosOob = throttle.normPosition < minThrottlePos || throttle.normPosition > maxThrottlePos;
                const isTargetPosOob = targetPos !== undefined && (targetPos < minThrottlePos || targetPos > maxThrottlePos);
                if (isTargetPosOob) {
                    // If the commanded throttle lever position is out of bounds, clamp it to within bounds.
                    targetPos = MathUtils.clamp(targetPos, minThrottlePos, maxThrottlePos);
                    speed = targetPos - throttle.normPosition;
                }
                else if (isThrottlePosOob && targetPos === undefined) {
                    // If there is no commanded throttle lever position but the current throttle lever position is out of
                    // bounds, command the throttle lever to move back in bounds.
                    targetPos = MathUtils.clamp(throttle.normPosition, minThrottlePos, maxThrottlePos);
                    speed = targetPos - throttle.normPosition;
                }
                if (targetPos !== undefined && speed !== undefined) {
                    // Check hysteresis, unless the current throttle position is out of bounds, in which case we always want to
                    // move the throttle back in bounds.
                    const lastCommandedSpeed = this.hysteresisRecord[throttle.index];
                    if (isThrottlePosOob
                        || lastCommandedSpeed === 0
                        || Math.sign(lastCommandedSpeed) === Math.sign(speed)
                        || Math.abs(speed) > this.hysteresis) {
                        throttle.drive(targetPos, dt);
                        this.hysteresisRecord[throttle.index] = speed;
                    }
                }
                else {
                    this.hysteresisRecord[throttle.index] = 0;
                }
            }
            else {
                this.selectedPowerPids[throttle.index].reset();
                this.overpowerPids[throttle.index].reset();
                this.hysteresisRecord[throttle.index] = 0;
            }
        }
    }
    /**
     * Calculates the engine power for all throttles commanded by this autothrottle's speed controller. The speed
     * controller incorporates the speed target and over-/under-speed protection if active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The engine power for all throttles commanded by this autothrottle's speed controller.
     */
    calculateSpeedTargetPower(dt, out) {
        var _a, _b, _c;
        out.selectedSpeedPowerTarget = undefined;
        out.overspeedProtPowerTarget = undefined;
        out.underspeedProtPowerTarget = undefined;
        out.isOverspeed = false;
        out.isUnderspeed = false;
        const ias = SimVar.GetSimVarValue(this.airspeedSimVar, SimVarValueType.Knots);
        const mach = SimVar.GetSimVarValue('AIRSPEED MACH', SimVarValueType.Number);
        const currentMachToKias = ias > 1 && mach > 0 ? ias / mach : Simplane.getMachToKias(1);
        const machToKias = this.machToKiasSmoother.next(isFinite(currentMachToKias) ? currentMachToKias : 1, dt);
        const lookahead = Math.max(0, this.iasLookahead.get());
        const smoothedIas = this.iasSmoother.next(ias, dt);
        if (lookahead !== this.lastIasLookahead) {
            this.lookaheadIasSmoother.reset();
            this.lastIasLookahead = lookahead;
        }
        let effectiveIas;
        const deltaIas = smoothedIas - (this.lastSmoothedIas === undefined ? smoothedIas : this.lastSmoothedIas);
        if (lookahead > 0 && this.lastSmoothedIas !== undefined) {
            // Somehow, NaN values can creep in here. So we will make sure if that happens we don't leave the system in an
            // unrecoverable state by resetting the smoother when the last smoothed value is NaN.
            const last = this.lookaheadIasSmoother.last();
            effectiveIas = last === null || isFinite(last)
                ? this.lookaheadIasSmoother.next(ias + deltaIas * lookahead / dt, dt)
                : this.lookaheadIasSmoother.reset(ias + deltaIas * lookahead / dt);
        }
        else {
            effectiveIas = smoothedIas;
        }
        this.lastSmoothedIas = smoothedIas;
        let effectiveAccel = 0;
        if (this.shouldTargetAccel) {
            effectiveAccel = this.accelSmoother.next(deltaIas / dt, dt);
        }
        const isTargetSpeed = this.targetMode.get() === AutothrottleTargetMode.Speed;
        const isOverspeedProtActive = this.isOverspeedProtActive.get();
        const isUnderspeedProtActive = this.isUnderspeedProtActive.get();
        let overspeedProtDelta;
        let underspeedProtDelta;
        let selectedSpeedDelta;
        if (isOverspeedProtActive) {
            const maxIas = Math.min(this.maxMach.get() * machToKias, this.maxIas.get());
            if (this.shouldTargetAccel) {
                overspeedProtDelta = this.updateAccelTargetPid(this.overspeedPid, this.overspeedAccelTargetFunc, this.overspeedProtAccelTargetSmoother, effectiveAccel, effectiveIas, maxIas, this.lastOverspeedIas, dt, this.overspeedChangeThreshold);
            }
            else {
                overspeedProtDelta = this.updateSpeedTargetPid(this.overspeedPid, effectiveIas, maxIas, this.lastOverspeedIas, dt, this.overspeedChangeThreshold);
            }
            out.isOverspeed = effectiveIas > maxIas;
            this.lastOverspeedIas = maxIas;
        }
        else {
            this.overspeedPid.reset();
            (_a = this.overspeedProtAccelTargetSmoother) === null || _a === void 0 ? void 0 : _a.reset();
            this.lastOverspeedIas = undefined;
        }
        if (isUnderspeedProtActive) {
            const minIas = Math.max(this.minMach.get() * machToKias, this.minIas.get());
            if (this.shouldTargetAccel) {
                underspeedProtDelta = this.updateAccelTargetPid(this.underspeedPid, this.underspeedAccelTargetFunc, this.underspeedProtAccelTargetSmoother, effectiveAccel, effectiveIas, minIas, this.lastUnderspeedIas, dt, this.underspeedChangeThreshold);
            }
            else {
                underspeedProtDelta = this.updateSpeedTargetPid(this.underspeedPid, effectiveIas, minIas, this.lastUnderspeedIas, dt, this.underspeedChangeThreshold);
            }
            out.isUnderspeed = effectiveIas < minIas;
            this.lastUnderspeedIas = minIas;
        }
        else {
            this.underspeedPid.reset();
            (_b = this.underspeedProtAccelTargetSmoother) === null || _b === void 0 ? void 0 : _b.reset();
            this.lastUnderspeedIas = undefined;
        }
        if (isTargetSpeed) {
            // Targeting speed
            const targetIas = this.selectedSpeedIsMach.get() ? this.selectedMach.get() * machToKias : this.selectedIas.get();
            if (this.shouldTargetAccel) {
                selectedSpeedDelta = this.updateAccelTargetPid(this.selectedSpeedPid, this.selectedSpeedAccelTargetFunc, this.selectedSpeedAccelTargetSmoother, effectiveAccel, effectiveIas, targetIas, this.lastTargetIas, dt, this.speedTargetChangeThreshold);
            }
            else {
                selectedSpeedDelta = this.updateSpeedTargetPid(this.selectedSpeedPid, effectiveIas, targetIas, this.lastTargetIas, dt, this.speedTargetChangeThreshold);
            }
            this.lastTargetIas = targetIas;
        }
        else {
            this.selectedSpeedPid.reset();
            (_c = this.selectedSpeedAccelTargetSmoother) === null || _c === void 0 ? void 0 : _c.reset();
            this.lastTargetIas = undefined;
        }
        let throttlePowerSum = 0;
        let throttlePowerCount = 0;
        for (let i = 0; i < this.throttles.length; i++) {
            const throttle = this.throttles[i];
            if (throttle.isServoActive) {
                throttlePowerSum += throttle.effectivePower;
                throttlePowerCount++;
            }
        }
        if (throttlePowerCount === 0) {
            this.overspeedProtPowerTargetSmoother.reset();
            this.underspeedProtPowerTargetSmoother.reset();
            this.selectedSpeedPowerTargetSmoother.reset();
            return out;
        }
        if (selectedSpeedDelta !== undefined) {
            out.selectedSpeedPowerTarget = this.selectedSpeedPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + selectedSpeedDelta, dt);
        }
        else {
            this.selectedSpeedPowerTargetSmoother.reset();
        }
        if (overspeedProtDelta !== undefined) {
            out.overspeedProtPowerTarget = this.overspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + overspeedProtDelta, dt);
        }
        else {
            this.overspeedProtPowerTargetSmoother.reset();
        }
        if (underspeedProtDelta !== undefined) {
            out.underspeedProtPowerTarget = this.underspeedProtPowerTargetSmoother.next(throttlePowerSum / throttlePowerCount + underspeedProtDelta, dt);
        }
        else {
            this.underspeedProtPowerTargetSmoother.reset();
        }
        return out;
    }
    /**
     * Updates a speed PID controller when directly targeting airspeed.
     * @param pid The PID controller to update.
     * @param effectiveIas The airplane's current effective indicated airspeed, in knots.
     * @param targetIas The target indicated airspeed, in knots.
     * @param lastTargetIas The target indicated airspeed during the last update, in knots.
     * @param dt The elapsed time since the last update, in seconds.
     * @param targetChangeThreshold The threshold, in knots per second, such that if the rate of change of the target
     * speed exceeds the threshold, the PID controller will ignore any contribution to the derivative term from the
     * changing target speed.
     * @returns The output of the speed PID controller.
     */
    updateSpeedTargetPid(pid, effectiveIas, targetIas, lastTargetIas, dt, targetChangeThreshold) {
        const error = targetIas - effectiveIas;
        // Cancel out any derivative term contributed by changes in the target speed.
        if (lastTargetIas !== undefined) {
            const targetIasDelta = targetIas - lastTargetIas;
            const lastError = pid.getPreviousError();
            if (lastError !== undefined && Math.abs(targetIasDelta / dt) >= targetChangeThreshold) {
                pid.getOutput(0, lastError + targetIasDelta);
            }
        }
        return pid.getOutput(dt, error);
    }
    /**
     * Updates a speed PID controller when targeting acceleration.
     * @param pid The PID controller to update.
     * @param accelTargetFunc A function which generates an acceleration to target, in knots per second, for a given
     * airspeed error.
     * @param accelTargetSmoother The smoother to use to smooth the target acceleration.
     * @param effectiveAccel The airplane's effective indicated acceleration, in knots per second.
     * @param effectiveIas The airplane's current effective indicated airspeed, in knots.
     * @param targetIas The target indicated airspeed, in knots.
     * @param lastTargetIas The target indicated airspeed during the last update, in knots.
     * @param dt The elapsed time since the last update, in seconds.
     * @param targetChangeThreshold The threshold, in knots per second, such that if the rate of change of the target
     * speed exceeds the threshold, the PID controller will ignore any contribution to the derivative term from the
     * changing target speed.
     * @returns The output of the speed PID controller.
     */
    updateAccelTargetPid(pid, accelTargetFunc, accelTargetSmoother, effectiveAccel, effectiveIas, targetIas, lastTargetIas, dt, targetChangeThreshold) {
        const iasError = targetIas - effectiveIas;
        const lastTargetAccel = accelTargetSmoother.last();
        const targetAccel = accelTargetSmoother.next(accelTargetFunc(iasError, targetIas, effectiveIas), dt);
        // Cancel out any derivative term contributed by changes in the target speed.
        if (lastTargetIas !== undefined) {
            const targetIasDelta = targetIas - lastTargetIas;
            const lastError = pid.getPreviousError();
            if (lastError !== undefined && Math.abs(targetIasDelta / dt) >= targetChangeThreshold) {
                accelTargetSmoother.reset(lastTargetAccel);
                const correctedTargetAccel = accelTargetSmoother.next(accelTargetFunc(iasError, targetIas - targetIasDelta, effectiveIas), dt);
                const targetAccelDelta = targetAccel - correctedTargetAccel;
                pid.getOutput(0, lastError + targetAccelDelta);
                accelTargetSmoother.reset(targetAccel);
            }
        }
        const error = targetAccel - effectiveAccel;
        return pid.getOutput(dt, error);
    }
    /**
     * Calculates the throttle position for a specific throttle commanded by this autothrottle's power controller. The
     * power controller incorporates the power target if active and overpower protection.
     * @param throttle The throttle for which to calculate commanded throttle position.
     * @param speedCommand The engine power commanded by this autothrottle's speed controller.
     * @param isOverpowerProtActive Whether overpower protection is active.
     * @param isPowerTargetActive Whether power target is active.
     * @param isThrottlePosTargetActive Whether throttle lever position target is active.
     * @param dt The elapsed time since the last update.
     * @param out The object to which to write the results.
     * @returns The throttle position for the specified throttle commanded by this autothrottle's power controller.
     */
    calculatePowerTargetThrottlePos(throttle, speedCommand, isOverpowerProtActive, isPowerTargetActive, isThrottlePosTargetActive, dt, out) {
        out.speed = undefined;
        out.targetPos = undefined;
        out.isOverspeedProtEngaged = false;
        out.isUnderspeedProtEngaged = false;
        out.isOverpowerProtEngaged = false;
        const targetPid = this.selectedPowerPids[throttle.index];
        const overpowerPid = this.overpowerPids[throttle.index];
        const power = throttle.power;
        const effectivePower = throttle.effectivePower;
        let overpowerProtDelta;
        let isOverpower = false;
        if (isOverpowerProtActive) {
            const maxPower = this.maxPower.get();
            overpowerProtDelta = overpowerPid.getOutput(dt, maxPower - effectivePower);
            isOverpower = power > maxPower;
        }
        else {
            overpowerPid.reset();
        }
        let targetDelta;
        let delta;
        let isUsingOverspeedProtCommand = false;
        let isUsingUnderspeedProtCommand = false;
        let isUsingOverpowerProtCommand = false;
        let powerTarget;
        if (isPowerTargetActive) {
            powerTarget = this.selectedPower.get();
        }
        else {
            powerTarget = speedCommand.selectedSpeedPowerTarget;
        }
        // Engage over/underspeed protection if the engine power target commanded by the protection controller is
        // less/greater than that commanded by the selected speed controller or the selected power, respectively, or if the
        // airplane is currently over/underspeeding and the protection controller is attempting to reduce/increase power,
        // respectively, when no other power target is being commanded.
        if (powerTarget === undefined) {
            if (speedCommand.overspeedProtPowerTarget !== undefined
                && (isThrottlePosTargetActive || (speedCommand.isOverspeed && speedCommand.overspeedProtPowerTarget < effectivePower))) {
                powerTarget = speedCommand.overspeedProtPowerTarget;
                isUsingOverspeedProtCommand = true;
            }
            else if (speedCommand.underspeedProtPowerTarget !== undefined
                && (isThrottlePosTargetActive || (speedCommand.isUnderspeed && speedCommand.underspeedProtPowerTarget > effectivePower))) {
                powerTarget = speedCommand.underspeedProtPowerTarget;
                isUsingUnderspeedProtCommand = true;
            }
        }
        else {
            if (speedCommand.overspeedProtPowerTarget !== undefined && speedCommand.overspeedProtPowerTarget < powerTarget) {
                powerTarget = speedCommand.overspeedProtPowerTarget;
                isUsingOverspeedProtCommand = true;
            }
            else if (speedCommand.underspeedProtPowerTarget !== undefined && speedCommand.underspeedProtPowerTarget > powerTarget) {
                powerTarget = speedCommand.underspeedProtPowerTarget;
                isUsingUnderspeedProtCommand = true;
            }
        }
        if (powerTarget !== undefined) {
            // Targeting power
            targetDelta = targetPid.getOutput(dt, powerTarget - effectivePower);
        }
        else {
            targetPid.reset();
        }
        // Engage overpower protection if the throttle position adjustment commanded by the protection controller is less
        // than that commanded by the target power controller, or if the engine is currently overpowered and the protection
        // controller is attempting to reduce power when no other throttle adjustment is being commanded.
        if (targetDelta === undefined) {
            if (overpowerProtDelta !== undefined && (isThrottlePosTargetActive || (isOverpower && overpowerProtDelta < 0))) {
                delta = overpowerProtDelta;
                isUsingOverpowerProtCommand = true;
            }
        }
        else {
            if (overpowerProtDelta !== undefined && overpowerProtDelta < targetDelta) {
                delta = overpowerProtDelta;
                isUsingOverpowerProtCommand = true;
            }
            else {
                delta = targetDelta;
            }
        }
        if (isThrottlePosTargetActive) {
            const selectedTarget = this.selectedThrottlePos.get();
            const selectedTargetDelta = MathUtils.clamp((selectedTarget - throttle.normPosition) / dt, -throttle.servoSpeed, throttle.servoSpeed);
            // Override the throttle adjustment commanded by the power controller if...
            if (
            // ... the power controller is not commanding any adjustment
            delta === undefined
                // ... OR overspeed or overpower protection is engaged but the adjustment required to move toward the selected
                // throttle position would reduce throttle *lower* than that commanded by the power controller
                || ((isUsingOverspeedProtCommand || isUsingOverpowerProtCommand) && selectedTargetDelta < delta)
                // ... OR underspeed protection is engaged but the adjustment required to move toward the selected throttle
                // position would increase throttle *higher* than that commanded by the power controller
                || (isUsingUnderspeedProtCommand && selectedTargetDelta > delta)) {
                delta = selectedTargetDelta;
                isUsingOverspeedProtCommand = false;
                isUsingUnderspeedProtCommand = false;
                isUsingOverpowerProtCommand = false;
            }
        }
        if (delta === undefined) {
            return out;
        }
        out.speed = delta;
        out.targetPos = throttle.normPosition + delta * dt;
        out.isOverspeedProtEngaged = isUsingOverspeedProtCommand;
        out.isUnderspeedProtEngaged = isUsingUnderspeedProtCommand;
        out.isOverpowerProtEngaged = isUsingOverpowerProtCommand;
        return out;
    }
    /**
     * Destroys this autothrottle.
     */
    destroy() {
        this.isAlive = false;
        this.stop();
        this.realTime.destroy();
        this.throttles.forEach(throttle => { throttle.destroy(); });
    }
    /**
     * Creates a PID controller using a given set of parameters.
     * @param params A set of PID parameters.
     * @returns A new PID controller created using the specified parameters.
     */
    static createPidFromParams(params) {
        return new PidController(params.kP, params.kI, params.kD, params.maxOut, params.minOut, params.maxI, params.minI);
    }
}
AbstractAutothrottle.ALL_THROTTLE_INDEXES = [1, 2, 3, 4];
/**
 * A throttle controlled by an autothrottle system.
 */
class AutothrottleThrottle {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param info Information describing this throttle.
     * @param servoSpeed The speed delivered by the servo controlling this throttle, in units of normalized position per
     * second.
     * @param powerSmoothingConstant The smoothing time constant, in seconds, to use to smooth engine power data.
     * @param powerSmoothingVelocityConstant The smoothing time constant, in seconds, to use to smooth estimated power
     * velocity while smoothing engine power data. A value of zero is equivalent to no smoothing. If not defined,
     * estimated power velocity will not be used to adjust smoothed engine power data.
     * @param powerLookahead The lookahead time, in seconds, to use for engine power data.
     * @param powerLookaheadSmoothingConstant The smoothing time constant, in seconds, to use to smooth lookahead engine
     * power data. If not defined, defaults to the value of {@linkcode powerSmoothingConstant}.
     * @param powerLookaheadSmoothingVelocityConstant The smoothing time constant, in seconds, to use to smooth estimated
     * power velocity while smoothing lookahead engine power data. A value of zero is equivalent to no smoothing. If not
     * defined, estimated power velocity will not be used to adjust smoothed lookahead engine power data. If not defined,
     * defaults to the value of {@linkcode powerSmoothingVelocityConstant}.
     * @param throttleLeverManager The throttle lever manager to use to request position changes for this throttle's
     * lever. If not defined, position changes for the lever will be requested using key events (specifically the
     * `THROTTLE[N]_SET` event).
     */
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerSmoothingVelocityConstant, powerLookahead, powerLookaheadSmoothingConstant, powerLookaheadSmoothingVelocityConstant, throttleLeverManager) {
        this.servoSpeed = servoSpeed;
        this.powerLookahead = powerLookahead;
        this._position = 0;
        this._power = 0;
        this._effectivePower = 0;
        this._isServoActive = Subject.create(false);
        this.lastPowerLookahead = this.powerLookahead.get();
        this.lastSmoothedPower = undefined;
        this.initKeyManager(bus);
        ({ index: this.index, idlePosition: this.idlePosition, maxThrustPosition: this.maxThrustPosition } = info);
        if (info.isVirtual) {
            this.virtualPos = ConsumerSubject.create(bus.getSubscriber().on(`v_throttle_lever_pos_${this.index}`), 0),
                this.getPosition = () => {
                    return this.virtualPos.get();
                };
        }
        else {
            this.throttlePosSimVar = `GENERAL ENG THROTTLE LEVER POSITION:${this.index}`;
            this.getPosition = () => {
                return SimVar.GetSimVarValue(this.throttlePosSimVar, SimVarValueType.Percent) / 100;
            };
        }
        this.normRange = this.maxThrustPosition - this.idlePosition;
        this.throttleSetKVar = `THROTTLE${this.index}_SET`;
        this.throttleLeverManager = info.isVirtual ? throttleLeverManager : undefined;
        const isServoActiveTopic = `at_servo_${this.index}_is_active`;
        this._isServoActive.sub(val => { bus.getPublisher().pub(isServoActiveTopic, val, true, true); });
        this.powerSmoother = new MultiExpSmoother(powerSmoothingConstant, powerSmoothingVelocityConstant);
        this.lookaheadPowerSmoother = new MultiExpSmoother(powerLookaheadSmoothingConstant !== null && powerLookaheadSmoothingConstant !== void 0 ? powerLookaheadSmoothingConstant : powerSmoothingConstant, powerLookaheadSmoothingVelocityConstant !== null && powerLookaheadSmoothingVelocityConstant !== void 0 ? powerLookaheadSmoothingVelocityConstant : powerSmoothingVelocityConstant);
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The current position of this throttle. */
    get position() {
        return this._position;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /**
     * The position of this throttle, normalized such that `0` is the idle position and `1` is the maximum thrust
     * position.
     */
    get normPosition() {
        return (this._position - this.idlePosition) / this.normRange;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The power delivered by this throttle's engine. */
    get power() {
        return this._power;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** The effective power delivered by this throttle's engine, after smoothing and lookahead have been applied. */
    get effectivePower() {
        return this._effectivePower;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether the autothrottle servo for this throttle is active. */
    get isServoActive() {
        return this._isServoActive.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set isServoActive(val) {
        this._isServoActive.set(val);
    }
    /**
     * Initializes the key event manager used by this throttle.
     * @param bus The event bus.
     */
    async initKeyManager(bus) {
        this.keyEventManager = await KeyEventManager.getManager(bus);
    }
    /**
     * Updates this throttle's current position and delivered power properties.
     * @param dt The elapsed time since the last update, in seconds.
     */
    update(dt) {
        this._position = this.getPosition();
        this._power = this.getPower();
        const lookahead = Math.max(0, this.powerLookahead.get());
        const smoothedPower = this.powerSmoother.next(this._power, dt);
        if (lookahead !== this.lastPowerLookahead) {
            this.lookaheadPowerSmoother.reset();
            this.lastPowerLookahead = lookahead;
        }
        if (lookahead > 0 && this.lastSmoothedPower !== undefined) {
            const delta = smoothedPower - this.lastSmoothedPower;
            this._effectivePower = this.lookaheadPowerSmoother.next(this._power + delta * lookahead / dt, dt);
        }
        else {
            this._effectivePower = smoothedPower;
        }
        this.lastSmoothedPower = smoothedPower;
    }
    /**
     * Drives this throttle toward a target normalized position over a period of time.
     * @param targetNormPos The target normalized position. Will be clamped to the range `[0, 1]`.
     * @param dt The amount of time over which to drive the throttle, in seconds.
     */
    drive(targetNormPos, dt) {
        var _a;
        const current = this.normPosition;
        const delta = targetNormPos - current;
        if (delta === 0) {
            return;
        }
        const deltaSign = Math.sign(delta);
        const toDrive = Math.min(dt * this.servoSpeed, (targetNormPos - current) * deltaSign) * deltaSign;
        const finalPos = this.idlePosition + (current + toDrive) * this.normRange;
        if (Math.abs(finalPos - this._position) < 0.5 / AutothrottleThrottle.RAW_AXIS_MAX) {
            return;
        }
        if (this.throttleLeverManager !== undefined) {
            this.throttleLeverManager.setThrottleLeverPosRaw(this.index, finalPos * AutothrottleThrottle.RAW_AXIS_MAX);
        }
        else {
            (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(this.throttleSetKVar, false, Math.round(finalPos * AutothrottleThrottle.RAW_AXIS_MAX));
        }
    }
    /**
     * Resets this throttle's power smoothing.
     */
    resetPowerSmoothing() {
        this.powerSmoother.reset();
        this.lookaheadPowerSmoother.reset();
        this.lastSmoothedPower = undefined;
    }
    /**
     * Destroys this throttle.
     */
    destroy() {
        var _a;
        (_a = this.virtualPos) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}
AutothrottleThrottle.RAW_AXIS_MAX = 16384;

/**
 * An autothrottle system for turbine jet engines.
 */
class JetAutothrottle extends AbstractAutothrottle {
    /** @inheritdoc */
    createThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerSmoothingVelocityConstant, powerLookahead, powerLookaheadSmoothingConstant, powerLookaheadSmoothingVelocityConstant, throttleLeverManager) {
        return new JetAutothrottleThrottle(bus, info, servoSpeed, powerSmoothingConstant, powerSmoothingVelocityConstant, powerLookahead, powerLookaheadSmoothingConstant, powerLookaheadSmoothingVelocityConstant, throttleLeverManager);
    }
}
/**
 * An autothrottle throttle for turbine jet engines.
 */
class JetAutothrottleThrottle extends AutothrottleThrottle {
    /** @inheritdoc */
    constructor(bus, info, servoSpeed, powerSmoothingConstant, powerSmoothingVelocityConstant, powerLookahead, powerLookaheadSmoothingConstant, powerLookaheadSmoothingVelocityConstant, throttleLeverManager) {
        super(bus, info, servoSpeed, powerSmoothingConstant, powerSmoothingVelocityConstant, powerLookahead, powerLookaheadSmoothingConstant, powerLookaheadSmoothingVelocityConstant, throttleLeverManager);
        this.commandedN1SimVar = `TURB ENG THROTTLE COMMANDED N1:${this.index}`;
    }
    /** @inheritdoc */
    getPower() {
        return SimVar.GetSimVarValue(this.commandedN1SimVar, SimVarValueType.Percent);
    }
}

/**
 * Transports an alert state to the CAS via the event bus.
 */
class CasAlertTransporter {
    /**
     * Creates an instance of a CasAlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     */
    constructor(bus, uuid, priority, suffix) {
        this.bus = bus;
        this.uuid = uuid;
        this.priority = priority;
        this.suffix = suffix;
        this.currentValue = false;
        this.subs = [];
        this.updateEntries = [];
        this.isAlive = true;
        this.isPaused = false;
    }
    /**
     * Sets whether or not the alert is active.
     * @param active Whether or not the alert is active.
     * @throws Error if this transporter has been destroyed.
     */
    set(active) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot change an alert with a dead transporter');
        }
        if (this.currentValue !== active) {
            if (active) {
                this.bus.getPublisher().pub('cas_activate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            else {
                this.bus.getPublisher().pub('cas_deactivate_alert', { key: { uuid: this.uuid, suffix: this.suffix }, priority: this.priority }, true, false);
            }
            this.currentValue = active;
        }
    }
    /**
     * Binds an alert state to a subscribable value.
     * @param toWatch The subscribable value to watch.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bind(toWatch, predicate) {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        this.subs.push(toWatch.sub(v => this.set(predicate(v)), true, this.isPaused));
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindUpdate(predicate) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: false,
            func: (deltaTime) => this.set(predicate(deltaTime))
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Binds the alert state to an update loop.
     * @param predicate The predicate that transforms the value into a boolean alert activity state.
     * @param state The optional state to pass into the predicate.
     * @returns The modified alert transporter.
     * @throws Error if this transporter has been destroyed.
     */
    bindStateUpdate(predicate, state) {
        var _a;
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot bind an alert state using a dead transporter');
        }
        const entry = {
            isPaused: this.isPaused,
            hasState: true,
            func: (deltaTime, stateInner) => this.set(predicate(deltaTime, stateInner)),
            state
        };
        this.updateEntries.push(entry);
        this.initUpdateFuncs();
        (_a = CasAlertTransporter.updateEntries) === null || _a === void 0 ? void 0 : _a.push(entry);
        return this;
    }
    /**
     * Resumes this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also resumed. On resumption, the values of bound subscribables are evaluated
     * immediately, while the values of bound update loops will be evaluated during the next update cycle.
     * @returns This transporter, after it has been resumed.
     * @throws Error if this transporter has been destroyed.
     */
    resume() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot resume a dead transporter');
        }
        if (!this.isPaused) {
            return this;
        }
        this.isPaused = false;
        this.subs.forEach(sub => { sub.resume(true); });
        this.updateEntries.forEach(entry => { entry.isPaused = false; });
        return this;
    }
    /**
     * Pauses this transporter. When this transporter is paused, any subscribables or update loops used to bind the state
     * of this transporter's alert are also paused.
     * @returns This transporter, after it has been paused.
     * @throws Error if this transporter has been destroyed.
     */
    pause() {
        if (!this.isAlive) {
            throw new Error('CasAlertTransporter: cannot pause a dead transporter');
        }
        if (this.isPaused) {
            return this;
        }
        this.isPaused = true;
        this.subs.forEach(sub => { sub.pause(); });
        if (CasAlertTransporter.updateEntries) {
            this.updateEntries.forEach(entry => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const index = CasAlertTransporter.updateEntries.indexOf(entry);
                if (index >= 0) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    CasAlertTransporter.updateEntries.splice(index, 1);
                }
            });
        }
        return this;
    }
    /**
     * Destroys this transporter. This will destroy any subscribables or update loops used to bind the state of this
     * transporter's alert. Once this transporter has been destroyed, it cannot be used to change the state of its alert,
     * bind the state of its alert, or be paused or resumed.
     */
    destroy() {
        this.isAlive = false;
        this.subs.forEach(sub => { sub.destroy(); });
        this.updateEntries.forEach(entry => { entry.isPaused = true; });
    }
    /**
     * Creates an instance of an AlertTransporter.
     * @param bus The event bus to use with this instance.
     * @param uuid The alert UUID.
     * @param priority The alert priority.
     * @param suffix The alert suffix.
     * @returns The created AlertTransporter.
     */
    static create(bus, uuid, priority, suffix) {
        return new CasAlertTransporter(bus, uuid, priority, suffix);
    }
    /**
     * Initializes the update functions.
     */
    initUpdateFuncs() {
        if (CasAlertTransporter.updateEntries === undefined) {
            CasAlertTransporter.updateEntries = [];
            this.bus.getSubscriber().on('simTime').handle((timestamp) => {
                if (CasAlertTransporter.previousTimestamp === -1) {
                    CasAlertTransporter.previousTimestamp = timestamp;
                }
                const deltaTime = MathUtils.clamp(timestamp - CasAlertTransporter.previousTimestamp, 0, 10000);
                if (CasAlertTransporter.updateEntries !== undefined) {
                    for (let i = 0; i < CasAlertTransporter.updateEntries.length; i++) {
                        const entry = CasAlertTransporter.updateEntries[i];
                        if (entry.isPaused) {
                            continue;
                        }
                        if (entry.hasState) {
                            entry.func(deltaTime, entry.state);
                        }
                        else {
                            entry.func(deltaTime);
                        }
                    }
                }
                CasAlertTransporter.previousTimestamp = timestamp;
            });
        }
    }
}
CasAlertTransporter.previousTimestamp = -1;

/**
 * This is a convenience tool for publishing and republishing CAS alert registrations.  Code
 * that wants to implement its own alert publishing system can use the CasRegistrationManager
 * to avoid having to subscribe to and handle requests on the bus for republication of alert
 * registrations.
 */
class CasRegistrationManager {
    /**
     * Create a CasRegistrationManager
     * @param bus The event bus
     */
    constructor(bus) {
        this.registrations = new Map();
        this.publisher = bus.getPublisher();
        const subscriber = bus.getSubscriber();
        subscriber.on('cas_publish_registration').handle(uuid => this.publishRegistration(uuid));
        subscriber.on('cas_publish_all_registrations').handle(() => this.publishAllRegistrations());
    }
    /**
     * Register an alert for management.
     * @param definition The CasAlertDefinition for this alert.
     */
    register(definition) {
        this.registrations.set(definition.uuid, definition);
        this.publishRegistration(definition.uuid);
    }
    /**
     * Handle publishing information for a single alert.
     * @param uuid The UUID of the registation to publish.
     */
    publishRegistration(uuid) {
        const definition = this.registrations.get(uuid);
        if (definition) {
            this.publisher.pub('cas_register_alert', definition, true, false);
        }
    }
    /**
     * Publish all current registrations.
     */
    publishAllRegistrations() {
        for (const uuid of this.registrations.keys()) {
            this.publishRegistration(uuid);
        }
    }
}

/**
 * A FADEC for turbojets. Controls engine throttle based on throttle lever position and other inputs.
 */
class JetFadec {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param modes The modes supported by this FADEC, ordered from highest to lowest priority.
     * @param throttleInfos An array containing information pertaining to the throttles controlled by this FADEC. The
     * order of modes in the array determines their priority during mode selection. On every update cycle, the FADEC
     * iterates through the modes array in order, calling `accept()` on each mode until a value of `true` is returned.
     * Therefore, modes positioned earlier in the array have a higher priority for selection.
     * @param desiredThrottleMin The min value to limit the desiredThrottle by. Defaults to -100.
     * @param desiredThrottleMax The max value to limit the desiredThrottle by. Defaults to 100.
     */
    constructor(bus, modes, throttleInfos, desiredThrottleMin = -100, desiredThrottleMax = 100) {
        this.bus = bus;
        this.modes = modes;
        this.desiredThrottleMin = desiredThrottleMin;
        this.desiredThrottleMax = desiredThrottleMax;
        this.publisher = this.bus.getPublisher();
        this.updateHandler = this.update.bind(this);
        this.realTimeSub = ConsumerSubject.create(this.bus.getSubscriber().on('realTime'), 0);
        this.updateTimer = null;
        this.lastUpdateTime = 0;
        this.throttleInfos = throttleInfos.map(info => {
            return Object.assign(Object.assign({}, info), { throttleSimVar: `GENERAL ENG THROTTLE LEVER POSITION:${info.index}`, thrustSimVar: `TURB ENG JET THRUST:${info.index}`, n1SimVar: `TURB ENG N1:${info.index}`, correctedN1SimVar: `TURB ENG CORRECTED N1:${info.index}`, fadecModeTopic: `fadec_mode_${info.index}` });
        });
        this.lastModes = this.throttleInfos.map(() => null);
        const sub = this.bus.getSubscriber();
        this.throttleLeverPositionValues = throttleInfos.map(info => {
            return ConsumerValue.create(sub.on(info.leverPosTopic), 0);
        });
        this.engineStates = {};
        for (const throttle of throttleInfos) {
            this.engineStates[throttle.index] = {
                throttleLeverPos: 0,
                throttle: 0,
                thrust: 0,
                n1: 0,
                n1Corrected: 0
            };
        }
    }
    /**
     * Turns this FADEC on. If this FADEC is already running, then it will be turned off before turning on again with
     * the specified frequency.
     * @param frequency The frequency, in hertz, at which this FADEC will update.
     */
    start(frequency) {
        this.stop();
        this.publisher.pub('fadec_active', true, true, true);
        this.updateTimer = setInterval(this.updateHandler, 1000 / frequency);
    }
    /**
     * Turns this FADEC off.
     */
    stop() {
        if (this.updateTimer === null) {
            return;
        }
        clearInterval(this.updateTimer);
        this.updateTimer = null;
        for (let i = 0; i < this.throttleInfos.length; i++) {
            this.setMode(i, null);
        }
        this.publisher.pub('fadec_active', false, true, true);
    }
    /**
     * Updates this FADEC.
     */
    update() {
        const realTime = Date.now();
        // Check if the current time has diverged from the event bus value by more than 1 second.
        // If it has, we are probably paused in the menu and should skip the update.
        if (realTime - this.realTimeSub.get() >= 1000) {
            return;
        }
        const dt = realTime - this.lastUpdateTime;
        this.onUpdate(dt);
        this.lastUpdateTime = realTime;
    }
    /**
     * A method called when this FADEC is updated.
     * @param dt The elapsed real time, in milliseconds, since the last update.
     */
    onUpdate(dt) {
        this.updateEngineStates();
        this.updateThrottles(dt);
    }
    /**
     * Updates the states for this FADEC's engines.
     */
    updateEngineStates() {
        for (let i = 0; i < this.throttleInfos.length; i++) {
            const info = this.throttleInfos[i];
            const state = this.engineStates[info.index];
            state.throttleLeverPos = this.throttleLeverPositionValues[i].get();
            state.throttle = SimVar.GetSimVarValue(info.throttleSimVar, SimVarValueType.Percent) / 100;
            state.thrust = SimVar.GetSimVarValue(info.thrustSimVar, SimVarValueType.Pounds);
            state.n1 = SimVar.GetSimVarValue(info.n1SimVar, SimVarValueType.Percent);
            state.n1Corrected = SimVar.GetSimVarValue(info.correctedN1SimVar, SimVarValueType.Percent);
        }
    }
    /**
     * Updates this FADEC's engine throttles.
     * @param dt The elapsed real time, in milliseconds, since the last update.
     */
    updateThrottles(dt) {
        for (let i = 0; i < this.throttleInfos.length; i++) {
            this.updateThrottle(i, dt);
        }
    }
    /**
     * Updates a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateThrottle(index, dt) {
        const info = this.throttleInfos[index];
        const { throttleLeverPos, throttle, thrust, n1, n1Corrected } = this.engineStates[info.index];
        // These values are expected to be changed in the for loop below
        let desiredThrottle = throttleLeverPos;
        let visibleThrottlePos = throttleLeverPos;
        for (let i = 0; i < this.modes.length; i++) {
            const mode = this.modes[i];
            if (mode.accept(info.index, throttleLeverPos, throttle, thrust, n1, n1Corrected)) {
                this.setMode(index, mode);
                desiredThrottle = mode.computeDesiredThrottle(info.index, throttleLeverPos, throttle, thrust, n1, n1Corrected, dt);
                visibleThrottlePos = mode.getVisibleThrottlePos(info.index, throttleLeverPos);
                break;
            }
        }
        const clampedThrottle = MathUtils.clamp(desiredThrottle * 100, this.desiredThrottleMin, this.desiredThrottleMax);
        SimVar.SetSimVarValue(info.throttleSimVar, SimVarValueType.Percent, clampedThrottle);
        SimVar.SetSimVarValue(info.visiblePosSimVar, 'number', MathUtils.clamp(visibleThrottlePos, -1, 1));
    }
    /**
     * Sets a FADEC mode for a throttle.
     * @param index The index of the throttle in this FADEC's throttle list.
     * @param mode The mode to set.
     */
    setMode(index, mode) {
        var _a;
        if (mode === this.lastModes[index]) {
            return;
        }
        this.lastModes[index] = mode;
        this.publisher.pub(this.throttleInfos[index].fadecModeTopic, (_a = mode === null || mode === void 0 ? void 0 : mode.name) !== null && _a !== void 0 ? _a : '', true, true);
    }
}
// This is pulled from the native sim code. Commonly used when correcting N1.
JetFadec.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

/**
 * A manager for virtual throttle levers. Intercepts key events that control engine throttle settings and uses them
 * to move virtual throttle levers instead. The positions of the virtual throttle levers are published on the event
 * bus.
 */
class ThrottleLeverManager {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param onInitCallback A callback function to be executed once this manager is initialized.
     * @param throttleLeverHandler A callback function which handles requested changes to throttle lever position. The
     * function should take three arguments: the index of the throttle lever, the current lever position (-1 to +1), and
     * the requested new lever position (-1 to +1), and return the position the lever should be set to. If not defined,
     * all requested changes to throttle lever position will be processed as-is.
     */
    constructor(bus, onInitCallback, throttleLeverHandler) {
        this.bus = bus;
        this.throttleLeverHandler = throttleLeverHandler;
        this.publisher = this.bus.getPublisher();
        this.throttleLevers = ArrayUtils.create(ThrottleLeverManager.THROTTLE_COUNT, index => {
            return {
                index: index + 1,
                topic: `v_throttle_lever_pos_${index + 1}`,
                rawPosition: 0
            };
        });
        const sub = bus.getSubscriber();
        const virtualPositions = this.throttleLevers.map(lever => {
            return ConsumerValue.create(sub.on(lever.topic), NaN);
        });
        KeyEventManager.getManager(bus).then(manager => {
            for (let i = 0; i < this.throttleLevers.length; i++) {
                // Initialize position to the pre-existing virtual lever position, if available. Otherwise, initialize to the
                // engine throttle lever position simvar.
                const lever = this.throttleLevers[i];
                const virtualPosition = virtualPositions[i].get();
                const initialPosition = isNaN(virtualPosition)
                    ? MathUtils.clamp(SimVar.GetSimVarValue(`GENERAL ENG THROTTLE LEVER POSITION:${lever.index}`, 'Percent') / 100, 0, 1)
                    : virtualPosition;
                virtualPositions[i].destroy();
                this.setRawThrottleLeverPosition(initialPosition * ThrottleLeverManager.RAW_MAX, i + 1);
            }
            this.keyEventManager = manager;
            manager.interceptKey('AXIS_THROTTLE_SET', false);
            manager.interceptKey('AXIS_THROTTLE1_SET', false);
            manager.interceptKey('AXIS_THROTTLE2_SET', false);
            manager.interceptKey('AXIS_THROTTLE3_SET', false);
            manager.interceptKey('AXIS_THROTTLE4_SET', false);
            manager.interceptKey('THROTTLE_AXIS_SET_EX1', false);
            manager.interceptKey('THROTTLE1_AXIS_SET_EX1', false);
            manager.interceptKey('THROTTLE2_AXIS_SET_EX1', false);
            manager.interceptKey('THROTTLE3_AXIS_SET_EX1', false);
            manager.interceptKey('THROTTLE4_AXIS_SET_EX1', false);
            manager.interceptKey('THROTTLE_SET', false);
            manager.interceptKey('THROTTLE1_SET', false);
            manager.interceptKey('THROTTLE2_SET', false);
            manager.interceptKey('THROTTLE3_SET', false);
            manager.interceptKey('THROTTLE4_SET', false);
            manager.interceptKey('THROTTLE_FULL', false);
            manager.interceptKey('THROTTLE1_FULL', false);
            manager.interceptKey('THROTTLE2_FULL', false);
            manager.interceptKey('THROTTLE3_FULL', false);
            manager.interceptKey('THROTTLE4_FULL', false);
            manager.interceptKey('THROTTLE_INCR', false);
            manager.interceptKey('THROTTLE1_INCR', false);
            manager.interceptKey('THROTTLE2_INCR', false);
            manager.interceptKey('THROTTLE3_INCR', false);
            manager.interceptKey('THROTTLE4_INCR', false);
            manager.interceptKey('THROTTLE_DECR', false);
            manager.interceptKey('THROTTLE1_DECR', false);
            manager.interceptKey('THROTTLE2_DECR', false);
            manager.interceptKey('THROTTLE3_DECR', false);
            manager.interceptKey('THROTTLE4_DECR', false);
            manager.interceptKey('THROTTLE_CUT', false);
            manager.interceptKey('THROTTLE1_CUT', false);
            manager.interceptKey('THROTTLE2_CUT', false);
            manager.interceptKey('THROTTLE3_CUT', false);
            manager.interceptKey('THROTTLE4_CUT', false);
            manager.interceptKey('INCREASE_THROTTLE', false);
            manager.interceptKey('DECREASE_THROTTLE', false);
            manager.interceptKey('THROTTLE_10', false);
            manager.interceptKey('THROTTLE_20', false);
            manager.interceptKey('THROTTLE_30', false);
            manager.interceptKey('THROTTLE_40', false);
            manager.interceptKey('THROTTLE_50', false);
            manager.interceptKey('THROTTLE_60', false);
            manager.interceptKey('THROTTLE_70', false);
            manager.interceptKey('THROTTLE_80', false);
            manager.interceptKey('THROTTLE_90', false);
            sub.on('key_intercept').handle(this.onKeyIntercepted.bind(this));
            onInitCallback && onInitCallback();
        });
    }
    /**
     * Sets the position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The position to set, in the range -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPos(index, pos) {
        return this.setThrottleLeverPosRaw(index, pos * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    /**
     * Changes the position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the lever position. The full lever range is expressed as -1 to +1.
     * @returns The throttle lever position at the end of the operation, in the range -1 to +1.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPos(index, delta) {
        return this.changeThrottleLeverPosRaw(index, delta * ThrottleLeverManager.RAW_MAX) / ThrottleLeverManager.RAW_MAX;
    }
    /**
     * Sets the raw position of a throttle lever.
     * @param index The index of the throttle lever to set, from 1 to 4, inclusive.
     * @param pos The raw position to set, in the range -16384 to +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    setThrottleLeverPosRaw(index, pos) {
        if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
            throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
        }
        this.setRawThrottleLeverPosition(pos, index);
        return this.throttleLevers[index - 1].rawPosition;
    }
    /**
     * Changes the raw position of a throttle lever.
     * @param index The index of the throttle lever to change, from 1 to 4, inclusive.
     * @param delta The amount by which to change the raw lever position. The full lever range is expressed as -16384 to
     * +16384.
     * @returns The raw throttle lever position at the end of the operation, in the range -16384 to +16384.
     * @throws Error if `index` is out of bounds.
     */
    changeThrottleLeverPosRaw(index, delta) {
        if (index < 1 || index > ThrottleLeverManager.THROTTLE_COUNT) {
            throw new Error(`ThrottleLeverManager: throttle index (${index}) out of bounds`);
        }
        this.changeRawThrottleLeverPosition(delta, index);
        return this.throttleLevers[index - 1].rawPosition;
    }
    /**
     * Responds to key intercept events.
     * @param data The event data.
     * @param data.key The key that was intercepted.
     * @param data.value0 The value of the intercepted key event.
     */
    onKeyIntercepted({ key, value0 }) {
        switch (key) {
            case 'AXIS_THROTTLE_SET':
            case 'THROTTLE_AXIS_SET_EX1':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, undefined, key);
                }
                break;
            case 'AXIS_THROTTLE1_SET':
            case 'THROTTLE1_AXIS_SET_EX1':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 1, key);
                }
                break;
            case 'AXIS_THROTTLE2_SET':
            case 'THROTTLE2_AXIS_SET_EX1':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 2, key);
                }
                break;
            case 'AXIS_THROTTLE3_SET':
            case 'THROTTLE3_AXIS_SET_EX1':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 3, key);
                }
                break;
            case 'AXIS_THROTTLE4_SET':
            case 'THROTTLE4_AXIS_SET_EX1':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition((value0 + ThrottleLeverManager.RAW_MAX) / 2, 4, key);
                }
                break;
            case 'THROTTLE_SET':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition(value0, undefined, key);
                }
                break;
            case 'THROTTLE1_SET':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition(value0, 1, key);
                }
                break;
            case 'THROTTLE2_SET':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition(value0, 2, key);
                }
                break;
            case 'THROTTLE3_SET':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition(value0, 3, key);
                }
                break;
            case 'THROTTLE4_SET':
                if (value0 !== undefined) {
                    this.setRawThrottleLeverPosition(value0, 4, key);
                }
                break;
            case 'THROTTLE_FULL':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, undefined, key);
                break;
            case 'THROTTLE1_FULL':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 1, key);
                break;
            case 'THROTTLE2_FULL':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 2, key);
                break;
            case 'THROTTLE3_FULL':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 3, key);
                break;
            case 'THROTTLE4_FULL':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX, 4, key);
                break;
            case 'THROTTLE_CUT':
                this.setRawThrottleLeverPosition(0, undefined, key);
                break;
            case 'THROTTLE1_CUT':
                this.setRawThrottleLeverPosition(0, 1, key);
                break;
            case 'THROTTLE2_CUT':
                this.setRawThrottleLeverPosition(0, 2, key);
                break;
            case 'THROTTLE3_CUT':
                this.setRawThrottleLeverPosition(0, 3, key);
                break;
            case 'THROTTLE4_CUT':
                this.setRawThrottleLeverPosition(0, 4, key);
                break;
            case 'THROTTLE_INCR':
            case 'INCREASE_THROTTLE':
                this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, undefined, key);
                break;
            case 'THROTTLE1_INCR':
                this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 1, key);
                break;
            case 'THROTTLE2_INCR':
                this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 2, key);
                break;
            case 'THROTTLE3_INCR':
                this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 3, key);
                break;
            case 'THROTTLE4_INCR':
                this.changeRawThrottleLeverPosition(ThrottleLeverManager.RAW_STEP, 4, key);
                break;
            case 'THROTTLE_DECR':
            case 'DECREASE_THROTTLE':
                this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, undefined, key);
                break;
            case 'THROTTLE1_DECR':
                this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 1, key);
                break;
            case 'THROTTLE2_DECR':
                this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 2, key);
                break;
            case 'THROTTLE3_DECR':
                this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 3, key);
                break;
            case 'THROTTLE4_DECR':
                this.changeRawThrottleLeverPosition(-ThrottleLeverManager.RAW_STEP, 4, key);
                break;
            case 'THROTTLE_10':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.1, undefined, key);
                break;
            case 'THROTTLE_20':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.2, undefined, key);
                break;
            case 'THROTTLE_30':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.3, undefined, key);
                break;
            case 'THROTTLE_40':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.4, undefined, key);
                break;
            case 'THROTTLE_50':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.5, undefined, key);
                break;
            case 'THROTTLE_60':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.6, undefined, key);
                break;
            case 'THROTTLE_70':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.7, undefined, key);
                break;
            case 'THROTTLE_80':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.8, undefined, key);
                break;
            case 'THROTTLE_90':
                this.setRawThrottleLeverPosition(ThrottleLeverManager.RAW_MAX * 0.9, undefined, key);
                break;
        }
    }
    /**
     * Sets a raw throttle lever position.
     * @param rawPosition The raw position to set.
     * @param index The index of the throttle lever to set. If undefined, the positions of all throttle levers will be
     * set.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    setRawThrottleLeverPosition(rawPosition, index, keyEvent) {
        rawPosition = MathUtils.clamp(Math.round(rawPosition), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
        const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
        for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
            const lever = this.throttleLevers[i - 1];
            if (this.throttleLeverHandler) {
                rawPosition = MathUtils.clamp(Math.round(this.throttleLeverHandler(lever.index, lever.rawPosition / ThrottleLeverManager.RAW_MAX, rawPosition / ThrottleLeverManager.RAW_MAX, keyEvent) * ThrottleLeverManager.RAW_MAX), -ThrottleLeverManager.RAW_MAX, ThrottleLeverManager.RAW_MAX);
            }
            if (rawPosition !== lever.rawPosition) {
                lever.rawPosition = rawPosition;
                this.publishThrottleLeverPosition(lever);
            }
        }
    }
    /**
     * Changes a raw throttle lever position.
     * @param delta The amount by which to change the raw lever position.
     * @param index The index of the throttle lever to change. If undefined, the positions of all throttle levers will be
     * changed.
     * @param keyEvent The key event responsible for this change, or `undefined` if this change was not triggered by a
     * key event.
     */
    changeRawThrottleLeverPosition(delta, index, keyEvent) {
        const end = (index !== null && index !== void 0 ? index : ThrottleLeverManager.THROTTLE_COUNT) + 1;
        for (let i = index !== null && index !== void 0 ? index : 1; i < end; i++) {
            this.setRawThrottleLeverPosition(this.throttleLevers[i - 1].rawPosition + delta, i, keyEvent);
        }
    }
    /**
     * Publishes a virtual throttle lever position to the event bus.
     * @param lever The lever whose position to publish.
     */
    publishThrottleLeverPosition(lever) {
        this.publisher.pub(lever.topic, lever.rawPosition / ThrottleLeverManager.RAW_MAX, true, true);
    }
}
ThrottleLeverManager.THROTTLE_COUNT = 4;
ThrottleLeverManager.RAW_MAX = 16384;
ThrottleLeverManager.RAW_STEP = 256;

/**
 * A structure representing a source of named data that can be modified
 */
class DataInterface {
    /**
     * Constructs a new `ModifiableDataSource`
     *
     * @param input  an input for data
     * @param modify a callback when the data needs to be modified
     */
    constructor(input, modify) {
        this.input = input;
        this.modify = modify;
        // super(input);
    }
    /** Creates a new DataInterface with a new modifier
     * @deprecated
     * @param modify the new modifier
     * @returns the new DataInterface
     */
    modifiable(modify) {
        return new DataInterface(this.input, modify);
    }
    /**
     * Creates a {@link DataInterface} from a {@link MutableSubscribable}
     * @param sub the {@link MutableSubscribable} to bind to
     * @returns the {@link DataInterface}
     */
    static fromMutSubscribable(sub) {
        return new DataInterface(sub, (value) => sub.set(value));
    }
    /**
     * Creates a {@link DataInterface} from a {@link Consumer}
     * @param consumer the {@link Consumer} to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the {@link DataInterface}
     */
    static fromConsumer(consumer, modifier) {
        return new DataInterface(consumer, (value) => modifier(value));
    }
}
/**
 * Class that manages a handler for a subscribable.
 *
 * The {@link pause} method is used to uncouple the handler when the binding must be disposed of
 */
class Binding {
    /**
     * Constructs a `Binding`
     *
     * @param input   a {@link DataSource} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * */
    constructor(input, valueHandler) {
        this.input = input;
        this.valueHandler = valueHandler;
        this.canInitialNotify = false;
        if ('isConsumer' in this.input) {
            this.sub = this.input.handle((data) => this.valueHandler(data));
        }
        else {
            this.canInitialNotify = true;
            this.sub = this.input.sub((data) => this.valueHandler(data), this.canInitialNotify, true);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this binding is paused. */
    get isPaused() {
        return this.sub.isPaused;
    }
    /** @inheritDoc */
    get isAlive() {
        return this.sub.isAlive;
    }
    // /**
    //  * @param value
    //  */
    // private proxyValueHandler(value: T): void {
    //   this.valueHandler(this, value);
    // }
    /**
     * Stops the binding and cancels the handler.
     * @returns This binding, after it has been paused.
     */
    pause() {
        this.sub.pause();
        return this;
    }
    /**
     * Restarts the binding and re-instates the handler.
     * @returns This binding, after it has been resumed.
     */
    resume() {
        this.sub.resume(true);
        return this;
    }
    /**
     * Destroys this binding.
     */
    destroy() {
        this.sub.destroy();
    }
}
/**
 * A binding between a data source, a new value handler and a source of changes to make to that value
 */
class TwoWayBinding extends Binding {
    /**
     * Constructs a new `TwoWayBinding`
     *
     * @param dataSource   a {@link DataInterface} for the binding
     * @param valueHandler a handler for when the value changes from the `DataSource`
     * @param valueEditor  a consumer for receiving new values to set using the source
     */
    constructor(dataSource, valueHandler, valueEditor) {
        super(dataSource.input, valueHandler);
        this.valueHandler = valueHandler;
        this.valueEditor = valueEditor;
        if ('isConsumer' in this.valueEditor) {
            this.editSub = this.valueEditor.handle(dataSource.modify, true);
        }
        else if (this.valueEditor instanceof SubEvent) {
            this.editSub = this.valueEditor.on((sender, data) => dataSource.modify(data));
        }
        else {
            this.editSub = this.valueEditor.sub(dataSource.modify, false, true);
        }
    }
    /** @inheritDoc */
    pause() {
        super.pause();
        this.editSub.pause();
        return this;
    }
    /** @inheritDoc */
    resume() {
        super.resume();
        this.editSub.resume();
        return this;
    }
    /** @inheritDoc */
    destroy() {
        super.destroy();
        this.editSub.destroy();
    }
}

/**
 * A class for defining FMC components
 *
 * ## LSK events
 *
 * This class hierarchy deals with LSK presses in the following order:
 *
 * 1. {@link handleSelectKey} - this is called by the page when it receives an LSk associated with the component
 * 2. IF the DELETE flag is set - call {@link FmcComponentOptions.onDelete} if it's present + apply return value logic - otherwise continue
 * 3. ELSE - call {@link FmcComponentOptions.onSelected} if it's present and apply return value logic - continue otherwise
 * 4. call {@link onHandleSelectKey} - overridden by a subclass
 */
class FmcComponent {
    /** @inheritDoc */
    constructor(page, options) {
        this.page = page;
        this.options = options;
        this.isDisabled = this.options.disabled !== undefined && typeof this.options.disabled === 'function' ? this.options.disabled : () => !!this.options.disabled;
    }
    /**
     * Invalidates the component and queues a re-render if one is not already queued
     */
    invalidate() {
        this.page.invalidate();
    }
    /** @inheritDoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleSelectKey(event) {
        var _a, _b;
        if (this.isDisabled()) {
            return false;
        }
        if (event.isDelete) {
            if (this.options.onDelete) {
                const result = await this.options.onDelete();
                if (result === true || typeof result === 'string') {
                    if ((_a = this.options.clearScratchpadOnSelectedHandled) !== null && _a !== void 0 ? _a : true) {
                        this.page.screen.clearScratchpad();
                    }
                    return result;
                }
            }
        }
        if (this.options.onSelected) {
            try {
                const result = await this.options.onSelected(event.scratchpadContents);
                if (result === true || typeof result === 'string') {
                    if ((_b = this.options.clearScratchpadOnSelectedHandled) !== null && _b !== void 0 ? _b : true) {
                        this.page.screen.clearScratchpad();
                    }
                    return result;
                }
            }
            catch (error) {
                return Promise.reject(error);
            }
        }
        return this.onHandleSelectKey(event);
    }
    /**
     * Returns the component's options
     * @returns The options.
     */
    getOptions() { return this.options; }
}

/**
 * An {@link FmcComponent} for displaying values according to formats
 */
class DisplayField extends FmcComponent {
    /** @inheritDoc */
    constructor(page, options) {
        super(page, options);
        this.options = options;
        this.value = null;
    }
    /**
     * Gets the raw value of this display field
     * @returns the value
     */
    get rawValue() {
        return this.value;
    }
    // /**
    //  * Creates an {@link DisplayField}
    //  *
    //  * @param page    the parent {@link FmcPage}
    //  * @param options parameters for the display field
    //  *
    //  * @returns the {@link DisplayField}
    //  */
    // public static create<T>(page: FmcPage, options: DisplayFieldOptions<T>): DisplayField<T> {
    //   return new DisplayField<T>(page, options);
    // }
    /**
     * Creates and registers a binding on the page, linking this field with a subscribable
     * @param subscribable the subscribable to bind to
     * @returns the created binding (usually not needed)
     */
    bind(subscribable) {
        const binding = new Binding(subscribable, (value) => this.takeValue(value, true));
        this.page.addBinding(binding);
        return this;
    }
    /**
     * Takes an input value, displays it and stores it
     * @param value the new input value
     * @param shouldInvalidate whether or not to invalidate the page
     */
    takeValue(value, shouldInvalidate = false) {
        this.value = value;
        if (shouldInvalidate) {
            this.invalidate();
        }
    }
    /** @inheritDoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleSelectKey(event) {
        return false;
    }
    /** @inheritDoc */
    render() {
        var _a, _b;
        const renderStr = (this.value !== null) ? this.options.formatter.format(this.value) : this.options.formatter.nullValueString;
        const styleStr = (typeof this.options.style === 'function') ? this.options.style(this.value) : this.options.style;
        return `${(_a = this.options.prefix) !== null && _a !== void 0 ? _a : ''}${renderStr}${(_b = this.options.suffix) !== null && _b !== void 0 ? _b : ''}${styleStr !== null && styleStr !== void 0 ? styleStr : ''}`;
    }
}

/**
 * An {@link FmcComponent} for displaying and accepting new values according to a validator and formatter.
 *
 * ## deleteAllowed
 * This class deals with LSK presses that have the DELETE flag active using a default implementation
 * of {@link FmcComponentOptions.onDelete}, which checks `options.deleteAllowed` - if `true` or not set,the `onValidLskInput` subject
 * is set to `null` - if `false`, the "INVALID DELETE" scratchpad message is returned and handled by {@link FmcComponent.handleSelectKey}.
 *
 * ## onModified
 * This class also introduces another LSK handler, {@link EditableFieldOptions.onModified}, which is run after a value has been
 * validated (it is not called for invalid values) and applies return value logic. This runs after the flow
 * described for {@link FmcComponent}.
 */
class EditableField extends DisplayField {
    /** @inheritDoc */
    constructor(page, options) {
        super(page, options);
        this.page = page;
        this.options = options;
        this.valueChanged = new SubEvent();
    }
    /**
     * Binds the input field to a mutable subscribable.
     * @param subscribable the mutable subscribable
     * @returns the instance of this {@link EditableField}
     */
    bind(subscribable) {
        return this.bindSource(DataInterface.fromMutSubscribable(subscribable));
    }
    /**
     * Binds the input field to a Consumer.
     * @param consumer the consumer to bind to (get)
     * @param modifier the modifier to use when the value is modified (set)
     * @returns the instance of this {@link EditableField}
     */
    bindConsumer(consumer, modifier) {
        return this.bindSource(DataInterface.fromConsumer(consumer, modifier));
    }
    /**
     * Binds the input field to a data interface.
     * @param source the data interface
     * @returns the instance of this {@link EditableField}
     */
    bindSource(source) {
        const binding = new TwoWayBinding(source, (value) => this.takeValue(value, true), this.valueChanged);
        this.page.addBinding(binding);
        return this;
    }
}

/**
 * {@link Validator} for parsing raw string values
 */
const RawValidator = {
    /** @inheritDoc */
    parse(input) {
        return input !== null && input !== void 0 ? input : '';
    }
};
/**
 * {@link Formatter} for displaying raw string values
 */
const RawFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value !== null && value !== void 0 ? value : '';
    }
};

/**
 * A field for displaying a link to navigate to another page
 */
class PageLinkField extends DisplayField {
    /** @inheritDoc */
    constructor(page, options) {
        var _a;
        const opts = {
            formatter: RawFormatter,
            style: options.disabled ? '[disabled]' : '',
            disabled: options.disabled,
            clearScratchpadOnSelectedHandled: false,
            onSelected: (_a = options.onSelected) !== null && _a !== void 0 ? _a : (async () => { page.screen.navigateTo(options.route, options.params); return true; }),
        };
        super(page, opts);
        this.takeValue(options.label);
    }
    /**
     * Creates an {@link PageLinkField}
     * @param page    the parent {@link FmcPage}
     * @param label  the label to display
     * @param route the route to navigate to (will disable link when empty)
     * @param disabled whether the link is disabled
     * @param params Parameters for the route
     * @returns the {@link PageLinkField}
     */
    static createLink(page, label, route, disabled = false, params) {
        if (route === '') {
            disabled = true;
        }
        return new PageLinkField(page, { label, route, disabled, params });
    }
}

/**
 * A field for displaying a switch label.
 */
class SwitchLabel extends EditableField {
    /** @inheritDoc */
    constructor(page, options = {}) {
        super(page, Object.assign({
            formatter: RawFormatter,
            activeStyle: 'green',
            caret: 'none',
            separator: 'slash',
        }, options));
        this.page = page;
    }
    /** @inheritDoc */
    render() {
        let string = '';
        if (this.value !== null) {
            for (let i = 0; i < this.options.optionStrings.length; i++) {
                const choice = this.options.optionStrings[i];
                string += choice;
                if (i === this.value) {
                    string += `[${this.options.activeStyle} d-text]`;
                }
                else {
                    string += '[s-text]';
                }
                if (i !== this.options.optionStrings.length - 1) {
                    switch (this.options.separator) {
                        case 'slash':
                            string += '/[d-text]';
                            break;
                        case 'arrows':
                            // if (i === this.value - 1) {
                            //   string += `←→[${this.options.activeStyle} d-text]`;
                            // } else {
                            string += '←→[d-text]';
                            // }
                            break;
                    }
                }
            }
            switch (this.options.caret) {
                case 'left':
                    string = `<[]${string}`;
                    break;
                case 'right':
                    string = `${string}>[]`;
                    break;
            }
        }
        return string;
    }
    /** @inheritDoc */
    async onHandleSelectKey() {
        if (this.value === null) {
            this.value = 0;
        }
        else {
            this.value = (this.value + 1) % this.options.optionStrings.length;
        }
        this.valueChanged.notify(this, this.value);
        this.invalidate();
        return true;
    }
}

/**
 * An {@link FmcComponent} for displaying and accepting new values according to a validator and formatter.
 *
 * ## deleteAllowed
 *
 * This class deals with LSK presses that have the DELETE flag active using a default implementation
 * of {@link FmcComponentOptions.onDelete}, which checks `options.deleteAllowed` - if `true` or not set,the `onValidLskInput` subject
 * is set to `null` - if `false`, the "INVALID DELETE" scratchpad message is returned and handled by {@link FmcComponent.handleSelectKey}.
 *
 * ## onModified
 *
 * This class also introduces another LSK handler, {@link InputFieldOptions.onModified}, which is run after a value has been
 * validated (it is not called for invalid values) and applies return value logic. This runs after the flow
 * described for {@link FmcComponent}.
 */
class TextInputField extends EditableField {
    /** @inheritDoc */
    constructor(page, options) {
        super(page, options);
        this.options = options;
        // Default `onDelete` behaviour for input fields
        if (this.options.onDelete === undefined) {
            this.options.onDelete = async () => {
                var _a;
                if ((_a = this.options.deleteAllowed) !== null && _a !== void 0 ? _a : true) {
                    // We cannot check at runtime if the field can take null, so we kinda have to do that
                    this.valueChanged.notify(this, null);
                    // Always clear s-pad since it has DELETE in it
                    this.page.screen.clearScratchpad();
                    return true;
                }
                else {
                    return Promise.reject(this.page.screen.options.textInputFieldDisallowedDeleteThrowValue);
                }
            };
        }
    }
    /**
     * Creates an {@link TextInputField} that uses a {@link RawValidator} and {@link RawFormatter}
     * @param page the parent {@link FmcPage}
     * @returns the {@link TextInputField}
     * @deprecated (0.5.X) use constructor instead
     */
    static createRawTextInput(page) {
        return new TextInputField(page, {
            formatter: Object.assign(Object.assign({}, RawFormatter), RawValidator),
        });
    }
    /** @inheritDoc */
    async onHandleSelectKey(event) {
        var _a, _b, _c, _d;
        if (event.isDelete === true) {
            if ((_a = this.options.deleteAllowed) !== null && _a !== void 0 ? _a : true) {
                this.valueChanged.notify(this, null); // We cannot check at runtime if the field can take null, so we kinda have to do that
                // Always clear s-pad since it has DELETE in it
                this.page.screen.clearScratchpad();
                return true;
            }
            else {
                return Promise.reject(this.page.screen.options.textInputFieldDisallowedDeleteThrowValue);
            }
        }
        const parsedValue = await this.options.formatter.parse(event.scratchpadContents);
        if (parsedValue !== null) {
            // Process an `onModified` hook if we have one
            if (this.options.onModified) {
                const onModifiedResult = await this.options.onModified(parsedValue);
                // If the hook returns `true`, we return its value but also run the side effect.
                // An error returned would throw an exception, so this would not run.
                if (onModifiedResult === true || typeof onModifiedResult === 'string') {
                    if ((_b = this.options.clearScratchpadOnValueAccepted) !== null && _b !== void 0 ? _b : true) {
                        this.page.screen.clearScratchpad();
                    }
                }
                else {
                    this.valueChanged.notify(this, parsedValue);
                }
                if (onModifiedResult === false) {
                    // Here, `false` means that the `onModified` hook did not handle the value - not that the LSK is inactive
                    // so we return `true` and clear the scratchpad instead, as we presume the hook did what it wanted
                    if ((_c = this.options.clearScratchpadOnValueAccepted) !== null && _c !== void 0 ? _c : true) {
                        this.page.screen.clearScratchpad();
                    }
                    return true;
                }
                return onModifiedResult;
            }
            else {
                this.valueChanged.notify(this, parsedValue);
                if ((_d = this.options.clearScratchpadOnValueAccepted) !== null && _d !== void 0 ? _d : true) {
                    this.page.screen.clearScratchpad();
                }
                return true;
            }
        }
        else {
            return Promise.reject(this.page.screen.options.textInputFieldParseFailThrowValue);
        }
    }
}

/**
 * Represents possible lifetimes for FmcPages
 */
var FmcPageLifecyclePolicy;
(function (FmcPageLifecyclePolicy) {
    /**
     * Page is only created and initialized once, the first time it is navigated to, the reloaded and resumed.
     */
    FmcPageLifecyclePolicy[FmcPageLifecyclePolicy["Singleton"] = 0] = "Singleton";
    /**
     * Page is re-created and re-initialized every time it is navigated to.
     */
    FmcPageLifecyclePolicy[FmcPageLifecyclePolicy["Transient"] = 1] = "Transient";
})(FmcPageLifecyclePolicy || (FmcPageLifecyclePolicy = {}));
/**
 * Base abstract class for FMC pages
 */
class AbstractFmcPage {
    /**
     * Ctor
     * @param bus the event bus
     * @param screen the FMC screen instance
     */
    constructor(bus, screen) {
        this.bus = bus;
        this.screen = screen;
        this.memorizedComponents = [];
        this.bindings = [];
        this.params = new Map();
        this.isDirty = false;
        /**
         * Handles when update/refresh of the FMCPage based on clock input
         * @param d is the Clock Value from the Event Bus
         */
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.clockHandler = (d) => {
            if (this.isDirty) {
                this.isDirty = false;
                this.initialRender();
            }
        };
        this.isInitialized = false;
        this.currentOutput = [];
        this.screen = screen;
        this.clockConsumer = this.bus.getSubscriber().on('realTime').atFrequency(10, false);
    }
    /**
     * Initializes the page.
     *
     * Use this for setting up subscriptions and such.
     */
    init() {
        this.onInit();
        this.addBinding(new Binding(this.screen.currentSubpageIndex, () => this.invalidate()));
    }
    /**
     * Init lifecycle hook
     */
    onInit() {
        // Do nothing
    }
    /**
     * Pauses the page and calls appropriate event handlers
     */
    pause() {
        for (const binding of this.bindings) {
            binding.pause();
        }
        this.isDirty = false;
        this.clockConsumer.off(this.clockHandler);
        this.onPause();
    }
    /**
     * Pause lifecycle hook
     */
    onPause() {
        // Do nothing
    }
    /**
     * Resumes the page and calls appropriate event handlers
     */
    resume() {
        for (const binding of this.bindings) {
            binding.resume(true);
        }
        this.onResume();
        this.isDirty = true;
        this.clockConsumer.handle(this.clockHandler);
    }
    /**
     * Resume lifecycle hook
     */
    onResume() {
        // Do nothing
    }
    /** Is called when the page button for the current page is pressed while already on that page. */
    onPageButtonPressed() {
        // Do nothing
    }
    /**
     * Destroys the page and calls appropriate event handlers
     */
    destroy() {
        this.isDirty = false;
        this.clockConsumer.off(this.clockHandler);
        for (const binding of this.bindings) {
            binding.destroy();
        }
        this.onDestroy();
    }
    /**
     * Destroy lifecycle hook
     */
    onDestroy() {
        // Do nothing
    }
    /**
     * Invalidates the render and sets the component into the dirty state
     */
    invalidate() {
        this.isDirty = true;
    }
    /**
     * Initial render function
     */
    initialRender() {
        if (!this.isInitialized) {
            return;
        }
        // TODO initialize all controls
        const templates = this.render();
        this.screen.currentSubpageCount.set(templates.length);
        const template = templates[this.screen.currentSubpageIndex.get() - 1];
        const render = [];
        this.memorizedComponents.length = 0;
        for (let i = 0; i < template.length; i++) {
            if (!render[i]) {
                render[i] = [];
            }
            const row = template[i];
            const renderRow = render[i];
            for (let j = 0; j < row.length; j++) {
                const col = row[j];
                if (col instanceof FmcComponent) {
                    if (!this.memorizedComponents[i]) {
                        this.memorizedComponents[i] = [null, null, null];
                    }
                    this.memorizedComponents[i][j] = col;
                    const componentRender = col.render();
                    if (Array.isArray(componentRender)) {
                        for (let k = 0; k < componentRender.length; k++) {
                            const componentRenderRow = componentRender[k];
                            for (let l = 0; l < componentRenderRow.length; l++) {
                                if (!render[i + k]) {
                                    render[i + k] = [];
                                }
                                render[i + k][l] = componentRenderRow[l];
                            }
                        }
                    }
                    else {
                        renderRow[row.indexOf(col)] = componentRender;
                    }
                }
                else {
                    renderRow[j] = col;
                }
            }
        }
        this.currentOutput = render;
        this.renderCallback(this.currentOutput, template, 0);
    }
    /**
     * Registers a binding on the page
     *
     * @param binding a {@link Binding}
     */
    addBinding(binding) {
        this.bindings.push(binding);
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleLineSelectKey(event) {
        var _a;
        const componentAtSk = (_a = this.memorizedComponents[event.row]) === null || _a === void 0 ? void 0 : _a[event.col];
        if (componentAtSk) {
            const selectKeyHandled = await componentAtSk.handleSelectKey(event);
            if (selectKeyHandled !== false) {
                return selectKeyHandled;
            }
        }
        return await this.onHandleSelectKey(event);
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to components
     *
     * @param event the LSK event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleSelectKey(event) {
        // Do nothing
        return false;
    }
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    async handleScrolling(event) {
        return this.onHandleScrolling(event);
    }
    /**
     * Handles a scrolling event recieved by the FMC, before passing it on to components
     *
     * @param event the scrolling event
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onHandleScrolling(event) {
        // Do nothing
        return false;
    }
}
/**
 * Configures the {@link FmcPageLifecyclePolicy} for this page
 */
AbstractFmcPage.lifecyclePolicy = FmcPageLifecyclePolicy.Singleton;

/**
 * Utility class to drive list
 */
class FmcListUtility {
    /**
     * FMC List Utility Class
     * @param page                  The Fmc Page
     * @param data                  The row input data (SubscribableArray<T>)
     * @param renderRow             Function to call when the list needs to be re-rendered with new data
     * @param size                  row count of the list per page
     * @param firstPageSize         row count of the first page of the list
     */
    constructor(page, data, renderRow, size = 5, firstPageSize = undefined) {
        this.page = page;
        this.data = data;
        this.renderRow = renderRow;
        this.size = size;
        this.firstPageSize = firstPageSize;
    }
    /**
     * Returns a rendered list page for a specified page
     * @param page The page number to render
     * @returns The FmcRenderTemplate
     */
    renderList(page) {
        const rows = [];
        let startIndex = (page - 1) * this.size;
        if (this.firstPageSize !== undefined && page > 1) {
            startIndex = this.firstPageSize + ((page - 2) * this.size);
        }
        for (let i = startIndex; i < startIndex + this.size; i++) {
            const prevData = this.data.tryGet(i - 1);
            const data = this.data.tryGet(i);
            const nextData = this.data.tryGet(i + 1);
            const subRows = this.renderRow(this.page, i - startIndex, prevData, data, nextData);
            subRows.forEach(row => rows.push(row));
        }
        return rows;
    }
    /**
     * Handles when the Select Key is pressed.
     * @param event The Select Key Event.
     * @returns Whether the event was handled by this component.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async handleSelectKey(event) {
        return false;
    }
}

/**
 * FMC Page factory, used to instantiate pages.
 *
 * FMC Pages should be instantiated with the required data and objects (FMS instances, avionics-specific utilities, event busses)
 * in instances of subclasses of this type.
 */
class FmcPageFactory {
}

/**
 * A router for an FMC screen.
 *
 * This registers routes and handles setting the appropriate page and params.
 */
class FmcRouter {
    constructor() {
        this.routes = {};
        this.currentRoute = Subject.create('/');
        this.currentSubpageIndex = Subject.create(1);
        this.currentSubpageCount = Subject.create(1);
    }
    /**
     * Adds a route to the router
     *
     * @param route the route string
     * @param page the target page constructor
     */
    addRoute(route, page) {
        this.routes[route] = page;
    }
    /**
     * Gets the associated page (or undefined) for a route
     *
     * @param routeString the route string
     *
     * @returns the associated page
     */
    getPageForRoute(routeString) {
        return this.routes[routeString.split('#', 2)[0].trim()];
    }
    /**
     * Gets the associated subpage index (after the hash) or 1 by default
     *
     * @param routeString the route string
     *
     * @returns the associated subpage index
     */
    getSubpageForRoute(routeString) {
        var _a;
        return parseInt((_a = routeString.split('#', 2)[1]) !== null && _a !== void 0 ? _a : '1');
    }
    /**
     * Moves to the previous subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    prevSubpage() {
        const currentIndex = this.currentSubpageIndex.get();
        if (currentIndex === 1) {
            this.currentSubpageIndex.set(this.currentSubpageCount.get());
        }
        else {
            this.currentSubpageIndex.set(currentIndex - 1);
        }
        return true;
    }
    /**
     * Moves to the next subpage if there is one available
     *
     * @returns whether or not the subpage was changed
     */
    nextSubpage() {
        const currentIndex = this.currentSubpageIndex.get();
        if (currentIndex >= this.currentSubpageCount.get()) {
            this.currentSubpageIndex.set(1);
        }
        else {
            this.currentSubpageIndex.set(currentIndex + 1);
        }
        return true;
    }
    /**
     * Moves to the specified subpage if there is one available
     *
     * @param index Desired subpage index (1-based)
     *
     * @returns whether or not the subpage was changed
     */
    setSubpage(index) {
        const currentIndex = this.currentSubpageIndex.get();
        if (index < 1 || index > this.currentSubpageCount.get() || currentIndex === index) {
            return false;
        }
        this.currentSubpageIndex.set(index);
        return true;
    }
}

/**
 * Scratchpad for an FMC screen
 */
class FmcScratchpad {
    /**
     * Ctor
     * @param bus the event bus
     * @param options the options
     * @param renderCallback the render callback
     */
    constructor(bus, options, renderCallback) {
        this.bus = bus;
        this.renderCallback = renderCallback;
        this.options = {
            cellWidth: 16,
            style: 'white d-text',
            deleteText: 'DELETE',
            surroundingText: ['', ''],
            errorTextCentered: false,
            clearScratchpadOnError: false,
        };
        this.contents = Subject.create('');
        this.errorContents = Subject.create('');
        this.renderedText = Subject.create('');
        this.isInDelete = Subject.create(false);
        Object.assign(this.options, options);
        MappedSubject.create(this.contents, this.errorContents, this.isInDelete).sub(() => this.renderText());
    }
    /**
     * Appends a string on the scratchpad
     * @param char the string to append
     */
    typeContents(char) {
        this.isInDelete.set(false);
        this.clearError();
        const contents = this.contents.get();
        this.contents.set(`${contents}${char}`);
    }
    /**
     * Deletes the last character on the scratchpad
     */
    backspace() {
        this.clearError();
        const contents = this.contents.get();
        this.contents.set(contents.substring(0, Math.max(0, contents.length - 1)));
    }
    /**
     * Clears the scratchpad
     *
     * @param clearError whether to clear any scratchpad error content, defaults to `true`
     */
    clear(clearError = true) {
        if (clearError) {
            this.clearError();
        }
        this.delete(false, false);
        this.contents.set('');
    }
    /**
     * Clears the scratchpad error
     */
    clearError() {
        this.errorContents.set('');
    }
    /**
     * Sets the scratchpad to an error message
     * @param error The error message
     */
    error(error) {
        if (this.options.clearScratchpadOnError) {
            this.isInDelete.set(false);
            this.contents.set('');
        }
        this.errorContents.set(error);
    }
    /**
     * Sets the scratchpad in DELETE mode (or not)
     *
     * @param value optional value to force, otherwise the value is set to `true`
     * @param clearError whether to clear any scratchpad error content, defaults to `true`
     */
    delete(value, clearError = true) {
        if (clearError) {
            this.clearError();
        }
        this.isInDelete.set(value !== null && value !== void 0 ? value : !this.isInDelete.get());
    }
    /**
     * Renders the scratchpad and sets the subject
     */
    renderText() {
        const surroundingTextWidth = this.options.surroundingText[0].length + this.options.surroundingText[1].length;
        const spaceToPadTo = this.options.cellWidth - surroundingTextWidth;
        // We use `\u00a0` instead of the normal space character here, due to what seems to be an issue involving the regular space character
        // causing a lack of repaints in some situations.
        let renderText;
        if (this.errorContents.get()) {
            const errorContents = this.errorContents.get();
            if (this.options.errorTextCentered) {
                const leftPad = '\u00a0'.repeat(Math.floor((spaceToPadTo - errorContents.length) / 2));
                const rightPad = '\u00a0'.repeat(Math.ceil((spaceToPadTo - errorContents.length) / 2));
                renderText = `${leftPad}${errorContents}${rightPad}`;
            }
            else {
                renderText = errorContents.padEnd(spaceToPadTo, '\u00a0');
            }
        }
        else if (this.isInDelete.get()) {
            renderText = this.options.deleteText.padEnd(spaceToPadTo, '\u00a0');
        }
        else {
            renderText = this.contents.get().padEnd(spaceToPadTo, '\u00a0');
        }
        const leftText = this.options.surroundingText[0];
        const rightText = this.options.surroundingText[1];
        const styleString = this.options.style ? `[${this.options.style}]` : '';
        this.renderedText.set(`${leftText}${renderText}${styleString}${rightText}`);
    }
}

/**
 * An FMC screen.
 *
 * This is the main object used to encapsulate an FMC screen and its rendering.
 *
 * Type parameter `T` should be a subclass of the {@link AbstractFmcPage} that is universally used by pages in this implementation.
 * This is done so that different avionics can have different types for different kinds of events and any data that pages might need to be
 * instantiated with.
 */
class FmcScreen {
    /**
     * Ctor
     * @param bus the event bus
     * @param pageFactory the page factory to be used for creating FMC pages for this screen
     * @param options the screen options
     * @param renderer the renderer to use for this screen
     * @param scratchpad the scratchpad to use for this screen
     */
    constructor(bus, pageFactory, options, renderer, scratchpad) {
        this.bus = bus;
        this.pageFactory = pageFactory;
        this.renderer = renderer;
        this.scratchpad = scratchpad;
        this.router = new FmcRouter();
        this.pageInstanceCache = new Map();
        this.options = {
            screenDimensions: {
                cellWidth: 24,
                cellHeight: 12,
            },
            lskNotHandledThrowValue: 'KEY NOT ACTIVE',
            textInputFieldDisallowedDeleteThrowValue: 'INVALID DELETE',
            textInputFieldParseFailThrowValue: 'INVALID ENTRY',
            enableScratchpad: true,
            eventPrefix: '',
        };
        this.currentlyDisplayedPage = null;
        Object.assign(this.options, options);
        if (this.options.enableScratchpad) {
            this.scratchpad.renderedText.sub((text) => {
                this.renderer.editOutputTemplate([[text]], this.options.screenDimensions.cellHeight - 1);
            });
        }
    }
    /**
     * Gets the current route
     *
     * @returns a string subject
     */
    get currentRoute() {
        return this.router.currentRoute;
    }
    /**
     * Gets the current subpage index for the current displayed page, 1-indexed
     *
     * @returns a number
     */
    get currentSubpageIndex() {
        return this.router.currentSubpageIndex;
    }
    /**
     * Gets the current number of subpages for the current displayed page
     *
     * @returns a number
     */
    get currentSubpageCount() {
        return this.router.currentSubpageCount;
    }
    /**
     * Navigates to a given route and displays the associated page, if available
     *
     * @param route the route
     * @param params the parameters to pass to the page
     */
    navigateTo(route, params) {
        const pageCtor = this.router.getPageForRoute(route);
        if (pageCtor) {
            this.router.currentRoute.set(route);
            let instance;
            if (pageCtor.lifecyclePolicy === FmcPageLifecyclePolicy.Singleton) {
                const existingInstance = this.pageInstanceCache.get(pageCtor);
                instance = existingInstance !== null && existingInstance !== void 0 ? existingInstance : this.instantiatePage(pageCtor);
                this.pageInstanceCache.set(pageCtor, instance);
            }
            else {
                instance = this.instantiatePage(pageCtor);
            }
            if (this.currentlyDisplayedPage) {
                this.currentlyDisplayedPage.pause();
            }
            this.currentlyDisplayedPage = instance;
            instance.params.clear();
            if (params) {
                for (const key of Object.keys(params)) {
                    instance.params.set(key, params[key]);
                }
            }
            if (!instance.isInitialized) {
                instance.init();
            }
            this.router.currentSubpageCount.set(instance.render().length);
            this.router.setSubpage(this.router.getSubpageForRoute(route));
            instance.isInitialized = true;
            instance.resume();
        }
    }
    /**
     * Clears the scratchpad, if applicable
     */
    clearScratchpad() {
        this.scratchpad.clear();
    }
    /**
     * Declares a route for a page class
     *
     * @param route the route to set
     * @param page the page to associate with it
     * @param routeEvent the event to associate with it
     */
    addPageRoute(route, page, routeEvent) {
        this.router.addRoute(route, page);
        if (routeEvent) {
            this.bus.getSubscriber().on(`${this.options.eventPrefix}${routeEvent}`).handle(() => {
                var _a;
                if (this.currentRoute.get() === route) {
                    (_a = this.currentlyDisplayedPage) === null || _a === void 0 ? void 0 : _a.onPageButtonPressed();
                }
                else {
                    this.navigateTo(route);
                }
            });
        }
    }
    /**
     * Adds a list of LSK events bound to certain positions on the rendering grid
     *
     * @param array the LSK events and their positions
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    addLskEvents(array) {
        for (const lsk of array) {
            this.bus.getSubscriber().on(`${this.options.eventPrefix}${lsk[0]}`).handle(() => {
                this.handleLineSelectKey(lsk[1], lsk[2]);
            });
        }
    }
    /**
     * Adds paging events bound the page slewing
     *
     * @param events the events to bind
     */
    addPagingEvents(events) {
        const subs = this.bus.getSubscriber();
        events.pageLeft && subs.on(`${this.options.eventPrefix}${events.pageLeft}`).handle(() => this.handlePagingKey('pageLeft'));
        events.pageRight && subs.on(`${this.options.eventPrefix}${events.pageRight}`).handle(() => this.handlePagingKey('pageRight'));
        events.pageUp && subs.on(`${this.options.eventPrefix}${events.pageUp}`).handle(() => this.handlePagingKey('pageUp'));
        events.pageDown && subs.on(`${this.options.eventPrefix}${events.pageDown}`).handle(() => this.handlePagingKey('pageDown'));
    }
    /**
     * Returns a consumer for an event prefixed for this particular screen.
     * @param event The event to subscribe to.
     * @returns A consumer for an event prefixed for this particular screen.
     * */
    onPrefixedEvent(event) {
        return this.bus.getSubscriber().on(`${this.options.eventPrefix}${event}`);
    }
    /**
     * Instantiates a page for this screen
     *
     * @param page the page constructor
     *
     * @returns the created page
     */
    instantiatePage(page) {
        return this.pageFactory.createPage(page, this.bus, this, this.acceptPageOutput.bind(this));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    acceptPageOutput(output, template, atRowIndex) {
        const rows = [...output];
        const totalRows = this.options.screenDimensions.cellHeight - (this.options.enableScratchpad ? 2 : 0);
        for (let i = rows.length; i < totalRows; i++) {
            rows.push(['']);
        }
        this.renderer.editOutputTemplate(rows, atRowIndex);
        if (this.options.enableScratchpad) {
            this.renderer.editOutputTemplate([[this.scratchpad.renderedText.get()]], this.options.screenDimensions.cellHeight - 1);
        }
    }
    /**
     * Handles a line select key recieved by the FMC, before passing it on to pages
     *
     * @param row the row of the LSK
     * @param col the side of the lSK (0 or 1)
     */
    handleLineSelectKey(row, col) {
        if (this.currentlyDisplayedPage) {
            const event = {
                row, col, scratchpadContents: this.scratchpad.contents.get(), isDelete: this.scratchpad.isInDelete.get(),
            };
            this.currentlyDisplayedPage.handleLineSelectKey(event).then((returnValue) => {
                if (typeof returnValue === 'string') {
                    this.scratchpad.contents.set(returnValue);
                }
                else if (!returnValue) {
                    this.onLineSelectKeyUnhandled(event);
                }
            }).catch((error) => this.onLineSelectKeyError(error));
        }
    }
    /**
     * Called when an LSK event is not handled by any code.
     *
     * @param selectKeyEvent the LSK event
     *
     * @throws the value of `options.lskNotHandledThrowValue` by default
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLineSelectKeyUnhandled(selectKeyEvent) {
        throw this.options.lskNotHandledThrowValue;
    }
    /**
     * Called when an LSK error is thrown. Sets `this.scratchpad.errorContents` (if error is a string; otherwise throws) by default.
     *
     * @param error the LSK error
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onLineSelectKeyError(error) {
        if (typeof error === 'string') {
            this.scratchpad.errorContents.set(error);
        }
        else {
            console.error(`Unhandled error in LSK handler: ${error}`);
        }
    }
    /**
     * Handles a paging key recieved by the FMC
     *
     * @param event the paging key event
     */
    async handlePagingKey(event) {
        var _a;
        const handledByPage = await ((_a = this.currentlyDisplayedPage) === null || _a === void 0 ? void 0 : _a.handleScrolling(event));
        if (handledByPage) {
            return;
        }
        if (event === 'pageLeft') {
            this.router.prevSubpage();
        }
        if (event === 'pageRight') {
            this.router.nextSubpage();
        }
    }
}

/** FMC Renderer class */
class SimpleFmcRenderer {
    /**
     * Ctor
     * @param eventBus The event bus.
     * @param targetElement The target element of the renderer.
     * @param options The options for the renderer.
     */
    constructor(eventBus, targetElement, options) {
        var _a;
        this.targetElement = targetElement;
        this.options = options;
        this.currentOutput = [];
        this.columnData = [];
        this.prevColumnData = [];
        this.hasChanges = false;
        this.colElArr = [];
        // HINT: Looks like thats too much but perf is better caching the text nodes
        this.colElNodeArr = [];
        this.rowElArr = [];
        this.containerTemplate = this.createContainerTemplate();
        this.columnData = this.createColumnInformation();
        this.prevColumnData = this.createColumnInformation();
        this.containerRef = this.targetElement;
        this.initializeContainer();
        this.clockConsumer = eventBus.getSubscriber().on('realTime').atFrequency((_a = this.options.updateFrequency) !== null && _a !== void 0 ? _a : 10, false);
        this.clockConsumer.handle(this.onClockUpdate.bind(this));
    }
    /** Initializes the container we will render to. */
    initializeContainer() {
        const container = this.containerTemplate.cloneNode(true);
        this.containerRef.replaceWith(container);
        // this.elecContainerRef.replaceChild(container, this.containerRef);
        this.containerRef = container;
        // build colElArr
        for (let r = 0; r < this.options.screenCellHeight; r++) {
            const rowEl = this.containerRef.childNodes[r];
            this.rowElArr.push(rowEl);
            const colArr = [];
            const colNodeArr = [];
            for (let c = 0; c < this.options.screenCellWidth; c++) {
                const colEl = rowEl.childNodes[c + 1];
                colArr.push(colEl);
                colNodeArr.push(colEl.firstChild);
            }
            this.colElArr.push(colArr);
            this.colElNodeArr.push(colNodeArr);
        }
    }
    /** Handles the clock update event. */
    onClockUpdate() {
        if (this.hasChanges) {
            this.hasChanges = false;
            this.renderToDom();
        }
    }
    /**
     * Edits part of the row output
     * @param output the output to insert
     * @param rowIndex the row index to insert at
     * @throws if `rowIndex` is too high
     */
    editOutputTemplate(output, rowIndex) {
        const rowsAvailable = (this.options.screenCellHeight) - rowIndex;
        if (rowsAvailable <= 0 || rowsAvailable < output.length) {
            throw new Error(`[FmcRenderer](editTemplate) Tried to write ${output.length - rowsAvailable} too many rows.`);
        }
        for (let i = rowIndex, c = 0; i < rowIndex + rowsAvailable && output[c]; i++, c++) {
            if (this.currentOutput[i] !== output[c]) {
                this.currentOutput[i] = output[c];
                this.hasChanges = true;
            }
        }
    }
    /** Renders the current template */
    renderToDom() {
        // get a new column data structure
        this.columnData = this.createColumnInformation();
        // parse and fill in the column data
        for (let index = 0; index < this.options.screenCellHeight; index++) {
            this.buildRowInfo(this.currentOutput[index], index);
        }
        // go through all rows and columns and update the content if necessary
        for (let r = 0; r < this.options.screenCellHeight; r++) {
            for (let c = 0; c < this.options.screenCellWidth; c++) {
                const colData = this.columnData[r][c];
                const prevColData = this.prevColumnData[r][c];
                if (colData.content !== prevColData.content || colData.styles !== prevColData.styles) {
                    if (colData.content !== prevColData.content) {
                        const colNodeEl = this.colElNodeArr[r][c];
                        colNodeEl.nodeValue = colData.content;
                    }
                    if (colData.styles !== prevColData.styles) {
                        const colEl = this.colElArr[r][c];
                        colEl.className = `fmc-letter ${colData.styles}`;
                    }
                }
            }
        }
        this.prevColumnData = this.columnData;
    }
    /**
     * Parse row templates and build the column information.
     * @param template the template to parse
     * @param rowIndex the row index
     */
    buildRowInfo(template, rowIndex) {
        // only content
        if (rowIndex < this.options.screenCellHeight && template) {
            if (template[0] !== '') {
                // LEFT
                this.buildColumnInformation(template[0], rowIndex, 'left');
            }
            if (template[1] && template[1] !== '') {
                // RIGHT
                this.buildColumnInformation(template[1], rowIndex, 'right');
            }
            if (template[2] && template[2] !== '') {
                // CENTER
                this.buildColumnInformation(template[2], rowIndex, 'center');
            }
        }
    }
    /**
     * Builds the data struct for the row's columns.
     * @param templateRowColumn template
     * @param rowIndex the row index
     * @param dir direction
     */
    buildColumnInformation(templateRowColumn, rowIndex, dir = 'left') {
        const content = this.parseContent(templateRowColumn);
        let charCount = 0;
        // count all letters
        content.forEach(x => {
            var _a, _b;
            charCount += (_b = (_a = x.content) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        });
        charCount = Math.min(charCount, this.options.screenCellWidth);
        // set start pos
        let charIndex = 0;
        if (dir === 'right') {
            charIndex = this.options.screenCellWidth - charCount;
        }
        else if (dir == 'center') {
            charIndex = Math.round((((this.options.screenCellWidth - 1) / 2) - (charCount / 2)));
        }
        // build data struct
        const row = this.columnData[rowIndex];
        content.forEach(x => {
            const letters = x.content.split('');
            letters.forEach((c) => {
                if (charIndex >= this.options.screenCellWidth) {
                    return;
                }
                const colInfo = row[charIndex];
                colInfo.styles = x.styles;
                colInfo.content = c === '' ? ' ' : c;
                charIndex++;
            });
        });
    }
    /**
     * Parses content into intermediate information blocks
     * @param content the content to parse
     * @returns a list of information blocks
     */
    parseContent(content) {
        const resultInfo = [];
        // if it starts with a bracket its probably empty
        if (content.startsWith('[')) {
            return resultInfo;
        }
        // eslint-disable-next-line no-useless-escape
        const regex = /([^\[\]\n]+)(\[[^\[\]\n]+\])*/g;
        let match = regex.exec(content);
        if (match) {
            while (match != null) {
                const el = {
                    content: match[1].replace('__LSB', '[').replace('__RSB', ']'),
                    styles: ''
                };
                if (match[2]) {
                    // eslint-disable-next-line no-useless-escape
                    const classes = match[2].match(/[^\s\[\]]+/g);
                    if (classes) {
                        el.styles = classes.join(' ');
                    }
                }
                resultInfo.push(el);
                match = regex.exec(content);
            }
        }
        return resultInfo;
    }
    /**
     * Builds the template for the whole container.
     * @param defaultAlternatingLayout if the rows should alternate
     * @returns the container template
     */
    createContainerTemplate(defaultAlternatingLayout = true) {
        // create container
        const container = document.createElement('div');
        container.id = 'fmc-container';
        this.colTemplate = this.createColumnTemplate();
        this.rowTemplate = this.createRowTemplate();
        // const preRenderRows = Date.now();
        for (let r = 0; r < this.options.screenCellHeight; r++) {
            // rows
            const row = this.rowTemplate.cloneNode(true);
            if (defaultAlternatingLayout && r % 2 == 1) {
                row.classList.remove('d-text');
                row.classList.add('s-text');
            }
            container.appendChild(row);
        }
        return container;
    }
    /**
     * Builds the template for a single row.
     * @returns the row template
     */
    createRowTemplate() {
        // create row template
        const rowTemplate = document.createElement('div');
        rowTemplate.classList.add('fmc-row');
        rowTemplate.classList.add('d-text');
        const cellHeight = this.options.screenPXHeight / this.options.screenCellHeight;
        rowTemplate.style.height = `${cellHeight}px`;
        rowTemplate.style.lineHeight = `${cellHeight}px`;
        const cellWidth = this.options.screenPXWidth / this.options.screenCellWidth;
        const lostDecimalWidth = cellWidth - Math.trunc(cellWidth);
        const paddingElemLeft = document.createElement('span');
        paddingElemLeft.style.width = `${Math.ceil((lostDecimalWidth * this.options.screenCellWidth) / 2)}px`;
        paddingElemLeft.style.display = 'inline-block';
        rowTemplate.appendChild(paddingElemLeft);
        // create spans in row template
        for (let c = 0; c < this.options.screenCellWidth; c++) {
            const col = this.colTemplate.cloneNode(true);
            rowTemplate.appendChild(col);
        }
        return rowTemplate;
    }
    /**
     * Builds the template for a single column.
     * @returns the column template
     */
    createColumnTemplate() {
        // create column template
        const colEl = document.createElement('div');
        colEl.classList.add('fmc-letter');
        colEl.style.width = `${this.options.screenPXWidth / this.options.screenCellWidth}px`;
        colEl.style.height = `${this.options.screenPXHeight / this.options.screenCellHeight}px`;
        colEl.style.lineHeight = `${this.options.screenPXHeight / this.options.screenCellHeight}px`;
        colEl.textContent = ' ';
        return colEl;
    }
    /**
     * Builds the data structure representing the content and looks.
     * @returns the data structure
     */
    createColumnInformation() {
        const columnInformation = [];
        for (let r = 0; r < this.options.screenCellHeight; r++) {
            const rowColumns = [];
            for (let c = 0; c < this.options.screenCellWidth; c++) {
                const colInfo = {
                    content: ' ',
                    styles: ''
                };
                rowColumns.push(colInfo);
            }
            columnInformation.push(rowColumns);
        }
        return columnInformation;
    }
}

/* eslint-disable max-len */
/**
 * A utility class for creating time formatters.
 *
 * Each time formatter is a function which generates output strings from input time values, expressed as UNIX
 * timestamps in milliseconds. The formatting behavior of a formatter is defined by its format template and options.
 *
 * Please refer to the {@link DateTimeFormatterOptions} type documentation for more information on individual
 * formatting options.
 *
 * Format templates are strings which contain zero or more fragments enclosed by curly braces (`{}`); For a given
 * format template, an output string is generated from an input duration by replacing each fragment in the template
 * with a string generated from the input. The parts of the template string that are not contained in any fragment are
 * passed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types
 * of fragments:
 * * Integer fragment. In EBNF notation, these take the form `{x}` where `x = 'M' | 'd' | 'w'`. Each numeric fragment
 * is replaced with an integer representation of the month (`M`), day of month (`d`), or day of week (`w`) part of the
 * input time. The number of `x` characters in the definition controls the number of leading zeroes with which the
 * output will be padded.
 * * Numeric fragment. In EBNF notation, these take the form `{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]` where
 * `x = 'H' | 'h' | 'm' | 's'`. Each numeric fragment is replaced with a numeric representation of the hour-24 (`H`),
 * hour-12 (`h`), minute (`m`), or second (`s`) part of the input time. The number of `x` characters in the definition
 * controls the number of leading zeroes with which the output will be padded. If the optional `'?'` character is
 * present, the output will drop all digits to the left of the decimal point if all such digits are equal to 0. The
 * total number of `x` characters to the right of the decimal point in the definition controls the decimal precision of
 * the output. Trailing zeroes to the right of the decimal point will be added to the output to a number of decimal
 * places equal to the number of non-parenthetical `x` characters to the right of the decimal point in the definition.
 * If there are no `x` characters to the right of the decimal point in the definition, then the output will have
 * infinite decimal precision with no extraneous trailing zeroes. Rounding behavior is always round down.
 * * Year fragment. In EBNF notation, these take the form `'YY' | 'YYYY'`. Each year fragment is replaced with either
 * the two-digit (`YY`) or unlimited-digit (`YYYY`) year of the input time.
 * * Month fragment. In EBNF notation, these take the form `('mon', ['.']) | ('MON', ['.']) | 'month' | 'MONTH'`. Each
 * month fragment is replaced with the name of the month of the input time. The case of the definition determines the
 * case of the output. `mon` will use abbreviated names. The presence of the optional `'.'` character will add a period
 * to the end of the abbreviated names.
 * * Day-of-week fragment. In EBNF notation, these take the form `('dy', ['.']) | ('DY', ['.']) | 'day' | 'DAY'`. Each
 * day-of-week fragment is replaced with the name of the day-of-week of the input time. The case of the definition
 * determines the case of the output. `dy` will use abbreviated names. The presence of the optional `'.'` character
 * will add a period to the end of the abbreviated names.
 * * AM/PM fragment. In EBNF notation, these take the form `'am' | 'a.m.' | 'AM' | 'A.M.'`. Each AM/PM fragment is
 * replaced with an AM/PM string depending on the time of day of the input. The case of the definition determines the
 * case of the output. Use of periods in the definition will add periods to the output.
 *
 * @example <caption>Formatting to a date</caption>
 * const formatter = DateTimeFormatter.create('{dd}-{MM}-{YY}');
 * formatter(0);              // 01-01-70
 * formatter(1597723200000);  // 18-08-20
 *
 * @example <caption>Formatting to a time (24-hr)</caption>
 * const formatter = DateTimeFormatter.create('{HH}:{mm}:{ss}');
 * formatter(0);              // 00:00:00
 * formatter(5145000);        // 01:25:45
 * formatter(57600000);       // 16:00:00
 *
 * @example <caption>Formatting to a time (12-hr)</caption>
 * const formatter = DateTimeFormatter.create('{hh}:{mm}:{ss} {am}');
 * formatter(0);              // 12:00:00 am
 * formatter(5145000);        // 01:25:45 am
 * formatter(57600000);       // 04:00:00 pm
 *
 * @example <caption>Formatting to a time with decimals</caption>
 * const formatter = DateTimeFormatter.create('{H}:{mm.m(m)}');
 * formatter(0);              // 0:00.0
 * formatter(5145000);        // 1:25.75
 *
 * @example <caption>Formatting to ISO 8601</caption>
 * const formatter = DateTimeFormatter.create('{YYYY}-{MM}-{dd}T{HH}:{mm}:{ss}');
 * formatter(0);              // 1970-01-01T00:00:00
 * formatter(1597723200000);  // 2020-08-18T04:00:00
 */
class DateTimeFormatter {
    /**
     * Creates a function which formats times, expressed as UNIX timestamps in milliseconds, to strings. The formatting
     * behavior of the function is defined by a specified format template and options. For more information on format
     * templates and their syntax, please refer to the {@link DateTimeFormatter} class documentation. For more
     * information on individual formatting options, please refer to the {@link DateTimeFormatterOptions} type
     * documentation.
     * @param format A template defining how the function formats durations.
     * @param options Options to customize the formatter. Options not explicitly defined will be set to the following
     * default values:
     * * `monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']`
     * * `monthNamesShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']`
     * * `dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']`
     * * `dayNamesShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']`
     * * `nanString = 'NaN'`
     * @returns A function which formats times, expressed as UNIX timestamps in milliseconds, to strings.
     */
    static create(format, options) {
        const optsToUse = this.resolveOptions(options);
        const builder = DateTimeFormatter.createBuilder(format, optsToUse);
        const date = new Date();
        const built = Array.from(builder, () => '');
        if (optsToUse.cache) {
            let cachedInput = undefined;
            let cachedOutput = undefined;
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                const roundedInput = Math.floor(time);
                if (cachedInput !== undefined && cachedOutput !== undefined && roundedInput === cachedInput) {
                    return cachedOutput;
                }
                cachedInput = roundedInput;
                date.setTime(roundedInput);
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return cachedOutput = built.join('');
            };
        }
        else {
            return (time) => {
                if (isNaN(time)) {
                    return optsToUse.nanString;
                }
                date.setTime(Math.floor(time));
                for (let i = 0; i < builder.length; i++) {
                    built[i] = builder[i](date);
                }
                return built.join('');
            };
        }
    }
    /**
     * Resolves a full set of options from a partial options object. Any option not explicitly defined by the partial
     * options object will revert to its default value.
     * @param options A partial options object.
     * @returns A new options object containing the full set of options resolved from the specified partial options
     * object.
     */
    static resolveOptions(options) {
        var _a;
        const resolved = Object.assign({}, options);
        for (const key in DateTimeFormatter.DEFAULT_OPTIONS) {
            (_a = resolved[key]) !== null && _a !== void 0 ? _a : (resolved[key] = DateTimeFormatter.DEFAULT_OPTIONS[key]);
        }
        return resolved;
    }
    /**
     * Creates an output string builder from a format template and options.
     * @param format A format template.
     * @param options Formatting options.
     * @returns An output string builder which conforms to the specified format template and options.
     */
    static createBuilder(format, options) {
        const split = format.split(DateTimeFormatter.FORMAT_REGEXP);
        return split.map((string) => {
            if (string.match(DateTimeFormatter.FORMAT_REGEXP)) {
                return DateTimeFormatter.parseFragment(string.substring(1, string.length - 1), options);
            }
            else {
                return () => string;
            }
        });
    }
    /**
     * Parses a format template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment. If the fragment is malformed, this method returns a function which always
     * generates an empty string.
     * @param fragment A format template fragment definition.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the template fragment.
     */
    static parseFragment(fragment, options) {
        const match = fragment.match(DateTimeFormatter.FRAGMENT_REGEXP);
        if (match) {
            if (match[1]) {
                return DateTimeFormatter.parseIntFragment(match);
            }
            else if (match[3]) {
                return DateTimeFormatter.parseNumFragment(match);
            }
            else if (match[10]) {
                return DateTimeFormatter.parseYearFragment(match);
            }
            else if (match[11]) {
                return DateTimeFormatter.parseMonthFragment(match, options);
            }
            else if (match[12]) {
                return DateTimeFormatter.parseDayFragment(match, options);
            }
            else if (match[13]) {
                return DateTimeFormatter.parseAMPMFragment(match);
            }
        }
        console.warn(`DateTimeFormatter: discarding fragment due to invalid syntax: {${fragment}}`);
        return () => '';
    }
    /**
     * Parses an integer template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An integer template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the integer template fragment.
     */
    static parseIntFragment(match) {
        const [
        /* 0 */ , fragmentMatch, // Matches the full fragment
        unitMatch // Matches the unit char ('M', 'd', 'w')
        ] = match;
        const intGetter = DateTimeFormatter.INT_GETTERS[unitMatch];
        const pad = fragmentMatch.length;
        return (date) => {
            return intGetter(date).toString().padStart(pad, '0');
        };
    }
    /**
     * Parses a numeric template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A numeric template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the numeric template fragment.
     */
    static parseNumFragment(match) {
        var _a, _b;
        const [
        /* 0 */ , /* 1 */ , /* 2 */ , /* 3 */ , leftMatch, // Matches unit chars to the left of the decimal point
        unitMatch, // Matches the unit char ('h', 'm', 's', etc)
        leftOptionalMatch, // Matches the question mark just to the left of the decimal point
        rightMatch, // Matches the decimal point and all chars to the right
        rightForcedMatch, // Matches unit chars to the right of the decimal point not surrounded by parens
        rightOptionalMatch // Matches unit chars to the right of the decimal point surrounded by parens
        ] = match;
        const numGetter = DateTimeFormatter.NUM_GETTERS[unitMatch];
        const numFractionGetter = DateTimeFormatter.NUM_FRACTION_GETTERS[unitMatch];
        const pad = leftMatch.length;
        const dropZero = !!leftOptionalMatch;
        const formatLeftFunc = dropZero
            ? ((date) => {
                const num = numGetter(date);
                return num === 0 ? '' : num.toString().padStart(pad, '0');
            }) : ((date) => numGetter(date).toString().padStart(pad, '0'));
        if (rightMatch) {
            if (rightMatch.length === 1) {
                // Unlimited decimal precision
                return (date) => {
                    return `${formatLeftFunc(date)}${numFractionGetter(date).toString().substring(1)}`;
                };
            }
            const forcedDecimalPlaces = (_a = rightForcedMatch === null || rightForcedMatch === void 0 ? void 0 : rightForcedMatch.length) !== null && _a !== void 0 ? _a : 0;
            const unforcedDecimalPlaces = (_b = rightOptionalMatch === null || rightOptionalMatch === void 0 ? void 0 : rightOptionalMatch.length) !== null && _b !== void 0 ? _b : 0;
            const totalDecimalPlaces = forcedDecimalPlaces + unforcedDecimalPlaces;
            const factor = Math.pow(10, totalDecimalPlaces);
            return (date) => {
                const decimal = numFractionGetter(date);
                const decimalRounded = Math.floor(decimal * factor) / factor;
                return `${formatLeftFunc(date)}.${decimalRounded.toString().substring(2).padEnd(forcedDecimalPlaces, '0')}`;
            };
        }
        else {
            return formatLeftFunc;
        }
    }
    /**
     * Parses a year template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A year template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the year template fragment.
     */
    static parseYearFragment(match) {
        if (match[10].length === 2) {
            // YY
            return (date) => (date.getUTCFullYear() % 100).toString();
        }
        else {
            // YYYY
            return (date) => date.getUTCFullYear().toString();
        }
    }
    /**
     * Parses a month template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match A month template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the month template fragment.
     */
    static parseMonthFragment(match, options) {
        const fragmentMatch = match[11];
        const isUpperCase = fragmentMatch[0] === 'M';
        if (fragmentMatch.length === 3) {
            // mon
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => text[date.getUTCMonth()];
        }
        else if (fragmentMatch.length === 4) {
            // mon.
            const text = isUpperCase ? options.monthNamesShort.map(str => str.toUpperCase()) : options.monthNamesShort;
            return (date) => {
                const month = date.getUTCMonth();
                return `${text[month]}${options.monthNamesShort[month] === options.monthNames[month] ? '' : '.'}`;
            };
        }
        else {
            // month
            const text = isUpperCase ? options.monthNames.map(str => str.toUpperCase()) : options.monthNames;
            return (date) => text[date.getUTCMonth()];
        }
    }
    /**
     * Parses a day-of-week template fragment and returns a function which generates a string from an input time
     * according to the rules defined by the fragment.
     * @param match A day-of-week template fragment, as a regular expression match.
     * @param options Formatting options.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the day-of-week template fragment.
     */
    static parseDayFragment(match, options) {
        const fragmentMatch = match[12];
        const isUpperCase = fragmentMatch[0] === 'D';
        if (fragmentMatch === 'dy') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => text[date.getUTCDay()];
        }
        else if (fragmentMatch === 'dy.') {
            const text = isUpperCase ? options.dayNamesShort.map(str => str.toUpperCase()) : options.dayNamesShort;
            return (date) => {
                const day = date.getUTCDay();
                return `${text[day]}${options.dayNamesShort[day] === options.dayNames[day] ? '' : '.'}`;
            };
        }
        else {
            // day
            const text = isUpperCase ? options.dayNames.map(str => str.toUpperCase()) : options.dayNames;
            return (date) => text[date.getUTCDay()];
        }
    }
    /**
     * Parses an am/pm template fragment and returns a function which generates a string from an input time according
     * to the rules defined by the fragment.
     * @param match An am/pm template fragment, as a regular expression match.
     * @returns A function which generates a string from an input time, expressed as a UNIX timestamp in milliseconds,
     * according to the rules defined by the am/pm template fragment.
     */
    static parseAMPMFragment(match) {
        const fragmentMatch = match[13];
        const isUpperCase = fragmentMatch[0] === 'A';
        const usePeriod = fragmentMatch.length > 2;
        let text = usePeriod ? ['a.m.', 'p.m.'] : ['am', 'pm'];
        if (isUpperCase) {
            text = text.map(str => str.toUpperCase());
        }
        return (date) => text[Math.floor(date.getUTCHours() / 12)];
    }
}
DateTimeFormatter.FORMAT_REGEXP = /({[^{}]*})/;
DateTimeFormatter.FRAGMENT_REGEXP = /^(?:(([Mdw])\2*)|((([Hhms])\5*)(\?)?(?:(\.(\5*)(?:\((\5+)\))?)?))|(YY|YYYY)|(mon\.?|month|MON\.?|MONTH)|(dy\.?|day|DY\.?|DAY)|(am|AM|a\.m\.|A\.M\.))$/;
DateTimeFormatter.INT_GETTERS = {
    ['w']: (date) => date.getUTCDay() + 1,
    ['d']: (date) => date.getUTCDate(),
    ['M']: (date) => date.getUTCMonth() + 1
};
DateTimeFormatter.NUM_GETTERS = {
    ['s']: (date) => date.getUTCSeconds(),
    ['m']: (date) => date.getUTCMinutes(),
    ['h']: (date) => 12 - (24 - date.getUTCHours()) % 12,
    ['H']: (date) => date.getUTCHours()
};
DateTimeFormatter.NUM_FRACTION_GETTERS = {
    ['s']: (date) => (date.getTime() % 1000) / 1000,
    ['m']: (date) => (date.getTime() % 60000) / 60000,
    ['h']: (date) => (date.getTime() % 3600000) / 3600000,
    ['H']: (date) => (date.getTime() % 3600000) / 3600000
};
DateTimeFormatter.DEFAULT_OPTIONS = {
    monthNames: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
    monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
    dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    nanString: 'NaN',
    cache: false
};

/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus.
 */
class DefaultUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings.
     * @param keepLocal If present and true, values will be kept local to the instrument on which they're set.
     */
    constructor(bus, settingDefs, keepLocal = false) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.subscriber = this.bus.getSubscriber();
        this.syncPublisher = this.bus.getPublisher();
        this.syncSubscriber = this.bus.getSubscriber();
        this.keepLocal = keepLocal;
        this.settings = new Map(settingDefs.map(def => {
            const initTopic = `usersetting_init_${def.name}`;
            const syncTopic = `usersetting_sync_${def.name}`;
            const entry = {
                syncTopic,
                syncTime: 0,
                initUid: Math.round(Math.random() * Number.MAX_SAFE_INTEGER)
            };
            entry.setting = new SyncableUserSetting(def, this.onSettingValueChanged.bind(this, entry));
            entry.initSub = this.syncSubscriber.on(initTopic).handle(data => {
                // Do not respond to our own initialization sync.
                if (data.uid === entry.initUid) {
                    return;
                }
                // If we receive an initialization sync event for a setting, that means a manager on another instrument tried
                // to initialize the same setting to its default value. However, since the setting already exists here, we will
                // send a response to override the initialized value with the existing value.
                this.syncPublisher.pub(entry.syncTopic, { value: entry.setting.value, syncTime: entry.syncTime, initUid: data.uid }, !this.keepLocal, true);
            }, true);
            // Because sync events are cached, the initial subscriptions to the sync topic below will grab the synced value
            // of the new setting if it exists on the local instrument (e.g. if the value was synced from another instrument
            // after the local instrument was created but before this manager and local setting were created).
            this.syncSubscriber.on(syncTopic).handle(this.onSettingValueSynced.bind(this, entry));
            if (entry.syncTime === 0) {
                // If the new setting has no synced value on the local instrument, we will try to grab an initialization value
                // instead. If one exists, we will use it, but keep the local sync time at 0. If there is a pending response
                // to this initialization value, we want to be ready to accept the response when it arrives, which we can't do
                // if the local sync time is non-zero).
                const sub = this.syncSubscriber.on(initTopic).handle(data => {
                    this.onSettingValueSynced(entry, { value: data.value, syncTime: 0 });
                });
                sub.destroy();
            }
            if (entry.syncTime === 0) {
                // An existing synced value does not exist for the new setting on the local instrument, so we will go ahead
                // and initialize the new setting value to its default and send an initialization sync event. If the setting
                // exists on other instruments, their managers will send an initialization response to override our initialized
                // value.
                this.syncPublisher.pub(initTopic, { value: entry.setting.value, syncTime: Date.now(), uid: entry.initUid }, !this.keepLocal, true);
                this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
            }
            entry.initSub.resume();
            return [def.name, entry];
        }));
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        return (_a = this.settings.get(name)) === null || _a === void 0 ? void 0 : _a.setting;
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.settings.values(), entry => entry.setting);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.settings.get(name);
        if (!setting) {
            throw new Error(`DefaultUserSettingManager: Could not find setting with name ${name}`);
        }
        return this.subscriber.on(name).whenChanged();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
    /**
     * A callback which is called when one of this manager's settings has its value changed locally.
     * @param entry The entry for the setting that was changed.
     * @param value The new value of the setting.
     */
    onSettingValueChanged(entry, value) {
        entry.syncTime = Date.now();
        this.syncPublisher.pub(entry.syncTopic, { value, syncTime: entry.syncTime }, !this.keepLocal, true);
    }
    /**
     * A callback which is called when a setting changed event is received over the event bus.
     * @param entry The entry for the setting that was changed.
     * @param data The sync data.
     */
    onSettingValueSynced(entry, data) {
        // If the sync event is an initialization response, ignore it if the local setting value has already been synced.
        // Otherwise, protect against race conditions by not responding to sync events older than the last time this
        // manager synced the setting.
        if ((data.initUid !== undefined && entry.syncTime !== 0)
            || (data.initUid === undefined && data.syncTime < entry.syncTime)) {
            return;
        }
        this.syncSettingFromEvent(entry, data);
    }
    /**
     * Syncs a setting using data received from a sync event.
     * @param entry The entry for the setting to sync.
     * @param data The sync event data.
     */
    syncSettingFromEvent(entry, data) {
        entry.syncTime = data.syncTime;
        entry.setting.syncValue(data.value);
        // Publish the public setting change event. Do NOT sync across the bus because doing so can result in older events
        // being received after newer events.
        this.publisher.pub(entry.setting.definition.name, entry.setting.value, false, true);
    }
}
/**
 * A manager for user settings. Provides settings using their names as keys, publishes value change events on the
 * event bus, and keeps setting values up to date when receiving change events across the bus, using a mapping from
 * abstracted settings keys to true underlying settings keys.
 */
class MappedUserSettingManager {
    /**
     * Creates an instance of a MappedUserSettingManager.
     * @param parent The parent setting manager.
     * @param map The map of abstracted keys to true underlying keys.
     */
    constructor(parent, map) {
        this.parent = parent;
        this.map = map;
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.tryGetSetting(mappedName);
    }
    /** @inheritdoc */
    getSetting(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.getSetting(mappedName);
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        var _a;
        const mappedName = ((_a = this.map[name]) !== null && _a !== void 0 ? _a : name);
        return this.parent.whenSettingChanged(mappedName);
    }
    /** @inheritdoc */
    getAllSettings() {
        return this.parent.getAllSettings();
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * An implementation of a user setting which can be synced across multiple instances.
 */
class SyncableUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     * @param valueChangedCallback A function to be called whenever the value of this setting changes.
     */
    constructor(definition, valueChangedCallback) {
        super();
        this.definition = definition;
        this.valueChangedCallback = valueChangedCallback;
        this.isMutableSubscribable = true;
        this._value = definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        return this._value;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        if (this._value === v) {
            return;
        }
        this._value = v;
        this.valueChangedCallback(v);
        this.notify();
    }
    /**
     * Syncs this setting to a value. This will not trigger a call to valueChangedCallback.
     * @param value The value to which to sync.
     */
    syncValue(value) {
        if (this._value === value) {
            return;
        }
        this._value = value;
        this.notify();
    }
    /** @inheritdoc */
    get() {
        return this._value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * An aliased user setting manager which can dynamically (re)define the settings from which its aliased settings are
 * sourced.
 */
class AliasedUserSettingManager {
    /**
     * Constructor.
     * @param bus The bus used by this manager to publish setting change events.
     * @param settingDefs The setting definitions used to initialize this manager's settings. The definitions should
     * define the settings' aliased names.
     */
    constructor(bus, settingDefs) {
        this.bus = bus;
        this.aliasedSettings = new Map(settingDefs.map(def => [def.name, new AliasedUserSetting(def)]));
    }
    /**
     * Defines the mappings from this manager's aliased settings to their source settings. Once the mappings are defined,
     * each aliased setting will take the value of its source setting, and setting the value of the aliased setting will
     * also set the value of the source setting. If a source setting cannot be defined for an aliased setting, the
     * aliased setting's value will be fixed to its default value and cannot be changed.
     * @param masterManager The manager hosting the settings from which this manager's aliased settings will be sourced.
     * @param map The mappings for this manager's aliased settings, as a set of key-value pairs where the keys are the
     * aliased setting names and the values are the source setting names. For any aliased setting whose name does not
     * appear as a key in the mapping, its source setting is assumed to have the same name.
     */
    useAliases(masterManager, map) {
        this.manager = masterManager.mapTo(map);
        for (const aliasedSetting of this.aliasedSettings.values()) {
            aliasedSetting.useSource(this.manager.tryGetSetting(aliasedSetting.definition.name));
        }
    }
    /** @inheritdoc */
    tryGetSetting(name) {
        return this.aliasedSettings.get(name);
    }
    /** @inheritdoc */
    getSetting(name) {
        const setting = this.tryGetSetting(name);
        if (setting === undefined) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return setting;
    }
    /** @inheritdoc */
    whenSettingChanged(name) {
        const setting = this.aliasedSettings.get(name);
        if (!setting) {
            throw new Error(`AliasedUserSettingManager: Could not find setting with name ${name}`);
        }
        return new BasicConsumer((handler, paused) => {
            return setting.sub(handler, true, paused);
        }).whenChanged();
    }
    /** @inheritdoc */
    getAllSettings() {
        return Array.from(this.aliasedSettings.values());
    }
    /** @inheritdoc */
    mapTo(map) {
        return new MappedUserSettingManager(this, map);
    }
}
/**
 * A user setting with a value which is sourced from another setting. While the setting has no source, its value is
 * fixed to its default value and cannot be changed.
 */
class AliasedUserSetting extends AbstractSubscribable {
    /**
     * Constructor.
     * @param definition This setting's definition.
     */
    constructor(definition) {
        super();
        this.definition = definition;
        this.isMutableSubscribable = true;
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** This setting's current value. */
    get value() {
        var _a, _b;
        return (_b = (_a = this.setting) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : this.definition.defaultValue;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set value(v) {
        this.setting && (this.setting.value = v);
    }
    /**
     * Sets this setting's source.
     * @param setting The user setting to use as the new source, or `undefined` to leave this setting without a source.
     */
    useSource(setting) {
        var _a;
        const oldValue = this.value;
        (_a = this.settingSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.setting = setting;
        if (setting !== undefined) {
            this.settingSub = setting.sub(() => { this.notify(); });
        }
        else {
            this.settingSub = undefined;
        }
        if (oldValue !== this.value) {
            this.notify();
        }
    }
    /** @inheritdoc */
    get() {
        return this.value;
    }
    /**
     * Sets the value of this setting.
     * @param value The new value.
     */
    set(value) {
        this.value = value;
    }
    /** @inheritdoc */
    resetToDefault() {
        this.set(this.definition.defaultValue);
    }
}

/**
 * The state of an avionics system.
 */
var AvionicsSystemState;
(function (AvionicsSystemState) {
    AvionicsSystemState["Off"] = "Off";
    AvionicsSystemState["Initializing"] = "Initializing";
    AvionicsSystemState["On"] = "On";
    AvionicsSystemState["Failed"] = "Failed";
})(AvionicsSystemState || (AvionicsSystemState = {}));

/**
 * A basic avionics system with a fixed initialization time and logic.
 */
class BasicAvionicsSystem {
    /**
     * Creates an instance of a BasicAvionicsSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param stateEvent The key of the state update event to send on state update.
     */
    constructor(index, bus, stateEvent) {
        this.index = index;
        this.bus = bus;
        this.stateEvent = stateEvent;
        /** The time it takes in milliseconds for the system to initialize. */
        this.initializationTime = 0;
        /** A timeout after which initialization will be complete. */
        this.initializationTimer = new DebounceTimer();
        this.publisher = this.bus.getPublisher();
        /** Whether power data consumed by this system is valid. */
        this.isPowerValid = false;
        this.bus.pub(this.stateEvent, { previous: undefined, current: undefined });
        // When not starting cold and dark (on runway or in air), electrical power simvars are not properly initialized
        // during loading, so we will ignore all power data until the game enters briefing state.
        const gameStateSub = GameStateProvider.get().sub(state => {
            var _a;
            if (state === GameState.briefing || state === GameState.ingame) {
                gameStateSub.destroy();
                this.isPowerValid = true;
                (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.resume(true);
            }
        }, false, true);
        gameStateSub.resume(true);
    }
    /** @inheritdoc */
    get state() {
        return this._state;
    }
    /**
     * Connects this system's power state to an {@link ElectricalEvents} topic, electricity logic element, or
     * {@link Subscribable}.
     * @param source The source to which to connect this system's power state.
     */
    connectToPower(source) {
        var _a;
        (_a = this.electricalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        this.electricalPowerSub = undefined;
        this.electricalPowerLogic = undefined;
        if (typeof source === 'string') {
            this.electricalPowerSub = this.bus.getSubscriber()
                .on(source)
                .whenChanged()
                .handle(this.onPowerChanged.bind(this), !this.isPowerValid);
        }
        else if (SubscribableUtils.isSubscribable(source)) {
            this.electricalPowerSub = source.sub(this.onPowerChanged.bind(this), true, !this.isPowerValid);
        }
        else {
            this.electricalPowerLogic = source;
            this.updatePowerFromLogic();
        }
    }
    /**
     * Sets the state of the avionics system and publishes the change.
     * @param state The new state to change to.
     */
    setState(state) {
        if (this._state !== state) {
            const previous = this._state;
            this._state = state;
            this.onStateChanged(previous, state);
            this.bus.pub(this.stateEvent, { previous, current: state });
        }
    }
    /**
     * Responds to changes in this system's state.
     * @param previousState The previous state.
     * @param currentState The current state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        // noop
    }
    /**
     * A callback called when the connected power state of the avionics system changes.
     * @param isPowered Whether or not the system is powered.
     */
    onPowerChanged(isPowered) {
        const wasPowered = this.isPowered;
        this.isPowered = isPowered;
        if (wasPowered === undefined) {
            this.initializationTimer.clear();
            if (isPowered) {
                this.setState(AvionicsSystemState.On);
            }
            else {
                this.setState(AvionicsSystemState.Off);
            }
        }
        else {
            if (isPowered) {
                this.setState(AvionicsSystemState.Initializing);
                this.initializationTimer.schedule(() => this.setState(AvionicsSystemState.On), this.initializationTime);
            }
            else {
                this.initializationTimer.clear();
                this.setState(AvionicsSystemState.Off);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        this.updatePowerFromLogic();
    }
    /**
     * Updates this system's power state from an electricity logic element.
     */
    updatePowerFromLogic() {
        if (!this.isPowerValid || this.electricalPowerLogic === undefined) {
            return;
        }
        const isPowered = this.electricalPowerLogic.getValue() !== 0;
        if (isPowered !== this.isPowered) {
            this.onPowerChanged(isPowered);
        }
    }
}

/**
 * A class that wraps the actual instrumenet implementation and handles the sim's vcockpit lifecycle.
 */
class FsBaseInstrument extends BaseInstrument {
    /**
     * A callback called when the element is attached to the DOM.
     */
    connectedCallback() {
        super.connectedCallback();
        this.fsInstrument = this.constructInstrument();
    }
    /**
     * Update method called by BaseInstrument
     */
    Update() {
        super.Update();
        if (this.fsInstrument) {
            this.fsInstrument.Update();
        }
    }
    /** @inheritdoc */
    onInteractionEvent(_args) {
        if (this.fsInstrument) {
            this.fsInstrument.onInteractionEvent(_args);
        }
    }
    /** @inheritdoc */
    onGameStateChanged(oldState, newState) {
        super.onGameStateChanged(oldState, newState);
        if (this.fsInstrument) {
            this.fsInstrument.onGameStateChanged(oldState, newState);
        }
    }
    /** @inheritdoc */
    onFlightStart() {
        super.onFlightStart();
        if (this.fsInstrument) {
            this.fsInstrument.onFlightStart();
        }
    }
    /** @inheritdoc */
    onSoundEnd(soundEventId) {
        super.onSoundEnd(soundEventId);
        if (this.fsInstrument) {
            this.fsInstrument.onSoundEnd(soundEventId);
        }
    }
    /**
     * Whether or not the instrument is interactive (a touchscreen instrument).
     * @returns True
     */
    get isInteractive() {
        return false;
    }
}

/**
 * A configuration object which defines options related to various aircraft sensors.
 */
class SensorsConfig {
    /**
     * Creates a new SensorsConfig from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     */
    constructor(baseInstrument, element) {
        if (element === undefined) {
            this.adcCount = 1;
            this.ahrsCount = 1;
            this.radarAltimeterCount = 1;
            this.gpsCount = 1;
            this.adcDefinitions = [undefined, { altimeterIndex: 1, airspeedIndicatorIndex: 1 }];
            this.ahrsDefinitions = [undefined, { attitudeIndicatorIndex: 1, directionIndicatorIndex: 1 }];
            this.radarAltimeterDefinitions = [undefined, {}];
            this.gpsDefinitions = [undefined, {}];
        }
        else {
            if (element.tagName !== 'Sensors') {
                throw new Error(`Invalid SensorsConfig definition: expected tag name 'Sensors' but was '${element.tagName}'`);
            }
            const adcCount = Number(element.getAttribute('adc-count'));
            if (!Number.isInteger(adcCount) || adcCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC count (must be a positive integer)');
                this.adcCount = 1;
            }
            else {
                this.adcCount = adcCount;
            }
            const ahrsCount = Number(element.getAttribute('ahrs-count'));
            if (!Number.isInteger(ahrsCount) || ahrsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS count (must be a positive integer)');
                this.ahrsCount = 1;
            }
            else {
                this.ahrsCount = ahrsCount;
            }
            const radarAltimeterCount = Number(element.getAttribute('radar-altimeter-count'));
            if (!Number.isInteger(radarAltimeterCount) || radarAltimeterCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized RA count (must be a positive integer)');
                this.radarAltimeterCount = 1;
            }
            else {
                this.radarAltimeterCount = radarAltimeterCount;
            }
            const gpsCount = Number(element.getAttribute('gps-count'));
            if (!Number.isInteger(gpsCount) || gpsCount < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS count (must be a positive integer)');
                this.gpsCount = 1;
            }
            else {
                this.gpsCount = gpsCount;
            }
            this.adcDefinitions = this.parseAdcDefinitions(baseInstrument, element);
            this.ahrsDefinitions = this.parseAhrsDefinitions(baseInstrument, element);
            this.radarAltimeterDefinitions = this.parseRadarAltimeterDefinitions(baseInstrument, element);
            this.gpsDefinitions = this.parseGpsDefinitions(baseInstrument, element);
        }
    }
    // eslint-disable-next-line jsdoc/require-returns
    /** Whether this configuration defines a radar altimeter. */
    get hasRadarAltimeter() {
        return this.radarAltimeterDefinitions.length > 1;
    }
    /**
     * Parses ADC definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of ADC definitions defined by the configuration document element.
     */
    parseAdcDefinitions(baseInstrument, element) {
        const adcElements = element.querySelectorAll(':scope>Adc');
        const defs = [];
        for (const adcElement of adcElements) {
            const index = Number(adcElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.adcCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized ADC index (must be an integer between 1 and the number of supported ADCs)');
                continue;
            }
            const altimeterIndex = Number(adcElement.getAttribute('altimeter'));
            if (!Number.isInteger(altimeterIndex) || altimeterIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized altimeter index (must be a positive integer)');
                continue;
            }
            const airspeedIndicatorIndex = Number(adcElement.getAttribute('airspeed-indicator'));
            if (!Number.isInteger(airspeedIndicatorIndex) || airspeedIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized airspeed indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = adcElement.querySelector(':scope>Electric');
            defs[index] = {
                altimeterIndex,
                airspeedIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    altimeterIndex: i,
                    airspeedIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses AHRS definitions from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of AHRS definitions defined by the configuration document element.
     */
    parseAhrsDefinitions(baseInstrument, element) {
        const ahrsElements = element.querySelectorAll(':scope>Ahrs');
        const defs = [];
        for (const ahrsElement of ahrsElements) {
            const index = Number(ahrsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.ahrsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const attitudeIndicatorIndex = Number(ahrsElement.getAttribute('attitude-indicator'));
            if (!Number.isInteger(attitudeIndicatorIndex) || attitudeIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized attitude indicator index (must be a positive integer)');
                continue;
            }
            const directionIndicatorIndex = Number(ahrsElement.getAttribute('direction-indicator'));
            if (!Number.isInteger(directionIndicatorIndex) || directionIndicatorIndex < 1) {
                console.warn('Invalid SensorsConfig definition: unrecognized direction indicator index (must be a positive integer)');
                continue;
            }
            const electricLogicElement = ahrsElement.querySelector(':scope>Electric');
            defs[index] = {
                attitudeIndicatorIndex,
                directionIndicatorIndex,
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.adcCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {
                    attitudeIndicatorIndex: i,
                    directionIndicatorIndex: i,
                };
            }
        }
        return defs;
    }
    /**
     * Parses a radar altimeter definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of RA definitions defined by the configuration document element.
     */
    parseRadarAltimeterDefinitions(baseInstrument, element) {
        const radarAltimeterElements = element.querySelectorAll(':scope>RadarAltimeter');
        const defs = [];
        for (const radarAltimeterElement of radarAltimeterElements) {
            const index = Number(radarAltimeterElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.radarAltimeterCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized AHRS index (must be an integer between 1 and the number of supported AHRS)');
                continue;
            }
            const electricLogicElement = radarAltimeterElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.radarAltimeterCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
    /**
     * Parses a GPS receiver definition from configuration document elements.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns An array of GPS definitions defined by the configuration document element.
     */
    parseGpsDefinitions(baseInstrument, element) {
        const gpsElements = element.querySelectorAll(':scope>Gps');
        const defs = [];
        for (const gpsElement of gpsElements) {
            const index = Number(gpsElement.getAttribute('index'));
            if (!Number.isInteger(index) || index < 1 || index > this.gpsCount) {
                console.warn('Invalid SensorsConfig definition: unrecognized GPS index (must be an integer between 1 and the number of supported GPS)');
                continue;
            }
            const electricLogicElement = gpsElement.querySelector(':scope>Electric');
            defs[index] = {
                electricity: electricLogicElement === null ? undefined : new CompositeLogicXMLElement(baseInstrument, electricLogicElement),
            };
        }
        // Set defaults for indexes that don't have definitions
        for (let i = 1; i <= this.gpsCount; i++) {
            if (defs[i] === undefined) {
                defs[i] = {};
            }
        }
        return defs;
    }
}

/**
 * A configuration object which defines options for G3000/5000 avionics systems.
 */
class AvionicsConfig {
    /**
     * Creates an AvionicsConfig from an XML configuration document.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param xmlConfig An XML configuration document.
     */
    constructor(baseInstrument, xmlConfig) {
        const root = xmlConfig.getElementsByTagName('PlaneHTMLConfig')[0];
        this.sensors = this.parseSensorsConfig(baseInstrument, root.querySelector(':scope>Sensors'));
    }
    /**
     * Parses a sensors configuration object from a configuration document element.
     * @param baseInstrument The `BaseInstrument` element associated with the configuration.
     * @param element A configuration document element.
     * @returns The sensors configuration defined by the configuration document element.
     */
    parseSensorsConfig(baseInstrument, element) {
        if (element !== null) {
            try {
                return new SensorsConfig(baseInstrument, element);
            }
            catch (e) {
                console.warn(e);
            }
        }
        return new SensorsConfig(baseInstrument, undefined);
    }
}

/** Takeoff thrust modes. */
var OptimumRequest;
(function (OptimumRequest) {
    OptimumRequest["OPTIMUM"] = "OPTIMUM";
})(OptimumRequest || (OptimumRequest = {}));
/** Takeoff thrust modes. To be used in the FMC */
var TakeoffThrustMode;
(function (TakeoffThrustMode) {
    TakeoffThrustMode["TO"] = "TO";
    TakeoffThrustMode["TO1"] = "TO 1";
    TakeoffThrustMode["TO2"] = "TO 2";
    TakeoffThrustMode["DTO"] = "D-TO";
    TakeoffThrustMode["DTO1"] = "D-TO 1";
    TakeoffThrustMode["DTO2"] = "D-TO 2";
})(TakeoffThrustMode || (TakeoffThrustMode = {}));
/** Possible takeoff thrust ratings for selection in the EFB. */
var EFBTakeoffThrustMode;
(function (EFBTakeoffThrustMode) {
    EFBTakeoffThrustMode["OPTIMUM"] = "OPTIMUM";
    EFBTakeoffThrustMode["TO"] = "TO";
    EFBTakeoffThrustMode["TO1"] = "TO 1 -10";
    EFBTakeoffThrustMode["TO2"] = "TO 2 -20";
    EFBTakeoffThrustMode["WINDSHEAR"] = "WINDSHEAR";
})(EFBTakeoffThrustMode || (EFBTakeoffThrustMode = {}));
/** Climb thrust modes. */
var ClimbThrustMode;
(function (ClimbThrustMode) {
    ClimbThrustMode["CLB"] = "CLB";
    ClimbThrustMode["CLB1"] = "CLB 1";
    ClimbThrustMode["CLB2"] = "CLB 2";
})(ClimbThrustMode || (ClimbThrustMode = {}));
/** Airborne thrust modes. */
var AirborneThrustMode;
(function (AirborneThrustMode) {
    /** Go-around thrust limit. */
    AirborneThrustMode["GA"] = "GA";
    /** Maximum continuous thrust limit. */
    AirborneThrustMode["CON"] = "CON";
    /** Cruise thrust limit. */
    AirborneThrustMode["CRZ"] = "CRZ";
})(AirborneThrustMode || (AirborneThrustMode = {}));
var GlideslopeStatus;
(function (GlideslopeStatus) {
    GlideslopeStatus[GlideslopeStatus["ON"] = 0] = "ON";
    GlideslopeStatus[GlideslopeStatus["OFF"] = 1] = "OFF";
})(GlideslopeStatus || (GlideslopeStatus = {}));
/** Speed modes. */
var SpeedMode;
(function (SpeedMode) {
    /** Economy speed. */
    SpeedMode["ECON"] = "ECON SPD";
    /** Select speed. Manually entered speed on the CDU or the VNAV speed target is the maneuvering speed for flaps zero. */
    SpeedMode["SEL"] = "SEL SPD";
    /** Long-range cruise speed. */
    SpeedMode["LRC"] = "LRC SPD";
    /** Engine-out long-range cruise speed. */
    SpeedMode["EOLRC"] = "EO LRC";
    /** Engine-out speed. */
    SpeedMode["EO"] = "EO SPD";
    /** Engine-out operations at airline specified engine out company speed. */
    SpeedMode["CO"] = "CO SPD";
    /** Speed is limited by VMO, MMO, flap limit, or buffet limit. */
    SpeedMode["LIM"] = "LIM SPD";
    /** Speed intervention entered on the MCP IAS/MACH indicator. */
    SpeedMode["MCP"] = "MCP SPD";
    /** Required time of arrival speed. */
    SpeedMode["RTA"] = "RTA";
})(SpeedMode || (SpeedMode = {}));
/** Runway conditions, the short list is for the FMC */
var RunwayCondition;
(function (RunwayCondition) {
    /** Dry */
    RunwayCondition["DRY"] = "DRY";
    /** Wet */
    RunwayCondition["WET"] = "WET";
    /** Wet, skid resistant */
    RunwayCondition["WET_SKID_RES"] = "WET SK-R";
})(RunwayCondition || (RunwayCondition = {}));
/** Runway conditions, longer list for the EFB takeoff performance calculation */
var EfbRunwayCondition;
(function (EfbRunwayCondition) {
    /** Dry */
    EfbRunwayCondition["DRY"] = "DRY";
    /** Wet */
    EfbRunwayCondition["WET"] = "WET";
    /** Standing water */
    EfbRunwayCondition["STNDNG_WTR"] = "STNDNG WTR";
    /** Slush */
    EfbRunwayCondition["SLUSH"] = "SLUSH WTR";
    /** Compact snow */
    EfbRunwayCondition["CMPCT_SNOW"] = "CMPCT SNOW";
    /** Dry snow */
    EfbRunwayCondition["DRY_SNOW"] = "DRY SNOW";
    /** Ice */
    EfbRunwayCondition["ICE"] = "Ice";
    /** Breaking action good */
    EfbRunwayCondition["GOOD"] = "GOOD";
    /** Breaking action Medium */
    EfbRunwayCondition["MEDIUM"] = "MEDIUM";
    /** Breaking action Poor */
    EfbRunwayCondition["POOR"] = "POOR";
})(EfbRunwayCondition || (EfbRunwayCondition = {}));
var EFBAntiIceSetting;
(function (EFBAntiIceSetting) {
    /** OFF */
    EFBAntiIceSetting["OFF"] = "OFF";
    /** ENGINE */
    EFBAntiIceSetting["ENGINE"] = "ENGINE";
    /** ENG AUTO */
    EFBAntiIceSetting["ENGINE_AUTO"] = "ENG AUTO";
})(EFBAntiIceSetting || (EFBAntiIceSetting = {}));

/**
 * Types of vertical flight path vectors.
 */
var VerticalFlightPathVectorType;
(function (VerticalFlightPathVectorType) {
    VerticalFlightPathVectorType["Climb"] = "Climb";
    VerticalFlightPathVectorType["ClimbLevel"] = "ClimbLevel";
    VerticalFlightPathVectorType["ClimbAcceleration"] = "ClimbAcceleration";
    VerticalFlightPathVectorType["ClimbLevelAcceleration"] = "ClimbLevelAcceleration";
    VerticalFlightPathVectorType["Cruise"] = "Cruise";
    VerticalFlightPathVectorType["CruiseAcceleration"] = "CruiseAcceleration";
    VerticalFlightPathVectorType["CruiseDeceleration"] = "CruiseDeceleration";
    VerticalFlightPathVectorType["LevelDeceleration"] = "LevelDeceleration";
    VerticalFlightPathVectorType["IdleDescent"] = "IdleDescent";
    VerticalFlightPathVectorType["IdleDescentDeceleration"] = "IdleDescentDeceleration";
    VerticalFlightPathVectorType["GeometricDescent"] = "GeometricDescent";
    VerticalFlightPathVectorType["GeometricDescentDeceleration"] = "GeometricDescentDeceleration";
})(VerticalFlightPathVectorType || (VerticalFlightPathVectorType = {}));
/**
 * Sources from which a flight path vector's target speed is derived.
 */
var VerticalFlightPathVectorSpeedSource;
(function (VerticalFlightPathVectorSpeedSource) {
    VerticalFlightPathVectorSpeedSource["None"] = "None";
    VerticalFlightPathVectorSpeedSource["Schedule"] = "Schedule";
    VerticalFlightPathVectorSpeedSource["FlightPlan"] = "FlightPlan";
    VerticalFlightPathVectorSpeedSource["Transition"] = "Transition";
    VerticalFlightPathVectorSpeedSource["Restriction"] = "Restriction";
})(VerticalFlightPathVectorSpeedSource || (VerticalFlightPathVectorSpeedSource = {}));
/**
 * The current VNAV altitude capture type.
 */
var BoeingVNavAltCaptureType;
(function (BoeingVNavAltCaptureType) {
    /** Altitude capture is not armed. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["None"] = 0] = "None";
    /** Altitude will capture the selected altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Selected"] = 1] = "Selected";
    /** Altitude will capture the VANV target altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["VNAV"] = 2] = "VNAV";
    /** Altitude will capture the cruise altitude. */
    BoeingVNavAltCaptureType[BoeingVNavAltCaptureType["Cruise"] = 3] = "Cruise";
})(BoeingVNavAltCaptureType || (BoeingVNavAltCaptureType = {}));
/**
 * Boeing VNAV tracking phases.
 */
var BoeingVNavTrackingPhase;
(function (BoeingVNavTrackingPhase) {
    BoeingVNavTrackingPhase["None"] = "None";
    BoeingVNavTrackingPhase["Climb"] = "Climb";
    BoeingVNavTrackingPhase["Cruise"] = "Cruise";
    BoeingVNavTrackingPhase["Descent"] = "Descent";
    BoeingVNavTrackingPhase["MissedApproach"] = "MissedApproach";
})(BoeingVNavTrackingPhase || (BoeingVNavTrackingPhase = {}));
/** This enum begins at 100 so that it can be used in combination with APVerticalModes in BoeingFmaData for display on the FMA. */
var BoeingVNavModes;
(function (BoeingVNavModes) {
    BoeingVNavModes[BoeingVNavModes["NONE"] = 100] = "NONE";
    BoeingVNavModes[BoeingVNavModes["ARMED"] = 101] = "ARMED";
    BoeingVNavModes[BoeingVNavModes["SPD_CLIMB"] = 102] = "SPD_CLIMB";
    BoeingVNavModes[BoeingVNavModes["SPD_DESCENT"] = 103] = "SPD_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_DESCENT"] = 104] = "PATH_DESCENT";
    BoeingVNavModes[BoeingVNavModes["PATH_IDLE"] = 105] = "PATH_IDLE";
    BoeingVNavModes[BoeingVNavModes["PATH_LEVEL"] = 106] = "PATH_LEVEL";
    BoeingVNavModes[BoeingVNavModes["ALT"] = 107] = "ALT";
    BoeingVNavModes[BoeingVNavModes["THR_DESCENT"] = 108] = "THR_DESCENT";
})(BoeingVNavModes || (BoeingVNavModes = {}));
/** Path Deviation Mode for the Boeing Vnav Manager. */
var PathDeviationMode;
(function (PathDeviationMode) {
    PathDeviationMode[PathDeviationMode["NONE"] = 0] = "NONE";
    PathDeviationMode[PathDeviationMode["BELOW"] = 1] = "BELOW";
    PathDeviationMode[PathDeviationMode["ABOVE"] = 2] = "ABOVE";
})(PathDeviationMode || (PathDeviationMode = {}));
var BoeingVnavDescentPendingType;
(function (BoeingVnavDescentPendingType) {
    BoeingVnavDescentPendingType["DesDir"] = "des-dir";
    BoeingVnavDescentPendingType["DesNow"] = "des-now";
})(BoeingVnavDescentPendingType || (BoeingVnavDescentPendingType = {}));

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * A manager and calculator for vertical flight plans for Boeing avionics systems.
 */
class BoeingPathCalculator extends SmoothingPathCalculator {
    /**
     * Creates an instance of BoeingPathCalculator.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary flight plan index to use to calculate a path from.
     * @param perfProvider A provider of airplane performance data.
     * @param engineDataProvider A provider of airplane engine data.
     * @param perfPlanRepository The performance plan repository.
     * @param windPlanner The wind planner.
     * @param options Options for the calculator.
     */
    constructor(bus, flightPlanner, primaryPlanIndex, perfProvider, engineDataProvider, perfPlanRepository, windPlanner, options) {
        var _a, _b, _c;
        super(bus, flightPlanner, primaryPlanIndex, options);
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.perfPlanRepository = perfPlanRepository;
        this.windPlanner = windPlanner;
        this.speedConstraintLists = [];
        this.verticalFlightPathEntries = [];
        this.perfPlanSubscriptions = [];
        this.accelerationResult = Vec2Math.create();
        this.enablePathCalc = (_a = options === null || options === void 0 ? void 0 : options.enablePathCalc) !== null && _a !== void 0 ? _a : false;
        this.engineCount = Math.max((_b = options === null || options === void 0 ? void 0 : options.engineCount) !== null && _b !== void 0 ? _b : 2, 1);
        this.performanceDescentIdleN1Offset = Math.max((_c = options === null || options === void 0 ? void 0 : options.performanceDescentIdleN1Offset) !== null && _c !== void 0 ? _c : 10, 0);
        if (this.enablePathCalc) {
            const sub = bus.getSubscriber();
            // TODO: Maybe support ADC system?
            this.indicatedAltitude = ConsumerValue.create(sub.on('indicated_alt'), 0);
            this.lnavIsAwaitingCalc = ConsumerSubject.create(sub.on('lnav_is_awaiting_calc'), false);
            this.lnavTrackedLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
            this.lnavLegDistanceRemaining = ConsumerValue.create(sub.on('lnav_leg_distance_remaining'), 0);
            this.fob = ConsumerValue.create(sub.on('fuel_usable_total_weight'), 0);
            // TODO: This is a massive hack that relies on LNAV's awaiting calculate logic as well as the fact that the only
            // way the active plan can change in the Boeings is through a plan copy. This needs to be replaced with a more
            // robust solution at some point and **UNDER NO CIRCUMSTANCES SHOULD IT BE REPLICATED ELSEWHERE**.
            const primaryPlanActiveLegIndex = Subject.create(0);
            sub.on('fplActiveLegChange').handle(event => {
                if (event.type === ActiveLegType.Lateral && event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(event.index);
                }
            });
            sub.on('fplCopied').handle(event => {
                if (event.targetPlanIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            sub.on('fplLoaded').handle(event => {
                if (event.planIndex === this.primaryPlanIndex) {
                    primaryPlanActiveLegIndex.set(this.flightPlanner.getFlightPlan(this.primaryPlanIndex).activeLateralLeg);
                }
            });
            this.canUpdatePrimaryPlan = MappedSubject.create(([isAwaitingCalc, trackedLegIndex, planActiveLegIndex]) => !isAwaitingCalc && trackedLegIndex === planActiveLegIndex, this.lnavIsAwaitingCalc, this.lnavTrackedLegIndex, primaryPlanActiveLegIndex);
            // We need to update pending vertical plans on an update loop in order to guarantee that we don't perform the
            // update using an intermediate state from LNAV (specifically when the tracked leg index has been updated before
            // the remaining leg distance).
            sub.on('realTime').handle(this.update.bind(this));
        }
    }
    /** @inheritdoc */
    createVerticalPlan(planIndex) {
        const verticalFlightPlan = {
            planIndex,
            length: 0,
            constraints: [],
            segments: [],
            destLegIndex: undefined,
            fafLegIndex: undefined,
            firstDescentConstraintLegIndex: undefined,
            lastDescentConstraintLegIndex: undefined,
            missedApproachStartIndex: undefined,
            currentAlongLegDistance: undefined,
            verticalDirectIndex: undefined,
            verticalDirectFpa: undefined,
            planChanged: true
        };
        this.verticalFlightPlans[planIndex] = verticalFlightPlan;
        return verticalFlightPlan;
    }
    /**
     * Gets the speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The speed constraint list for the specified flight plan.
     */
    getSpeedConstraintList(planIndex) {
        var _a;
        return (_a = this.speedConstraintLists[planIndex]) !== null && _a !== void 0 ? _a : this.createSpeedConstraintList(planIndex);
    }
    /**
     * Gets the calculated vertical flight path for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The calculated vertical flight path for the specified flight plan.
     */
    getVerticalFlightPath(planIndex) {
        return this.getVerticalFlightPathEntry(planIndex).path;
    }
    /**
     * Gets the vertical flight path entry for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The vertical flight path entry for the specified flight plan.
     */
    getVerticalFlightPathEntry(planIndex) {
        var _a;
        return (_a = this.verticalFlightPathEntries[planIndex]) !== null && _a !== void 0 ? _a : this.createVerticalFlightPathEntry(planIndex);
    }
    /**
     * Gets the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The speed constraint in effect for the specified flight plan leg and vertical flight phase, or
     * `undefined` if there is no speed constraint in effect.
     */
    getCurrentSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        return speedConstraints[this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach)];
    }
    /**
     * Gets the next speed constraint to take effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The next speed constraint to take effect for the specified flight plan leg and vertical flight phase,
     * or `undefined` if there is no speed constraint in effect.
     */
    getNextSpeedConstraint(planIndex, globalLegIndex, flightPhase, isMissedApproach) {
        const speedConstraints = this.getSpeedConstraintList(planIndex);
        const currentIndex = this.getCurrentSpeedConstraintIndex(planIndex, speedConstraints, globalLegIndex, flightPhase, isMissedApproach);
        if (currentIndex < 0) {
            if (flightPhase === VerticalFlightPhase.Climb) {
                // If there is no current constraint in effect during climb, there can be no next climb constraint because
                // either we have sequenced all climb constraints or there is at least one non-climb constraint to sequence
                // before the next climb constraint.
                return undefined;
            }
            else {
                // If there is no current constraint in effect during descent, it is still possible that the next upcoming
                // constraint to be sequenced is the next descent constraint. This constraint, if it exists, is located at the
                // index where the current constraint would be located if it existed, so we need to check if the constraint at
                // that index is a descent constraint and has yet to be sequenced.
                const constraint = speedConstraints[-currentIndex - 1];
                if (constraint !== undefined && flightPhase === constraint.flightPhase && constraint.globalLegIndex >= globalLegIndex) {
                    return constraint;
                }
                else {
                    return undefined;
                }
            }
        }
        const isMapr = speedConstraints[currentIndex].isMissedApproach;
        const constraint = speedConstraints[currentIndex + 1];
        if (constraint !== undefined && flightPhase === constraint.flightPhase && isMapr === constraint.isMissedApproach) {
            return constraint;
        }
        return undefined;
    }
    /**
     * Gets the index of the speed constraint in effect for a given flight plan leg and vertical flight phase.
     * @param planIndex The index of the flight plan.
     * @param speedConstraintList The speed constraint list for the flight plan.
     * @param globalLegIndex The global index of the flight plan leg for which to get the speed constraint in effect.
     * @param flightPhase The vertical flight phase for which to get the speed constraint in effect.
     * @param isMissedApproach Whether the missed approach phase is active. If not defined, then the missed approach
     * phase is considered active if and only if the specified flight plan leg is in the missed approach.
     * @returns The index of the speed constraint in effect for the specified flight plan leg and vertical flight phase.
     * If there is no speed constraint in effect, `-(i + 1)` is returned instead, where `i` is the index at which the
     * constraint would be located if it existed.
     */
    getCurrentSpeedConstraintIndex(planIndex, speedConstraintList, globalLegIndex, flightPhase, isMissedApproach) {
        var _a, _b;
        if (flightPhase === VerticalFlightPhase.Climb) {
            const inMissedApproach = isMissedApproach !== null && isMissedApproach !== void 0 ? isMissedApproach : (this.flightPlanner.hasFlightPlan(planIndex)
                && BitFlags.isAll((_b = (_a = this.flightPlanner.getFlightPlan(planIndex).tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.flags) !== null && _b !== void 0 ? _b : 0, LegDefinitionFlags.MissedApproach));
            // During climb, the next upcoming climb speed constraint to be sequenced is in effect.
            for (let i = 0; i < speedConstraintList.length; i++) {
                const constraint = speedConstraintList[i];
                // Speed constraints in the missed approach are not active until we are in the missed approach.
                if (constraint.isMissedApproach && !inMissedApproach) {
                    return -(i + 1);
                }
                if (constraint.globalLegIndex >= globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 1);
                }
            }
            return -(speedConstraintList.length + 1);
        }
        else {
            // During descent, the last sequenced descent speed constraint is in effect.
            for (let i = speedConstraintList.length - 1; i >= 0; i--) {
                const constraint = speedConstraintList[i];
                if (constraint.globalLegIndex < globalLegIndex) {
                    return flightPhase === constraint.flightPhase ? i : -(i + 2);
                }
            }
            return -1;
        }
    }
    /**
     * Creates a new, empty speed constraint list for a flight plan.
     * @param planIndex The index of the flight plan.
     * @returns The created speed constraint list.
     */
    createSpeedConstraintList(planIndex) {
        return this.speedConstraintLists[planIndex] = [];
    }
    /**
     * Creates a new vertical path entry for a flight plan. The new entry will be initialized with an empty vertical
     * path.
     * @param planIndex The index of the flight plan.
     * @returns The created vertical path entry.
     */
    createVerticalFlightPathEntry(planIndex) {
        const entry = {
            path: BoeingPathCalculator.createVerticalPath(planIndex),
            perfDescentWorkingPath: BoeingPathCalculator.createVerticalPath(planIndex),
            geoDescentCoarsePath: BoeingPathCalculator.createGeometricDescentCoarsePath(),
            needsRebuild: false
        };
        this.verticalFlightPathEntries[planIndex] = entry;
        return entry;
    }
    /** @inheritdoc */
    onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent) {
        if (!this.enablePathCalc) {
            return;
        }
        super.onPlanChanged(planIndex, legChangeEvent, segmentChangeEvent);
        const verticalPath = this.getVerticalFlightPath(planIndex);
        verticalPath.isPending = true;
    }
    /** @inheritdoc */
    onPlanCalculated(event) {
        if (!this.enablePathCalc) {
            return;
        }
        if (event.planIndex !== this.primaryPlanIndex || this.canUpdatePrimaryPlan.get()) {
            this.buildVerticalFlightPlanAndComputeAndNotify(event.planIndex);
        }
    }
    /**
     * Updates this calculator.
     */
    update() {
        if (this.canUpdatePrimaryPlan.get()
            && this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)
            && this.getVerticalFlightPath(this.primaryPlanIndex).isPending) {
            this.buildVerticalFlightPlanAndComputeAndNotify(this.primaryPlanIndex);
        }
    }
    /** @inheritdoc */
    buildVerticalFlightPlan(lateralPlan, verticalPlan) {
        super.buildVerticalFlightPlan(lateralPlan, verticalPlan);
        this.buildSpeedConstraints(lateralPlan, this.getSpeedConstraintList(verticalPlan.planIndex));
        this.buildVerticalFlightPath(lateralPlan, this.getVerticalFlightPathEntry(verticalPlan.planIndex));
    }
    /**
     * Builds a speed constraint list from a lateral flight plan.
     * @param lateralPlan The lateral flight plan.
     * @param speedConstraints The speed constraint list to build.
     */
    buildSpeedConstraints(lateralPlan, speedConstraints) {
        var _a, _b;
        let speedConstraintIndex = 0;
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(lateralPlan.planIndex);
        for (let segmentIndex = 0; segmentIndex < lateralPlan.segmentCount; segmentIndex++) {
            const segment = lateralPlan.tryGetSegment(segmentIndex);
            if (segment) {
                for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
                    const leg = segment.legs[segmentLegIndex];
                    const isDirectToLeg = BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo)
                        && lateralPlan.directToData.segmentIndex === segmentIndex
                        && lateralPlan.directToData.segmentLegIndex === segmentLegIndex - this.directToLegOffset;
                    const approachSpeed = (_a = perfPlan.approachFlapSpeed.get()) === null || _a === void 0 ? void 0 : _a[1];
                    const windCorrection = perfPlan.approachWindCorrection.get();
                    const hasAutoApproachSpeed = leg.verticalData.speedDesc === SpeedRestrictionType.Unused
                        && BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF)
                        && approachSpeed !== undefined;
                    // If the leg is a direct-to leg with an associated direct-to target leg, skip it since its constraint is
                    // duplicated from that of the target leg.
                    if ((leg.verticalData.speedDesc !== SpeedRestrictionType.Unused || hasAutoApproachSpeed) && !isDirectToLeg) {
                        const isMissedApproach = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
                        const isCursorDepartureOrMissedApproach = segment.segmentType === FlightPlanSegmentType.Departure || isMissedApproach;
                        // If the constraint leg is a direct-to target, shift the leg index to that of the direct-to leg.
                        const isDirectToTarget = lateralPlan.directToData.segmentIndex === segmentIndex
                            && lateralPlan.directToData.segmentLegIndex === segmentLegIndex;
                        const constraint = (_b = speedConstraints[speedConstraintIndex]) !== null && _b !== void 0 ? _b : (speedConstraints[speedConstraintIndex] = BoeingPathCalculator.createSpeedConstraintListItem());
                        constraint.globalLegIndex = segment.offset + segmentLegIndex + (isDirectToTarget ? this.directToLegOffset : 0);
                        constraint.flightPhase = isCursorDepartureOrMissedApproach ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent;
                        constraint.speedConstraint.speedDesc = hasAutoApproachSpeed ? SpeedRestrictionType.At : leg.verticalData.speedDesc;
                        constraint.speedConstraint.speed = hasAutoApproachSpeed ? (approachSpeed + windCorrection) : leg.verticalData.speed;
                        constraint.speedConstraint.speedUnit = hasAutoApproachSpeed ? SpeedUnit.IAS : leg.verticalData.speedUnit;
                        constraint.isMissedApproach = hasAutoApproachSpeed ? false : isMissedApproach;
                        let useMin = false;
                        let useMax = false;
                        switch (constraint.speedConstraint.speedDesc) {
                            case SpeedRestrictionType.At:
                            case SpeedRestrictionType.Between:
                                useMin = true;
                                useMax = true;
                                break;
                            case SpeedRestrictionType.AtOrAbove:
                                useMin = true;
                                break;
                            case SpeedRestrictionType.AtOrBelow:
                                useMax = true;
                                break;
                        }
                        constraint.minCas = -Infinity;
                        constraint.maxCas = Infinity;
                        constraint.minMach = -Infinity;
                        constraint.maxMach = Infinity;
                        if (useMin) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.minMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.minCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        if (useMax) {
                            if (constraint.speedConstraint.speedUnit === SpeedUnit.MACH) {
                                constraint.maxMach = constraint.speedConstraint.speed;
                            }
                            else {
                                constraint.maxCas = UnitType.KNOT.convertTo(constraint.speedConstraint.speed, UnitType.MPS);
                            }
                        }
                        speedConstraintIndex++;
                    }
                }
            }
        }
        speedConstraints.length = speedConstraintIndex;
    }
    /**
     * Builds an empty vertical flight path from a lateral flight plan. After the path is built, it will contain one
     * leg (containing zero vectors) for each leg in the lateral flight plan, and all TOC/TOD data will be undefined.
     * @param lateralPlan The lateral flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to build.
     */
    buildVerticalFlightPath(lateralPlan, verticalPathEntry) {
        verticalPathEntry.needsRebuild = false;
        const verticalPath = verticalPathEntry.path;
        verticalPath.legs.length = lateralPlan.length;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            if (leg) {
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
            else {
                verticalPath.legs[i] = BoeingPathCalculator.createVerticalPathLeg();
            }
        }
        verticalPath.isPending = true;
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Initializes performance plan subscriptions for an indexed flight plan. Once these subscriptions are initialized,
     * the vertical path for the flight plan will be flagged to be rebuilt during the next flight plan calculation cycle
     * whenever certain performance plan values change. If subscriptions are already initialized for the specified flight
     * plan, then this method does nothing.
     * @param planIndex The index of the flight plan for which to initialize performance plan subscriptions.
     */
    initPerfPlanSubscriptions(planIndex) {
        if (this.perfPlanSubscriptions[planIndex]) {
            return;
        }
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(planIndex);
        const entry = this.getVerticalFlightPathEntry(planIndex);
        const handler = () => { entry.needsRebuild = true; };
        const speedHandler = (mode, activeMode) => {
            if (mode.get() === activeMode) {
                entry.needsRebuild = true;
            }
        };
        const approachSpeedHandler = () => {
            const verticalPlan = this.verticalFlightPlans[planIndex];
            verticalPlan && (verticalPlan.planChanged = true);
        };
        const climbSelSpeedHandler = speedHandler.bind(this, perfPlan.speedClimbMode, SpeedMode.SEL);
        const cruiseSelSpeedHandler = speedHandler.bind(this, perfPlan.speedCruiseMode, SpeedMode.SEL);
        const descentSelSpeedHandler = speedHandler.bind(this, perfPlan.speedDescentMode, SpeedMode.SEL);
        this.perfPlanSubscriptions[planIndex] = [
            perfPlan.speedClimbMode.sub(handler),
            perfPlan.speedClimbSelectCas.sub(climbSelSpeedHandler),
            perfPlan.speedClimbSelectMach.sub(climbSelSpeedHandler),
            perfPlan.speedCruiseMode.sub(handler),
            perfPlan.speedCruiseSelectCas.sub(cruiseSelSpeedHandler),
            perfPlan.speedCruiseSelectMach.sub(cruiseSelSpeedHandler),
            perfPlan.speedDescentMode.sub(handler),
            perfPlan.speedDescentSelectCas.sub(descentSelSpeedHandler),
            perfPlan.speedDescentSelectMach.sub(descentSelSpeedHandler),
            perfPlan.cruiseAltitude.sub(handler),
            perfPlan.climbSpeedLimitAltitude.sub(handler),
            perfPlan.climbSpeedLimitCas.sub(handler),
            perfPlan.climbSpeedRestrAltitude.sub(handler),
            perfPlan.climbSpeedRestrCas.sub(handler),
            perfPlan.descentSpeedLimitAltitude.sub(handler),
            perfPlan.descentSpeedLimitCas.sub(handler),
            perfPlan.descentSpeedRestrAltitude.sub(handler),
            perfPlan.descentSpeedRestrCas.sub(handler),
            perfPlan.approachFlapSpeed.sub(approachSpeedHandler),
            perfPlan.approachWindCorrection.sub(approachSpeedHandler)
        ];
    }
    /** @inheritdoc */
    computePath(lateralPlan, verticalPlan) {
        var _a, _b;
        const verticalPathEntry = this.getVerticalFlightPathEntry(verticalPlan.planIndex);
        this.initPerfPlanSubscriptions(verticalPlan.planIndex);
        if (verticalPathEntry.needsRebuild) {
            this.buildVerticalFlightPath(lateralPlan, verticalPathEntry);
        }
        const verticalPath = verticalPathEntry.path;
        verticalPath.isPending = false;
        if (verticalPlan.constraints.length < 1) {
            return;
        }
        const activeLegIndex = this.lnavTrackedLegIndex.get();
        const activeDistanceToLegEnd = Math.max(0, UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER));
        // TODO: Support engine-out ops.
        const engineCount = this.engineCount;
        // Compute FPAs for geometric descent segment.
        this.computeDescentPath(lateralPlan, verticalPlan);
        const perfPlan = this.perfPlanRepository.forFlightPlanIndex(verticalPlan.planIndex);
        const climbSpeedMode = perfPlan.speedClimbMode.get();
        const cruiseSpeedMode = perfPlan.speedCruiseMode.get();
        const descentSpeedMode = perfPlan.speedDescentMode.get();
        let cruiseAltitude = perfPlan.cruiseAltitude.get();
        const zfw = perfPlan.manualZfw.get();
        let climbCas, climbMach;
        let cruiseCas, cruiseMach;
        let descentCas, descentMach;
        if (climbSpeedMode === SpeedMode.SEL) {
            climbCas = perfPlan.speedClimbSelectCas.get();
            climbMach = perfPlan.speedClimbSelectMach.get();
        }
        else {
            climbCas = perfPlan.speedClimbEconCas.get();
            climbMach = perfPlan.speedClimbEconMach.get();
        }
        if (cruiseSpeedMode === SpeedMode.SEL) {
            cruiseCas = perfPlan.speedCruiseSelectCas.get();
            cruiseMach = perfPlan.speedCruiseSelectMach.get();
        }
        else {
            cruiseCas = perfPlan.speedCruiseEconCas.get();
            cruiseMach = perfPlan.speedCruiseEconMach.get();
        }
        if (descentSpeedMode === SpeedMode.SEL) {
            descentCas = perfPlan.speedDescentSelectCas.get();
            descentMach = perfPlan.speedDescentSelectMach.get();
        }
        else {
            descentCas = perfPlan.speedDescentEconCas.get();
            descentMach = perfPlan.speedDescentEconMach.get();
        }
        if (cruiseAltitude === null
            || zfw === null
            || (climbCas === null && climbMach === null)
            || (cruiseCas === null && cruiseMach === null)
            || (descentCas === null && descentMach === null)) {
            this.clearVerticalPath(verticalPathEntry);
            return;
        }
        const maprStartLegIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintLegIndex = (_b = verticalPlan.firstDescentConstraintLegIndex) !== null && _b !== void 0 ? _b : -1;
        const lastSimulatedLegIndex = maprStartLegIndex < 0 ? lateralPlan.length : maprStartLegIndex;
        const firstDescentConstraintIndex = verticalPlan.firstDescentConstraintLegIndex === undefined
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const isPastCalculatedTod = verticalPath.todLegIndex !== undefined && verticalPath.todDistanceToLegEnd !== undefined
            && (activeLegIndex > verticalPath.todLegIndex
                || (activeLegIndex === verticalPath.todLegIndex && activeDistanceToLegEnd <= verticalPath.todDistanceToLegEnd));
        climbCas !== null && climbCas !== void 0 ? climbCas : (climbCas = Infinity);
        climbMach !== null && climbMach !== void 0 ? climbMach : (climbMach = Infinity);
        cruiseCas !== null && cruiseCas !== void 0 ? cruiseCas : (cruiseCas = Infinity);
        cruiseMach !== null && cruiseMach !== void 0 ? cruiseMach : (cruiseMach = Infinity);
        descentCas !== null && descentCas !== void 0 ? descentCas : (descentCas = Infinity);
        descentMach !== null && descentMach !== void 0 ? descentMach : (descentMach = Infinity);
        cruiseAltitude = UnitType.FOOT.convertTo(cruiseAltitude, UnitType.METER);
        climbCas = UnitType.KNOT.convertTo(climbCas, UnitType.MPS);
        cruiseCas = UnitType.KNOT.convertTo(cruiseCas, UnitType.MPS);
        descentCas = UnitType.KNOT.convertTo(descentCas, UnitType.MPS);
        const currentAltitude = UnitType.FOOT.convertTo(this.indicatedAltitude.get(), UnitType.METER);
        const currentWeight = zfw + this.fob.get();
        let climbTransitionAltitude = perfPlan.climbSpeedLimitAltitude.get();
        if (climbTransitionAltitude !== null) {
            climbTransitionAltitude = UnitType.FOOT.convertTo(climbTransitionAltitude, UnitType.METER);
        }
        let climbTransitionCas = perfPlan.climbSpeedLimitCas.get();
        if (climbTransitionCas !== null) {
            climbTransitionCas = UnitType.KNOT.convertTo(climbTransitionCas, UnitType.MPS);
        }
        let climbRestrictionAltitude = perfPlan.climbSpeedRestrAltitude.get();
        if (climbRestrictionAltitude !== null) {
            climbRestrictionAltitude = UnitType.FOOT.convertTo(climbRestrictionAltitude, UnitType.METER);
        }
        let climbRestrictionCas = perfPlan.climbSpeedRestrCas.get();
        if (climbRestrictionCas !== null) {
            climbRestrictionCas = UnitType.KNOT.convertTo(climbRestrictionCas, UnitType.MPS);
        }
        let descentTransitionAltitude = perfPlan.descentSpeedLimitAltitude.get();
        if (descentTransitionAltitude !== null) {
            descentTransitionAltitude = UnitType.FOOT.convertTo(descentTransitionAltitude, UnitType.METER);
        }
        let descentTransitionCas = perfPlan.descentSpeedLimitCas.get();
        if (descentTransitionCas !== null) {
            descentTransitionCas = UnitType.KNOT.convertTo(descentTransitionCas, UnitType.MPS);
        }
        let descentRestrictionAltitude = perfPlan.descentSpeedRestrAltitude.get();
        if (descentRestrictionAltitude !== null) {
            descentRestrictionAltitude = UnitType.FOOT.convertTo(descentRestrictionAltitude, UnitType.METER);
        }
        let descentRestrictionCas = perfPlan.descentSpeedRestrCas.get();
        if (descentRestrictionCas !== null) {
            descentRestrictionCas = UnitType.KNOT.convertTo(descentRestrictionCas, UnitType.MPS);
        }
        const lateralLegs = [...lateralPlan.legs()];
        if (!isPastCalculatedTod) {
            const clearEndIndex = Math.min(verticalPath.legs.length, activeLegIndex);
            for (let i = 0; i < clearEndIndex; i++) {
                verticalPath.legs[i].vectors.length = 0;
                verticalPath.legs[i].simDistance = 0;
            }
            verticalPath.tocLegIndex = undefined;
            verticalPath.tocDistanceToLegEnd = undefined;
            verticalPath.tocWeight = undefined;
            // Only simulate the climb if we have not yet sequenced the first descent constraint (if one exists).
            if (firstDescentConstraintLegIndex < 0 || activeLegIndex <= firstDescentConstraintLegIndex) {
                this.simulateClimb(lateralLegs, verticalPlan, verticalPath, perfPlan.climbThrustMode.get(), climbCas, climbMach, climbTransitionAltitude, climbTransitionCas, climbRestrictionAltitude, climbRestrictionCas, cruiseAltitude, activeLegIndex, activeDistanceToLegEnd, currentAltitude, currentWeight, lastSimulatedLegIndex, false, engineCount);
            }
            this.simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, lastSimulatedLegIndex, engineCount);
            // If there exists at least one descent constraint and we have not yet sequenced it, then we need to simulate
            // the descent, beginning with the performance descent.
            if (firstDescentConstraintIndex >= 0 && activeLegIndex <= firstDescentConstraintLegIndex) {
                const firstDescentConstraintAltitude = firstDescentConstraint.legs[0].altitude;
                if (isFinite(firstDescentConstraintAltitude)) {
                    if (cruiseAltitude > firstDescentConstraintAltitude) {
                        // Cruise altitude is above the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist of a level deceleration segment + an idle descent segment that intercepts
                        // the geometric descent path at the first descent constraint.
                        this.computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                    else {
                        // Cruise altitude is at or below the altitude at which we cross the first descent constraint. Therefore the
                        // performance descent will consist only of a level deceleration segment that intercepts the geometric
                        // descent path at some point past the first descent constraint. Alternatively, if the geometric descent
                        // path never descends below the cruise altitude, there will be no descent.
                        this.computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount);
                    }
                }
            }
        }
        else {
            // We are past the calculated TOD. In this case, we will not recalculate the TOD. However, if we are still in
            // the performance descent segment, we need to adjust the vertical path vectors to account for any changes in
            // lateral leg distances.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && (activeLegIndex < verticalPath.geoDescentSimInterceptLegIndex
                    || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex
                        && activeDistanceToLegEnd > verticalPath.geoDescentSimInterceptDistanceToLegEnd))) {
                this.adjustPerformanceDescent(lateralLegs, verticalPath);
            }
        }
        if (maprStartLegIndex < 0 || activeLegIndex < maprStartLegIndex) {
            // We are not in the missed approach.
            // If a geometric descent intercept was calculated, simulate the geometric descent.
            if (verticalPath.geoDescentSimInterceptLegIndex !== undefined
                && verticalPath.geoDescentSimInterceptVectorIndex !== undefined
                && verticalPath.geoDescentSimInterceptDistanceToLegEnd !== undefined
                && verticalPath.geoDescentInterceptWeight !== undefined) {
                this.simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, descentTransitionAltitude, descentTransitionCas, descentRestrictionAltitude, descentRestrictionCas, activeLegIndex, activeDistanceToLegEnd, currentWeight, engineCount);
            }
        }
    }
    /**
     * Clears a vertical flight path of all vectors and resets all computed TOC, TOD, and performance descent data.
     * @param verticalPathEntry The entry for the vertical flight path to clear.
     */
    clearVerticalPath(verticalPathEntry) {
        const verticalPath = verticalPathEntry.path;
        for (let i = 0; i < verticalPath.legs.length; i++) {
            const leg = verticalPath.legs[i];
            leg.vectors.length = 0;
            leg.simDistance = 0;
        }
        verticalPath.tocLegIndex = undefined;
        verticalPath.tocDistanceToLegEnd = undefined;
        verticalPath.tocWeight = undefined;
        verticalPath.todLegIndex = undefined;
        verticalPath.todDistanceToLegEnd = undefined;
        verticalPath.perfDescentTodDistance = undefined;
        verticalPath.perfDescentSimDistance = undefined;
        verticalPath.geoDescentInterceptLegIndex = undefined;
        verticalPath.geoDescentInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentSimInterceptLegIndex = undefined;
        verticalPath.geoDescentSimInterceptVectorIndex = undefined;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = undefined;
        verticalPath.geoDescentInterceptWeight = undefined;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legs.length = 0;
        coarsePath.legIndexOffset = 0;
    }
    /**
     * Calculates the top of descent and simulates the performance (off-idle) descent phase for a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computePerformanceDescent(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const firstDescentConstraintLegIndex = firstDescentConstraint.index;
        const targetAltitude = firstDescentConstraint.legs[0].altitude;
        if (cruiseAltitude <= targetAltitude) {
            // Cruise altitude is below the target altitude, so there is no path to be calculated (we will transition
            // immediately from cruise to geometric descent when we intercept the first descent path).
            return;
        }
        const geoInterceptLegIndex = firstDescentConstraintLegIndex + 1;
        const geoInterceptConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, geoInterceptLegIndex);
        const geoInterceptConstraintTargetAltitude = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.targetAltitude;
        const geoInterceptLeg = geoInterceptConstraint === null || geoInterceptConstraint === void 0 ? void 0 : geoInterceptConstraint.legs[geoInterceptLegIndex - geoInterceptConstraint.index];
        const doesGeoInterceptLegStartLevel = geoInterceptLeg === undefined
            || geoInterceptLeg.fpa === 0
            || firstDescentConstraint.targetAltitude + 1 < geoInterceptLeg.altitude + VNavUtils.altitudeForDistance(geoInterceptLeg.fpa, geoInterceptLeg.distance);
        // Now we will iteratively solve for the TOD. In each iteration, we will choose a TOD along the flight path,
        // then simulate the entire performance descent segment down to the first descent constraint. If the lateral
        // distance covered brings us to within tolerance to the constraint fix, we are done. Otherwise, we adjust
        // the TOD by a lateral distance equal to the difference between the simulated lateral distance and the required
        // lateral distance and run another iteration.
        // TODO: Support speed restriction
        // If the performance descent was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use a crude estimate based on constant FPA.
        const verticalPath = verticalPathEntry.path;
        let estimatedTodDistanceFromFirstConstraint;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromFirstConstraint = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromFirstConstraint = VNavUtils.distanceForAltitude(-3, targetAltitude - cruiseAltitude);
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDescentDistance = estimatedTodDistanceFromFirstConstraint;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the first descent constraint fix to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = firstDescentConstraintLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDescentDistance;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the first descent constraint.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, doesGeoInterceptLegStartLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDescentDistance, todLegIndex, todDistanceToLegEnd, firstDescentConstraintLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDescentDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDescentDistance, prevEstimate);
                prevEstimate = estimatedDescentDistance;
                prevError = todDistanceError;
                estimatedDescentDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = firstDescentConstraintLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = 0;
    }
    /**
     * Calculates the top of descent and simulates the level deceleration segment for a flight plan in which the cruise
     * altitude intercepts the geometric descent path after the first descent altitude constraint.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the calculation
     * and simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param firstDescentConstraintIndex The index of the first descent altitude constraint in the vertical flight plan.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param engineCount The number of operational engines to simulate.
     */
    computeLevelDeceleration(lateralLegs, verticalPlan, verticalPathEntry, cruiseAltitude, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, firstDescentConstraintIndex, activeLegIndex, engineCount) {
        // Find the constraint that defines the vertical path we will intercept. This must be a non-flat constraint with a
        // target altitude lower than the cruise altitude.
        let constraintToIntercept = undefined;
        for (let i = firstDescentConstraintIndex - 1; i >= 0; i--) {
            const constraint = verticalPlan.constraints[i];
            if (constraint.type === 'climb' || constraint.type === 'missed') {
                break;
            }
            if (constraint.targetAltitude <= cruiseAltitude && constraint.fpa > 0) {
                constraintToIntercept = constraint;
                break;
            }
        }
        // If there is no constraint to intercept, then we will remain in cruise until the end of the flight plan.
        if (!constraintToIntercept) {
            return;
        }
        const verticalPath = verticalPathEntry.path;
        // Find the point along the flight plan at which the cruise altitude intercepts the geometric descent path.
        let distanceToIntercept = VNavUtils.distanceForAltitude(constraintToIntercept.fpa, cruiseAltitude - constraintToIntercept.targetAltitude);
        let interceptLegIndex = constraintToIntercept.index;
        let interceptDistanceToLegEnd = 0;
        let interceptLeg = lateralLegs[interceptLegIndex];
        while (interceptLeg && distanceToIntercept > 0) {
            const legDistance = interceptLeg.calculated ? interceptLeg.calculated.distanceWithTransitions : 0;
            if (legDistance > distanceToIntercept) {
                interceptDistanceToLegEnd = distanceToIntercept;
                break;
            }
            else {
                distanceToIntercept -= legDistance;
                interceptLeg = lateralLegs[--interceptLegIndex];
            }
        }
        // Now we will iteratively solve for the TOD, which in this context is the beginning of level deceleration.
        // If the level deceleration was previously simulated, use the previous simulation's distance from TOD to first
        // descent constraint as our initial estimate. Otherwise, use an arbitrary estimate of 10km.
        let estimatedTodDistanceFromIntercept;
        if (verticalPath.perfDescentTodDistance !== undefined) {
            estimatedTodDistanceFromIntercept = verticalPath.perfDescentTodDistance;
        }
        else {
            estimatedTodDistanceFromIntercept = 10000;
        }
        const lateralLegIterableEndIndex = Math.max(0, activeLegIndex - 1);
        const simulatedVerticalPath = verticalPathEntry.perfDescentWorkingPath;
        let estimatedDecelerationDistance = estimatedTodDistanceFromIntercept;
        let iterationCount = 0;
        let todDistanceError = 0;
        let prevEstimate = undefined;
        let prevError = 0;
        while (iterationCount < 10) {
            // -----------------------------
            // Iterate backwards from the intercept point to find the lateral position of the TOD
            // -----------------------------
            let todLeg = undefined;
            let todLegIndex = interceptLegIndex;
            let todDistanceToLegEnd = 0;
            let distanceToGo = estimatedDecelerationDistance + interceptDistanceToLegEnd;
            while (todLegIndex > lateralLegIterableEndIndex) {
                const leg = lateralLegs[todLegIndex];
                // TODO: Handle direct-to's, discontinuities and holds, etc...
                const calcs = leg.calculated;
                if (calcs && calcs.distanceWithTransitions > 0) {
                    todLeg = leg;
                    if (distanceToGo <= calcs.distanceWithTransitions) {
                        todDistanceToLegEnd = distanceToGo;
                        distanceToGo = 0;
                        break;
                    }
                    else {
                        distanceToGo -= calcs.distanceWithTransitions;
                    }
                }
                todLegIndex--;
            }
            if (todLeg === undefined) {
                // There are no calculated legs before the intercept point.
                return;
            }
            // In case we hit the FROM leg or the beginning of the flight plan before reaching the TOD, add any remaining
            // distance to the last iterated leg
            todDistanceToLegEnd += distanceToGo;
            BoeingPathCalculator.copyVerticalPath(verticalPath, simulatedVerticalPath);
            // -----------------------------
            // Simulate the descent starting from the TOD and ending at the first descent constraint altitude.
            // -----------------------------
            const totalDistanceCovered = this.simulatePerformanceDescent(lateralLegs, verticalPlan, simulatedVerticalPath, cruiseAltitude, cruiseAltitude, constraintToIntercept.targetAltitude, false, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedDecelerationDistance, todLegIndex, todDistanceToLegEnd, interceptLegIndex + 1, engineCount);
            iterationCount++;
            // -----------------------------
            // Check simulated distance versus estimated distance. If they are within tolerance, we are finished. Otherwise,
            // set the simulated distance as the new estimated distance and run another iteration.
            // -----------------------------
            todDistanceError = estimatedDecelerationDistance - totalDistanceCovered;
            if (Math.abs(todDistanceError) <= 1000) {
                break;
            }
            if (prevEstimate === undefined) {
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = totalDistanceCovered;
            }
            else {
                const nextEstimate = MathUtils.lerp(0, todDistanceError, prevError, estimatedDecelerationDistance, prevEstimate);
                prevEstimate = estimatedDecelerationDistance;
                prevError = todDistanceError;
                estimatedDecelerationDistance = nextEstimate;
            }
        }
        BoeingPathCalculator.copyVerticalPath(simulatedVerticalPath, verticalPath);
        verticalPath.geoDescentInterceptLegIndex = interceptLegIndex;
        verticalPath.geoDescentInterceptDistanceToLegEnd = interceptDistanceToLegEnd;
    }
    /**
     * Adjusts the vertical flight path vectors in the performance (off-idle) descent to account for changes in lateral
     * flight plan leg distances since the vectors were simulated.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPath The vertical flight path containing the vectors to adjust.
     */
    adjustPerformanceDescent(lateralLegs, verticalPath) {
        var _a, _b, _c;
        if (verticalPath.todLegIndex === undefined
            || verticalPath.todDistanceToLegEnd === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined) {
            return;
        }
        let distanceCovered = verticalPath.todDistanceToLegEnd;
        const endLegIndex = Math.min(verticalPath.legs.length, verticalPath.geoDescentSimInterceptLegIndex + 1);
        for (let i = verticalPath.todLegIndex + 1; i < endLegIndex; i++) {
            const leg = verticalPath.legs[i];
            if (leg.vectors.length === 0) {
                continue;
            }
            const isInterceptLeg = i === verticalPath.geoDescentSimInterceptLegIndex;
            const endDistanceToLegEnd = isInterceptLeg ? verticalPath.geoDescentSimInterceptDistanceToLegEnd : 0;
            const lerpEndDistanceToLegEnd = Math.max(0, endDistanceToLegEnd);
            const newLegDistance = (_c = (_b = (_a = lateralLegs[i]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            for (let j = 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (isInterceptLeg && vector.simStartDistanceToLegEnd <= endDistanceToLegEnd) {
                    break;
                }
                vector.startDistanceToLegEnd = MathUtils.lerp(vector.simStartDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
                vector.endDistanceToLegEnd = MathUtils.lerp(vector.simEndDistanceToLegEnd, leg.simDistance, lerpEndDistanceToLegEnd, newLegDistance, lerpEndDistanceToLegEnd);
            }
            distanceCovered += newLegDistance - endDistanceToLegEnd;
        }
        verticalPath.perfDescentTodDistance = distanceCovered;
    }
    /**
     * Simulates the VNAV climb phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param climbThrustMode The thrust mode to use during the climb phase.
     * @param climbCas The climb calibrated airspeed to use, in meters per second.
     * @param climbMach The climb mach number to use.
     * @param transitionAltitude The climb transition altitude, in meters above MSL, or `null` if there is no transition
     * speed.
     * @param transitionCas The climb transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The climb restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The climb restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param bocLegIndex The global index of the flight plan leg containing the start of the climb.
     * @param bocDistanceToLegEnd The lateral distance, in meters, from the start of the climb to the end of its
     * containing leg.
     * @param bocAltitude The altitude, in meters above MSL, of the start of the climb.
     * @param bocWeight The airplane weight, in pounds, at the start of the climb.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the climb, exclusive. If the
     * climb is simulated to end past the last eligible leg, then the simulation will proceed along the last eligible leg
     * as if it were infinitely extended until the top of climb is reached.
     * @param isMissedApproach Whether the simulated climb is part of the missed approach.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateClimb(lateralLegs, verticalPlan, verticalPath, climbThrustMode, climbCas, climbMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, cruiseAltitude, bocLegIndex, bocDistanceToLegEnd, bocAltitude, bocWeight, endLegIndex, isMissedApproach, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        var _k, _l;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        if (bocAltitude >= cruiseAltitude - 100 || bocLegIndex >= endLegIndex) {
            return;
        }
        let climbN1MethodName;
        switch (climbThrustMode) {
            case ClimbThrustMode.CLB1:
                climbN1MethodName = 'getClb1N1';
                break;
            case ClimbThrustMode.CLB2:
                climbN1MethodName = 'getClb2N1';
                break;
            default:
                climbN1MethodName = 'getClbMaxN1';
        }
        const wingArea = this.perfProvider.getWingArea();
        let currentVerticalPathLegIndex = bocLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        // Simulate climb steps. Each step covers the distance to the end of the next lateral leg, the next AT OR BELOW
        // climb altitude restriction to be sequenced, the next speed restriction or speed transition to be sequenced, or
        // 1000 feet of climb, whichever is shorter.
        let currentAltitude = bocAltitude;
        let currentLegIndex = bocLegIndex;
        let currentLeg = lateralLegs[bocLegIndex];
        let distanceToLegEnd = bocDistanceToLegEnd;
        let currentWeight = bocWeight;
        const getNextTargetConstraint = isMissedApproach ? VNavUtils.getNextMaprTargetConstraint : VNavUtils.getNextClimbTargetConstraint;
        let currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, bocLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = climbCas;
        const defaultTargetCasSource = isFinite(climbCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = climbMach;
        const defaultTargetMachSource = isFinite(climbMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let casToUse = Infinity;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude < cruiseAltitude) {
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedClimbWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedClimbIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (currentTargetAltitudeConstraint && currentLegIndex > currentTargetAltitudeConstraint.index) {
                // We passed the current target altitude constraint that we were tracking, so we need to get the new current
                // target altitude constraint.
                currentTargetAltitudeConstraint = getNextTargetConstraint(verticalPlan, currentLegIndex);
            }
            // Do not apply flight plan leg altitude restriction if we are past the end of the last eligible leg to be
            // simulated. Otherwise we might get stuck below the cruise altitude forever.
            const targetAltitude = currentTargetAltitudeConstraint && (currentLegIndex < endLegIndex - 1 || distanceToLegEnd > 0)
                ? Math.min(cruiseAltitude, currentTargetAltitudeConstraint.maxAltitude)
                : cruiseAltitude;
            if (currentSpeedConstraint && currentLegIndex > currentSpeedConstraint.globalLegIndex) {
                // We passed the current speed constraint that we were tracking, so we need to get the new current speed
                // constraint.
                currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Climb, isMissedApproach);
                // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed constraint
                // increased our target speed.
                if (!isAccelerating) {
                    isAccelerating = true;
                    accelerationCas = casToUse;
                }
            }
            if (useTransitionCas) {
                if (currentAltitude >= transitionAltitude) {
                    useTransitionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed transition
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            if (useRestrictionCas) {
                if (currentAltitude >= restrictionAltitude) {
                    useRestrictionCas = false;
                    // If we are not currently accelerating, set acceleration flag to true in case sequencing the speed restriction
                    // increased our target speed.
                    if (!isAccelerating) {
                        isAccelerating = true;
                        accelerationCas = casToUse;
                    }
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, targetAltitude - currentAltitude);
            let distanceStep;
            let timeStep;
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
                altitudeStep = Math.min(altitudeStep, restrictionAltitude - currentAltitude);
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
                altitudeStep = Math.min(altitudeStep, transitionAltitude - currentAltitude);
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = casToTarget);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || casToTarget <= accelerationCas + 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            casToUse = isAccelerating ? accelerationCas : casToTarget;
            // If we are on the last eligible leg to be simulated, we will run the simulation even if the leg does not have
            // a non-zero calculated distance in order to guarantee that the simulation eventually reaches cruise altitude.
            if (currentLegIndex === endLegIndex - 1 || (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0)) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let vs;
                let engineFuelFlow;
                if (altitudeStep <= 0) {
                    // The current altitude is at or above the current target climb altitude (if it were at or above the cruise
                    // altitude we would have exited the while loop already). In this case, we will hold the current altitude
                    // until we sequence the altitude constraint.
                    altitudeStep = 0;
                    vs = 0;
                    const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                    if (isAccelerating) {
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        const targetCl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, targetTas);
                        const targetNetThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, targetCl, 0);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(targetNetThrustRequired, currentWeight, cl, tas, 0, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        timeStep = tasStep / acceleration;
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                        timeStep = distanceStep / gs;
                    }
                    const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                }
                else {
                    // The current altitude is below the current target climb altitude, so we will climb using the selected climb
                    // climb thrust rating.
                    const temperatureK = temperature + 273.15;
                    const n1 = this.engineDataProvider[climbN1MethodName](UnitType.METER.convertTo(currentAltitude, UnitType.FOOT), temperatureK * AeroMath.totalTemperatureRatioAir(mach) - 273.15);
                    const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                    const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                    const engineNetThrust = engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature);
                    if (isAccelerating) {
                        vs = BoeingPathCalculator.CLIMB_ACCEL_VS_MPS;
                        const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, vs, 0));
                        const tasStep = Math.min(targetTas - tas, 3);
                        const accelTimeStep = tasStep / acceleration;
                        const accelAltitudeStep = vs * accelTimeStep;
                        // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the current climb target altitude).
                        if (accelAltitudeStep > altitudeStep) {
                            // vs cannot be 0 here
                            timeStep = altitudeStep / vs;
                        }
                        else {
                            altitudeStep = accelAltitudeStep;
                            timeStep = accelTimeStep;
                        }
                        distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                    }
                    else {
                        vs = Math.max(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), 1);
                        timeStep = altitudeStep / vs;
                        distanceStep = timeStep * gs;
                    }
                    engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                }
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd && currentLegIndex < endLegIndex - 1) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined || (currentLegIndex === endLegIndex - 1 && distanceToLegEnd > 0 && distanceStep > distanceToLegEnd)) {
                    // We are either advancing legs or we are about to cross the end of the last eligible leg to be simulated.
                    // Either way we need to end the current step at the end of the current leg.
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * vs;
                    if (advanceLegIndexTo !== undefined) {
                        currentLegIndex = advanceLegIndexTo;
                        currentLeg = lateralLegs[currentLegIndex];
                        distanceToLegEnd = (_e = (_d = currentLeg.calculated) === null || _d === void 0 ? void 0 : _d.distanceWithTransitions) !== null && _e !== void 0 ? _e : 0;
                    }
                    else {
                        distanceToLegEnd = 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentAltitude += altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.ClimbLevelAcceleration;
                    }
                    else {
                        vectorType = vs > 0 ? VerticalFlightPathVectorType.Climb : VerticalFlightPathVectorType.ClimbLevel;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from a level acceleration into a climb
                        // acceleration or vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_f = (_k = pathLeg.vectors)[vectorIndex]) !== null && _f !== void 0 ? _f : (_k[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_g = (_l = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_l[0] = BoeingPathCalculator.createVerticalPathVector());
                vector.type = isAccelerating ? VerticalFlightPathVectorType.ClimbAcceleration : VerticalFlightPathVectorType.Climb;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = currentAltitude;
                vector.endAltitude = currentAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
        verticalPath.tocLegIndex = currentLegIndex;
        verticalPath.tocDistanceToLegEnd = distanceToLegEnd;
        verticalPath.tocWeight = currentWeight;
    }
    /**
     * Simulates the VNAV cruise phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param cruiseCas The cruise calibrated airspeed to use, in meters per second.
     * @param cruiseMach The cruise mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the cruise, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCruise(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, cruiseCas, cruiseMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        endLegIndex = Math.min(endLegIndex, lateralLegs.length);
        let tocLegIndex;
        let tocDistanceToLegEnd;
        let tocWeight = activeWeight;
        let currentVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let tocCasToUse;
        // If a TOC is defined in the vertical flight path, then we need to make sure we start writing cruise vectors after
        // the TOC. Otherwise, the simulation starts in the cruise phase at the airplane's current along-track position, so
        // we will start writing vectors at index 0 for the active leg.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            // Check if the TOC lies past the end of its containing leg. If it does, then we need to start our simulation at
            // the beginning of the next leg.
            if (verticalPath.tocDistanceToLegEnd < 0) {
                tocLegIndex = verticalPath.tocLegIndex + 1;
                tocDistanceToLegEnd = (_c = (_b = (_a = lateralLegs[tocLegIndex]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
            }
            else {
                tocLegIndex = verticalPath.tocLegIndex;
                tocDistanceToLegEnd = verticalPath.tocDistanceToLegEnd;
                tocWeight = verticalPath.tocWeight;
                currentVerticalPathLegIndex = tocLegIndex;
                const tocPathLeg = verticalPath.legs[tocLegIndex];
                for (let i = 0; i < tocPathLeg.vectors.length; i++) {
                    const vector = tocPathLeg.vectors[i];
                    if (vector.startDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector starts at or after the TOC -> start inserting cruise vectors at this index.
                        currentVerticalPathVectorIndex = i;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                        break;
                    }
                    if (vector.endDistanceToLegEnd <= tocDistanceToLegEnd) {
                        // The current vector ends at or after the TOC -> change the vector to end at the TOC if necessary and start
                        // inserting cruise vectors at the next index.
                        if (vector.endDistanceToLegEnd < tocDistanceToLegEnd) {
                            vector.endAltitude = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                            vector.endWeight = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                            // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                            // vector will be. For non-acceleration vectors, the end speed stays the same.
                            if (vector.endCas !== vector.startCas) {
                                // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                                // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                                // stays constant.
                                vector.endMach = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                                vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                            }
                            // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                            // vectors, but the absolute magnitude of the error should still be acceptable.
                            vector.duration = MathUtils.lerp(tocDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                            vector.simStartDistanceToLegEnd = tocDistanceToLegEnd;
                            vector.endDistanceToLegEnd = tocDistanceToLegEnd;
                        }
                        currentVerticalPathVectorIndex = i + 1;
                        currentVerticalPathLegDuration += vector.duration;
                        tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                        break;
                    }
                    currentVerticalPathVectorIndex = i + 1;
                    currentVerticalPathLegDuration += vector.duration;
                    tocCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                }
            }
        }
        else {
            tocLegIndex = activeLegIndex;
            tocDistanceToLegEnd = activeDistanceToLegEnd;
            currentVerticalPathLegIndex = tocLegIndex;
        }
        if (tocLegIndex >= endLegIndex) {
            return;
        }
        const wingArea = this.perfProvider.getWingArea();
        const pressure = AeroMath.isaPressure(cruiseAltitude);
        const isaTemperature = AeroMath.isaTemperature(cruiseAltitude);
        const cruiseAltitudeFeet = UnitType.METER.convertTo(cruiseAltitude, UnitType.FOOT);
        // Simulate cruise steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction, or 100 NM, whichever is shorter.
        let currentLegIndex = tocLegIndex;
        let currentLeg = lateralLegs[tocLegIndex];
        let distanceToLegEnd = tocDistanceToLegEnd;
        let currentWeight = tocWeight;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, tocLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        let defaultTargetCas = cruiseCas;
        let defaultTargetCasSource = isFinite(cruiseCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        if (restrictionAltitude !== null && restrictionCas !== null && cruiseAltitude < restrictionAltitude && restrictionCas < defaultTargetCas) {
            defaultTargetCas = restrictionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (transitionAltitude !== null && transitionCas !== null && cruiseAltitude < transitionAltitude && transitionCas < defaultTargetCas) {
            defaultTargetCas = transitionCas;
            defaultTargetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        const defaultTargetMach = cruiseMach;
        const defaultTargetMachSource = isFinite(cruiseMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let isAccelerating = true;
        let accelerationCas = undefined;
        let acceleration = 0;
        let accelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherLegIndex = undefined;
        while (currentLegIndex < endLegIndex) {
            // Check if we need to update winds and delta ISA offset.
            if (currentLegIndex !== lastWeatherLegIndex) {
                const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_d = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, cruiseAltitudeFeet, distanceAlongLeg)) !== null && _d !== void 0 ? _d : 0;
                lastWeatherLegIndex = currentLegIndex;
            }
            const temperature = isaTemperature + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                // Speed transition and restriction have higher priority than flight plan speed constraints
                if (useSpeedConstraint.minCas > targetCas && targetCasSource === VerticalFlightPathVectorSpeedSource.Schedule) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            tocCasToUse !== null && tocCasToUse !== void 0 ? tocCasToUse : (tocCasToUse = casToTarget);
            let distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
            let timeStep;
            accelerationCas !== null && accelerationCas !== void 0 ? accelerationCas : (accelerationCas = tocCasToUse);
            // Check if we need to continue to accelerate
            if (isAccelerating && (!isFinite(accelerationCas) || Math.abs(casToTarget - accelerationCas) <= 0.1)) {
                isAccelerating = false;
                accelerationCas = casToTarget;
            }
            const casToUse = isAccelerating ? accelerationCas : casToTarget;
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (windVector && windVector[1] > 0 && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                const mach = AeroMath.casToMach(casToUse, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                const netThrustRequired = this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0);
                if (isAccelerating) {
                    const accelerationSign = casToTarget - accelerationCas >= 0 ? 1 : -1;
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                    let tasStep;
                    if (accelerationSign === 1) {
                        acceleration = Math.max(0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0));
                        tasStep = Math.min(targetTas - tas, 3);
                    }
                    else {
                        acceleration = Math.min(-0.1, this.perfProvider.getAcceleration(engineNetThrust * engineCount, currentWeight, cl, tas, 0, 0));
                        tasStep = Math.max(targetTas - tas, -3);
                    }
                    timeStep = tasStep / acceleration;
                    distanceStep = gs * timeStep + acceleration / 2 * timeStep * timeStep;
                }
                else {
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 150 NM. This threshold is
                            // chosen because it guarantees that we don't overshoot any anticipated distance less than or equal to
                            // 50 NM (50 NM + 100 NM maximum step distance).
                            if (distanceToNextSpeedConstraint <= BoeingPathCalculator.MAX_DISTANCE_STEP + 92600) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                // Assume that the airplane decelerates as quickly as possible by using idle thrust.
                                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                                const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, 0, engineNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // distance step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters before the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isAccelerating = true;
                                    accelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    distanceStep = Math.min(distanceStep, distanceToNextSpeedConstraint - distanceToDecel - 500);
                                }
                            }
                        }
                    }
                }
                const grossThrustPerEngineRequired = this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = distanceStep / gs);
                // Check if we reach the end of the current leg before the end of the distance step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceToLegEnd <= distanceStep) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    distanceStep = distanceToLegEnd;
                    if (isAccelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, acceleration);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    currentLegIndex = advanceLegIndexTo;
                    currentLeg = lateralLegs[advanceLegIndexTo];
                    distanceToLegEnd = (_f = (_e = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepEndDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isAccelerating) {
                        accelerationCas = AeroMath.tasToCas(tas + acceleration * timeStep, pressure, temperature);
                    }
                }
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - distanceStep / gs * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isAccelerating) {
                        vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.Cruise;
                    }
                    if (isAccelerating) {
                        // If we are accelerating, we need to check if we went straight from an acceleration to a deceleration or
                        // vice versa. If so, we need to insert a new vector.
                        if (!accelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            accelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not accelerating, we need to check if the current vector is an acceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = accelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        accelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isAccelerating || !accelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = cruiseAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        accelerationVectorStarted = isAccelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = cruiseAltitude;
                    vector.endWeight = currentWeight;
                    if (isAccelerating) {
                        vector.endCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(accelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    if (!isAccelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    accelerationVectorStarted = false;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isAccelerating) {
                    vectorType = acceleration >= 0 ? VerticalFlightPathVectorType.CruiseAcceleration : VerticalFlightPathVectorType.CruiseDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.Cruise;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isAccelerating) {
                    vector.startCas = UnitType.MPS.convertTo(accelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(accelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                accelerationVectorStarted = false;
            }
        }
    }
    /**
     * Simulates the VNAV performance (off-idle) descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPath The vertical flight path to which to write the results of the simulation.
     * @param cruiseAltitude The cruise altitude, in meters above MSL.
     * @param targetAltitude The altitude to target, in meters above MSL, at the end of the performance descent phase.
     * @param geoInterceptConstraintTargetAltitude The target altitude of the descent altitude constraint containing the
     * point where the performance descent intercepts the geometric descent path, or `undefined` if there is no such
     * constraint.
     * @param isGeoInterceptPathLevel Whether the geometric descent path is level at the point where the performance
     * descent intercepts it.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param estimatedTodDistance The lateral distance, in meters, from the top of descent to the first descent altitude
     * constraint along the flight plan.
     * @param todLegIndex The global index of the flight plan leg containing the top of descent.
     * @param todDistanceToLegEnd The lateral distance, in meters, from the top of descent to the end of its containing
     * leg.
     * @param endLegIndex The global index of the last flight plan leg for which to simulate the descent, exclusive.
     * @param engineCount The number of operational engines to simulate.
     * @returns The total simulated distance, in meters, of the performance descent phase.
     */
    simulatePerformanceDescent(lateralLegs, verticalPlan, verticalPath, cruiseAltitude, targetAltitude, geoInterceptConstraintTargetAltitude, isGeoInterceptPathLevel, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, estimatedTodDistance, todLegIndex, todDistanceToLegEnd, endLegIndex, engineCount) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
        var _l, _m;
        if (todLegIndex >= lateralLegs.length) {
            verticalPath.todLegIndex = todLegIndex;
            verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
            verticalPath.perfDescentTodDistance = estimatedTodDistance;
            verticalPath.perfDescentSimDistance = 0;
            return 0;
        }
        const wingArea = this.perfProvider.getWingArea();
        // Find the vertical path vector
        let currentVerticalPathLegIndex = todLegIndex;
        let currentVerticalPathVectorIndex = 0;
        let currentVerticalPathLegDuration = 0;
        let todCasToUse;
        let todWeight = 0;
        const todPathLeg = verticalPath.legs[todLegIndex];
        for (let i = 0; i < todPathLeg.vectors.length; i++) {
            const vector = todPathLeg.vectors[i];
            if (vector.startDistanceToLegEnd <= todDistanceToLegEnd) {
                // The current vector starts at or after the TOD -> start inserting descent vectors at this index.
                currentVerticalPathVectorIndex = i;
                todCasToUse = UnitType.KNOT.convertTo(vector.startCas, UnitType.MPS);
                todWeight = vector.startWeight;
                break;
            }
            if (vector.endDistanceToLegEnd < todDistanceToLegEnd) {
                // The current vector ends after the TOD -> change the vector to end at the TOD and start inserting descent
                // vectors at the next index.
                vector.endAltitude = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startAltitude, vector.endAltitude, true, true);
                vector.endWeight = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startWeight, vector.endWeight, true, true);
                // If we are ending an acceleration vector early, we need to recalculate what the speed at the new end of the
                // vector will be. For non-acceleration vectors, the end speed stays the same.
                if (vector.endCas !== vector.startCas) {
                    // Assume constant acceleration throughout the vector (potentially not accurate, but we will accept some
                    // degree of error here). Also assume the proportionality constant between TAS and mach (i.e. speed of sound)
                    // stays constant.
                    vector.endMach = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, vector.startMach, vector.endMach, true, true);
                    vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCasIsa(vector.endMach, vector.endAltitude), UnitType.KNOT);
                }
                // Linearly interpolate the duration from the distance. This will not be 100% accurate for acceleration
                // vectors, but the absolute magnitude of the error should still be acceptable.
                vector.duration = MathUtils.lerp(todDistanceToLegEnd, vector.startDistanceToLegEnd, vector.endDistanceToLegEnd, 0, vector.duration, true, true);
                vector.simEndDistanceToLegEnd = todDistanceToLegEnd;
                vector.endDistanceToLegEnd = todDistanceToLegEnd;
                currentVerticalPathVectorIndex = i + 1;
                currentVerticalPathLegDuration += vector.duration;
                todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
                todWeight = vector.endWeight;
                break;
            }
            currentVerticalPathVectorIndex = i + 1;
            currentVerticalPathLegDuration += vector.duration;
            todCasToUse = UnitType.KNOT.convertTo(vector.endCas, UnitType.MPS);
            todWeight = vector.endWeight;
        }
        // If a TOC is defined, then check if the TOD lies before the TOC. If it does, then use the TOC weight as the weight
        // at TOD instead of the estimated weight at the TOD.
        if (verticalPath.tocLegIndex !== undefined && verticalPath.tocDistanceToLegEnd !== undefined && verticalPath.tocWeight !== undefined) {
            if (todLegIndex < verticalPath.tocLegIndex
                || (todLegIndex === verticalPath.tocLegIndex && todDistanceToLegEnd > verticalPath.tocDistanceToLegEnd)) {
                todWeight = verticalPath.tocWeight;
            }
        }
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next (anticipated)
        // speed restriction or speed transition, or 1000 feet of descent, whichever is shorter.
        let currentAltitude = cruiseAltitude;
        let currentLegIndex = todLegIndex;
        let currentLeg = lateralLegs[todLegIndex];
        let distanceToLegEnd = todDistanceToLegEnd;
        let advanceLegIndexTo = undefined;
        let lastVerticalPathLegIndex = currentVerticalPathLegIndex;
        let lastVerticalPathVectorIndex = currentVerticalPathVectorIndex - 1;
        let lastDistanceToLegEnd = todDistanceToLegEnd;
        let currentWeight = todWeight;
        let totalDistanceCovered = 0;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, todLegIndex, VerticalFlightPhase.Descent);
        let useNextSpeedConstraint = false;
        // Only apply transition and restriction speed limits if they are defined and the either we are intercepting the
        // geometric descent below the threshold altitudes or the intercept is at the threshold altitude and the geometric
        // descent path at the point of intercept descends past the threshold altitude (i.e. we will not level off at the
        // intercept).
        const canUseTransitionCas = transitionAltitude !== null
            && transitionCas !== null
            && (targetAltitude < transitionAltitude - 0.3048
                || (targetAltitude < transitionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < transitionAltitude - 0.3048)));
        let useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude;
        const canUseRestrictionCas = restrictionAltitude !== null
            && restrictionCas !== null
            && (targetAltitude < restrictionAltitude - 0.3048
                || (targetAltitude < restrictionAltitude + 0.3048
                    && !isGeoInterceptPathLevel
                    && (geoInterceptConstraintTargetAltitude !== undefined && geoInterceptConstraintTargetAltitude < restrictionAltitude - 0.3048)));
        let useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        endLegIndex = Math.min(lateralLegs.length, endLegIndex);
        let isInLevelDecelerationPhase = true;
        let isDecelerating = true;
        let decelerationCas = undefined;
        let decelerationAccel = 0;
        let decelerationVectorStarted = false;
        let windVector = null;
        let wind = 0;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentAltitude > targetAltitude || isInLevelDecelerationPhase) {
            // If the current leg is the leg that we want to advance to, reset the advance leg index so that we don't skip
            // the current leg.
            if (advanceLegIndexTo === currentLegIndex) {
                advanceLegIndexTo = undefined;
            }
            // Check if we need to update winds and delta ISA offset.
            if (currentAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                // If we are still at cruise altitude (i.e. level deceleration), then use cruise winds. Otherwise use descent
                // winds.
                if (currentAltitude === cruiseAltitude) {
                    const distanceAlongLeg = currentLeg.calculated ? currentLeg.calculated.distanceWithTransitions - distanceToLegEnd : 0;
                    windVector = this.windPlanner.getInterpolatedWindAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_a = this.windPlanner.getInterpolatedIsaDeltaAlongLeg(verticalPath.planIndex, currentLegIndex, currentAltitudeFeet, distanceAlongLeg)) !== null && _a !== void 0 ? _a : 0;
                }
                else {
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                }
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            let altitudeStep = Math.min(BoeingPathCalculator.MAX_ALTITUDE_STEP, currentAltitude - targetAltitude);
            let distanceStep;
            let timeStep;
            let mach;
            let tas;
            let gs;
            let cl;
            let n1;
            let vs;
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
                useNextSpeedConstraint = false;
            }
            useTransitionCas || (useTransitionCas = canUseTransitionCas && currentAltitude < transitionAltitude);
            useRestrictionCas || (useRestrictionCas = canUseRestrictionCas && currentAltitude < restrictionAltitude);
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            const useSpeedConstraint = useNextSpeedConstraint && nextSpeedConstraint ? nextSpeedConstraint : currentSpeedConstraint;
            if (useSpeedConstraint) {
                if (useSpeedConstraint.minCas > targetCas) {
                    targetCas = useSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxCas < targetCas) {
                    targetCas = useSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.minMach > targetMach) {
                    targetMach = useSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (useSpeedConstraint.maxMach < targetMach) {
                    targetMach = useSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            todCasToUse !== null && todCasToUse !== void 0 ? todCasToUse : (todCasToUse = casToTarget);
            decelerationCas !== null && decelerationCas !== void 0 ? decelerationCas : (decelerationCas = todCasToUse);
            // Check if we need to continue to decelerate
            if (isDecelerating && (!isFinite(decelerationCas) || casToTarget >= decelerationCas - 0.1)) {
                isDecelerating = false;
                isInLevelDecelerationPhase = false;
                decelerationCas = casToTarget;
                // If we were only simulating the level deceleration phase, then end the simulation now that we are no longer
                // in it.
                if (currentAltitude <= targetAltitude) {
                    break;
                }
            }
            if (advanceLegIndexTo === undefined) {
                // We are not skipping the current leg.
                // Find the wind component along the lateral flight path at the current simulated position.
                const courseCircle = BoeingPathCalculator.geoCircleCache[0];
                const coursePosition = BoeingPathCalculator.vec3Cache[0];
                if (currentLeg.calculated && windVector && windVector[1] > 0
                    && BoeingPathCalculator.getCourseAndPositionAlongLeg(currentLeg.calculated, distanceToLegEnd, courseCircle, coursePosition)) {
                    wind = FlightPathUtils.projectVelocityToCircle(UnitType.KNOT.convertTo(windVector[1], UnitType.MPS), coursePosition, windVector[0] + 180, courseCircle);
                    if (!isFinite(wind)) {
                        wind = 0;
                    }
                }
                else {
                    wind = 0;
                }
                let casToUse;
                if (isDecelerating) {
                    vs = isInLevelDecelerationPhase ? 0 : BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                    casToUse = decelerationCas;
                    mach = AeroMath.casToMach(decelerationCas, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    n1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    decelerationAccel = Math.min(-0.1, this.perfProvider.getAcceleration(this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) * engineCount, currentWeight, cl, tas, vs, 0));
                    const targetTas = AeroMath.casToTas(casToTarget, pressure, temperature);
                    const tasStep = Math.min(tas - targetTas, 3);
                    const accelTimeStep = tasStep / -decelerationAccel;
                    const accelAltitudeStep = -vs * accelTimeStep;
                    // Make sure we don't exceed the existing altitude step (1000 feet or altitude to the first descent constraint).
                    if (accelAltitudeStep > altitudeStep) {
                        // vs cannot be 0 here
                        timeStep = altitudeStep / -vs;
                    }
                    else {
                        altitudeStep = accelAltitudeStep;
                        timeStep = accelTimeStep;
                    }
                    distanceStep = gs * timeStep + decelerationAccel / 2 * timeStep * timeStep;
                }
                else {
                    altitudeStep = Math.min(304.8, currentAltitude - targetAltitude);
                    casToUse = casToTarget;
                    mach = AeroMath.casToMach(casToUse, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    gs = tas + wind;
                    cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                    n1 = idleN1 + this.performanceDescentIdleN1Offset;
                    if (!useNextSpeedConstraint && nextSpeedConstraint) {
                        let casToAnticipate = undefined;
                        if (nextSpeedConstraint.maxCas < casToUse) {
                            casToAnticipate = nextSpeedConstraint.maxCas;
                        }
                        else if (isFinite(nextSpeedConstraint.maxMach)) {
                            const nextSpeedConstraintMachCas = AeroMath.machToCas(nextSpeedConstraint.maxMach, pressure);
                            if (nextSpeedConstraintMachCas < casToUse) {
                                casToAnticipate = nextSpeedConstraintMachCas;
                            }
                        }
                        if (casToAnticipate !== undefined) {
                            const distanceToNextSpeedConstraint = BoeingPathCalculator.getDistanceToSpeedConstraint(lateralLegs, nextSpeedConstraint, currentLegIndex, distanceToLegEnd);
                            // Do not try to anticipate the next speed constraint until we are within 100 NM.
                            if (distanceToNextSpeedConstraint <= 185200) {
                                const tasToAnticipate = AeroMath.casToTas(casToAnticipate, pressure, temperature);
                                const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                                const [, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                                // If we are within 1000 meters or past the point where we need to start decelerating to meet the speed
                                // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the
                                // altitude step if necessary so that the next step begins at the point at which we are predicted to
                                // need to start decelerating to reach the target speed 500 meters prior to the speed constraint.
                                if (distanceToDecel >= distanceToNextSpeedConstraint - 1000) {
                                    useNextSpeedConstraint = true;
                                    isDecelerating = true;
                                    decelerationCas = casToUse;
                                    continue;
                                }
                                else {
                                    const engineNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(n1, mach, pressure, temperature);
                                    vs = Math.min(this.perfProvider.getVerticalSpeed(engineNetThrust * engineCount, currentWeight, cl, tas, 0), -1);
                                    altitudeStep = Math.min(altitudeStep, (distanceToNextSpeedConstraint - distanceToDecel - 500) / gs * -vs);
                                }
                            }
                        }
                    }
                    // If we are not yet using the speed restriction limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the restriction altitude, check if we need to start anticipating the speed restriction.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseRestrictionCas
                        && !useRestrictionCas
                        && restrictionCas < casToUse
                        && (targetAltitude < restrictionAltitude - 1)
                        && currentAltitude - restrictionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(restrictionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToRestriction = currentAltitude - restrictionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // restriction, immediately start decelerating towards the restriction speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the restriction altitude.
                        if (altitudeToDecel >= altitudeToRestriction - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToRestriction - altitudeToDecel - 100);
                        }
                    }
                    // If we are not yet using the speed transition limit, the limit is less than the current target speed, and we
                    // are within 3500 feet of the transition altitude, check if we need to start anticipating the speed transition.
                    // This threshold is chosen because it guarantees that we don't overshoot any anticipated altitude less than
                    // or equal to 2500 feet (2500 feet + 1000 feet maximum step altitude).
                    if (canUseTransitionCas
                        && !useTransitionCas
                        && transitionCas < casToUse
                        && currentAltitude - transitionAltitude <= BoeingPathCalculator.MAX_ALTITUDE_STEP + 762) {
                        const tasToAnticipate = AeroMath.casToTas(transitionCas, pressure, temperature);
                        const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature);
                        const [timeToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(tas, tasToAnticipate, BoeingPathCalculator.DESCENT_DECEL_VS_MPS, engineIdleNetThrust, engineCount, wingArea, 0, currentWeight, pressure, temperature, this.accelerationResult, density, soundSpeed);
                        const altitudeToDecel = timeToDecel * -BoeingPathCalculator.DESCENT_DECEL_VS_MPS;
                        const altitudeToTransition = currentAltitude - transitionAltitude;
                        // If we are within 200 meters of or past the altitude where we need to start decelerating to meet the speed
                        // transition, immediately start decelerating towards the transition speed. Otherwise, reduce the altitude
                        // step if necessary so that the next step begins at the altitude at which we are predicted to need to start
                        // decelerating to reach the target speed 100 meters above the transition altitude.
                        if (altitudeToDecel >= altitudeToTransition - 200) {
                            useTransitionCas = true;
                            isDecelerating = true;
                            decelerationCas = casToUse;
                            continue;
                        }
                        else {
                            altitudeStep = Math.min(altitudeStep, altitudeToTransition - altitudeToDecel - 100);
                        }
                    }
                }
                const thrustCorrection = this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                const engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(n1, mach) / thrustCorrection;
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                vs !== null && vs !== void 0 ? vs : (vs = Math.min(this.perfProvider.getVerticalSpeed((engineGrossThrust - this.perfProvider.getEngineRamDrag(n1, mach, pressure, temperature)) * engineCount, currentWeight, cl, tas, 0), -1));
                timeStep !== null && timeStep !== void 0 ? timeStep : (timeStep = altitudeStep / -vs);
                distanceStep !== null && distanceStep !== void 0 ? distanceStep : (distanceStep = timeStep * gs);
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg. If there is no lateral leg to advance to, then continue
                // using the current leg.
                if (distanceStep >= distanceToLegEnd) {
                    // Search forward in the lateral plan for a leg with a non-zero calculated distance until we are past the
                    // last eligible leg.
                    let searchLegIndex = currentLegIndex;
                    while (++searchLegIndex < endLegIndex) {
                        const searchLeg = lateralLegs[searchLegIndex];
                        if (searchLeg.calculated && searchLeg.calculated.distanceWithTransitions > 0) {
                            advanceLegIndexTo = searchLegIndex;
                            break;
                        }
                    }
                }
                const currentLegDistance = (_d = (_c = currentLeg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                const stepStartCas = casToUse;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    if (isDecelerating) {
                        const newTimeStep = BoeingPathCalculator.timeToDistance(distanceToLegEnd, tas, decelerationAccel);
                        // It's theoretically not possible for the result to be NaN since distanceToLegEnd is less than or equal to
                        // distanceStep. However, with rounding errors it might happen, in which case we know that the time step to
                        // the end of the leg must be very close to the originally calculated time step, so we will preserve the
                        // original time step.
                        if (!isNaN(newTimeStep)) {
                            timeStep = newTimeStep;
                        }
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                    else {
                        timeStep = distanceToLegEnd / gs;
                    }
                    altitudeStep = timeStep * -vs;
                    currentLegIndex++;
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_f = (_e = currentLeg.calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                    if (isDecelerating) {
                        decelerationCas = AeroMath.tasToCas(tas + decelerationAccel * timeStep, pressure, temperature);
                    }
                }
                totalDistanceCovered += stepDistance;
                currentVerticalPathLegDuration += timeStep;
                currentAltitude -= altitudeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    let vectorIndex;
                    let vectorType;
                    if (isInLevelDecelerationPhase) {
                        vectorType = VerticalFlightPathVectorType.LevelDeceleration;
                    }
                    else if (isDecelerating) {
                        vectorType = VerticalFlightPathVectorType.IdleDescentDeceleration;
                    }
                    else {
                        vectorType = VerticalFlightPathVectorType.IdleDescent;
                    }
                    if (isDecelerating) {
                        // If we are decelerating, we need to check if we went straight from a level deceleration into a descent
                        // deceleration. If so, we need to insert a new vector.
                        if (!decelerationVectorStarted || pathLeg.vectors[currentVerticalPathVectorIndex].type === vectorType) {
                            vectorIndex = currentVerticalPathVectorIndex;
                        }
                        else {
                            vectorIndex = ++currentVerticalPathVectorIndex;
                            decelerationVectorStarted = false;
                        }
                    }
                    else {
                        // If we are not decelerating, we need to check if the current vector is a deceleration vector that we have
                        // been extending. If so, we need to insert a new vector.
                        vectorIndex = decelerationVectorStarted ? ++currentVerticalPathVectorIndex : currentVerticalPathVectorIndex;
                        decelerationVectorStarted = false;
                    }
                    const vector = (_g = (_l = pathLeg.vectors)[vectorIndex]) !== null && _g !== void 0 ? _g : (_l[vectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    if (!isDecelerating || !decelerationVectorStarted) {
                        vector.type = vectorType;
                        vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                        vector.startAltitude = stepStartAltitude;
                        vector.startWeight = stepStartWeight;
                        vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = targetCasSource;
                        vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                        vector.targetMachSource = targetMachSource;
                        vector.startCas = UnitType.MPS.convertTo(stepStartCas, UnitType.KNOT);
                        vector.startMach = AeroMath.casToMach(stepStartCas, pressure);
                        vector.duration = timeStep;
                        decelerationVectorStarted = isDecelerating;
                    }
                    else {
                        vector.duration += timeStep;
                    }
                    vector.simEndDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = currentAltitude;
                    vector.endWeight = currentWeight;
                    if (isDecelerating) {
                        vector.endCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                        vector.endMach = AeroMath.casToMach(decelerationCas, pressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                    lastVerticalPathVectorIndex = currentVerticalPathVectorIndex;
                    lastDistanceToLegEnd = stepEndDistanceToLegEnd;
                    if (!isDecelerating || advanceLegIndexTo !== undefined) {
                        currentVerticalPathVectorIndex++;
                    }
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentLegDistance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentVerticalPathLegIndex++;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    decelerationVectorStarted = false;
                }
            }
            else {
                // The current leg is being skipped, which can only happen if it has no calculated lateral path or the lateral
                // path has a distance of zero. Therefore we insert one zero-length vector into the vertical path for the leg
                // and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_h = (_m = pathLeg.vectors)[0]) !== null && _h !== void 0 ? _h : (_m[0] = BoeingPathCalculator.createVerticalPathVector());
                let vectorType;
                if (isDecelerating) {
                    vectorType = isInLevelDecelerationPhase ? VerticalFlightPathVectorType.LevelDeceleration : VerticalFlightPathVectorType.IdleDescentDeceleration;
                }
                else {
                    vectorType = VerticalFlightPathVectorType.IdleDescent;
                }
                vector.type = vectorType;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = cruiseAltitude;
                vector.endAltitude = cruiseAltitude;
                vector.targetCas = isFinite(targetCas) ? UnitType.MPS.convertTo(targetCas, UnitType.KNOT) : NaN;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = isFinite(targetMach) ? targetMach : NaN;
                vector.targetMachSource = targetMachSource;
                if (isDecelerating) {
                    vector.startCas = UnitType.MPS.convertTo(decelerationCas, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(decelerationCas, pressure);
                }
                else {
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                }
                vector.endCas = vector.startCas;
                vector.endMach = vector.startMach;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentLeg = lateralLegs[currentLegIndex];
                distanceToLegEnd = (_k = (_j = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _j === void 0 ? void 0 : _j.distanceWithTransitions) !== null && _k !== void 0 ? _k : 0;
                lastVerticalPathLegIndex = currentVerticalPathLegIndex;
                lastVerticalPathVectorIndex = 0;
                lastDistanceToLegEnd = 0;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                decelerationVectorStarted = false;
            }
        }
        verticalPath.todLegIndex = todLegIndex;
        verticalPath.todDistanceToLegEnd = todDistanceToLegEnd;
        verticalPath.perfDescentTodDistance = estimatedTodDistance;
        verticalPath.perfDescentSimDistance = totalDistanceCovered;
        verticalPath.geoDescentSimInterceptLegIndex = lastVerticalPathLegIndex;
        verticalPath.geoDescentSimInterceptVectorIndex = lastVerticalPathVectorIndex;
        verticalPath.geoDescentSimInterceptDistanceToLegEnd = lastDistanceToLegEnd;
        verticalPath.geoDescentInterceptWeight = currentWeight;
        return totalDistanceCovered;
    }
    /**
     * Simulates the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param activeDistanceToLegEnd The along-track lateral distance, in meters, from the airplane's current position to
     * the end of the active flight plan leg.
     * @param activeWeight The current airplane weight, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, activeLegIndex, activeDistanceToLegEnd, activeWeight, engineCount) {
        var _a, _b, _c;
        const verticalPath = verticalPathEntry.path;
        if (verticalPlan.firstDescentConstraintLegIndex === undefined
            || verticalPlan.lastDescentConstraintLegIndex === undefined
            || verticalPath.geoDescentSimInterceptLegIndex === undefined
            || verticalPath.geoDescentSimInterceptVectorIndex === undefined
            || verticalPath.geoDescentSimInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptLegIndex === undefined
            || verticalPath.geoDescentInterceptDistanceToLegEnd === undefined
            || verticalPath.geoDescentInterceptWeight === undefined) {
            return;
        }
        const firstDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.firstDescentConstraintLegIndex);
        const firstDescentConstraint = verticalPlan.constraints[firstDescentConstraintIndex];
        const lastDescentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, verticalPlan.lastDescentConstraintLegIndex);
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        if (!firstDescentConstraint || !lastDescentConstraint) {
            return;
        }
        // Start simulation at the active leg, or the start of the geometric descent, whichever one comes later.
        const startAtActive = activeLegIndex > verticalPath.geoDescentSimInterceptLegIndex
            || (activeLegIndex === verticalPath.geoDescentSimInterceptLegIndex && activeDistanceToLegEnd < verticalPath.geoDescentSimInterceptDistanceToLegEnd);
        let startLegIndex = startAtActive ? activeLegIndex : verticalPath.geoDescentSimInterceptLegIndex;
        // Simulate until the MAP or the end of the flight plan, whichever one comes first.
        const endLegIndex = Math.min(lateralLegs.length, (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity);
        if (startLegIndex >= endLegIndex) {
            return;
        }
        let startDistanceToLegEnd;
        let startWeight;
        let startVerticalPathLegIndex = startLegIndex;
        let startVerticalPathVectorIndex = 0;
        let startVerticalPathLegDuration = 0;
        if (startAtActive) {
            startDistanceToLegEnd = activeDistanceToLegEnd;
            startWeight = activeWeight;
        }
        else {
            startDistanceToLegEnd = verticalPath.geoDescentSimInterceptDistanceToLegEnd;
            startWeight = verticalPath.geoDescentInterceptWeight;
            startVerticalPathVectorIndex = verticalPath.geoDescentSimInterceptVectorIndex + 1;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            for (let i = 0; i < startVerticalPathVectorIndex; i++) {
                startVerticalPathLegDuration += pathLeg.vectors[i].duration;
            }
        }
        let startLeg = lateralLegs[startLegIndex];
        // If the current leg is not calculated, we are already at or past the end of the leg, or we are initially
        // intercepting the geometric descent at the first descent constraint, advance to the next leg.
        if (!startLeg.calculated
            || startDistanceToLegEnd <= 0
            || (startLegIndex === verticalPath.geoDescentInterceptLegIndex
                && verticalPath.geoDescentInterceptLegIndex === verticalPlan.constraints[firstDescentConstraintIndex].index
                && verticalPath.geoDescentInterceptDistanceToLegEnd === 0)) {
            startLegIndex++;
            startLeg = lateralLegs[startLegIndex];
            startDistanceToLegEnd = (_c = (_b = startLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
            const pathLeg = verticalPath.legs[startVerticalPathLegIndex];
            pathLeg.vectors.length = startVerticalPathVectorIndex;
            pathLeg.simDuration = startVerticalPathLegDuration;
            startVerticalPathLegIndex = startLegIndex;
            startVerticalPathVectorIndex = 0;
            startVerticalPathLegDuration = 0;
        }
        if (startAtActive) {
            // If we are starting at the active leg, then we need to clear all vectors prior to the starting leg
            for (let i = 0; i < startLegIndex; i++) {
                const leg = verticalPath.legs[i];
                leg.vectors.length = 0;
                leg.simDistance = 0;
                leg.simDuration = 0;
            }
        }
        this.simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount);
        this.simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount);
    }
    /**
     * Performs a coarse simulation of the VNAV geometric descent phase of a flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalPathEntry The entry for the vertical flight path to which to write the results of the simulation.
     * @param lastDescentConstraintIndex The index of the last descent altitude constraint in the flight plan.
     * @param descentCas The descent calibrated airspeed to use, in meters per second.
     * @param descentMach The descent mach number to use.
     * @param transitionAltitude The descent transition altitude, in meters above MSL, or `null` if there is no
     * transition speed.
     * @param transitionCas The descent transition calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param restrictionAltitude The descent restriction altitude, in meters above MSL, or `null` if there is no
     * restriction speed.
     * @param restrictionCas The descent restriction calibrated airspeed, in meters per second, or `null` if there is no
     * transition speed.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param endLegIndex The global index of the flight plan leg at which to end the simulation, exclusive.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateCoarseGeometricDescent(lateralLegs, verticalPlan, verticalPathEntry, lastDescentConstraintIndex, descentCas, descentMach, transitionAltitude, transitionCas, restrictionAltitude, restrictionCas, startLegIndex, startDistanceToLegEnd, startWeight, endLegIndex, engineCount) {
        // Simulate coarse descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, or the next change in target airspeed, whichever is shorter.
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        var _m, _o, _p, _q;
        const verticalPath = verticalPathEntry.path;
        const lastDescentConstraint = verticalPlan.constraints[lastDescentConstraintIndex];
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        coarsePath.legIndexOffset = startLegIndex;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentLeg = lateralLegs[currentLegIndex];
        let currentCoarsePathLegIndex = 0;
        let currentCoarsePathVectorIndex = 0;
        let currentWeight = startWeight;
        let currentAltitudeConstraintIndex = -1;
        let priorAltitudeConstraintIndex = -1;
        let currentAltitudeConstraint = undefined;
        let priorAltitudeConstraint = undefined;
        let currentSpeedConstraint = this.getCurrentSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        let nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, startLegIndex, VerticalFlightPhase.Descent);
        const canUseTransitionCas = transitionAltitude !== null && transitionCas !== null;
        let useTransitionCas = false;
        const canUseRestrictionCas = restrictionAltitude !== null && restrictionCas !== null;
        let useRestrictionCas = false;
        const defaultTargetCas = descentCas;
        const defaultTargetCasSource = isFinite(descentCas) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        const defaultTargetMach = descentMach;
        const defaultTargetMachSource = isFinite(descentMach) ? VerticalFlightPathVectorSpeedSource.Schedule : VerticalFlightPathVectorSpeedSource.None;
        let legCourse = undefined;
        let lastLegCourseIndex = undefined;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentLegIndex < endLegIndex) {
            // Update the current and prior altitude constraints for the current leg.
            if (currentLegIndex <= lastDescentConstraint.index) {
                if (!currentAltitudeConstraint || currentLegIndex > currentAltitudeConstraint.index) {
                    currentAltitudeConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, currentLegIndex);
                    priorAltitudeConstraintIndex = currentAltitudeConstraintIndex + 1;
                }
            }
            else {
                currentAltitudeConstraintIndex = -1;
                priorAltitudeConstraintIndex = -1;
            }
            currentAltitudeConstraint = verticalPlan.constraints[currentAltitudeConstraintIndex];
            priorAltitudeConstraint = verticalPlan.constraints[priorAltitudeConstraintIndex];
            let distanceStep = distanceToLegEnd;
            let startAltitude;
            let endAltitude;
            let fpa; // Negative = descending path.
            // Calculate the current vector's start and end altitude and FPA.
            if (currentAltitudeConstraint && priorAltitudeConstraint) {
                // We are not past the last descent constraint.
                const verticalLeg = currentAltitudeConstraint.legs[currentAltitudeConstraint.index - currentLegIndex];
                const desiredAltitude = VNavUtils.altitudeForDistance(verticalLeg.fpa, distanceToLegEnd) + verticalLeg.altitude;
                if (desiredAltitude > priorAltitudeConstraint.targetAltitude + 1) {
                    // The desired altitude on the current leg's vertical path exceeds the prior constraint's target altitude
                    // (with tolerance to guard against floating point error and generating very short vectors when the vertical
                    // path doesn't quite line up with the lateral leg distance). Therefore we will hold the prior constraint's
                    // target altitude until we intercept the vertical path.
                    startAltitude = priorAltitudeConstraint.targetAltitude;
                    endAltitude = startAltitude;
                    fpa = 0;
                    if (verticalLeg.fpa > 0 && verticalLeg.altitude < priorAltitudeConstraint.targetAltitude) {
                        distanceStep = MathUtils.lerp(startAltitude, verticalLeg.altitude, desiredAltitude, distanceToLegEnd, 0);
                    }
                }
                else {
                    endAltitude = verticalLeg.altitude;
                    startAltitude = desiredAltitude;
                    fpa = -verticalLeg.fpa;
                }
            }
            else {
                // We are past the last descent constraint. Therefore we will hold the target altitude of the last constraint.
                startAltitude = lastDescentConstraint.targetAltitude;
                endAltitude = startAltitude;
                fpa = 0;
            }
            if (nextSpeedConstraint && currentLegIndex > nextSpeedConstraint.globalLegIndex) {
                // We passed the next speed constraint that we were tracking, so we need to set the current speed
                // constraint to what was the next speed constraint, and find the new next speed constraint.
                currentSpeedConstraint = nextSpeedConstraint;
                nextSpeedConstraint = this.getNextSpeedConstraint(verticalPlan.planIndex, currentLegIndex, VerticalFlightPhase.Descent);
            }
            if (!useTransitionCas && canUseTransitionCas) {
                if (startAltitude < transitionAltitude - 0.3048 || (startAltitude < transitionAltitude + 0.3048 && endAltitude < transitionAltitude - 0.3048)) {
                    useTransitionCas = true;
                }
            }
            if (!useRestrictionCas && canUseRestrictionCas) {
                if (startAltitude < restrictionAltitude - 0.3048 || (startAltitude < restrictionAltitude + 0.3048 && endAltitude < restrictionAltitude - 0.3048)) {
                    useRestrictionCas = true;
                }
            }
            let targetCas = defaultTargetCas;
            let targetCasSource = defaultTargetCasSource;
            let targetMach = defaultTargetMach;
            let targetMachSource = defaultTargetMachSource;
            if (currentSpeedConstraint) {
                if (currentSpeedConstraint.minCas > targetCas) {
                    targetCas = currentSpeedConstraint.minCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxCas < targetCas) {
                    targetCas = currentSpeedConstraint.maxCas;
                    targetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.minMach > targetMach) {
                    targetMach = currentSpeedConstraint.minCas;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
                if (currentSpeedConstraint.maxMach < targetMach) {
                    targetMach = currentSpeedConstraint.maxMach;
                    targetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
                }
            }
            if (useRestrictionCas && restrictionCas < targetCas) {
                targetCas = restrictionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
            }
            if (useTransitionCas && transitionCas < targetCas) {
                targetCas = transitionCas;
                targetCasSource = VerticalFlightPathVectorSpeedSource.Transition;
            }
            // If the vector didn't start below the transition altitude but will end below it, then we will end the vector
            // at the transition altitude.
            if (!useTransitionCas && canUseTransitionCas && endAltitude < transitionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(transitionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = transitionAltitude;
            }
            // If the vector didn't start below the restriction altitude but will end below it, then we will end the vector
            // at the restriction altitude.
            if (!useRestrictionCas && canUseRestrictionCas && endAltitude < restrictionAltitude - 0.3048) {
                distanceStep = MathUtils.lerp(restrictionAltitude, startAltitude, endAltitude, 0, distanceStep);
                endAltitude = restrictionAltitude;
            }
            // Check if we need to update winds and delta ISA offset.
            if (startAltitude !== lastWeatherAltitude) {
                const currentAltitudeFeet = UnitType.METER.convertTo(startAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = startAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(startAltitude);
            const temperature = AeroMath.isaTemperature(startAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(targetCas, AeroMath.machToCas(targetMach, pressure));
            if (currentLeg.calculated && currentLeg.calculated.distanceWithTransitions > 0) {
                if (currentLegIndex !== lastLegCourseIndex) {
                    if (currentLeg.calculated.startLat !== undefined
                        && currentLeg.calculated.startLon !== undefined
                        && currentLeg.calculated.endLat !== undefined
                        && currentLeg.calculated.endLon !== undefined) {
                        legCourse = GeoPoint.finalBearing(currentLeg.calculated.startLat, currentLeg.calculated.startLon, currentLeg.calculated.endLat, currentLeg.calculated.endLon);
                        if (!isFinite(legCourse)) {
                            legCourse = undefined;
                        }
                    }
                    else {
                        legCourse = undefined;
                    }
                    lastLegCourseIndex = currentLegIndex;
                }
                // Find the average wind component along the lateral flight path for the current leg.
                let wind = 0;
                if (windVector && windVector[1] > 0 && legCourse !== undefined) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(legCourse, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                const mach = AeroMath.casToMach(casToTarget, pressure);
                const tas = AeroMath.machToTas(mach, soundSpeed);
                const gs = tas + wind;
                const vs = gs * Math.tan(fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                if (distanceStep >= distanceToLegEnd - 1e-3) {
                    distanceStep = distanceToLegEnd;
                }
                const timeStep = distanceStep / gs;
                const netThrustRequired = vs === 0
                    ? this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0)
                    : this.perfProvider.getRequiredThrust(currentWeight, cl, tas, vs, 0);
                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                const idleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature) * engineCount;
                // If the net thrust required to fly the vertical path is less than the net thrust provided with engines at
                // idle, then use idle fuel flow since engines can't go below idle.
                const engineGrossThrust = netThrustRequired <= idleNetThrust
                    ? this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach)
                    : this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg before the end of the altitude step. If so, end the step at the
                // end of the leg instead and advance the lateral leg.
                let advanceLegIndexTo = undefined;
                if (distanceStep >= distanceToLegEnd) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const currentLegDistance = currentLeg.calculated.distanceWithTransitions;
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = startAltitude;
                const stepStartWeight = currentWeight;
                let stepDistance;
                let stepEndDistanceToLegEnd;
                if (advanceLegIndexTo !== undefined) {
                    stepEndDistanceToLegEnd = 0;
                    stepDistance = distanceToLegEnd;
                    currentLegIndex = advanceLegIndexTo;
                    if (currentLegIndex < endLegIndex) {
                        currentLeg = lateralLegs[advanceLegIndexTo];
                        distanceToLegEnd = (_c = (_b = currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.distanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
                    }
                }
                else {
                    stepDistance = distanceStep;
                    stepEndDistanceToLegEnd = distanceToLegEnd - stepDistance;
                    distanceToLegEnd = stepEndDistanceToLegEnd;
                }
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (stepDistance > 0 || (currentCoarsePathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = (_d = (_m = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _d !== void 0 ? _d : (_m[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                    const vector = (_e = (_o = pathLeg.vectors)[currentCoarsePathVectorIndex]) !== null && _e !== void 0 ? _e : (_o[currentCoarsePathVectorIndex] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    vector.targetCas = targetCas;
                    vector.targetCasSource = targetCasSource;
                    vector.targetMach = targetMach;
                    vector.targetMachSource = targetMachSource;
                    vector.fpa = fpa;
                    vector.endDistanceToLegEnd = stepEndDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentCoarsePathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const pathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    pathLeg.vectors.length = currentCoarsePathVectorIndex;
                    pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                    pathLeg.distance = currentLegDistance;
                    pathLeg.course = legCourse;
                    currentCoarsePathLegIndex = advanceLegIndexTo - startLegIndex;
                    currentCoarsePathVectorIndex = 0;
                }
            }
            else {
                // The current leg has no calculated lateral path or the lateral path has a distance of zero. Therefore we
                // insert one zero-length vector into the vertical path for the leg and advance to the next leg.
                const pathLeg = (_f = (_p = coarsePath.legs)[currentCoarsePathLegIndex]) !== null && _f !== void 0 ? _f : (_p[currentCoarsePathLegIndex] = BoeingPathCalculator.createGeometricDescentCoarseLeg());
                const vector = (_g = (_q = pathLeg.vectors)[0]) !== null && _g !== void 0 ? _g : (_q[0] = BoeingPathCalculator.createGeometricDescentCoarseVector());
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = startAltitude;
                vector.endAltitude = endAltitude;
                vector.targetCas = targetCas;
                vector.targetCasSource = targetCasSource;
                vector.targetMach = targetMach;
                vector.targetMachSource = targetMachSource;
                vector.fpa = 0;
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                pathLeg.vectors.length = 1;
                pathLeg.altitudeConstraintIndex = currentAltitudeConstraintIndex;
                pathLeg.distance = 0;
                pathLeg.course = undefined;
                currentLegIndex++;
                if (currentLegIndex < endLegIndex) {
                    currentLeg = lateralLegs[currentLegIndex];
                    distanceToLegEnd = (_j = (_h = currentLeg.calculated) === null || _h === void 0 ? void 0 : _h.distanceWithTransitions) !== null && _j !== void 0 ? _j : 0;
                }
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
            }
        }
        // Delete all coarse path legs after the last simulated leg.
        coarsePath.legs.length = currentCoarsePathLegIndex;
        if (coarsePath.legs.length === 0) {
            return;
        }
        // Compute estimated deceleration times and distances.
        // Get the speed constraint in effect after sequencing the last leg.
        const endSpeedConstraint = nextSpeedConstraint && endLegIndex > nextSpeedConstraint.globalLegIndex ? nextSpeedConstraint : undefined;
        let endTargetCas = defaultTargetCas;
        let endTargetCasSource = defaultTargetCasSource;
        let endTargetMach = defaultTargetMach;
        let endTargetMachSource = defaultTargetMachSource;
        if (endSpeedConstraint) {
            if (endSpeedConstraint.minCas > endTargetCas) {
                endTargetCas = endSpeedConstraint.minCas;
                endTargetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.maxCas < endTargetCas) {
                endTargetCas = endSpeedConstraint.maxCas;
                endTargetCasSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.minMach > endTargetMach) {
                endTargetMach = endSpeedConstraint.minCas;
                endTargetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
            if (endSpeedConstraint.maxMach < endTargetMach) {
                endTargetMach = endSpeedConstraint.maxMach;
                endTargetMachSource = VerticalFlightPathVectorSpeedSource.FlightPlan;
            }
        }
        if (useRestrictionCas && restrictionCas < endTargetCas) {
            endTargetCas = restrictionCas;
            endTargetCasSource = VerticalFlightPathVectorSpeedSource.Restriction;
        }
        if (useTransitionCas && transitionCas < endTargetMach) {
            endTargetCas = transitionCas;
            endTargetMachSource = VerticalFlightPathVectorSpeedSource.Transition;
        }
        let distanceToEnd = 0;
        let nextVector;
        let nextCasToTarget;
        let anticipatedTargetCas = Infinity;
        let anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
        let anticipatedTargetMach = Infinity;
        let anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
        for (let i = coarsePath.legs.length - 1; i >= 0; i--) {
            const leg = coarsePath.legs[i];
            for (let j = leg.vectors.length - 1; j >= 0; j--) {
                const vector = leg.vectors[j];
                // Check if we need to update winds and delta ISA offset.
                if (lastWeatherAltitude === undefined || Math.abs(vector.endAltitude - lastWeatherAltitude) > 1) {
                    const currentAltitudeFeet = UnitType.METER.convertTo(vector.endAltitude, UnitType.FOOT);
                    windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                    deltaIsa = (_k = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _k !== void 0 ? _k : 0;
                    lastWeatherAltitude = vector.endAltitude;
                }
                const pressure = AeroMath.isaPressure(vector.endAltitude);
                const casToTarget = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, pressure));
                if (nextCasToTarget === undefined) {
                    // If nextCasToTarget is undefined, then we are not extending deceleration from the succeeding vector (the
                    // previous one to be iterated) into the current vector. Therefore, we will set the anticipated speed values to
                    // be equal to the target speed at the beginning of the succeeding vector.
                    if (nextVector) {
                        nextCasToTarget = Math.min(nextVector.targetCas, AeroMath.machToCas(nextVector.targetMach, pressure));
                        anticipatedTargetCas = nextVector.targetCas;
                        anticipatedTargetCasSource = nextVector.targetCasSource;
                        anticipatedTargetMach = nextVector.targetMach;
                        anticipatedTargetMachSource = nextVector.targetMachSource;
                    }
                    else {
                        nextCasToTarget = Math.min(endTargetCas, AeroMath.machToCas(endTargetMach, pressure));
                        anticipatedTargetCas = endTargetCas;
                        anticipatedTargetCasSource = endTargetCasSource;
                        anticipatedTargetMach = endTargetMach;
                        anticipatedTargetMachSource = endTargetMachSource;
                    }
                }
                if (isFinite(casToTarget) && isFinite(nextCasToTarget) && nextCasToTarget < casToTarget - 0.5) {
                    // We need to decelerate.
                    const initialMach = AeroMath.casToMach(casToTarget, pressure);
                    const finalMach = AeroMath.casToMach(nextCasToTarget, pressure);
                    const temperature = AeroMath.isaTemperature(vector.endAltitude) + deltaIsa;
                    const density = AeroMath.densityAir(pressure, temperature);
                    const soundSpeed = AeroMath.soundSpeedAir(temperature);
                    const initialTas = AeroMath.machToTas(initialMach, soundSpeed);
                    const finalTas = AeroMath.machToTas(finalMach, soundSpeed);
                    // Find the wind component along the leg's course.
                    let wind = 0;
                    if (leg.course !== undefined && windVector && windVector[0] > 0) {
                        wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS) * Math.cos(MathUtils.diffAngleDeg(leg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                    }
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(initialTas, finalTas));
                    const initialGs = initialTas + wind;
                    const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, initialMach);
                    const engineIdleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, initialMach, pressure, temperature);
                    const vs = VNavUtils.altitudeForDistance(vector.fpa, initialGs);
                    const [timeToDecel, distanceToDecel] = this.perfProvider.estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineIdleNetThrust, engineCount, wingArea, 0, vector.endWeight, pressure, temperature, this.accelerationResult, density, soundSpeed, BoeingPathCalculator.MIN_DESCENT_ACCELERATION);
                    vector.estimatedDecelTime = timeToDecel;
                    vector.estimatedDecelDistance = distanceToDecel + wind * timeToDecel;
                    vector.estimatedDecelStartTas = initialTas;
                    vector.estimatedDecelEndTas = finalTas;
                    vector.estimatedDecelWind = wind;
                    vector.anticipatedTargetCas = anticipatedTargetCas;
                    vector.anticipatedTargetCasSource = anticipatedTargetCasSource;
                    vector.anticipatedTargetMach = anticipatedTargetMach;
                    vector.anticipatedTargetMachSource = anticipatedTargetMachSource;
                    const vectorDistance = vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
                    if (vector.estimatedDecelDistance > vectorDistance) {
                        // The distance required to decelerate is longer than the vector. Therefore, we need to determine the
                        // speed at the start of the vector such that a deceleration starting at that speed will reach the
                        // anticipated target speed at the end of the vector.
                        const acceleration = (finalTas - initialTas) / timeToDecel;
                        vector.estimatedDecelTime = BoeingPathCalculator.timeToDistance(vectorDistance, initialTas + wind, acceleration);
                        vector.estimatedDecelDistance = vectorDistance;
                        // Check if we need to get updated weather data for the altitude at the start of the vector.
                        if (lastWeatherAltitude === undefined || Math.abs(vector.startAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(vector.startAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_l = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _l !== void 0 ? _l : 0;
                            lastWeatherAltitude = vector.startAltitude;
                        }
                        const vectorStartPressure = AeroMath.isaPressure(vector.startAltitude);
                        const vectorStartSoundSpeed = AeroMath.soundSpeedIsa(vector.startAltitude, deltaIsa);
                        let vectorStartTas = finalTas - acceleration * vector.estimatedDecelTime;
                        let vectorStartCas = AeroMath.machToCas(AeroMath.tasToMach(vectorStartTas, vectorStartSoundSpeed), vectorStartPressure);
                        // If the altitude is different between the start and end of the vector, then we need to make sure that the
                        // different airspeed conversions don't result in the estimated CAS at the start of the vector being less
                        // than the anticipated CAS at the end of the vector.
                        if (vectorStartCas < nextCasToTarget) {
                            vectorStartCas = nextCasToTarget;
                            vectorStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartCas, vectorStartPressure), vectorStartSoundSpeed);
                        }
                        // Check if the estimated CAS at the start of the vector is less than the (non-anticipated) target CAS at
                        // the start of the vector. If it is, then we need to extend the deceleration into the preceding vector
                        // (the next one to be iterated). If it is not, then we will have the deceleration start at the beginning
                        // of the vector at the non-anticipated target speed.
                        const vectorStartTargetCas = Math.min(vector.targetCas, AeroMath.machToCas(vector.targetMach, vectorStartPressure));
                        if (vectorStartCas < vectorStartTargetCas) {
                            vector.estimatedDecelStartTas = vectorStartTas;
                            // Set nextCasToTarget so that the preceding vector (the next one to be iterated) will anticipate the
                            // speed at the start of this vector required to meet this vector's anticipated speed target instead of
                            // this vector's target speed.
                            nextCasToTarget = vectorStartCas;
                        }
                        else {
                            vector.estimatedDecelStartTas = AeroMath.machToTas(AeroMath.casToMach(vectorStartTargetCas, vectorStartPressure), vectorStartSoundSpeed);
                            nextCasToTarget = undefined;
                        }
                    }
                    else {
                        nextCasToTarget = undefined;
                    }
                }
                else {
                    vector.estimatedDecelTime = 0;
                    vector.estimatedDecelDistance = 0;
                    vector.estimatedDecelStartTas = 0;
                    vector.estimatedDecelEndTas = 0;
                    vector.estimatedDecelWind = 0;
                    vector.anticipatedTargetCas = Infinity;
                    vector.anticipatedTargetCasSource = VerticalFlightPathVectorSpeedSource.None;
                    vector.anticipatedTargetMach = Infinity;
                    vector.anticipatedTargetMachSource = VerticalFlightPathVectorSpeedSource.None;
                    nextCasToTarget = undefined;
                }
                nextVector = vector;
            }
            leg.endDistanceToEnd = distanceToEnd;
            distanceToEnd += leg.distance;
        }
    }
    /**
     * Performs a detailed simulation of the VNAV geometric descent phase of a flight plan.
     * @param verticalPathEntry The entry for the vertical flight path.
     * @param startLegIndex The global index of the flight plan leg at which to start the simulation.
     * @param startDistanceToLegEnd The distance from the point at which to start the simulation to the end of its
     * containing leg, in meters.
     * @param startVerticalPathLegIndex The index of the vertical path leg at which to start the simulation.
     * @param startVerticalPathVectorIndex The within-leg index of the vertical path vector at which to start the
     * simulation.
     * @param startVerticalPathLegDuration The total duration, in seconds, of all vertical path vectors in the leg
     * containing the start of the simulation that are situated prior to the start point.
     * @param startWeight The airplane's gross weight at the start of the simulation, in pounds.
     * @param engineCount The number of operational engines to simulate.
     */
    simulateDetailedGeometricDescent(verticalPathEntry, startLegIndex, startDistanceToLegEnd, startVerticalPathLegIndex, startVerticalPathVectorIndex, startVerticalPathLegDuration, startWeight, engineCount) {
        // Simulate descent steps. Each step covers the distance to the end of the next lateral leg, the next
        // change in FPA, the next change in target airspeed, or 1000 feet of descent, whichever is shorter.
        var _a, _b, _c, _d, _e;
        var _f, _g;
        const verticalPath = verticalPathEntry.path;
        const coarsePath = verticalPathEntry.geoDescentCoarsePath;
        const wingArea = this.perfProvider.getWingArea();
        let currentLegIndex = startLegIndex;
        let distanceToLegEnd = startDistanceToLegEnd;
        let currentVerticalPathLegIndex = startVerticalPathLegIndex;
        let currentVerticalPathVectorIndex = startVerticalPathVectorIndex;
        let currentVerticalPathLegDuration = startVerticalPathLegDuration;
        let currentWeight = startWeight;
        let currentCoarsePathLegIndex = startLegIndex - coarsePath.legIndexOffset;
        let currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
        let currentCoarsePathVectorIndex = 0;
        let windVector = null;
        let deltaIsa = 0;
        let lastWeatherAltitude = undefined;
        while (currentCoarsePathLegIndex < coarsePath.legs.length) {
            // Find the coarse path vector containing the current position in the simulation.
            let coarsePathVector = currentCoarsePathLeg.vectors[currentCoarsePathVectorIndex];
            while (currentCoarsePathVectorIndex < currentCoarsePathLeg.vectors.length - 1 && coarsePathVector.endDistanceToLegEnd > distanceToLegEnd) {
                coarsePathVector = currentCoarsePathLeg.vectors[++currentCoarsePathVectorIndex];
            }
            // If the current coarse path vector has zero length, then currentAltitude will be set to the start altitude
            // because lerp() defaults to y0 when x0 and x1 are equal.
            const currentAltitude = MathUtils.lerp(distanceToLegEnd, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude, true, true);
            let altitudeStep;
            let distanceStep;
            // Check if we need to update winds and delta ISA offset.
            if (lastWeatherAltitude === undefined || Math.abs(currentAltitude - lastWeatherAltitude) > 1) {
                const currentAltitudeFeet = UnitType.METER.convertTo(currentAltitude, UnitType.FOOT);
                windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                deltaIsa = (_a = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _a !== void 0 ? _a : 0;
                lastWeatherAltitude = currentAltitude;
            }
            // Ambient conditions
            const pressure = AeroMath.isaPressure(currentAltitude);
            const temperature = AeroMath.isaTemperature(currentAltitude) + deltaIsa;
            const density = AeroMath.densityAir(pressure, temperature);
            const soundSpeed = AeroMath.soundSpeedAir(temperature);
            const currentWeightNewtons = UnitType.POUND_FORCE.convertTo(currentWeight, UnitType.NEWTON);
            const casToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, pressure));
            if (currentCoarsePathLeg.distance > 0) {
                // Find the wind component along the leg's course.
                let wind = 0;
                if (currentCoarsePathLeg.course !== undefined && windVector && windVector[0] > 0) {
                    wind = UnitType.KNOT.convertTo(windVector[1], UnitType.MPS)
                        * Math.cos(MathUtils.diffAngleDeg(currentCoarsePathLeg.course, windVector[0] + 180, false) * Avionics.Utils.DEG2RAD);
                }
                let maxDistanceStep;
                let isDecelerating;
                let acceleration;
                if (coarsePathVector.estimatedDecelTime > 0) {
                    // The current coarse path vector ends with a deceleration to an anticipated target speed.
                    const decelStartDistanceToLegEnd = coarsePathVector.estimatedDecelDistance + coarsePathVector.endDistanceToLegEnd;
                    if (decelStartDistanceToLegEnd > distanceToLegEnd - 1e-3) {
                        // We are currently decelerating.
                        maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                        isDecelerating = true;
                        acceleration = (coarsePathVector.estimatedDecelEndTas - coarsePathVector.estimatedDecelStartTas) / coarsePathVector.estimatedDecelTime;
                    }
                    else {
                        // We have not yet reached the point where deceleration starts. We need to ensure that the current vector
                        // does not extend beyond the deceleration start point.
                        maxDistanceStep = distanceToLegEnd - decelStartDistanceToLegEnd;
                        isDecelerating = false;
                        acceleration = 0;
                    }
                }
                else {
                    // The current coarse path vector does not end with a deceleration.
                    maxDistanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    isDecelerating = false;
                    acceleration = 0;
                }
                if (coarsePathVector.fpa < 0) {
                    const maxAltitudeStep = currentAltitude - MathUtils.lerp(distanceToLegEnd - maxDistanceStep, coarsePathVector.startDistanceToLegEnd, coarsePathVector.endDistanceToLegEnd, coarsePathVector.startAltitude, coarsePathVector.endAltitude);
                    if (maxAltitudeStep > BoeingPathCalculator.MAX_ALTITUDE_STEP + BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_ALTITUDE_STEP / maxAltitudeStep * maxDistanceStep;
                        altitudeStep = BoeingPathCalculator.MAX_ALTITUDE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                        altitudeStep = maxAltitudeStep;
                    }
                }
                else {
                    if (maxDistanceStep > BoeingPathCalculator.MAX_DISTANCE_STEP + BoeingPathCalculator.MAX_DISTANCE_STEP_TOL) {
                        distanceStep = BoeingPathCalculator.MAX_DISTANCE_STEP;
                    }
                    else {
                        distanceStep = maxDistanceStep;
                    }
                    altitudeStep = 0;
                }
                let endDistanceToLegEnd;
                let endAltitude;
                let shouldAdvanceVector;
                // Check if we need to advance to the next coarse path vector after the current step, with tolerance for
                // floating point errors.
                if (distanceToLegEnd - distanceStep < coarsePathVector.endDistanceToLegEnd + 1e-3) {
                    distanceStep = distanceToLegEnd - coarsePathVector.endDistanceToLegEnd;
                    endDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd;
                    endAltitude = coarsePathVector.endAltitude;
                    shouldAdvanceVector = true;
                }
                else {
                    endDistanceToLegEnd = distanceToLegEnd - distanceStep;
                    endAltitude = currentAltitude - altitudeStep;
                    shouldAdvanceVector = false;
                }
                let startCas;
                let startMach;
                let endCas;
                let endMach;
                let mach;
                let tas;
                let gs;
                let timeStep;
                if (isDecelerating) {
                    const decelStartDistanceToLegEnd = coarsePathVector.endDistanceToLegEnd + coarsePathVector.estimatedDecelDistance;
                    const startTimeToDecelEnd = distanceToLegEnd >= decelStartDistanceToLegEnd - 1
                        ? coarsePathVector.estimatedDecelTime
                        : BoeingPathCalculator.timeToDistance(distanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const endTimeToDecelEnd = endDistanceToLegEnd <= coarsePathVector.endDistanceToLegEnd + 1
                        ? 0
                        : BoeingPathCalculator.timeToDistance(endDistanceToLegEnd - coarsePathVector.endDistanceToLegEnd, coarsePathVector.estimatedDecelEndTas + coarsePathVector.estimatedDecelWind, -acceleration);
                    const startTas = coarsePathVector.estimatedDecelEndTas - acceleration * startTimeToDecelEnd;
                    const endTas = coarsePathVector.estimatedDecelEndTas - acceleration * endTimeToDecelEnd;
                    tas = startTas;
                    mach = AeroMath.tasToMach(tas, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - Math.min(startTas, endTas));
                    gs = tas + wind;
                    timeStep = BoeingPathCalculator.timeToDistance(distanceStep, gs, acceleration);
                    if (!isFinite(timeStep)) {
                        timeStep = distanceStep / ((startTas + endTas) / 2 + wind);
                    }
                    if (altitudeStep > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_b = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _b !== void 0 ? _b : 0;
                            lastWeatherAltitude = endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(endAltitude, deltaIsa);
                        endMach = AeroMath.tasToMach(endTas, endSoundSpeed);
                        endCas = AeroMath.machToCas(endMach, endPressure);
                    }
                    else {
                        endMach = AeroMath.tasToMach(endTas, soundSpeed);
                        endCas = AeroMath.machToCas(endMach, pressure);
                    }
                    startMach = AeroMath.tasToMach(startTas, soundSpeed);
                    startCas = AeroMath.machToCas(startMach, pressure);
                    if (startCas < endCas) {
                        startCas = endCas;
                        startMach = AeroMath.casToMach(startCas, pressure);
                    }
                }
                else {
                    mach = AeroMath.casToMach(casToTarget, pressure);
                    tas = AeroMath.machToTas(mach, soundSpeed);
                    // Clamp wind to guarantee positive ground speed.
                    wind = Math.max(wind, BoeingPathCalculator.MIN_GROUND_SPEED - tas);
                    gs = tas + wind;
                    timeStep = distanceStep / gs;
                    startCas = casToTarget;
                    startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (altitudeStep > 1) {
                        const endPressure = AeroMath.isaPressure(endAltitude);
                        const endCasToTarget = coarsePathVector.targetCas;
                        const endMachCasToTarget = AeroMath.machToCas(coarsePathVector.targetMach, endPressure);
                        if (endMachCasToTarget <= endCasToTarget) {
                            endCas = endMachCasToTarget;
                            endMach = coarsePathVector.targetMach;
                        }
                        else {
                            endCas = endCasToTarget;
                            endMach = AeroMath.casToMach(casToTarget, endPressure);
                        }
                    }
                    else {
                        endCas = startCas;
                        endMach = startMach;
                    }
                }
                const vs = gs * Math.tan(coarsePathVector.fpa * Avionics.Utils.DEG2RAD);
                const cl = AeroMath.liftCoefficient(currentWeightNewtons, wingArea, density, tas);
                let engineGrossThrust;
                const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(temperature, mach);
                if (isDecelerating) {
                    // Assume engines are at idle if we are decelerating.
                    engineGrossThrust = this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach);
                }
                else {
                    const netThrustRequired = vs === 0
                        ? this.perfProvider.getLevelFlightRequiredThrust(currentWeight, cl, 0)
                        : this.perfProvider.getRequiredThrust(currentWeight, cl, tas, vs, 0);
                    const idleNetThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, mach, pressure, temperature) * engineCount;
                    // If the net thrust required to fly the vertical path is less than the net thrust provided with engines at
                    // idle, then use idle fuel flow since engines can't go below idle.
                    engineGrossThrust = netThrustRequired <= idleNetThrust
                        ? this.perfProvider.getEngineCorrectedGrossThrust(idleN1, mach) / this.perfProvider.getThrustCorrectionFactor(pressure, mach)
                        : this.perfProvider.estimateGrossThrustFromNetThrust(netThrustRequired / engineCount, mach, pressure, temperature);
                }
                const engineFuelFlow = this.perfProvider.getEngineFuelFlow(engineGrossThrust) / 3600;
                // Check if we reach the end of the current leg at the end of the step. If so, advance to the next leg.
                let advanceLegIndexTo = undefined;
                if (shouldAdvanceVector && currentCoarsePathVectorIndex + 1 >= currentCoarsePathLeg.vectors.length) {
                    advanceLegIndexTo = currentLegIndex + 1;
                }
                const stepStartDistanceToLegEnd = distanceToLegEnd;
                const stepStartAltitude = currentAltitude;
                const stepStartWeight = currentWeight;
                distanceToLegEnd = endDistanceToLegEnd;
                currentVerticalPathLegDuration += timeStep;
                currentWeight = Math.max(0, currentWeight - timeStep * engineFuelFlow * engineCount);
                // If we advanced a positive distance forward or we are advancing legs and no vectors have been added to the
                // current leg path, then insert a new vertical path vector describing the simulated step.
                if (distanceStep > 0 || (currentVerticalPathVectorIndex === 0 && advanceLegIndexTo !== undefined)) {
                    const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                    const vector = (_c = (_f = pathLeg.vectors)[currentVerticalPathVectorIndex]) !== null && _c !== void 0 ? _c : (_f[currentVerticalPathVectorIndex] = BoeingPathCalculator.createVerticalPathVector());
                    vector.gs = gs;
                    vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                    vector.simStartDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startDistanceToLegEnd = stepStartDistanceToLegEnd;
                    vector.startAltitude = stepStartAltitude;
                    vector.startWeight = stepStartWeight;
                    if (isDecelerating) {
                        vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                        vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    }
                    else {
                        vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                        vector.targetCasSource = coarsePathVector.targetCasSource;
                        vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                        vector.targetMachSource = coarsePathVector.targetMachSource;
                    }
                    vector.startCas = UnitType.MPS.convertTo(startCas, UnitType.KNOT);
                    vector.startMach = startMach;
                    vector.endCas = UnitType.MPS.convertTo(endCas, UnitType.KNOT);
                    vector.endMach = endMach;
                    vector.duration = timeStep;
                    vector.simEndDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endDistanceToLegEnd = endDistanceToLegEnd;
                    vector.endAltitude = endAltitude;
                    vector.endWeight = currentWeight;
                    currentVerticalPathVectorIndex++;
                }
                // If we are advancing legs, then remove all vertical path vectors in the old leg after the ones we inserted
                // and update leg data.
                if (advanceLegIndexTo !== undefined) {
                    const leg = verticalPath.legs[currentVerticalPathLegIndex];
                    leg.vectors.length = currentVerticalPathVectorIndex;
                    leg.simDistance = currentCoarsePathLeg.distance;
                    leg.simDuration = currentVerticalPathLegDuration;
                    currentLegIndex = advanceLegIndexTo;
                    currentVerticalPathLegIndex = advanceLegIndexTo;
                    currentVerticalPathVectorIndex = 0;
                    currentVerticalPathLegDuration = 0;
                    currentCoarsePathLegIndex = advanceLegIndexTo - coarsePath.legIndexOffset;
                    currentCoarsePathVectorIndex = 0;
                    if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                        currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                        distanceToLegEnd = currentCoarsePathLeg.distance;
                    }
                }
                else if (shouldAdvanceVector) {
                    currentCoarsePathVectorIndex++;
                }
            }
            else {
                // The current leg has a distance of zero. Therefore we insert one zero-length vector into the vertical path
                // for the leg and advance to the next leg.
                const pathLeg = verticalPath.legs[currentVerticalPathLegIndex];
                const vector = (_d = (_g = pathLeg.vectors)[0]) !== null && _d !== void 0 ? _d : (_g[0] = BoeingPathCalculator.createVerticalPathVector());
                const isDecelerating = coarsePathVector.anticipatedTargetCasSource !== VerticalFlightPathVectorSpeedSource.None
                    || coarsePathVector.anticipatedTargetMachSource !== VerticalFlightPathVectorSpeedSource.None;
                vector.gs = AeroMath.casToTas(casToTarget, pressure, temperature);
                vector.type = isDecelerating ? VerticalFlightPathVectorType.GeometricDescentDeceleration : VerticalFlightPathVectorType.GeometricDescent;
                vector.simStartDistanceToLegEnd = 0;
                vector.simEndDistanceToLegEnd = 0;
                vector.startDistanceToLegEnd = 0;
                vector.endDistanceToLegEnd = 0;
                vector.startAltitude = coarsePathVector.startAltitude;
                vector.endAltitude = coarsePathVector.endAltitude;
                if (isDecelerating) {
                    vector.targetCas = isFinite(coarsePathVector.anticipatedTargetCas) ? UnitType.MPS.convertTo(coarsePathVector.anticipatedTargetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.anticipatedTargetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.anticipatedTargetMach) ? coarsePathVector.anticipatedTargetMach : NaN;
                    vector.targetMachSource = coarsePathVector.anticipatedTargetMachSource;
                    vector.startMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelStartTas, soundSpeed);
                    vector.startCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.startMach, pressure), UnitType.KNOT);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        // Check if we need to update winds and delta ISA offset.
                        if (lastWeatherAltitude === undefined || Math.abs(coarsePathVector.endAltitude - lastWeatherAltitude) > 1) {
                            const currentAltitudeFeet = UnitType.METER.convertTo(coarsePathVector.endAltitude, UnitType.FOOT);
                            windVector = this.windPlanner.getInterpolatedDescentWind(verticalPath.planIndex, currentAltitudeFeet, true, BoeingPathCalculator.windCache[0]);
                            deltaIsa = (_e = this.windPlanner.getInterpolatedDescentIsaDelta(verticalPath.planIndex, currentAltitudeFeet, true)) !== null && _e !== void 0 ? _e : 0;
                            lastWeatherAltitude = coarsePathVector.endAltitude;
                        }
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endSoundSpeed = AeroMath.soundSpeedIsa(coarsePathVector.endAltitude, deltaIsa);
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, endSoundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, endPressure), UnitType.KNOT);
                    }
                    else {
                        vector.endMach = AeroMath.tasToMach(coarsePathVector.estimatedDecelEndTas, soundSpeed);
                        vector.endCas = UnitType.MPS.convertTo(AeroMath.machToCas(vector.endMach, pressure), UnitType.KNOT);
                    }
                }
                else {
                    vector.targetCas = isFinite(coarsePathVector.targetCas) ? UnitType.MPS.convertTo(coarsePathVector.targetCas, UnitType.KNOT) : NaN;
                    vector.targetCasSource = coarsePathVector.targetCasSource;
                    vector.targetMach = isFinite(coarsePathVector.targetMach) ? coarsePathVector.targetMach : NaN;
                    vector.targetMachSource = coarsePathVector.targetMachSource;
                    vector.startCas = UnitType.MPS.convertTo(casToTarget, UnitType.KNOT);
                    vector.startMach = AeroMath.casToMach(casToTarget, pressure);
                    if (Math.abs(coarsePathVector.endAltitude - coarsePathVector.startAltitude) > 1) {
                        const endPressure = AeroMath.isaPressure(coarsePathVector.endAltitude);
                        const endCasToTarget = Math.min(coarsePathVector.targetCas, AeroMath.machToCas(coarsePathVector.targetMach, endPressure));
                        vector.endMach = UnitType.MPS.convertTo(endCasToTarget, UnitType.KNOT);
                        vector.endCas = AeroMath.casToMach(endCasToTarget, endPressure);
                    }
                    else {
                        vector.endCas = vector.startCas;
                        vector.endMach = vector.startMach;
                    }
                    vector.endCas = vector.startCas;
                    vector.endMach = vector.startMach;
                }
                vector.startWeight = currentWeight;
                vector.endWeight = currentWeight;
                vector.duration = 0;
                pathLeg.vectors.length = 1;
                pathLeg.simDistance = 0;
                pathLeg.simDuration = 0;
                currentLegIndex++;
                currentVerticalPathLegIndex++;
                currentVerticalPathVectorIndex = 0;
                currentVerticalPathLegDuration = 0;
                currentCoarsePathLegIndex++;
                currentCoarsePathVectorIndex = 0;
                if (currentCoarsePathLegIndex < coarsePath.legs.length) {
                    currentCoarsePathLeg = coarsePath.legs[currentCoarsePathLegIndex];
                    distanceToLegEnd = currentCoarsePathLeg.distance;
                }
            }
        }
    }
    /**
     * Gets the time required to travel a given distance with constant acceleration.
     * @param distance The distance to travel.
     * @param v0 The initial velocity. The value should be expressed in units of `distance` per unit time.
     * @param acceleration The acceleration. The value should be expressed in units of `distance` per unit time squared.
     * @returns The time required to travel the specified distance given the specified constant acceleration from the
     * initial velocity. The value is expressed in the unit of time chosen for `v0` and `acceleration`.
     */
    static timeToDistance(distance, v0, acceleration) {
        if (acceleration === 0) {
            return distance / v0;
        }
        const a = acceleration / 2;
        const b = v0;
        const c = -distance;
        return (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);
    }
    /**
     * Creates a new speed constraint list item.
     * @returns A new speed constraint list item.
     */
    static createSpeedConstraintListItem() {
        return {
            globalLegIndex: 0,
            flightPhase: VerticalFlightPhase.Climb,
            speedConstraint: {
                speedDesc: SpeedRestrictionType.Unused,
                speed: 0,
                speedUnit: SpeedUnit.IAS
            },
            isMissedApproach: false,
            minCas: -Infinity,
            maxCas: Infinity,
            minMach: -Infinity,
            maxMach: Infinity
        };
    }
    /**
     * Creates a new vertical flight path.
     * @param planIndex The index of the path's associated flight plan. Defaults to `0`.
     * @returns A new vertical flight path.
     */
    static createVerticalPath(planIndex = 0) {
        return {
            planIndex,
            legs: [],
            isPending: false,
            tocLegIndex: undefined,
            tocDistanceToLegEnd: undefined,
            tocWeight: undefined,
            todLegIndex: undefined,
            todDistanceToLegEnd: undefined,
            perfDescentTodDistance: undefined,
            perfDescentSimDistance: undefined,
            geoDescentInterceptLegIndex: undefined,
            geoDescentInterceptDistanceToLegEnd: undefined,
            geoDescentSimInterceptLegIndex: undefined,
            geoDescentSimInterceptVectorIndex: undefined,
            geoDescentSimInterceptDistanceToLegEnd: undefined,
            geoDescentInterceptWeight: undefined
        };
    }
    /**
     * Creates a new vertical flight path leg.
     * @returns A new vertical flight path leg.
     */
    static createVerticalPathLeg() {
        return {
            vectors: [],
            simDistance: 0,
            simDuration: 0
        };
    }
    /**
     * Creates a new vertical flight path vector.
     * @returns A new vertical flight path vector.
     */
    static createVerticalPathVector() {
        return {
            type: VerticalFlightPathVectorType.Climb,
            simStartDistanceToLegEnd: 0,
            simEndDistanceToLegEnd: 0,
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: NaN,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: NaN,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            startCas: 0,
            startMach: 0,
            endCas: 0,
            endMach: 0,
            gs: 0,
            startWeight: 0,
            endWeight: 0,
            duration: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path.
     * @returns A new geometric descent coarse vertical flight path.
     */
    static createGeometricDescentCoarsePath() {
        return {
            legs: [],
            legIndexOffset: 0
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path leg.
     * @returns A new geometric descent coarse vertical flight path leg.
     */
    static createGeometricDescentCoarseLeg() {
        return {
            vectors: [],
            altitudeConstraintIndex: -1,
            distance: 0,
            endDistanceToEnd: 0,
            course: undefined
        };
    }
    /**
     * Creates a new geometric descent coarse vertical flight path vector.
     * @returns A new geometric descent coarse vertical flight path vector.
     */
    static createGeometricDescentCoarseVector() {
        return {
            startDistanceToLegEnd: 0,
            endDistanceToLegEnd: 0,
            startAltitude: 0,
            endAltitude: 0,
            targetCas: Infinity,
            targetCasSource: VerticalFlightPathVectorSpeedSource.None,
            targetMach: Infinity,
            targetMachSource: VerticalFlightPathVectorSpeedSource.None,
            fpa: 0,
            anticipatedTargetCas: Infinity,
            anticipatedTargetCasSource: VerticalFlightPathVectorSpeedSource.None,
            anticipatedTargetMach: Infinity,
            anticipatedTargetMachSource: VerticalFlightPathVectorSpeedSource.None,
            estimatedDecelTime: 0,
            estimatedDecelDistance: 0,
            estimatedDecelStartTas: 0,
            estimatedDecelEndTas: 0,
            estimatedDecelWind: 0,
            startWeight: 0,
            endWeight: 0
        };
    }
    /**
     * Copies a vertical flight path.
     * @param source The path to copy from.
     * @param target The path to copy to. If not defined, a new vertical flight path will be created.
     * @returns The vertical flight path that was copied to.
     */
    static copyVerticalPath(source, target) {
        if (!target) {
            target = BoeingPathCalculator.createVerticalPath(source.planIndex);
        }
        target.legs.length = source.legs.length;
        for (let i = 0; i < source.legs.length; i++) {
            target.legs[i] = BoeingPathCalculator.copyVerticalPathLeg(source.legs[i], target.legs[i]);
        }
        target.tocLegIndex = source.tocLegIndex;
        target.tocDistanceToLegEnd = source.tocDistanceToLegEnd;
        target.tocWeight = source.tocWeight;
        target.todLegIndex = source.todLegIndex;
        target.todDistanceToLegEnd = source.todDistanceToLegEnd;
        target.perfDescentTodDistance = source.perfDescentTodDistance;
        target.perfDescentSimDistance = source.perfDescentSimDistance;
        target.geoDescentInterceptLegIndex = source.geoDescentInterceptLegIndex;
        target.geoDescentInterceptDistanceToLegEnd = source.geoDescentInterceptDistanceToLegEnd;
        target.geoDescentSimInterceptLegIndex = source.geoDescentSimInterceptLegIndex;
        target.geoDescentSimInterceptVectorIndex = source.geoDescentSimInterceptVectorIndex;
        target.geoDescentSimInterceptDistanceToLegEnd = source.geoDescentSimInterceptDistanceToLegEnd;
        target.geoDescentInterceptWeight = source.geoDescentInterceptWeight;
        return target;
    }
    /**
     * Copies a vertical flight path leg.
     * @param source The leg to copy from.
     * @param target The leg to copy to. If not defined, a new vertical flight path leg will be created.
     * @returns The vertical flight path leg that was copied to.
     */
    static copyVerticalPathLeg(source, target) {
        var _a;
        if (!target) {
            target = BoeingPathCalculator.createVerticalPathLeg();
        }
        target.vectors.length = source.vectors.length;
        for (let i = 0; i < source.vectors.length; i++) {
            target.vectors[i] = Object.assign((_a = target.vectors[i]) !== null && _a !== void 0 ? _a : {}, source.vectors[i]);
        }
        target.simDistance = source.simDistance;
        target.simDuration = source.simDuration;
        return target;
    }
    /**
     * Gets the lateral distance, in meters, from a given query point along a flight plan to a speed constraint in the
     * same flight plan.
     * @param lateralLegs An array of lateral flight plan legs, in the order in which they appear in the plan.
     * @param speedConstraint The speed constraint to get the distance to.
     * @param globalLegIndex The global index of the flight plan leg containing the query point.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of its containing leg.
     * @returns The lateral distance, in meters, from the specified query point to the specified speed constraint.
     * @throws RangeError if `globalLegIndex` is out of bounds.
     */
    static getDistanceToSpeedConstraint(lateralLegs, speedConstraint, globalLegIndex, distanceToLegEnd) {
        var _a, _b, _c, _d, _e, _f;
        if (globalLegIndex < 0 || globalLegIndex >= lateralLegs.length) {
            throw new RangeError();
        }
        if (globalLegIndex <= speedConstraint.globalLegIndex) {
            let distance = distanceToLegEnd;
            const end = Math.min(speedConstraint.globalLegIndex + 1, lateralLegs.length);
            for (let i = globalLegIndex + 1; i < end; i++) {
                distance += (_b = (_a = lateralLegs[i].calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions) !== null && _b !== void 0 ? _b : 0;
            }
            return distance;
        }
        else {
            let distance = distanceToLegEnd - ((_d = (_c = lateralLegs[globalLegIndex].calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) !== null && _d !== void 0 ? _d : 0);
            const end = Math.max(speedConstraint.globalLegIndex, 0);
            for (let i = globalLegIndex - 1; i > end; i--) {
                distance -= (_f = (_e = lateralLegs[i].calculated) === null || _e === void 0 ? void 0 : _e.distanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
            }
            return distance;
        }
    }
    /**
     * Gets the geo circle representation of the course at and the position vector of a point along a flight plan leg's
     * lateral flight path.
     * @param legCalc The lateral flight path calculations for a flight plan leg.
     * @param distanceToLegEnd The distance, in meters, from the query point to the end of the flight plan leg.
     * @param courseOut The geo circle to which write the flight path course at the query point.
     * @param positionOut The 3D vector to which to write the position vector of the query point.
     * @returns Whether a course and position vector were successfully found for the query point.
     */
    static getCourseAndPositionAlongLeg(legCalc, distanceToLegEnd, courseOut, positionOut) {
        // Iterate over all vectors (including transitions) in the leg in forward order until we reach the query point.
        let distanceToGo = legCalc.distanceWithTransitions - distanceToLegEnd;
        let vectors = legCalc.ingress;
        let vectorIndex = 0;
        let vector = vectors[vectorIndex];
        let lastVector = undefined;
        // ingress vectors
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // ingress to egress vectors
        vectors = legCalc.ingressToEgress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // egress vectors
        vectors = legCalc.egress;
        vector = vectors[vectorIndex = 0];
        while (vector) {
            if (vector.distance >= distanceToGo) {
                FlightPathUtils.setGeoCircleFromVector(vector, courseOut);
                courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(vector.startLat, vector.startLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
                return true;
            }
            lastVector = vector;
            distanceToGo -= vector.distance;
            vector = vectors[++vectorIndex];
        }
        // If we have exhausted all vectors on the leg without reaching the query point, advance past the end of the last
        // vector (if it exists).
        if (lastVector) {
            FlightPathUtils.setGeoCircleFromVector(lastVector, courseOut);
            courseOut.offsetDistanceAlong(BoeingPathCalculator.getCourseAndPositionAlongLegCache.geoPoint[0].set(lastVector.endLat, lastVector.endLon), UnitType.METER.convertTo(distanceToGo, UnitType.GA_RADIAN), positionOut, Math.PI);
            return true;
        }
        return false;
    }
}
BoeingPathCalculator.MAX_DISTANCE_STEP = 185200; // meters (100 nautical miles)
BoeingPathCalculator.MAX_DISTANCE_STEP_TOL = 18520; // meters (10 nautical miles)
BoeingPathCalculator.MAX_ALTITUDE_STEP = 304.8; // meters (1000 feet)
BoeingPathCalculator.MAX_ALTITUDE_STEP_TOL = 30.48; // meters (100 feet)
BoeingPathCalculator.CLIMB_ACCEL_VS_MPS = UnitType.FPM.convertTo(500, UnitType.MPS);
BoeingPathCalculator.DESCENT_DECEL_VS_MPS = UnitType.FPM.convertTo(-500, UnitType.MPS);
BoeingPathCalculator.MIN_GROUND_SPEED = 25.722; // meters per second (50 knots)
BoeingPathCalculator.MIN_DESCENT_ACCELERATION = 0.2572; // meters per second squared (0.5 knots per second)
BoeingPathCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingPathCalculator.vec3Cache = [Vec3Math.create()];
BoeingPathCalculator.geoCircleCache = [new GeoCircle(Vec3Math.create(), 0)];
BoeingPathCalculator.windCache = [Vec2Math.create()];
BoeingPathCalculator.getCourseAndPositionAlongLegCache = {
    geoPoint: [new GeoPoint(0, 0)]
};

var BoeingVNavVars;
(function (BoeingVNavVars) {
    BoeingVNavVars["VNAVDesiredState"] = "L:WTAP_Boeing_VNav_Desired_State";
    BoeingVNavVars["RNP"] = "L:WTAP_Boeing_VNav_RNP";
    BoeingVNavVars["PerformanceTODDistance"] = "L:WTAP_VNav_Distance_To_Performance_TOD";
    BoeingVNavVars["PerformanceTODLegIndex"] = "L:WTAP_VNav_Performance_TOD_Leg_Index";
    BoeingVNavVars["PerformanceTODDistanceInLeg"] = "L:WTAP_VNav_Performance_TOD_Distance_In_Leg";
})(BoeingVNavVars || (BoeingVNavVars = {}));
/** A publisher for Boeing VNAV sim var events. */
class BoeingVNavSimVarPublisher extends SimVarPublisher {
    /**
     * Create a VNavSimVarPublisher
     * @param bus The EventBus to publish to
     */
    constructor(bus) {
        super(BoeingVNavSimVarPublisher.simvars, bus);
    }
    /**
     * Publish a control event.
     * @param event The event from ControlEvents.
     * @param value The value of the event.
     */
    publishEvent(event, value) {
        this.publish(event, value, true);
    }
}
BoeingVNavSimVarPublisher.simvars = new Map([
    ['boeingvnav_desired_state', { name: BoeingVNavVars.VNAVDesiredState, type: SimVarValueType.Enum }],
    ['boeingvnav_rnp', { name: BoeingVNavVars.RNP, type: SimVarValueType.Number }],
    ['boeingvnav_performance_tod_distance', { name: BoeingVNavVars.PerformanceTODDistance, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_leg_distance', { name: BoeingVNavVars.PerformanceTODDistanceInLeg, type: SimVarValueType.Meters }],
    ['boeingvnav_performance_tod_global_leg_index', { name: BoeingVNavVars.PerformanceTODLegIndex, type: SimVarValueType.Number }],
]);

/**
 * Valid CDI scale labels for the LVar scale enum.
 */
var CDIScaleLabel;
(function (CDIScaleLabel) {
    CDIScaleLabel[CDIScaleLabel["Departure"] = 0] = "Departure";
    CDIScaleLabel[CDIScaleLabel["Terminal"] = 1] = "Terminal";
    CDIScaleLabel[CDIScaleLabel["TerminalDeparture"] = 2] = "TerminalDeparture";
    CDIScaleLabel[CDIScaleLabel["TerminalArrival"] = 3] = "TerminalArrival";
    CDIScaleLabel[CDIScaleLabel["Enroute"] = 4] = "Enroute";
    CDIScaleLabel[CDIScaleLabel["Oceanic"] = 5] = "Oceanic";
    CDIScaleLabel[CDIScaleLabel["Approach"] = 6] = "Approach";
    CDIScaleLabel[CDIScaleLabel["MissedApproach"] = 7] = "MissedApproach";
})(CDIScaleLabel || (CDIScaleLabel = {}));
/**
 * Sim var names for Boeing LNAV-related data.
 */
var BoeingLNavDataVars;
(function (BoeingLNavDataVars) {
    /** The global leg index of the flight plan leg that is nominally being tracked by LNAV. */
    BoeingLNavDataVars["NominalLegIndex"] = "L:WTBoeing_LNavData_Nominal_Leg_Index";
    /** The current CDI scale label. */
    // eslint-disable-next-line @typescript-eslint/no-shadow
    BoeingLNavDataVars["CDIScaleLabel"] = "L:WTBoeing_LNavData_CDI_Scale_Label";
    /** The current lateral RNP in nautical miles */
    BoeingLNavDataVars["RNP"] = "L:WTBoeing_LNavData_RNP";
    /** The nominal distance remaining to the end of the currently tracked flight plan leg. */
    BoeingLNavDataVars["TrackedLegEndDistance"] = "L:WTBoeing_LNavData_Tracked_Leg_End_Distance";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Distance_Direct";
    /** The straight-line distance between the present position and the destination, in nautical miles. */
    BoeingLNavDataVars["DestinationRunwayDistanceDirect"] = "L:WTBoeing_LNavData_Destination_Runway_Distance_Direct";
    /** The flight plan distance to the final approach fix, in nautical miles. */
    BoeingLNavDataVars["FafDistance"] = "L:WTBoeing_LNavData_Faf_Distance";
    /** The direct distance to the missed approach point fix, in nautical miles, or -1 if invalid. */
    BoeingLNavDataVars["MapDistanceDirect"] = "L:WTBoeing_LNavData_Map_Distance";
    /** The total direct distance in nautical miles, or 0 when invalid. */
    BoeingLNavDataVars["TotalDistanceDirect"] = "L:WTBoeing_LNavData_Total_Distance_Direct";
})(BoeingLNavDataVars || (BoeingLNavDataVars = {}));
/**
 * A publisher for Boeing LNAV-related data sim var events.
 */
class BoeingLNavDataSimVarPublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(BoeingLNavDataSimVarPublisher.simvars, bus);
    }
}
BoeingLNavDataSimVarPublisher.simvars = new Map([
    ['lnavdata_dtk_true', { name: LNavDataVars.DTKTrue, type: SimVarValueType.Degree }],
    ['lnavdata_dtk_mag', { name: LNavDataVars.DTKMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_xtk', { name: LNavDataVars.XTK, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale', { name: LNavDataVars.CDIScale, type: SimVarValueType.NM }],
    ['lnavdata_cdi_scale_label', { name: BoeingLNavDataVars.CDIScaleLabel, type: SimVarValueType.Number }],
    ['lnavdata_rnp', { name: BoeingLNavDataVars.RNP, type: SimVarValueType.Number }],
    ['lnavdata_waypoint_bearing_true', { name: LNavDataVars.WaypointBearingTrue, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_bearing_mag', { name: LNavDataVars.WaypointBearingMagnetic, type: SimVarValueType.Degree }],
    ['lnavdata_waypoint_distance', { name: LNavDataVars.WaypointDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance', { name: LNavDataVars.DestinationDistance, type: SimVarValueType.NM }],
    ['lnavdata_total_distance_direct', { name: BoeingLNavDataVars.TotalDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_nominal_leg_index', { name: BoeingLNavDataVars.NominalLegIndex, type: SimVarValueType.Number }],
    ['lnavdata_tracked_leg_end_distance', { name: BoeingLNavDataVars.TrackedLegEndDistance, type: SimVarValueType.NM }],
    ['lnavdata_destination_distance_direct', { name: BoeingLNavDataVars.DestinationDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_destination_runway_distance_direct', { name: BoeingLNavDataVars.DestinationRunwayDistanceDirect, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_faf', { name: BoeingLNavDataVars.FafDistance, type: SimVarValueType.NM }],
    ['lnavdata_distance_to_map_direct', { name: BoeingLNavDataVars.MapDistanceDirect, type: SimVarValueType.NM }],
]);

/** base publisher for simvars */
class BoeingAPSimVarPublisher extends SimVarPublisher {
    /**
     * Create a BoeingAPSimVarPublisher
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the pace of publishing
     */
    constructor(bus, pacer = undefined) {
        super(BoeingAPSimVarPublisher.simvars, bus, pacer);
    }
}
BoeingAPSimVarPublisher.simvars = new Map([
    ['ap_boeing_disconnected', { name: 'L:WT_Boeing_Autopilot_Disconnected', type: SimVarValueType.Bool }],
    ['ap_boeing_selected_ias', { name: 'AUTOPILOT AIRSPEED HOLD VAR:1', type: SimVarValueType.Knots }],
    ['ap_boeing_selected_mach', { name: 'AUTOPILOT MACH HOLD VAR:1', type: SimVarValueType.Number }],
    ['ap_boeing_mcp_speed_is_mach', { name: 'L:XMLVAR_AirSpeedIsInMach', type: SimVarValueType.Bool }],
    ['ap_boeing_track_mode_active', { name: 'L:XMLVAR_TRK_MODE_ACTIVE', type: SimVarValueType.Bool }],
    ['ap_boeing_approach_mode_armed', { name: 'L:AP_APR_ARMED', type: SimVarValueType.Bool }],
    ['ap_boeing_autothrottle_armed', { name: 'L:AS01B_AUTO_THROTTLE_ARM_STATE', type: SimVarValueType.Bool }],
]);

/**
 * A Boeing flare autopilot director.
 */
class BoeingAPFlareDirector {
    /**
     * Creates an instance of the flare director.
     * @param bus The event bus to use with this instance.
     * @param options Options for this director.
     */
    constructor(bus, options) {
        var _a;
        this.bus = bus;
        this.raSystem = this.bus.getSubscriber();
        this.ra = ConsumerSubject.create(this.raSystem.on('ra_radio_alt_1').whenChangedBy(1), 0);
        this.adcSystem = this.bus.getSubscriber();
        this.tas = ConsumerSubject.create(this.adcSystem.on('tas').whenChangedBy(1), 0);
        this.gs = ConsumerValue.create(this.bus.getSubscriber().on('ground_speed').whenChangedBy(1), 0);
        this.onGround = ConsumerValue.create(this.adcSystem.on('on_ground'), true);
        /** gross weight in pounds */
        this.grossWeight = ConsumerValue.create(this.bus.getSubscriber().on('total_weight'), 0);
        this.desiredPitchFilter = new ExpSmoother(200 / Math.LN2);
        this.lastPitchFilterTime = 0;
        this.touchdown = false;
        /** JS timestamp when touchdown occured */
        this.touchdownTime = undefined;
        this.touchdownPitch = undefined;
        this.radioAltimeterOffset = 0;
        this.state = DirectorState.Inactive;
        this.maxAltitude = (_a = options === null || options === void 0 ? void 0 : options.activationAltitude) !== null && _a !== void 0 ? _a : 80;
        if ((options === null || options === void 0 ? void 0 : options.radioAltimeterOffset) !== undefined) {
            this.radioAltimeterOffset = options.radioAltimeterOffset;
        }
        this.desiredVsFunction = (options === null || options === void 0 ? void 0 : options.desiredVs) ? options.desiredVs : (height) => Math.min(-75, -150 * Math.exp(height / 30) + 150);
        this.ra.pause();
        this.tas.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.desiredPitchFilter.reset();
            this.touchdown = false;
            this.ra.resume();
            this.gs.resume();
            this.tas.resume();
            this.grossWeight.resume();
            this.state = DirectorState.Armed;
            this.onArm !== undefined && this.onArm();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.ra.pause();
        this.gs.pause();
        this.tas.pause();
        this.grossWeight.pause();
    }
    /**
     * Updates this director.
     */
    update() {
        let desiredPitch = 0;
        if (!this.onGround.get() && (this.state === DirectorState.Armed || this.state === DirectorState.Active)) {
            desiredPitch = this.getDesiredPitch();
        }
        if (this.state === DirectorState.Armed && this.ra.get() <= this.maxAltitude && desiredPitch !== 0) {
            const currentPitch = -SimVar.GetSimVarValue('PLANE PITCH DEGREES', SimVarValueType.Degree);
            if (desiredPitch - currentPitch >= 0) {
                this.activate();
            }
        }
        else if (this.state === DirectorState.Active) {
            this.touchdown || (this.touchdown = this.onGround.get() === true);
            if (this.touchdown) {
                // nosewheel pitch target after touchdown
                const time = Date.now();
                if (this.touchdownTime === undefined || this.touchdownPitch === undefined) {
                    this.touchdownTime = time;
                    this.touchdownPitch = -SimVar.GetSimVarValue('PLANE PITCH DEGREES', SimVarValueType.Degree);
                }
                const elapsed = time - this.touchdownTime;
                // drive the nosewheel down smoothly
                const pitch = MathUtils.lerp(elapsed / 1000, 0, BoeingAPFlareDirector.NOSEWHEEL_LOWER_TIME, this.touchdownPitch, 0, true, true);
                this.setPitch && this.setPitch(-pitch);
            }
            else {
                // airborne/flare pitch target
                this.setPitch && this.setPitch(-desiredPitch);
                this.touchdownTime = undefined;
                this.touchdownPitch = undefined;
            }
        }
        if (this.onGround.get() === true && this.tas.get() < 60) {
            this.deactivate();
        }
    }
    /**
     * Gets a desired pitch from the selected vs value.
     * @returns The desired pitch angle.
     */
    getDesiredPitch() {
        const ra = SimVar.GetSimVarValue('RADIO HEIGHT', SimVarValueType.Feet);
        const height = ra + this.radioAltimeterOffset;
        const inertialVs = SimVar.GetSimVarValue('VELOCITY WORLD Y', SimVarValueType.FPM);
        const desiredVs = this.desiredVsFunction(height, this.grossWeight.get(), inertialVs);
        const desiredFpa = VNavUtils.getFpaFromVerticalSpeed(desiredVs, this.gs.get()) + this.getVerticalWindCorrection();
        const desiredPitch = SimVar.GetSimVarValue('INCIDENCE ALPHA', SimVarValueType.Degree) + desiredFpa;
        const time = Date.now();
        const dt = time - this.lastPitchFilterTime;
        this.lastPitchFilterTime = time;
        return this.desiredPitchFilter.next(MathUtils.clamp(desiredPitch, -3, 9), dt);
    }
    /**
     * Gets the vertical wind correction in degrees.
     * @returns The vertical wind correction in degrees.
     */
    getVerticalWindCorrection() {
        // Wind correction FPA will be the FPA required to negate the vertical wind (so negative verticalWindAverageValue)
        return VNavUtils.getFpa(SimVar.GetSimVarValue('AIRSPEED TRUE', SimVarValueType.FPM), -SimVar.GetSimVarValue('AMBIENT WIND Y', SimVarValueType.FPM));
    }
}
/** Target in seconds between main gear touchdown and nosewheel touchdown. */
BoeingAPFlareDirector.NOSEWHEEL_LOWER_TIME = 3;

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A Boeing autopilot TOGA Director to be used for either a vertical TO or GA mode.
 */
class BoeingAPTogaDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The Event Bus.
     * @param apValues The apValues Data Object.
     * @param minimumPitch The minimum pitch value to set in degrees, default 8 (will be this on ground always)
     * @param maximumPitch The maximum pitch value to set in degrees, default 18
     */
    constructor(bus, apValues, minimumPitch = 8, maximumPitch = 18) {
        this.apValues = apValues;
        this.minimumPitch = minimumPitch;
        this.maximumPitch = maximumPitch;
        this.speedTarget = ConsumerValue.create(null, 0).pause();
        this.onGround = ConsumerValue.create(null, true).pause();
        this.state = DirectorState.Inactive;
        const sub = bus.getSubscriber();
        this.speedTarget.setConsumer(sub.on('fms_speed_autopilot_target_toga_ias'));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.flcComputer = new GenericFlcComputer({ kP: 2, kI: 0, kD: 0, maxOut: 90, minOut: -90 });
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.speedTarget.resume();
        this.onGround.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.speedTarget.pause();
        this.onGround.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        var _a;
        this.resumeSubs();
        this.state = DirectorState.Active;
        (_a = this.onActivate) === null || _a === void 0 ? void 0 : _a.call(this);
        // TODO: The simvar is not currently writeable, so the line below has no effect.
        SimVar.SetSimVarValue('AUTOPILOT TAKEOFF POWER ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('L:WT_TOGA_ACTIVE', 'Bool', true);
        this.flcComputer.activate(true);
    }
    /**
     * Arms this director.
     * This director has no armed mode, so it activates immediately.
     */
    arm() {
        if (this.state == DirectorState.Inactive) {
            this.activate();
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.flcComputer.deactivate();
        // TODO: The simvar is not currently writeable, so the line below has no effect.
        SimVar.SetSimVarValue('AUTOPILOT TAKEOFF POWER ACTIVE', 'Bool', false);
        SimVar.SetSimVarValue('L:WT_TOGA_ACTIVE', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        var _a, _b;
        if (this.state === DirectorState.Active) {
            if (this.onGround.get() || this.speedTarget.get() < 100) {
                (_a = this.drivePitch) === null || _a === void 0 ? void 0 : _a.call(this, -this.minimumPitch, false, false);
            }
            else {
                this.flcComputer.setTargetSpeed(this.speedTarget.get());
                this.flcComputer.update();
                const pitchTarget = this.flcComputer.pitchTarget.get();
                // The flcComputer takes care of the aoa adjustment since it needs aoa anyhow,
                // and there is no vertical wind correction for an FLC mode.
                pitchTarget !== null && ((_b = this.drivePitch) === null || _b === void 0 ? void 0 : _b.call(this, MathUtils.clamp(pitchTarget, -this.maximumPitch, -this.minimumPitch), false, false));
            }
        }
    }
}

/**
 * Statuses for a Boeing autothrottle.
 */
var BoeingAutothrottleStatus;
(function (BoeingAutothrottleStatus) {
    BoeingAutothrottleStatus["Off"] = "Off";
    BoeingAutothrottleStatus["Disconnected"] = "Disconnected";
    BoeingAutothrottleStatus["Armed"] = "Armed";
    BoeingAutothrottleStatus["On"] = "On";
})(BoeingAutothrottleStatus || (BoeingAutothrottleStatus = {}));
/**
 * Boeing autothrottle system modes.
 */
var BoeingAutothrottleModes;
(function (BoeingAutothrottleModes) {
    /** Null mode. */
    BoeingAutothrottleModes["NONE"] = "";
    /** Autothrottle servos are disabled to allow throttle to be held in place during takeoff and climb while below 400 feet AGL. */
    BoeingAutothrottleModes["TAKEOFF_HOLD"] = "TO HOLD";
    /** Autothrottle servos are disabled to allow throttle to be manipulated in FLC/VNAV SPD descent. */
    BoeingAutothrottleModes["DESCENT_HOLD"] = "DES HOLD";
    /** Autothrottle targets thrust to descent at -1250 fpm. */
    BoeingAutothrottleModes["DESCENT_THR"] = "DES THR";
    /** Autothrottle hold protection has failed. */
    BoeingAutothrottleModes["HOLD_FAIL"] = "HOLD FAIL";
    /** Autothrottle targets takeoff thrust. */
    BoeingAutothrottleModes["TO"] = "TO";
    /** Autothrottle targets CLB thrust. */
    BoeingAutothrottleModes["CLIMB"] = "CLIMB";
    /** Autothrottle targets Max Continuous thrust. */
    BoeingAutothrottleModes["CON"] = "CON";
    /** Autothrottle targets GA thrust. */
    BoeingAutothrottleModes["GA"] = "GA";
    /** Autothrottle targets thrust to climb at minimum 2000 fpm, up to GA thrust limit. */
    BoeingAutothrottleModes["GA_THR"] = "GA THR";
    /** Autothrottle targets a set airspeed. */
    BoeingAutothrottleModes["SPD"] = "SPD";
    /** Autothrottle targets idle thrust. */
    BoeingAutothrottleModes["IDLE"] = "IDLE";
    /** Autothrottle reduces throttles to idle during landing once below 40 AGL. */
    BoeingAutothrottleModes["RETARD"] = "RETARD";
})(BoeingAutothrottleModes || (BoeingAutothrottleModes = {}));

/**
 * Message categories for Boeing FMC messages
 */
var BoeingFmcErrorCategories;
(function (BoeingFmcErrorCategories) {
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["EntryErrorAdvisory"] = 0] = "EntryErrorAdvisory";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Advisory"] = 1] = "Advisory";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Communications"] = 2] = "Communications";
    BoeingFmcErrorCategories[BoeingFmcErrorCategories["Alert"] = 3] = "Alert";
})(BoeingFmcErrorCategories || (BoeingFmcErrorCategories = {}));

/**
 * Help window message definitions - those are associated with pre-made {@link HelpWindowMessage} objects in
 * the {@link DefinedHelpWindowMessages} object. They can be thrown in CDU LSK handlers to show the associated message on the
 * help window.
 */
var BoeingFmcErrorKeys;
(function (BoeingFmcErrorKeys) {
    BoeingFmcErrorKeys["AppTuneInhibitedMcp"] = "AppTuneInhibitedMcp";
    BoeingFmcErrorKeys["DragRequired"] = "DragRequired";
    BoeingFmcErrorKeys["FmcAppModeUavailGp"] = "FmcAppModeUavailGp";
    BoeingFmcErrorKeys["FmcAppModeUavailQfe"] = "FmcAppModeUavailQfe";
    BoeingFmcErrorKeys["FmcAppTuneDisagree"] = "FmcAppTuneDisagree";
    BoeingFmcErrorKeys["InertialOriginDisagree"] = "InertialOriginDisagree";
    BoeingFmcErrorKeys["InvalidDelete"] = "InvalidDelete";
    BoeingFmcErrorKeys["GenericInvalidEntry"] = "GenericInvalidEntry";
    BoeingFmcErrorKeys["InvalidEntryRouteAirway"] = "InvalidEntryRouteAirway";
    BoeingFmcErrorKeys["InvalidEntryRouteTermination"] = "InvalidEntryRouteTermination";
    BoeingFmcErrorKeys["InvalidEntryWindDirSpdInitial"] = "InvalidEntryWindDirSpdInitial";
    BoeingFmcErrorKeys["InvalidEntryBearingDistance"] = "InvalidEntryBearingDistance";
    BoeingFmcErrorKeys["InvalidEntryAltitudeOrTime"] = "InvalidEntryAltitudeOrTime";
    BoeingFmcErrorKeys["NotInDataBase"] = "NotInDataBase";
    BoeingFmcErrorKeys["ResetMcpAlt"] = "ResetMcpAlt";
    BoeingFmcErrorKeys["RunwayNaForSid"] = "RunwayNaForSid";
    BoeingFmcErrorKeys["TakeoffFlapsDeleted"] = "TakeoffFlapsDeleted";
    BoeingFmcErrorKeys["TakeoffSpeedsDeleted"] = "TakeoffSpeedsDeleted";
    BoeingFmcErrorKeys["ThrustRequired"] = "ThrustRequired";
    BoeingFmcErrorKeys["TakeoffDataUplink"] = "TakeoffDataUplink";
    BoeingFmcErrorKeys["Generic"] = "Generic";
})(BoeingFmcErrorKeys || (BoeingFmcErrorKeys = {}));
const BoeingFmcErrorKeysCategories = {
    [BoeingFmcErrorKeys.AppTuneInhibitedMcp]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.DragRequired]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppModeUavailGp]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppModeUavailQfe]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.FmcAppTuneDisagree]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.InertialOriginDisagree]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.InvalidDelete]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.GenericInvalidEntry]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryRouteAirway]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryRouteTermination]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryWindDirSpdInitial]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryBearingDistance]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.InvalidEntryAltitudeOrTime]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.NotInDataBase]: BoeingFmcErrorCategories.EntryErrorAdvisory,
    [BoeingFmcErrorKeys.ResetMcpAlt]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.RunwayNaForSid]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffFlapsDeleted]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffSpeedsDeleted]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.ThrustRequired]: BoeingFmcErrorCategories.Alert,
    [BoeingFmcErrorKeys.TakeoffDataUplink]: BoeingFmcErrorCategories.Communications,
    [BoeingFmcErrorKeys.Generic]: BoeingFmcErrorCategories.Advisory,
};

/** The state of the altitude alerter. */
var AltAlertState;
(function (AltAlertState) {
    /** Disabled Mode */
    AltAlertState[AltAlertState["DISABLED"] = 0] = "DISABLED";
    /** Armed Mode. */
    AltAlertState[AltAlertState["ARMED"] = 1] = "ARMED";
    /** Within 900 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_900"] = 2] = "WITHIN_900";
    /** Within 300 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_300"] = 3] = "WITHIN_300";
    /** Within 200 feet of preselected altitude. */
    AltAlertState[AltAlertState["WITHIN_200"] = 4] = "WITHIN_200";
    /** Captured the preselected altitude. */
    AltAlertState[AltAlertState["CAPTURED"] = 5] = "CAPTURED";
    /** Outside of the 200ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_200"] = 6] = "DEVIATION_200";
    /** Outside of the 300ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_300"] = 7] = "DEVIATION_300";
    /** Outside of the 900ft deviation zone */
    AltAlertState[AltAlertState["DEVIATION_900"] = 8] = "DEVIATION_900";
})(AltAlertState || (AltAlertState = {}));
/** Navigation sources for lateral and vertical guidance */
var NavigationSource;
(function (NavigationSource) {
    NavigationSource[NavigationSource["NONE"] = 0] = "NONE";
    /** FMC/non-precision source i.e. LNAV or VNAV */
    NavigationSource[NavigationSource["NPS"] = 1] = "NPS";
    NavigationSource[NavigationSource["IAN"] = 2] = "IAN";
    NavigationSource[NavigationSource["ILS"] = 3] = "ILS";
    NavigationSource[NavigationSource["GLS"] = 4] = "GLS";
})(NavigationSource || (NavigationSource = {}));
/** Approach frequency tuning mode for the ILS radio */
var ApproachTuningMode;
(function (ApproachTuningMode) {
    ApproachTuningMode[ApproachTuningMode["Park"] = 0] = "Park";
    ApproachTuningMode[ApproachTuningMode["ParkTuned"] = 1] = "ParkTuned";
    ApproachTuningMode[ApproachTuningMode["Autotuned"] = 2] = "Autotuned";
    ApproachTuningMode[ApproachTuningMode["ManuallyTuned"] = 3] = "ManuallyTuned";
})(ApproachTuningMode || (ApproachTuningMode = {}));
var VorTuningMode;
(function (VorTuningMode) {
    /** The FMC isn't currently tuning a VOR */
    VorTuningMode[VorTuningMode["None"] = 0] = "None";
    /** The FMC is tuning the VOR manually entered on the CDU by the pilots */
    VorTuningMode[VorTuningMode["ManuallyTuned"] = 1] = "ManuallyTuned";
    /** The FMC is tuning a VOR required by the current procedure */
    VorTuningMode[VorTuningMode["ProcedureTuned"] = 2] = "ProcedureTuned";
    /** The FMC is tuning a VOR that features as a waypoint on the current route */
    VorTuningMode[VorTuningMode["RouteTuned"] = 3] = "RouteTuned";
    /** The FMC is tuning a suitable nearby VOR */
    VorTuningMode[VorTuningMode["AutoTuned"] = 4] = "AutoTuned";
})(VorTuningMode || (VorTuningMode = {}));
var AutolandCapability;
(function (AutolandCapability) {
    AutolandCapability[AutolandCapability["None"] = 0] = "None";
    AutolandCapability[AutolandCapability["FailPassive"] = 1] = "FailPassive";
    AutolandCapability[AutolandCapability["FailOperational"] = 2] = "FailOperational";
})(AutolandCapability || (AutolandCapability = {}));

/** Type for whether ND is in HDG up or TRK up mode. */
var BoeingNdHdgTrkUpMode;
(function (BoeingNdHdgTrkUpMode) {
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["HDG"] = 0] = "HDG";
    BoeingNdHdgTrkUpMode[BoeingNdHdgTrkUpMode["TRK"] = 1] = "TRK";
})(BoeingNdHdgTrkUpMode || (BoeingNdHdgTrkUpMode = {}));
/**
 * IRS alignment time modes.
 */
var BoeingIrsAlignTimeMode;
(function (BoeingIrsAlignTimeMode) {
    /** IRS aligns instantly. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Instant"] = 0] = "Instant";
    /** IRS attitude alignment finishes in 30 seconds and full alignment finishes in 60 seconds. */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Accelerated"] = 1] = "Accelerated";
    /**
     * IRS attitude alignment finishes in 30 seconds and full alignment finishes in an amount of time approximating the
     * real unit (5 minutes at the equator to 17 minutes near the poles).
     */
    BoeingIrsAlignTimeMode[BoeingIrsAlignTimeMode["Realistic"] = 2] = "Realistic";
})(BoeingIrsAlignTimeMode || (BoeingIrsAlignTimeMode = {}));
const boeingMsfsUserSettings = [
    {
        name: 'boeingMsfsNdHdgTrkUpMode',
        defaultValue: BoeingNdHdgTrkUpMode.TRK,
    },
    {
        name: 'boeingMsfsIrsAlignTime',
        defaultValue: BoeingIrsAlignTimeMode.Accelerated,
    },
    {
        name: 'boeingMsfsSelcal',
        defaultValue: 'DM-ES',
    },
];
/**
 * Utility class for retrieving boeing msfs user setting managers.
 * These are user settings for Boeing aircraft and are meant to be persistent.
 */
class BoeingMsfsUserSettings {
    /**
     * Retrieves a manager for boeing msfs user settings.
     * @param bus The event bus.
     * @returns a manager for boeing msfs user settings.
     */
    static getManager(bus) {
        if (BoeingMsfsUserSettings.INSTANCE === undefined) {
            BoeingMsfsUserSettings.INSTANCE = new DefaultUserSettingManager(bus, boeingMsfsUserSettings);
        }
        return BoeingMsfsUserSettings.INSTANCE;
    }
}

const refsSettings = [
    {
        name: 'minimumsMode',
        defaultValue: MinimumsMode.OFF,
    },
    {
        name: 'decisionHeightFeet',
        defaultValue: 0,
    },
    {
        name: 'decisionAltitudeFeet',
        defaultValue: 0,
    },
    {
        name: 'metricAltitudeDisplay',
        defaultValue: false,
    },
    {
        name: 'fltNumber',
        defaultValue: '',
    },
    {
        name: 'fpvActive',
        defaultValue: false,
    },
    /** The EICAS page secondary engine indicators display state. */
    {
        name: 'eicasSecondaryEngineIndicatorsOn',
        defaultValue: false,
    }
];
/** Utility class for retrieving Refs user setting managers. */
class CockpitUserSettings {
    /**
     * Retrieves a manager for Refs user settings.
     * @param bus The event bus.
     * @returns a manager for Refs user settings.
     */
    static getManager(bus) {
        if (CockpitUserSettings.INSTANCE === undefined) {
            CockpitUserSettings.INSTANCE = new DefaultUserSettingManager(bus, refsSettings);
            CockpitUserSettings.wireSettings(CockpitUserSettings.INSTANCE);
        }
        return CockpitUserSettings.INSTANCE;
    }
    /**
     * Wires up any special setttings handlers.
     * @param settingsManager The settings manager.
     */
    static wireSettings(settingsManager) {
        CockpitUserSettings.subs.push(settingsManager.getSetting('fltNumber').sub(fltNumber => {
            // strip the first 1-3 letters from the callsign to get only the numbers to feed to the default ATC
            const justTheNumber = fltNumber.includes('-') || fltNumber.length === 0
                ? '0'
                : fltNumber.replace(/^([A-Z]{1,3})/, '');
            SimVar.SetSimVarValue('ATC FLIGHT NUMBER', SimVarValueType.String, justTheNumber);
        }));
    }
}
CockpitUserSettings.subs = [];

/**
 * TCAS operating mode setting values.
 */
var TcasOperatingModeSetting;
(function (TcasOperatingModeSetting) {
    TcasOperatingModeSetting["TA_RA"] = "TA_RA";
    TcasOperatingModeSetting["TAOnly"] = "TAOnly";
    TcasOperatingModeSetting["Standby"] = "Standby";
})(TcasOperatingModeSetting || (TcasOperatingModeSetting = {}));
const trafficSettings = [
    {
        name: 'trafficOperatingMode',
        defaultValue: TcasOperatingModeSetting.TAOnly
    },
    {
        name: 'trafficShowOther',
        defaultValue: true
    },
    {
        name: 'trafficAltitudeRelative',
        defaultValue: true
    },
    {
        name: 'trafficShowAbove',
        defaultValue: false
    },
    {
        name: 'trafficShowBelow',
        defaultValue: false
    }
];
/**
 * Utility class for retrieving the traffic user setting manager.
 */
class TrafficUserSettings {
    /**
     * Retrieves a setting manager with traffic user settings.
     * @param bus The event bus.
     * @returns A setting manager with traffic user settings.
     */
    static getManager(bus) {
        var _a;
        return (_a = TrafficUserSettings.INSTANCE) !== null && _a !== void 0 ? _a : (TrafficUserSettings.INSTANCE = new DefaultUserSettingManager(bus, trafficSettings));
    }
}

var VSpeedType;
(function (VSpeedType) {
    VSpeedType["V1"] = "V1";
    VSpeedType["Vr"] = "Vr";
    VSpeedType["V2"] = "V2";
    // Venr = 'Venr',
    // Vapp = 'Vapp',
    VSpeedType["Vref"] = "Vref";
})(VSpeedType || (VSpeedType = {}));
/** Utility class for retrieving the vspeeds user setting manager. */
class VSpeedUserSettings {
    /**
     * Ctor
     * @param bus The event bus.
     */
    constructor(bus) {
        const settingDefs = [];
        for (const vspeed in VSpeedType) {
            settingDefs.push({
                name: `vspeed_value_${vspeed}`,
                defaultValue: 0
            });
        }
        this.manager = new DefaultUserSettingManager(bus, settingDefs);
    }
    /**
     * Get an instance of VSpeedUserSettings.
     * @param bus The event bus.
     * @returns An instance of VSpeedUserSettings.
     */
    static getManager(bus) {
        if (VSpeedUserSettings.INSTANCE === undefined) {
            VSpeedUserSettings.INSTANCE = new VSpeedUserSettings(bus);
        }
        return VSpeedUserSettings.INSTANCE;
    }
    /** @inheritdoc */
    getSettings(type) {
        return {
            value: this.manager.getSetting(`vspeed_value_${type}`)
        };
    }
}

// TODO consider getting limits from game vars
// add game var to get slat angles for each handle position => no config needed?
/**
 * Flap Position Computer
 * @deprecated Needs refactored into BoeingFlapSystem
 */
class FlapComputer {
    /**
     * Constructor a new FlapComputer
     * @param bus Event bus
     * @param config Flap Computer configuration
     */
    constructor(bus, config) {
        this.bus = bus;
        this.flapsLeftAngle = ConsumerSubject.create(null, 0);
        this.flapsRightAngle = ConsumerSubject.create(null, 0);
        this.slatsLeftAngle = ConsumerSubject.create(null, 0);
        this.slatsRightAngle = ConsumerSubject.create(null, 0);
        /** total gross weight in lbs */
        this.grossWeight = ConsumerSubject.create(null, 0);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.flapInterpolatedPosition = Subject.create(0);
        this.flapInterpolatedLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapLimitIndex = Subject.create(0);
        this.flapLimitPosition = Subject.create(0);
        this.flapLimitSpeed = Subject.create(Number.MAX_SAFE_INTEGER);
        this.flapManeuverSpeed = Subject.create(0);
        this.holdingSpeed = Subject.create(0);
        this.needUpdate = true;
        this.flapPositionConfig = [...config.flap_positions].sort((a, b) => a.flapAngle === b.flapAngle ? a.slatAngle - b.slatAngle : a.flapAngle - b.flapAngle);
        this.flapSpeedLimitLookup = new LerpLookupTable(this.flapPositionConfig.filter((c) => isFinite(c.speedLimit)).map((c) => [c.speedLimit, c.label]));
        this.speedData = config.speed_data;
        const pub = this.bus.getPublisher();
        this.flapInterpolatedPosition.sub((pos) => pub.pub('flap_computer_interpolated_position', pos));
        this.flapInterpolatedLimitSpeed.sub((pos) => pub.pub('flap_computer_interpolated_limit_speed', pos));
        this.flapLimitIndex.sub((index) => pub.pub('flap_computer_limit_index', index));
        this.flapLimitPosition.sub((pos) => pub.pub('flap_computer_limit_position', pos));
        this.flapLimitSpeed.sub((speed) => pub.pub('flap_computer_limit_speed', speed));
        this.flapManeuverSpeed.sub((speed) => pub.pub('flap_computer_maneuver_speed', speed));
        this.holdingSpeed.sub((speed) => pub.pub('flap_computer_holding_speed', speed));
        this.listenToEvents();
    }
    /** Update the flap setting from the flap and slat angles */
    updateFlapPosition() {
        if (!this.needUpdate) {
            return;
        }
        this.needUpdate = false;
        // we consider the highest out of the two sides
        const actualFlapAngle = Math.max(this.flapsLeftAngle.get(), this.flapsRightAngle.get());
        const actualSlatAngle = Math.max(this.slatsLeftAngle.get(), this.slatsRightAngle.get());
        // find the flap position used for speed limit calculation (increments just after passing each position)
        let flapLimitIndex = this.flapPositionConfig.findIndex((p) => actualFlapAngle <= p.flapAngle + FlapComputer.ANGLE_TOLERANCE);
        const firstFlapPos = this.flapPositionConfig[flapLimitIndex];
        for (; flapLimitIndex < this.flapPositionConfig.length - 1; flapLimitIndex++) {
            const nextLimitPos = this.flapPositionConfig[flapLimitIndex + 1];
            if (nextLimitPos.flapAngle !== firstFlapPos.flapAngle) {
                break;
            }
            const limitPos = this.flapPositionConfig[flapLimitIndex];
            if (actualSlatAngle <= limitPos.slatAngle + FlapComputer.ANGLE_TOLERANCE) {
                break;
            }
        }
        const flapLimitPosition = this.flapPositionConfig[flapLimitIndex];
        this.flapLimitIndex.set(flapLimitIndex);
        this.flapLimitPosition.set(flapLimitPosition.label);
        this.flapLimitSpeed.set(isFinite(flapLimitPosition.speedLimit) ? flapLimitPosition.speedLimit : -1);
        this.flapManeuverSpeed.set(this.speedData.getFlapManeuverSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        this.holdingSpeed.set(this.speedData.getHoldingSpeed(this.flapLimitPosition.get(), this.grossWeight.get(), this.pressureAlt.get()));
        // interpolate a position for display on the EICAS
        let interpolatedLabel = 0;
        // if we're clean, no need for interpolation
        if (flapLimitIndex > 0) {
            // choose the next index (lower flap position/angle)
            const nextLowerFlapPosition = this.flapPositionConfig[flapLimitIndex - 1];
            let k;
            if ((flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle) < FlapComputer.ANGLE_TOLERANCE) {
                // flap position doesn't change... interpolate slat angle
                k = (flapLimitPosition.slatAngle - actualSlatAngle) / (flapLimitPosition.slatAngle - nextLowerFlapPosition.slatAngle);
            }
            else {
                k = (flapLimitPosition.flapAngle - actualFlapAngle) / (flapLimitPosition.flapAngle - nextLowerFlapPosition.flapAngle);
            }
            interpolatedLabel = MathUtils.clamp(Avionics.Utils.lerpAngle(flapLimitPosition.label, nextLowerFlapPosition.label, k), nextLowerFlapPosition.label, flapLimitPosition.label);
        }
        this.flapInterpolatedPosition.set(interpolatedLabel);
        if (interpolatedLabel > 0) {
            this.flapInterpolatedLimitSpeed.set(this.flapSpeedLimitLookup.get(interpolatedLabel));
        }
        else {
            this.flapInterpolatedLimitSpeed.set(-1);
        }
    }
    /** Setup event listeners */
    listenToEvents() {
        const sub = this.bus.getSubscriber();
        this.flapsLeftAngle.setConsumer(sub.on('flaps_left_angle').withPrecision(2));
        this.flapsRightAngle.setConsumer(sub.on('flaps_right_angle').withPrecision(2));
        this.slatsLeftAngle.setConsumer(sub.on('slats_left_angle').withPrecision(2));
        this.slatsRightAngle.setConsumer(sub.on('slats_right_angle').withPrecision(2));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(-3));
        sub.on('realTime').atFrequency(5).handle(this.updateFlapPosition.bind(this));
        MappedSubject.create(() => this.needUpdate = true, this.flapsLeftAngle, this.flapsRightAngle, this.slatsLeftAngle, this.slatsRightAngle, this.grossWeight, this.pressureAlt);
    }
}
FlapComputer.ANGLE_TOLERANCE = 0.25;

/**
 * Standard Boeing 787-10 names for backplane instruments and publishers.
 */
var InstrumentBackplaneNames;
(function (InstrumentBackplaneNames) {
    InstrumentBackplaneNames["Adc"] = "Adc";
    InstrumentBackplaneNames["Ahrs"] = "Ahrs";
    InstrumentBackplaneNames["Ai"] = "AI";
    InstrumentBackplaneNames["Alert"] = "Alert";
    InstrumentBackplaneNames["Ambient"] = "Ambient";
    InstrumentBackplaneNames["AntiIce"] = "AntiIce";
    InstrumentBackplaneNames["Autopilot"] = "Autopilot";
    InstrumentBackplaneNames["AutopilotRadioNav"] = "AutopilotRadioNav";
    InstrumentBackplaneNames["B78Apu"] = "B78Apu";
    InstrumentBackplaneNames["B78Door"] = "B78Door";
    InstrumentBackplaneNames["B78Gear"] = "B78Gear";
    InstrumentBackplaneNames["B78Hydraulics"] = "B78Hydraulics";
    InstrumentBackplaneNames["Base"] = "Base";
    InstrumentBackplaneNames["BoeingAutopilot"] = "BoeingAutopilot";
    InstrumentBackplaneNames["Brakes"] = "Brakes";
    InstrumentBackplaneNames["Clock"] = "Clock";
    InstrumentBackplaneNames["ControlSurfaces"] = "ControlSurfaces";
    InstrumentBackplaneNames["CockpitVars"] = "CockpitVars";
    InstrumentBackplaneNames["Eis"] = "Eis";
    InstrumentBackplaneNames["Electrical"] = "Electrical";
    InstrumentBackplaneNames["Engine"] = "Engine";
    InstrumentBackplaneNames["Fadec"] = "Fadec";
    InstrumentBackplaneNames["FuelSystem"] = "FuelSystem";
    InstrumentBackplaneNames["FuelTotalizer"] = "FuelTotalizer";
    InstrumentBackplaneNames["FmsOperatingPhase"] = "FmsOperatingPhase";
    InstrumentBackplaneNames["Gnss"] = "Gnss";
    InstrumentBackplaneNames["HEvents"] = "HEvents";
    InstrumentBackplaneNames["Hydraulics"] = "Hydraulics";
    InstrumentBackplaneNames["LNav"] = "LNav";
    InstrumentBackplaneNames["LNavData"] = "LNavData";
    InstrumentBackplaneNames["Minimums"] = "Minimums";
    InstrumentBackplaneNames["NavCom"] = "NavCom";
    InstrumentBackplaneNames["NavEvents"] = "NavEvents";
    InstrumentBackplaneNames["NavProc"] = "NavProc";
    InstrumentBackplaneNames["Pressurization"] = "Pressurization";
    InstrumentBackplaneNames["SpeedLimit"] = "SpeedLimit";
    InstrumentBackplaneNames["Sound"] = "Sound";
    InstrumentBackplaneNames["Timer"] = "Timer";
    InstrumentBackplaneNames["Traffic"] = "Traffic";
    InstrumentBackplaneNames["VNav"] = "VNav";
    InstrumentBackplaneNames["BoeingVNav"] = "BoeingVNav";
    InstrumentBackplaneNames["WeightFuel"] = "WeightFuel";
    InstrumentBackplaneNames["Xpdr"] = "Xpdr";
    InstrumentBackplaneNames["WeightAndBalance"] = "WeightAndBalance";
    InstrumentBackplaneNames["Units"] = "Units";
})(InstrumentBackplaneNames || (InstrumentBackplaneNames = {}));

/**
 * A Garmin marker beacon receiver system.
 */
class MarkerBeaconSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a marker beacon system.
     * @param index The index of the marker beacon system.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `marker_state_${index}`);
        const radioAltTopic = `marker_mkr_bcn_state_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's marker beacon state data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `marker_mkr_bcn_state_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.beaconStateSub = this.bus.getSubscriber().on('marker_beacon_state').handle(val => {
            this.publisher.pub(topic, val);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.beaconStateSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.beaconStateSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

const SHORT_LLA_FORMAT_REGEX = /^([NS])(\d{2})([WE])(\d{3})$/;
const LONG_LLA_FORMAT_REGEX = /^([NS])(\d{4}(?:\.\d)?)([WE])(\d{5}(?:\.\d)?)$/;
/**
 * Utilities for parsing coordinates in the WT21 supported formats
 */
class BoeingCoordinatesUtils {
    /**
     * Parses a string according to the LAT LONG format
     *
     * @param str             the string to parse
     * @param acceptShortForm whether to accept the short (XYYZUU/XYYUUZ) formats
     *
     * @returns a {@link LatLongInterface} object if a valid LL definition and `null` otherwise
     */
    static parseLatLong(str, acceptShortForm = true) {
        if (acceptShortForm) {
            const shortMatch = SHORT_LLA_FORMAT_REGEX.exec(str);
            if (shortMatch) {
                const latDir = shortMatch[1];
                const latNum = shortMatch[2];
                const lonDir = shortMatch[3];
                const lonNum = shortMatch[4];
                const parsedLat = this.parseLatitude(latDir, latNum);
                const parsedLon = this.parseLongitude(lonDir, lonNum);
                if (!parsedLat || !parsedLon) {
                    return null;
                }
                return { lat: parsedLat, long: parsedLon };
            }
        }
        const fullMatch = LONG_LLA_FORMAT_REGEX.exec(str);
        if (!fullMatch) {
            return null;
        }
        const latDir = fullMatch[1];
        const latNum = fullMatch[2];
        const lonDir = fullMatch[3];
        const lonNum = fullMatch[4];
        // if either has a decimal, both must
        if (latNum.includes('.') !== lonNum.includes('.')) {
            return null;
        }
        const parsedLat = this.parseLatitude(latDir, latNum);
        const parsedLon = this.parseLongitude(lonDir, lonNum);
        if (!parsedLat || !parsedLon) {
            return null;
        }
        return { lat: parsedLat, long: parsedLon };
    }
    /**
     * Parses a latitude string
     *
     * @param dirStr the N or S string part
     * @param numStr the numerical string part
     *
     * @returns the latitude in degrees
     */
    static parseLatitude(dirStr, numStr) {
        let lat;
        const splitLatNum = numStr.split('.');
        const latLeft = splitLatNum[0];
        const latRight = splitLatNum[1];
        // Parse latitude degrees + minutes
        if (latLeft.length > 2) {
            const deg = parseInt(latLeft.substring(0, 2));
            const min = parseInt(latLeft.substring(2));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lat = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lat = parseInt(latLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (latRight) {
            const secs = parseFloat(`0.${latRight}`);
            const add = secs / 60;
            lat += add;
        }
        // If direction is S, negate latitude
        if (dirStr === 'S') {
            lat *= -1;
        }
        if (Math.abs(lat) > 90) {
            return null;
        }
        return lat;
    }
    /**
     * Parses a longitude string
     *
     * @param dirStr the W or E string part
     * @param numStr the numerical string part
     *
     * @returns the longitude in degrees
     */
    static parseLongitude(dirStr, numStr) {
        let lon;
        const splitLonNum = numStr.split('.');
        const lonLeft = splitLonNum[0];
        const lonRight = splitLonNum[1];
        // Parse longitude degrees + minutes
        if (lonLeft.length > 3) {
            const deg = parseInt(lonLeft.substring(0, 3));
            const min = parseInt(lonLeft.substring(3));
            if (min >= 60) {
                return null;
            }
            const minDecimal = min / 60;
            lon = deg + (Number.isFinite(minDecimal) ? minDecimal : 0);
        }
        else {
            lon = parseInt(lonLeft);
        }
        // If we have digits after a decimal, we consider them as decimals of a minute
        if (lonRight) {
            const secs = parseFloat(`0.${lonRight}`);
            const add = secs / 60;
            lon += add;
        }
        // If direction is W, negate longitude
        if (dirStr === 'W') {
            lon *= -1;
        }
        if (Math.abs(lon) > 180) {
            return null;
        }
        return lon;
    }
}

/** Example match would be: `DEN270/22.5` */
const PBD_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
/** Example match would be: `DEN090/DVV180` */
const PBPB_REGEX = /^(\w+)(\d{3}(?:\.\d)?)\/(\w+)(\d{3}(?:\.\d)?)(?:\/(\w+))?$/;
const ATO_REGEX = /^(\w+)\/([+-]?\d{1,3}(?:\.\d)?)(?:\/(\w+))?$/;
// This should technically be only TF, but that doesn't make much sense and seems like a mistake
const ATO_VALID_PREVIOUS_LEG_TYPES = [LegType.CF, LegType.DF, LegType.IF, LegType.TF, LegType.RF];
const ATO_VALID_NEXT_LEG_TYPES = [LegType.IF, LegType.TF];
/**
 * Error that can occur when creating an ATO waypoint
 */
var AlongTrackOffsetError;
(function (AlongTrackOffsetError) {
    AlongTrackOffsetError[AlongTrackOffsetError["NotAvailable"] = 0] = "NotAvailable";
    AlongTrackOffsetError[AlongTrackOffsetError["DistanceTooLarge"] = 1] = "DistanceTooLarge";
})(AlongTrackOffsetError || (AlongTrackOffsetError = {}));
/**
 * Utilities for Boeing pilot defined waypoints
 */
class BoeingPilotWaypointUtils {
    /**
     * Returns whether the limit number of pilot defined waypoints is reached
     *
     * @param facilities the existing user facilities
     *
     * @returns a boolean
     */
    static isLimitReached(facilities) {
        return facilities.length >= 50; // TODO 50 for RTE 1, 50 for RTE 2
    }
    /**
     * Returns the next available auto-generated name, given existing user facilities and an ident
     *
     * @param facilities the existing user facilities
     * @param ident      the ident of the facility
     *
     * @returns a string to be used as an ident for a user facility
     */
    static nextAutoGeneratedName(facilities, ident) {
        let suffix = 1;
        for (const facility of facilities) {
            const facIdent = ICAO.getIdent(facility.icao);
            if (facIdent.match(`${ident.substring(0, 3)}\\d\\d`)) {
                suffix++;
            }
        }
        return `${ident.substring(0, 3)}${suffix.toString().padStart(2, '0')}`;
    }
    /**
     * Returns the name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(0).padStart(2, '0');
        const longitudeSign = coordinates.lon > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.lon).toFixed(0).padStart(3, '0');
        return `${latitudeSign}${latitudeStr}${longitudeSign}${longitudeStr}`;
    }
    /**
     * Returns the internal name for a lat/long waypoint
     *
     * @param coordinates the coordinates of the waypoint
     *
     * @returns a string
     */
    static latLongInternalIdent(coordinates) {
        const latitudeSign = coordinates.lat > 0 ? 'N' : 'S';
        const latitudeStr = Math.abs(coordinates.lat).toFixed(3);
        const longitudeSign = coordinates.long > 0 ? 'E' : 'W';
        const longitudeStr = Math.abs(coordinates.long).toFixed(3);
        return `${latitudeSign}${latitudeStr}|${longitudeSign}${longitudeStr}`;
    }
    /**
     * Converts a scratchpad entry to a {@link UserFacility} if applicable
     *
     * @param fms                  the {@link BoeingFms} instance
     * @param selectWptFromIdent   the function called to select a facility
     * @param scratchpadContents   the scratchpad contents
     * @param targetGlobalLegIndex the target global leg index, if applicable
     *
     * @returns a user facility, or null if none is parsed
     */
    static async createFromScratchpadEntry(fms, selectWptFromIdent, scratchpadContents, targetGlobalLegIndex) {
        var _a, _b, _c, _d;
        const pbdMatch = BoeingPilotWaypointUtils.parsePlaceBearingDistance(scratchpadContents);
        if (pbdMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facility = await selectWptFromIdent(pbdMatch.placeIdent, fms.ppos);
            if (facility) {
                const ident = (_a = pbdMatch.newIdent) !== null && _a !== void 0 ? _a : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facility.icao));
                const usrFacility = UserFacilityUtils.createFromRadialDistance(`U      ${ident}`, facility, pbdMatch.bearing, pbdMatch.distance);
                return [usrFacility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const pbpbMatch = BoeingPilotWaypointUtils.parsePlaceBearingPlaceBearing(scratchpadContents);
        if (pbpbMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const facilityA = await selectWptFromIdent(pbpbMatch.placeAIdent, fms.ppos);
            const facilityB = await selectWptFromIdent(pbpbMatch.placeBIdent, fms.ppos);
            if (facilityA && facilityB) {
                const ident = (_b = pbpbMatch.newIdent) !== null && _b !== void 0 ? _b : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, ICAO.getIdent(facilityA.icao));
                const facility = UserFacilityUtils.createFromRadialRadial(`U      ${ident}`, facilityA, pbpbMatch.bearingA, facilityB, pbpbMatch.bearingB);
                if (!facility) {
                    return Promise.reject('NO INTERSECTION');
                }
                return [facility, false];
            }
            else {
                return Promise.reject('NOT IN DATA BASE');
            }
        }
        const atoMatch = BoeingPilotWaypointUtils.parseAlongTrackOffset(scratchpadContents);
        if (atoMatch) {
            if (targetGlobalLegIndex === undefined) {
                throw new Error('Along-track offset can only be created by createFromScratchpadEntry is a target global leg index is specified');
            }
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            const plan = fms.getPlanForFmcRender();
            const lnavActiveLegIndex = SimVar.GetSimVarValue(LNavVars.TrackedLegIndex, SimVarValueType.Number);
            const lnavActiveLegDistanceAlong = SimVar.GetSimVarValue(LNavVars.LegDistanceAlong, SimVarValueType.NM);
            const result = await BoeingPilotWaypointUtils.createAlongTrackOffset(fms.facLoader, plan, targetGlobalLegIndex, lnavActiveLegIndex, lnavActiveLegDistanceAlong, atoMatch.distance);
            if (!Array.isArray(result)) {
                if (result === AlongTrackOffsetError.DistanceTooLarge) {
                    return Promise.reject('DISTANCE TOO LARGE');
                }
                else {
                    return Promise.reject('ALONG TRK WPT N/A');
                }
            }
            const [usrPos, insertAfter] = result;
            const leg = plan.getLeg(targetGlobalLegIndex);
            const ident = (_c = atoMatch.newIdent) !== null && _c !== void 0 ? _c : BoeingPilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, (_d = leg.name) !== null && _d !== void 0 ? _d : 'USR');
            return [UserFacilityUtils.createFromLatLon(`U      ${ident}`, usrPos.lat, usrPos.lon), insertAfter];
        }
        const coordinatesMatch = BoeingCoordinatesUtils.parseLatLong(scratchpadContents);
        if (coordinatesMatch) {
            const existingUserFacilities = fms.getUserFacilities();
            if (BoeingPilotWaypointUtils.isLimitReached(existingUserFacilities)) {
                return Promise.reject('PILOT WPT LIST FULL');
            }
            // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
            // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
            // needed - in BoeingFmsUtils.buildBoeingLegName, we extract the values to reconstruct the short name
            const ident = BoeingPilotWaypointUtils.latLongInternalIdent(coordinatesMatch);
            return [UserFacilityUtils.createFromLatLon(`ULL    ${ident}`, coordinatesMatch.lat, coordinatesMatch.long), false];
        }
        return null;
    }
    /**
     * Parses a string according to the PB/D format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingDistanceInput} object if a valid PBD definition and `null` otherwise
     */
    static parsePlaceBearingDistance(str) {
        const match = str.match(PBD_REGEX);
        if (!match) {
            return null;
        }
        const bearing = parseFloat(match[2]);
        if (bearing < 0 || bearing > 360) {
            return null;
        }
        return {
            placeIdent: match[1],
            bearing,
            distance: parseFloat(match[3]),
            newIdent: match[4],
        };
    }
    /**
     * Parses a string according to the PB/PB format
     *
     * @param str the string to parse
     *
     * @returns a {@link PlaceBearingPlaceBearingInput} object if a valid PBPB definition and `null` otherwise
     */
    static parsePlaceBearingPlaceBearing(str) {
        const match = str.match(PBPB_REGEX);
        if (!match) {
            return null;
        }
        const bearingA = parseFloat(match[2]);
        const bearingB = parseFloat(match[4]);
        if (bearingA < 0 || bearingA > 360 || bearingA < 0 || bearingB > 360) {
            return null;
        }
        return {
            placeAIdent: match[1],
            bearingA,
            placeBIdent: match[3],
            bearingB,
            newIdent: match[5],
        };
    }
    /**
     * Parses a string according to the along-track offset format
     *
     * @param str the string to parse
     *
     * @returns a {@link AlongTrackOffsetInput} object if a valid ATO definition and `null` otherwise
     */
    static parseAlongTrackOffset(str) {
        const match = str.match(ATO_REGEX);
        if (!match) {
            return null;
        }
        return {
            placeIdent: match[1],
            distance: parseFloat(match[2]),
            newIdent: match[3],
        };
    }
    /**
     * Creates an along-track offset position with input data
     *
     * @param facLoader                  the facility loader
     * @param plan                       the flight plan the ATO is being created from
     * @param globalLegIndex             the global leg index in the plan the ATO is being created from (WT21: LSK position)
     * @param lnavActiveLegIndex         the active lnav leg index (not nominal)
     * @param lnavDistanceAlongActiveLeg the distance flown along the active lnav leg
     * @param distance                   the distance input
     *
     * @returns a {@link GeoPoint}
     */
    static async createAlongTrackOffset(facLoader, plan, globalLegIndex, lnavActiveLegIndex, lnavDistanceAlongActiveLeg, distance) {
        const planLeg = plan.tryGetLeg(globalLegIndex);
        if (planLeg) {
            const distanceNegative = distance < 0;
            // Check for the previous leg type being valid if the distance is negative
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    if (!ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType)) {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
                else {
                    return AlongTrackOffsetError.NotAvailable;
                }
            }
            let fixIcao1 = undefined;
            let fixIcao2 = undefined;
            let facility1 = undefined;
            let facility2 = undefined;
            if (distanceNegative) {
                const previousPlanLeg = plan.tryGetLeg(globalLegIndex - 1);
                if (previousPlanLeg) {
                    const previousLegType = previousPlanLeg.leg.type;
                    const legType = planLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(previousLegType) && ATO_VALID_NEXT_LEG_TYPES.includes(legType)) {
                        let maxDistance = planLeg.calculated ? UnitType.NMILE.convertFrom(planLeg.calculated.distance, UnitType.METER) : -1;
                        if (lnavActiveLegIndex === globalLegIndex) {
                            maxDistance -= lnavDistanceAlongActiveLeg;
                            maxDistance = Math.max(0, maxDistance);
                        }
                        if (Math.abs(distance) < maxDistance) {
                            fixIcao1 = previousPlanLeg.leg.fixIcao;
                            fixIcao2 = planLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                }
            }
            else {
                const nextPlanLeg = plan.tryGetLeg(globalLegIndex + 1);
                if (nextPlanLeg) {
                    const legType = planLeg.leg.type;
                    const nextLegType = nextPlanLeg.leg.type;
                    if (ATO_VALID_PREVIOUS_LEG_TYPES.includes(legType) && ATO_VALID_NEXT_LEG_TYPES.includes(nextLegType)) {
                        const maxDistance = nextPlanLeg.calculated ? UnitType.NMILE.convertFrom(nextPlanLeg.calculated.distance, UnitType.METER) : -1;
                        let minDistance = 0;
                        if (lnavActiveLegIndex === globalLegIndex + 1) {
                            minDistance = lnavDistanceAlongActiveLeg;
                        }
                        if (distance > minDistance && distance < maxDistance) {
                            fixIcao1 = planLeg.leg.fixIcao;
                            fixIcao2 = nextPlanLeg.leg.fixIcao;
                        }
                        else {
                            return AlongTrackOffsetError.DistanceTooLarge;
                        }
                    }
                    else {
                        return AlongTrackOffsetError.NotAvailable;
                    }
                }
            }
            if (fixIcao1 && fixIcao1 !== ICAO.emptyIcao && fixIcao2 && fixIcao2 !== ICAO.emptyIcao) {
                facility1 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao1), fixIcao1);
                facility2 = await facLoader.getFacility(ICAO.getFacilityType(fixIcao2), fixIcao2);
                if (facility1 && facility2) {
                    const circle = GeoCircle.createGreatCircle(facility1, facility2);
                    const offsetOut = new Float64Array(3);
                    circle.offsetDistanceAlong(distanceNegative ? facility2 : facility1, UnitType.GA_RADIAN.convertFrom(distance, UnitType.NMILE), offsetOut);
                    const geoPoint = new GeoPoint(0, 0);
                    geoPoint.setFromCartesian(offsetOut);
                    return [geoPoint, !distanceNegative];
                }
            }
        }
        return AlongTrackOffsetError.NotAvailable;
    }
}

/**
 * Utility Methods for the Boeing FMS.
 */
class BoeingFmsUtils {
    /**
     * Gets the active segment in the Lateral Flight Plan.
     * @param plan The Lateral Flight Plan.
     * @returns The Active Flight Plan Segment or undefined.
     */
    static getActiveSegment(plan) {
        if (plan.length > 0 && plan.activeLateralLeg >= 0 && plan.activeLateralLeg < plan.length) {
            return plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
        }
        return undefined;
    }
    /**
     * Checks whether a leg exists in a segment with the specified ICAO and, if so, returns the leg index of that leg.
     * @param segment The segment to check for the icao.
     * @param icao The ICAO to check for in the segment.
     * @returns The segment leg index of the leg with the matching icao, or -1.
     */
    static findIcaoInSegment(segment, icao) {
        if (icao !== undefined) {
            for (let l = 0; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (leg !== undefined && leg.leg !== undefined && leg.leg.fixIcao && leg.leg.fixIcao === icao) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Utility method to return a one-way runway leg
     * @param airport The runway's parent airport.
     * @param oneWayRunway is the one wway runway object
     * @param isOriginRunway is a bool whether this is the origin or destination (origin = true, dest = false)
     * @returns a leg object for the runway
     */
    static buildRunwayLeg(airport, oneWayRunway, isOriginRunway) {
        return FlightPlan.createLeg({
            lat: oneWayRunway.latitude,
            lon: oneWayRunway.longitude,
            type: isOriginRunway ? LegType.IF : LegType.TF,
            fixIcao: RunwayUtils.getRunwayFacilityIcao(airport, oneWayRunway),
            altitude1: isOriginRunway
                ? oneWayRunway.elevation
                : oneWayRunway.elevation + UnitType.METER.convertFrom(50, UnitType.FOOT) // Arrival runway leg altitude should be 50 feet above threshold
        });
    }
    /**
     * Utility method to return a visual approach for a runway.
     * @param facRepo is a facility repository in which to store the created faf leg facility
     * @param airport is the airport facility for the visual approach.
     * @param runway is the runway to build the visual approach for.
     * @param finalLegDistance is the distance from the runway to place the faf leg in NM.
     * @param finalLegVpa is the vertical path angle selected for the final approach, or undefined if not applicable.
     * @returns an approach procedure.
     */
    static buildVisualApproach(facRepo, airport, runway, finalLegDistance, finalLegVpa) {
        const runwayVec = GeoPoint.sphericalToCartesian(runway.latitude, runway.longitude, BoeingFmsUtils.vec3Cache[0]);
        const approachPath = BoeingFmsUtils.geoCircleCache[0].setAsGreatCircle(runwayVec, runway.course);
        const runwayCode = RunwayUtils.getRunwayCode(runway.direction);
        const runwayLetter = RunwayUtils.getDesignatorLetter(runway.runwayDesignator).padStart(1, ' ');
        const fafLatLon = approachPath.offsetDistanceAlong(runwayVec, UnitType.NMILE.convertTo(-finalLegDistance, UnitType.GA_RADIAN), BoeingFmsUtils.geoPointCache[0]);
        const runwayIdent = RunwayUtils.getRunwayNameString(runway.direction, runway.runwayDesignator);
        const finalLegIdent = `${finalLegVpa !== undefined ? 'FA' : 'RX'}${runwayIdent}`;
        const icao = `S${ICAO.getIdent(airport.icao).padStart(4, ' ')}${runwayCode}${runwayLetter}${finalLegIdent}`;
        // Add facility to facRepo
        const fafFacility = UserFacilityUtils.createFromLatLon(icao, fafLatLon.lat, fafLatLon.lon);
        facRepo.add(fafFacility);
        const fafLeg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: icao,
            course: MagVar.trueToMagnetic(approachPath.bearingAt(fafLatLon), fafLatLon),
            fixTypeFlags: FixTypeFlags.FAF,
            lat: fafLatLon.lat,
            lon: fafLatLon.lon,
            altDesc: AltitudeRestrictionType.AtOrAbove,
            altitude1: runway.elevation + (Math.tan(UnitType.DEGREE.convertTo(finalLegVpa !== null && finalLegVpa !== void 0 ? finalLegVpa : 3, UnitType.RADIAN)) * UnitType.NMILE.convertTo(finalLegDistance, UnitType.METER)),
        });
        const runwayLeg = BoeingFmsUtils.buildRunwayLeg(airport, runway, false);
        runwayLeg.verticalAngle = finalLegVpa !== undefined ? 360 - Math.abs(finalLegVpa) : 0;
        runwayLeg.fixTypeFlags = FixTypeFlags.MAP;
        const finalLegs = [];
        finalLegs.push(fafLeg);
        finalLegs.push(runwayLeg);
        return {
            name: `Visual RW${runway.designation}`,
            runway: runway.designation,
            icaos: [],
            transitions: [],
            finalLegs: finalLegs,
            missedLegs: [],
            approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
            approachSuffix: '',
            runwayDesignator: runway.runwayDesignator,
            runwayNumber: runway.direction,
            rnavTypeFlags: RnavTypeFlags.None
        };
    }
    /**
     * Utility method to check whether an approach is authorized for GPS guidance.
     * @param approachType The approach type.
     * @returns True if GPS guidance is authorized, false otherwise.
     */
    static isGpsApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
            case ApproachType.APPROACH_TYPE_RNAV:
                return true;
        }
        return false;
    }
    /**
     * Utility method to check for an approach with a tunable localizer.
     * @param approachType The approach type.
     * @returns True if a localizer needs to be tuned, otherwise false.
     */
    static isLocalizerApproach(approachType) {
        switch (approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_SDF:
                return true;
        }
        return false;
    }
    /**
     * Gets the procedure index and transition index from procedure details of the lateral plan based on segment type.
     * @param segmentType The segment type.
     * @param lateralPlan The lateral flight plan.
     * @returns an array of procedureIndex, transitionIndex.
     */
    static getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, lateralPlan) {
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return [lateralPlan.procedureDetails.departureIndex, lateralPlan.procedureDetails.departureTransitionIndex];
            case FlightPlanSegmentType.Arrival:
                return [lateralPlan.procedureDetails.arrivalIndex, lateralPlan.procedureDetails.arrivalTransitionIndex];
            case FlightPlanSegmentType.Approach:
                return [lateralPlan.procedureDetails.approachIndex, lateralPlan.procedureDetails.approachTransitionIndex];
        }
        return [-1, -1];
    }
    /**
     * Combiner method to get a procedure name as a string for the FPLN Page.
     * @param segmentType The segment type.
     * @param facility The facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The transition index.
     * @returns the name as a string.
     */
    static getProcedureNameAsString(segmentType, facility, procedureIndex, transitionIndex) {
        if (facility === undefined) {
            return 'NO FACILITY';
        }
        switch (segmentType) {
            case FlightPlanSegmentType.Departure:
                return this.getDepartureNameAsString(facility, procedureIndex);
            case FlightPlanSegmentType.Arrival:
                if (transitionIndex !== undefined) {
                    return this.getArrivalNameAsString(facility, procedureIndex, transitionIndex);
                }
                break;
            case FlightPlanSegmentType.Approach:
                if (procedureIndex === -1 && transitionIndex === -1) {
                    // must be visual
                    return 'VISUAL';
                }
                else if (transitionIndex !== undefined) {
                    return this.getApproachNameAsString(facility, procedureIndex, transitionIndex);
                }
        }
        return 'PROC NAME ERROR';
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @returns The name of the departure procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getDepartureNameAsString(facility, procedureIndex) {
        // let name = '';
        const departure = facility.departures[procedureIndex];
        // if (runway) {
        //   name += `RW${runway.designation}.`;
        // }
        // const transition = departure.enRouteTransitions[transitionIndex];
        // if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(transition.legs[transition.legs.length - 1].fixIcao)}`;
        // } else if (departure.commonLegs.length > 0) {
        //   name += `${departure.name}.${ICAO.getIdent(departure.commonLegs[departure.commonLegs.length - 1].fixIcao)}`;
        // } else {
        //   name += `${departure.name}`;
        // }
        return `${departure.name}`;
    }
    /**
     * Gets the name of a arrival procedure as a string.
     * @param facility The airport to which the arrival belongs.
     * @param procedureIndex An arrival procedure index.
     * @param transitionIndex The index of the arrival enroute transition.
     * @returns The name of the arrival procedure.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    static getArrivalNameAsString(facility, procedureIndex, transitionIndex) {
        const arrival = facility.arrivals[procedureIndex];
        // TODO We may need to add back the transition name
        const transition = arrival.enRouteTransitions[transitionIndex];
        if (transition !== undefined && transitionIndex > -1 && transition.legs.length > 0) {
            return `${ICAO.getIdent(transition.legs[0].fixIcao)}.${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        else {
            return `${arrival === null || arrival === void 0 ? void 0 : arrival.name}`;
        }
        // else if (arrival.commonLegs.length > 0) {
        //   name += `${ICAO.getIdent(arrival.commonLegs[0].fixIcao)}.${arrival?.name}`;
        // }
        // if (runway) {
        //   name += `.RW${runway.designation}`;
        // }
        // return `${arrival?.name}`;
    }
    /**
     * Utility method to analyze an approach for its name components and
     * pack them into a custom type.
     * @param proc The approach procedure.
     * @param transitionIndex The transition index.
     * @returns The name as an ApproachNameParts
     */
    static getApproachNameAsParts(proc, transitionIndex) {
        let type;
        // let subtype: string | undefined;
        // let rnavType: string | undefined;
        switch (proc.approachType) {
            case ApproachType.APPROACH_TYPE_GPS:
                type = 'GPS';
                break;
            case ApproachType.APPROACH_TYPE_VOR:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDB:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_ILS:
                type = 'ILS';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER:
                type = 'LOC';
                break;
            case ApproachType.APPROACH_TYPE_SDF:
                type = 'SDF';
                break;
            case ApproachType.APPROACH_TYPE_LDA:
                type = 'LDA';
                break;
            case ApproachType.APPROACH_TYPE_VORDME:
                type = 'VOR';
                break;
            case ApproachType.APPROACH_TYPE_NDBDME:
                type = 'NDB';
                break;
            case ApproachType.APPROACH_TYPE_RNAV:
                type = 'RNV';
                break;
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
                type = 'BCS';
                break; // no idea if this is the real format
            case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                type = 'VISUAL';
                break;
            default:
                type = '???';
                break;
        }
        let transition = undefined;
        if (transitionIndex > -1 && proc.transitions.length > 0) {
            transition = proc.transitions[transitionIndex].name;
        }
        return {
            type: type,
            suffix: proc.approachSuffix ? proc.approachSuffix : undefined,
            runway: proc.runwayNumber === 0 ? undefined : RunwayUtils.getRunwayNameString(proc.runwayNumber, proc.runwayDesignator, true),
            transition: transition
        };
    }
    /**
     * Gets the name of a departure procedure as a string.
     * @param facility The Facility.
     * @param procedureIndex The procedure index.
     * @param transitionIndex The index of the departure enroute transition.
     * @param runway The runway of the departure, if any.
     * @returns The name of the departure procedure.
     */
    /**
     * Utility method that gets an approach and returns its name as a flat
     * string suitable for use in embedded text content.
     * @param facility The Facility.
     * @param procedureIndex The approach index.
     * @param transitionIndex The index of the approach transition.
     * @returns The formatted name as a string.
     */
    static getApproachNameAsString(facility, procedureIndex, transitionIndex) {
        const approach = facility.approaches[procedureIndex];
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, transitionIndex);
        let name = parts.transition ? parts.transition + '.' + parts.type : parts.type;
        parts.suffix && (name += `${parts.runway ? ' ' : '–'}${parts.suffix}`);
        parts.runway && (name += ` ${parts.runway}`);
        // parts.flags && (name += ` ${parts.flags}`);
        return name;
    }
    /**
     * Get the name of an approach in the format used on the EFIS
     * @param facilityOrApproach Either an airport facility (if combined with a procedure as the second arg) or an approach procedure
     * @param procedureIndex Index of the desired approach if the first arg is an airport facility
     * @returns formatted approach name ready for EFIS display
     */
    static getApproachNameAsEfisString(facilityOrApproach, procedureIndex) {
        var _a, _b;
        const approach = 'airportPrivateType' in facilityOrApproach ? facilityOrApproach.approaches[procedureIndex !== null && procedureIndex !== void 0 ? procedureIndex : -1] : facilityOrApproach;
        if (!approach) {
            return '???';
        }
        const parts = BoeingFmsUtils.getApproachNameAsParts(approach, -1);
        if (parts.runway) {
            return `${parts.type}${(_a = parts.suffix) !== null && _a !== void 0 ? _a : ''} ${parts.runway}`;
        }
        else {
            return `${parts.type}${(_b = parts.suffix) !== null && _b !== void 0 ? _b : ''}`;
        }
    }
    /**
     * Checks whether an approach has a primary NAV frequency based on its type. Only approaches of the following types
     * have primary NAV frequencies: ILS, LOC (BC), LDA, SDF, VOR(DME).
     * @param approach The approach to check.
     * @returns Whether the specified approach has a primary NAV frequency based on its type.
     */
    static approachHasNavFrequency(approach) {
        switch (approach.approachType) {
            case ApproachType.APPROACH_TYPE_ILS:
            case ApproachType.APPROACH_TYPE_LOCALIZER:
            case ApproachType.APPROACH_TYPE_LOCALIZER_BACK_COURSE:
            case ApproachType.APPROACH_TYPE_LDA:
            case ApproachType.APPROACH_TYPE_SDF:
            case ApproachType.APPROACH_TYPE_VOR:
            case ApproachType.APPROACH_TYPE_VORDME:
                return true;
            default:
                return false;
        }
    }
    /**
     * Gets the nominal leg from which a specified flight plan leg originates. The nominal from leg excludes any legs
     * which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLeg(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return undefined;
        }
        for (leg of plan.legs(true, plan.getLegIndexFromLeg(leg))) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return leg;
            }
        }
        return undefined;
    }
    /**
     * Gets the global leg index of the nominal leg from which a specified flight plan leg originates. The nominal from
     * leg excludes any legs which are part of a direct to or vectors-to-final sequence.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment containing the leg for which to get the from leg.
     * @param segmentLegIndex The index of the leg for which to get the from leg in its segment.
     * @returns The nominal leg from which the specified flight plan leg originates.
     */
    static getNominalFromLegIndex(plan, segmentIndex, segmentLegIndex) {
        let leg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return -1;
        }
        let index = plan.getLegIndexFromLeg(leg);
        for (leg of plan.legs(true, index)) {
            if (!BitFlags.isAny(leg.flags, LegDefinitionFlags.DirectTo | LegDefinitionFlags.VectorsToFinal)) {
                return index;
            }
            index--;
        }
        return -1;
    }
    /**
     * Gets an altitude for display with padding, Flight Level Handling
     * @param altitudeMeters the altitude IN METERS to evaluate
     * @param transitionAltitudeFeet the transition altitude IN FEET to evaluate
     * @returns A display string
     */
    static parseAltitudeForDisplay(altitudeMeters, transitionAltitudeFeet) {
        const altitudeFeet = Math.round(UnitType.METER.convertTo(altitudeMeters, UnitType.FOOT));
        transitionAltitudeFeet = Math.round(transitionAltitudeFeet);
        if (altitudeFeet >= transitionAltitudeFeet) {
            return 'FL' + (altitudeFeet / 100).toFixed(0).padStart(3, '0');
        }
        return altitudeFeet.toFixed(0).padStart(5, ' ');
    }
    /**
     * Checks if leg type is an "arc" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isArcLeg(legType) {
        return arcLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "heading to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "heading to" leg type.
     */
    static isHeadingToLeg(legType) {
        return headingToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "hold at" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "hold at" leg type.
     */
    static isHoldAtLeg(legType) {
        return holdAtLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is an "to altitude" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "to altitude" leg type.
     */
    static isAltitudeLeg(legType) {
        return altitudeLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "course to" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "course to" leg type.
     */
    static isCourseToLeg(legType) {
        return courseToLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "discontinuity" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "discontinuity" leg type.
     */
    static isDiscontinuityLeg(legType) {
        return discontinuityLegTypes.includes(legType);
    }
    /**
     * Checks if leg type is a "vectors" leg type.
     * @param legType The LegType.
     * @returns Whether the leg type is a "vectors" leg type.
     */
    static isVectorsLeg(legType) {
        return vectorsTypes.includes(legType);
    }
    /**
     * Gets the direct to magnetic course from the leg vectors.
     * @param leg The Leg Definition
     * @returns the magnetic course.
     */
    static getDirectToCourse(leg) {
        let course = 360;
        if (leg.leg.type === LegType.DF && leg.calculated !== undefined) {
            const vector = leg.calculated.flightPath[leg.calculated.flightPath.length - 1];
            if (vector !== undefined) {
                const circle = FlightPathUtils.setGeoCircleFromVector(vector, this.geoCircleCache[0]);
                // If it is a great circle, then it's basically the "straight" part of the path, so we want to get the bearing at the start,
                // otherwise it's the turn, so we want the bearing from the end of the turn.
                const point = circle.isGreatCircle()
                    ? BoeingFmsUtils.geoPointCache[0].set(vector.startLat, vector.startLon)
                    : BoeingFmsUtils.geoPointCache[0].set(vector.endLat, vector.endLon);
                course = circle.bearingAt(point, Math.PI);
                course = MagVar.trueToMagnetic(course, MagVar.get(point));
            }
        }
        else if (leg.leg.type === LegType.CF && leg.calculated !== undefined) {
            course = leg.leg.course;
        }
        return course;
    }
    /**
     * Checks for an airway at a leg and returns the airway or undefined
     * @param facLoader The facility loader.
     * @param icao The icao of the entry to check.
     * @param airwayName The airway to search for.
     * @returns The airway object or undefined
     */
    static async isAirwayAtLeg(facLoader, icao, airwayName) {
        const facility = await facLoader.getFacility(FacilityType.Intersection, icao);
        if (facility) {
            const matchedRoute = facility.routes.find((r) => r.name === airwayName);
            if (matchedRoute) {
                const airway = await facLoader.getAirway(matchedRoute.name, matchedRoute.type, icao);
                return airway;
            }
        }
        return undefined;
    }
    /**
     * Looks for an airway with name {@link airwayBName} crossing one of the fixes of airway {@link airwayA}
     *
     * @param facLoader the facility loader
     * @param airwayA the airway to look for intersections in
     * @param airwayBName the name of the second airway
     *
     * @returns a tuple of the found airway and the fix ICAO where the two airways cross
     */
    static async findAirwayCrossingAirway(facLoader, airwayA, airwayBName) {
        for (const fac of airwayA.waypoints) {
            const airwayBFacRoute = fac.routes.find((it) => it.name === airwayBName);
            if (airwayBFacRoute) {
                const airway = await facLoader.getAirway(airwayBFacRoute.name, airwayBFacRoute.type, fac.icao);
                return [airway, fac.icao];
            }
        }
    }
    /**
     * Checks for an airway exit at a given icao.
     * @param airway The Airway Object.
     * @param icao The icao of the entry to check.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static isLegValidAirwayExit(airway, icao) {
        return airway.waypoints.find((w) => w.icao === icao);
    }
    /**
     * Checks for an airway exit matching an input ident
     * @param airway The AirwayObject.
     * @param ident The Ident to search for.
     * @returns The Intersection Facility if the leg is a valid exit to the airway.
     */
    static matchIdentToAirway(airway, ident) {
        return airway.waypoints.find((w) => ICAO.getIdent(w.icao) === ident);
    }
    /**
     * Checks whether a leg should appear on the Direct To Page based on leg type.
     * @param leg The FlightPlanLeg to evaluate.
     * @returns whether or not the leg should appear on the Direct To page.
     */
    static canLegBeSelectedOnDirectPage(leg) {
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
            case LegType.FM:
            case LegType.VM:
            case LegType.HA:
            case LegType.HM:
            case LegType.HF:
            case LegType.PI:
            case LegType.CI:
            case LegType.VI:
            case LegType.CR:
            case LegType.VR:
                return false;
            default:
                return true;
        }
    }
    /**
     * Checks whether a leg with a given type being active should cause LNAV to be auto unsuspended
     * @param legType the leg type
     * @returns a boolean
     */
    static canLegBeAutoUnsuspended(legType) {
        switch (legType) {
            case LegType.HM:
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return false;
            default:
                return true;
        }
    }
    /**
     * Builds leg names using default nomenclature.
     * @param leg The leg to build a name for.
     * @returns The name of the leg.
     */
    static buildBoeingLegName(leg) {
        // Name for PPOS hold leg
        if (leg.fixIcao === ICAO.emptyIcao && BoeingFmsUtils.isHoldAtLeg(leg.type)) {
            return 'PPOS';
        }
        let legDistanceNM;
        switch (leg.type) {
            case LegType.CA:
            case LegType.FA:
            case LegType.VA:
                return `(${UnitType.METER.convertTo(leg.altitude1, UnitType.FOOT).toFixed(0).padEnd(5, ' ')})`;
            case LegType.FM:
            case LegType.VM:
                return 'VECTORS';
            case LegType.FC:
                legDistanceNM = Math.round(UnitType.METER.convertTo(leg.distance, UnitType.NMILE));
                return `D${leg.course.toFixed(0).padStart(3, '0')}${String.fromCharCode(64 + Utils.Clamp(legDistanceNM, 1, 26))}`;
            case LegType.CD:
            case LegType.FD:
            case LegType.VD:
                legDistanceNM = UnitType.METER.convertTo(leg.distance, UnitType.NMILE);
                return `${ICAO.getIdent(leg.originIcao)}${legDistanceNM.toFixed(1)}`;
            case LegType.CR:
            case LegType.VR:
                return `${ICAO.getIdent(leg.originIcao)}${leg.theta.toFixed(0)}`;
            case LegType.CI:
            case LegType.VI:
            case LegType.PI:
                return '(INTC)';
            default:
                if (leg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(leg.fixIcao) === FacilityType.USR) {
                    const regionStr = ICAO.getRegionCode(leg.fixIcao);
                    // This is a hack used to store a facility ICAO that won't clash with other pilot-defined LL waypoints that end up
                    // with the same displayed ident. The ident contained in the facility ICAO has higher precision than
                    // needed - here, we extract the values to reconstruct the short name
                    if (regionStr === 'LL') {
                        const ident = ICAO.getIdent(leg.fixIcao);
                        const [latStr, longStr] = ident.split('|');
                        const lat = parseFloat(latStr.replace('N', '').replace('S', '-'));
                        const long = parseFloat(longStr.replace('E', '').replace('W', '-'));
                        return BoeingPilotWaypointUtils.latLongIdent(BoeingFmsUtils.geoPointCache[1].set(lat, long));
                    }
                }
                return ICAO.getIdent(leg.fixIcao);
        }
    }
    /**
     * Reconciles a flight plan's Direct-To data with its internal leg structure. Scans the legs of the flight plan for
     * Direct-To legs and sets the segment index and segment leg index of the plan's Direct-To data to point to the leg
     * immediately preceding the first Direct-To leg found, or to -1 for both if the plan contains no Direct-To legs.
     * @param plan A flight plan.
     */
    static reconcileDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.directToData.segmentIndex = i;
                    plan.directToData.segmentLegIndex = j - 1;
                    return;
                }
            }
        }
        plan.directToData.segmentIndex = -1;
        plan.directToData.segmentLegIndex = -1;
    }
    /**
     * Removes all of a flight plan's Direct-To data, but from the DirectToData object and from any legs in the plan.
     * Scans the legs of the flight plan for Direct-To legs and removes them.
     * @param plan A flight plan.
     */
    static removeAllDirectToData(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
        plan.setDirectToData(-1, true);
    }
    /**
     * Removes all of a flight plan's Displaced Active Legs,
     * which are flagged when a procedure is added and the active leg array is moved to enroute.
     * @param plan A flight plan.
     */
    static removeDisplacedActiveLegs(plan) {
        // Scan flight plan for DTO legs
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            for (let j = 0; j < segment.legs.length; j++) {
                const leg = segment.legs[j];
                if (BitFlags.isAll(leg.flags, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg)) {
                    plan.removeLeg(i, j, true);
                }
            }
        }
    }
    /**
     * Writes the calculated end coordinates of a leg to {@link out}, if the necessary calculated data exists
     *
     * @param leg the leg to find the end point for
     * @param out the {@link GeoPoint} to write the result to
     *
     * @returns whether anything was written
     */
    static writeLegCalculatedEndPoint(leg, out) {
        if (leg.calculated && leg.calculated.endLat && leg.calculated.endLon) {
            out.set(leg.calculated.endLat, leg.calculated.endLon);
            return true;
        }
        return false;
    }
    /**
     * Returns true if a leg is a vector of discontinuity.
     * @param leg The FlightPlanLeg
     * @returns Whether the leg is a vector of discontinuity
     */
    static isLegVectOrDisco(leg) {
        switch (leg.type) {
            case LegType.FM:
            case LegType.VM:
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
            default:
                return false;
        }
    }
    /**
     * Returns hold legs in the flight plan. Used to determine and show appropriate HOLD pages.
     *
     * @param plan     the flight plan in question
     * @param inMissed whether to only include missed approach holds
     *
     * @returns the result
     */
    static getPlanHolds(plan, inMissed = false) {
        var _a;
        const holdLegs = [];
        for (const leg of plan.legs()) {
            const legSegment = (_a = plan.getSegmentFromLeg(leg)) === null || _a === void 0 ? void 0 : _a.segmentType;
            if (!inMissed && legSegment === FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (inMissed && legSegment !== FlightPlanSegmentType.MissedApproach) {
                continue;
            }
            if (this.isHoldAtLeg(leg.leg.type)) {
                holdLegs.push(leg);
            }
        }
        return holdLegs;
    }
    /**
     * Returns the first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`.
     * @param plan The flight plan.
     * @param fixIcao The fix's ICAO.
     * @returns The first occurrence of an HM leg whose `fixIcoa` matches the passed `fixIcao`, or -1 if not found.
     * */
    static findHoldInPlan(plan, fixIcao) {
        let index = -1;
        for (const leg of plan.legs()) {
            if (leg.leg.type !== LegType.HM) {
                continue;
            }
            if (leg.leg.fixIcao === fixIcao) {
                index = plan.getLegIndexFromLeg(leg);
                break;
            }
        }
        return index;
    }
    /**
     * Calculates time in seconds to fly a certain distance at a ground speed
     *
     * @param distance distance to fly
     * @param groundSpeed GS to predict with
     *
     * @returns time in number of seconds
     */
    static estimateSecondsForDistance(distance, groundSpeed) {
        return (distance / groundSpeed) * 3600;
    }
    /**
     * Calculates distance flown for a number of seconds at a ground speed
     *
     * @param seconds time flown in number of seconds
     * @param groundSpeed GS to predict with
     *
     * @returns distance in nautical miles
     */
    static estimateDistanceForSeconds(seconds, groundSpeed) {
        return (seconds / 3600) * groundSpeed;
    }
    /**
     * Returns the index of the last non-missed approach leg in the flight plan
     *
     * @param plan the plan to use for lookup
     *
     * @returns array of index and ident, or undefined if no approach segment
     */
    static getLastNonMissedApproachLeg(plan) {
        if (plan.length === 0) {
            return -1;
        }
        let legIndex = plan.length - 1;
        while (BitFlags.isAll(plan.getLeg(legIndex).flags, LegDefinitionFlags.MissedApproach)) {
            legIndex--;
        }
        return legIndex;
    }
    /**
     * Returns the distance between the end of a leg before a discontinuity and the start of the leg after that discontinuity
     *
     * @param prevLeg the leg before the discontinuity
     * @param nextLeg the leg after the discontinuity
     *
     * @returns the great circle distance between the end of the previous leg and the start of the next leg, in metres
     */
    static distanceBetweenDiscontinuedLegs(prevLeg, nextLeg) {
        var _a, _b;
        let distance;
        if (prevLeg && nextLeg && ((_a = prevLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) && prevLeg.calculated.endLon && ((_b = nextLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLat) && nextLeg.calculated.endLon) {
            const term = new GeoPoint(prevLeg.calculated.endLat, prevLeg.calculated.endLon);
            const start = new GeoPoint(nextLeg.calculated.endLat, nextLeg.calculated.endLon);
            distance = UnitType.GA_RADIAN.convertTo(term.distance(start), UnitType.METER);
        }
        else {
            distance = 0;
        }
        return distance;
    }
    /**
     * Formats a facility frequency's type for display on the FMC
     *
     * @param frequency  the frequency
     * @param noneString (optional) the string to return when the type is "None"
     *
     * @returns a string
     */
    static formatFacilityFrequencyType(frequency, noneString = 'UNKNOWN') {
        switch (frequency.type) {
            case FacilityFrequencyType.ASOS:
                return 'ASOS';
            case FacilityFrequencyType.ATIS:
                return 'ATIS';
            case FacilityFrequencyType.AWOS:
                return 'AWOS';
            case FacilityFrequencyType.Approach:
                return 'APR';
            case FacilityFrequencyType.CPT:
            case FacilityFrequencyType.Clearance:
                return 'CLEARANCE';
            case FacilityFrequencyType.CTAF:
                return 'CTAF';
            case FacilityFrequencyType.Center:
                return 'CTR';
            case FacilityFrequencyType.Departure:
                return 'DEP';
            case FacilityFrequencyType.FSS:
                return 'FSS';
            case FacilityFrequencyType.GCO:
                return 'GCO';
            case FacilityFrequencyType.Ground:
                return 'GND';
            case FacilityFrequencyType.Multicom:
                return 'MULTICOM';
            case FacilityFrequencyType.Tower:
                return 'TWR';
            case FacilityFrequencyType.Unicom:
                return 'UNICOM';
            default:
                return noneString;
        }
    }
    /**
     * Formats a facility type (and, if applicable, VOR type) into a string
     *
     * Used on the SELECT DESIRED XXX page
     *
     * @param facility the facility
     *
     * @returns a string
     */
    static formatFacilityType(facility) {
        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
            switch (facility.type) {
                default:
                case VorType.VOR:
                    return 'VOR';
                case VorType.VORDME:
                    return 'VORDME';
                case VorType.VORTAC:
                    return 'VORTAC';
                case VorType.TACAN:
                    return 'TACAN';
                case VorType.ILS:
                    return 'ILS';
                case VorType.DME:
                    return 'DME';
            }
        }
        else {
            switch (ICAO.getFacilityType(facility.icao)) {
                case FacilityType.Airport:
                    return 'APRT';
                case FacilityType.NDB:
                    return 'NDB';
                case FacilityType.Intersection:
                    return 'WAYPOINT';
                case FacilityType.RWY:
                    return 'RUNWAY';
                case FacilityType.USR:
                    return 'PILOT';
                case FacilityType.VIS:
                    return 'VISUAL';
                default:
                    return 'UNKNOWN';
            }
        }
    }
    /**
     * Returns the distance from PPOS to the end of a leg, given a lateral plan and a global leg index
     * @param lateralPlan the lateral plan
     * @param globalLegIndex the global leg index
     * @returns the distance, in metres
     */
    static getDistanceFromPposToLegEnd(lateralPlan, globalLegIndex) {
        var _a, _b;
        const legDistanceRemaining = SimVar.GetSimVarValue(LNavVars.LegDistanceRemaining, SimVarValueType.NM);
        const legDistanceRemainingMetres = UnitType.METER.convertFrom(legDistanceRemaining, UnitType.NMILE);
        const currentLeg = lateralPlan.getLeg(lateralPlan.activeLateralLeg);
        const targetLeg = lateralPlan.getLeg(globalLegIndex);
        if (currentLeg.calculated && targetLeg.calculated) {
            const cumulativeDistanceToCurrentLeg = (_a = currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistanceWithTransitions;
            const cumulativeDistanceToTargetLeg = (_b = targetLeg.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions;
            const distanceBetweenLegs = cumulativeDistanceToTargetLeg - cumulativeDistanceToCurrentLeg;
            return legDistanceRemainingMetres + distanceBetweenLegs;
        }
        return undefined;
    }
    /**
     * Toggle assumed temp takeoff derate.
     * @param mode The takeoff thrust mode.
     * @returns The opposite derate mode of the passed fixed thrust mode.
     */
    static toggleAssumedTempDerate(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO: return TakeoffThrustMode.DTO;
            case TakeoffThrustMode.TO1: return TakeoffThrustMode.DTO1;
            case TakeoffThrustMode.TO2: return TakeoffThrustMode.DTO2;
            case TakeoffThrustMode.DTO: return TakeoffThrustMode.TO;
            case TakeoffThrustMode.DTO1: return TakeoffThrustMode.TO1;
            case TakeoffThrustMode.DTO2: return TakeoffThrustMode.TO2;
        }
    }
    /**
     * Returns whether the passed takeoff thrust mode is an assumed temperature derate mode.
     * @param mode The takeoff thrust mode.
     * @returns Whether the passed takeoff thrust mode is an assumed temperature derate mode.
     */
    static thrustModeIsAssumedTemp(mode) {
        return (mode === TakeoffThrustMode.DTO ||
            mode === TakeoffThrustMode.DTO1 ||
            mode === TakeoffThrustMode.DTO2);
    }
    /**
     * Checks if two VHF frequencies are equal
     * @param frequencyA The first frequency to compare
     * @param frequencyB The second frequency to compare
     * @returns true if the frequencies are equal
     */
    static vhfFrequenciesEqual(frequencyA, frequencyB) {
        return Math.abs(frequencyA - frequencyB) < 0.0025;
    }
    /**
     * Check if a leg can contain wind data
     * @param legType Leg Type
     * @returns true if the leg is eligible for wind data
     */
    static legTypeCanHaveWind(legType) {
        switch (legType) {
            case LegType.AF:
            case LegType.CF:
            case LegType.DF:
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.IF:
            case LegType.RF:
            case LegType.TF:
                return true;
            default:
                return false;
        }
    }
    /**
     * Get a basic facility with only the properties of {@link Facility} from any facility.
     * @param facility The facility.
     * @returns A facility instance with only the basic subset of properties.
     */
    static getBaseFacility(facility) {
        return {
            icao: facility.icao,
            name: facility.name,
            lat: facility.lat,
            lon: facility.lon,
            region: facility.region,
            city: facility.city,
            magvar: facility.magvar,
        };
    }
}
BoeingFmsUtils.vec3Cache = [new Float64Array(3)];
BoeingFmsUtils.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
BoeingFmsUtils.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
BoeingFmsUtils.DTO_LEG_OFFSET = 3;
/**
 * Utility method to return a single RnavTypeFlag from multiple possible flags.
 * @param rnavTypeFlags The input RnavTypeFlags.
 * @returns A single RnavTypeFlag
 */
BoeingFmsUtils.getBestRnavType = ApproachUtils.getBestRnavType;
/**
 * Additional Bitflags describing a leg definition specific to the Boeing FMS
 */
var BoeingExtraLegDefinitionFlags;
(function (BoeingExtraLegDefinitionFlags) {
    /**
     * A leg that was part of the active leg pair in a procedure when the procedure was removed, and was subsequently
     * moved to another segment in the plan.
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DisplacedActiveLeg"] = 536870912] = "DisplacedActiveLeg";
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["ProcedureLeg"] = 1073741824] = "ProcedureLeg";
    /**
     * Applied to the target leg of a direct to
     */
    BoeingExtraLegDefinitionFlags[BoeingExtraLegDefinitionFlags["DirectToTarget"] = -2147483648] = "DirectToTarget";
})(BoeingExtraLegDefinitionFlags || (BoeingExtraLegDefinitionFlags = {}));
/** Array of "arc" leg types. */
const arcLegTypes = [LegType.AF, LegType.RF];
/** Array of "heading to" leg types. */
const headingToLegTypes = [LegType.VA, LegType.VD, LegType.VI, LegType.VM, LegType.VR];
/** Array of "hold at" leg types. */
const holdAtLegTypes = [LegType.HA, LegType.HF, LegType.HM];
/** Array of "to altitude" leg types. */
const altitudeLegTypes = [LegType.CA, LegType.FA, LegType.VA, LegType.HA];
/** Array of "course to" leg types. */
const courseToLegTypes = [LegType.CA, LegType.CF, LegType.CI];
/**
 * Array of "discontinuity" leg types
 */
const discontinuityLegTypes = [LegType.Discontinuity, LegType.ThruDiscontinuity];
/** Array of "vectors" leg types */
const vectorsTypes = [LegType.FM, LegType.VM];

/* eslint-disable max-len */
/**
 * A class for syncing a flight plan with the game
 * HINT: This class always needs to run on an instrument that has bound bing maps
 * Otherwise the GET_IS_BUSHTRIP coherent call won't return
 */
class FlightPlanAsoboSync {
    /**
     * Inits flight plan asobo sync
     */
    static async init() {
        return new Promise((resolve) => {
            if (!FlightPlanAsoboSync.fpListenerInitialized) {
                RegisterViewListener('JS_LISTENER_FLIGHTPLAN', () => {
                    FlightPlanAsoboSync.fpListenerInitialized = true;
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
    /**
     * Loads the flight plan from the sim.
     * @param fms an instance of the fms
     */
    static async loadFromGame(fms) {
        await FlightPlanAsoboSync.init();
        Coherent.call('LOAD_CURRENT_ATC_FLIGHTPLAN');
        // Coherent.call('LOAD_CURRENT_GAME_FLIGHT');
        await Wait.awaitDelay(3000);
        const data = await Coherent.call('GET_FLIGHTPLAN');
        const isDirectTo = data.isDirectTo;
        let lastEnrouteSegment = 1;
        if (isDirectTo) {
            return false;
        }
        if (data.waypoints.length === 0) {
            return false;
        }
        await fms.emptyFlightPlan();
        const plan = fms.getPlanToModify();
        let originFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[0].icao)) {
            originFacilityType = ICAO.getFacilityType(data.waypoints[0].icao);
        }
        if (originFacilityType === FacilityType.Airport) {
            const originFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[0].icao), data.waypoints[0].icao);
            if (originFac !== undefined) {
                FlightPlanAsoboSync.setDeparture(originFac, data, fms);
            }
        }
        else if (originFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportOriginLeg(data, plan, fms);
        }
        const destIndex = data.waypoints.length - 1;
        let destFacilityType = undefined;
        if (ICAO.isFacility(data.waypoints[destIndex].icao)) {
            destFacilityType = ICAO.getFacilityType(data.waypoints[destIndex].icao);
        }
        if (destFacilityType === FacilityType.Airport) {
            const destFac = await fms.facLoader.getFacility(ICAO.getFacilityType(data.waypoints[destIndex].icao), data.waypoints[destIndex].icao);
            if (destFac !== undefined) {
                await FlightPlanAsoboSync.setDestination(destFac, data, fms);
            }
        }
        lastEnrouteSegment = FlightPlanAsoboSync.setEnroute(data, plan, fms);
        if (destFacilityType !== FacilityType.Airport && destFacilityType !== undefined) {
            FlightPlanAsoboSync.buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment);
        }
        plan.calculate(0).then(() => {
            plan.setLateralLeg(0);
        });
        return true;
    }
    /**
     * Syncs the plan back to the sim as best as possible
     * @param fms an instance of FMS
     */
    static async SaveToGame(fms) {
        var _a, _b;
        try {
            await FlightPlanAsoboSync.init();
            const plan = fms.getPrimaryFlightPlan();
            // TODO: Disable until GET_IS_BUSHTRIP is not dependent on having a bound bing map
            // const isBushtrip = await Coherent.call('GET_IS_BUSHTRIP');
            // if (isBushtrip) {
            //   return;
            // }
            await Coherent.call('SET_CURRENT_FLIGHTPLAN_INDEX', 0).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('CLEAR_CURRENT_FLIGHT_PLAN').catch((err) => console.log(JSON.stringify(err)));
            if (fms.facilityInfo.originFacility) {
                await Coherent.call('SET_ORIGIN', fms.facilityInfo.originFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (fms.facilityInfo.destinationFacility) {
                await Coherent.call('SET_DESTINATION', fms.facilityInfo.destinationFacility.icao, false).catch((err) => console.log(JSON.stringify(err)));
            }
            if (plan.procedureDetails.originRunway) {
                await Coherent.call('SET_ORIGIN_RUNWAY_INDEX', (_a = plan.procedureDetails.originRunway) === null || _a === void 0 ? void 0 : _a.parentRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            }
            await Coherent.call('SET_DEPARTURE_RUNWAY_INDEX', plan.procedureDetails.departureRunwayIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_PROC_INDEX', plan.procedureDetails.departureIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_DEPARTURE_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.departureTransitionIndex === -1 ? 0 : plan.procedureDetails.departureTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            // Put in the enroute waypoints
            const enrouteSegments = plan.segmentsOfType(FlightPlanSegmentType.Enroute);
            const legsToAdd = [];
            for (const segment of enrouteSegments) {
                // get legs in segment and put them into a temp array of legs to sync
                for (const leg of segment.legs) {
                    if (FlightPlanAsoboSync.isSyncableLeg(leg.leg)) {
                        legsToAdd.push(leg);
                    }
                }
            }
            // check if the last leg to sync is the destination airport and, if so, remove that leg from the array of legs to sync.
            if (legsToAdd.length > 0 && legsToAdd[legsToAdd.length - 1].leg.fixIcao === plan.destinationAirport) {
                legsToAdd.pop();
            }
            let globalIndex = 1;
            // sync the array of legs to sync to the sim flight plan
            for (const leg of legsToAdd) {
                try {
                    const facType = ICAO.getFacilityType(leg.leg.fixIcao);
                    if (facType === FacilityType.USR) {
                        const usrFac = await fms.facLoader.getFacility(facType, leg.leg.fixIcao);
                        await Coherent.call('ADD_CUSTOM_WAYPOINT', (_b = leg.name) !== null && _b !== void 0 ? _b : leg.leg.fixIcao, globalIndex, usrFac.lat, usrFac.lon, false);
                    }
                    else {
                        await Coherent.call('ADD_WAYPOINT', leg.leg.fixIcao, globalIndex, false);
                    }
                    globalIndex++;
                }
                catch (error) {
                    console.warn(`Error during fp sync: ${JSON.stringify(error)}`);
                }
            }
            await Coherent.call('SET_ARRIVAL_RUNWAY_INDEX', plan.procedureDetails.arrivalRunwayTransitionIndex === -1 ? 0 : plan.procedureDetails.arrivalRunwayTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_PROC_INDEX', plan.procedureDetails.arrivalIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_ARRIVAL_ENROUTE_TRANSITION_INDEX', plan.procedureDetails.arrivalTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            await Coherent.call('SET_APPROACH_INDEX', plan.procedureDetails.approachIndex).then(() => {
                Coherent.call('SET_APPROACH_TRANSITION_INDEX', plan.procedureDetails.approachTransitionIndex).catch((err) => console.log(JSON.stringify(err)));
            }).catch((err) => console.log(JSON.stringify(err)));
            const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
            if ((activeSegment === null || activeSegment === void 0 ? void 0 : activeSegment.segmentType) === FlightPlanSegmentType.Approach) {
                await Coherent.call('TRY_AUTOACTIVATE_APPROACH').catch((err) => console.log(JSON.stringify(err)));
            }
            Coherent.call('RECOMPUTE_ACTIVE_WAYPOINT_INDEX').catch((err) => console.log(JSON.stringify(err)));
        }
        catch (error) {
            console.error(`Error during fp sync: ${error}`);
        }
    }
    /**
     * Checks if a leg is syncable to the stock flight plan system.
     * @param leg the leg to check
     * @returns true if the leg is syncable, false otherwise
     */
    static isSyncableLeg(leg) {
        return FlightPlanAsoboSync.nonSyncableLegTypes.indexOf(leg.type) === -1;
    }
    /**
     * Sets the departure procedure or facility if specified
     * @param facility is the origin airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns whether a departure was set.
     */
    static setDeparture(facility, data, fms) {
        let originOneWayRunway = undefined;
        if (data.originRunwayIndex > -1) {
            const oneWayRunways = [];
            let index = 0;
            facility.runways.forEach((runway) => {
                for (const rw of RunwayUtils.getOneWayRunways(runway, index)) {
                    oneWayRunways.push(rw);
                }
                index++;
            });
            oneWayRunways.sort(RunwayUtils.sortRunways);
            originOneWayRunway = oneWayRunways[data.originRunwayIndex];
        }
        if (data.departureProcIndex >= 0 && data.departureProcIndex < facility.departures.length) {
            // Runway and enroute transition indexes default to 0 even when the departure has no runway or enroute
            // transitions, so we have to do the OOB checks ourselves.
            const departure = facility.departures[data.departureProcIndex];
            if (data.departureRunwayIndex >= 0 && data.departureRunwayIndex < departure.runwayTransitions.length) {
                const runwayTransition = departure.runwayTransitions[data.departureRunwayIndex];
                const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                originOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
            }
            const enrouteTransitionIndex = data.departureEnRouteTransitionIndex < 0 || data.departureEnRouteTransitionIndex >= departure.enRouteTransitions.length
                ? -1
                : data.departureEnRouteTransitionIndex;
            fms.insertDeparture(facility, data.departureProcIndex, data.departureRunwayIndex, enrouteTransitionIndex, originOneWayRunway);
            return true;
        }
        else if (facility !== undefined) {
            fms.setOrigin(facility, originOneWayRunway);
            return true;
        }
        return false;
    }
    /**
     * Sets the destination airport
     * @param facility is the destination airport facility record
     * @param data is the flight plan sync data object from the world map
     * @param fms an instance of the fms
     * @returns A Promise which is fulfilled with whether a destination was set.
     */
    static async setDestination(facility, data, fms) {
        let destOneWayRunway = undefined;
        let setDestination = false;
        if (data.arrivalProcIndex >= 0 && data.arrivalProcIndex < facility.arrivals.length) {
            // Runway and enroute transition indexes default to 0 even when the departure has no runway or enroute
            // transitions, so we have to do the OOB checks ourselves.
            const arrival = facility.arrivals[data.arrivalProcIndex];
            if (data.arrivalRunwayIndex >= 0 && data.arrivalRunwayIndex < arrival.runwayTransitions.length) {
                const runwayTransition = arrival.runwayTransitions[data.arrivalRunwayIndex];
                if (runwayTransition !== undefined) {
                    const runwayString = RunwayUtils.getRunwayNameString(runwayTransition.runwayNumber, runwayTransition.runwayDesignation);
                    destOneWayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, runwayString);
                }
            }
            const enrouteTransitionIndex = data.arrivalEnRouteTransitionIndex < 0 || data.arrivalEnRouteTransitionIndex >= arrival.enRouteTransitions.length
                ? -1
                : data.arrivalEnRouteTransitionIndex;
            fms.insertArrival(facility, data.arrivalProcIndex, data.arrivalRunwayIndex, enrouteTransitionIndex, destOneWayRunway);
            setDestination = true;
        }
        if (data.approachIndex !== -1) {
            const approachTransitionIndex = data.approachTransitionIndex === 0 &&
                facility.approaches[data.approachIndex].transitions.length < 1 ? -1 : data.approachTransitionIndex;
            await fms.insertApproach({ facility, approachIndex: data.approachIndex, approachTransitionIndex });
            setDestination = true;
        }
        if (facility !== undefined && data.arrivalProcIndex === -1 && data.approachIndex === -1) {
            fms.setDestination(facility);
            setDestination = true;
        }
        return setDestination;
    }
    /**
     * Sets the enroute portion of the flight plan
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of the fms
     * @returns the last enroute segment
     */
    static setEnroute(data, plan, fms) {
        const enrouteStart = (data.departureWaypointsSize == -1) ? 1 : data.departureWaypointsSize;
        const enroute = data.waypoints.slice(enrouteStart, -(Math.max(0, data.arrivalWaypointsSize) + 1));
        let custIdx = 1;
        let currentSegment = 1;
        let lastDepartureLegIcao = undefined;
        let lastLegWasAirway = false;
        if (data.departureProcIndex > -1) {
            const depSegment = plan.getSegment(0);
            if (depSegment.legs.length > 1) {
                lastDepartureLegIcao = depSegment.legs[depSegment.legs.length - 1].leg.fixIcao;
            }
        }
        for (let i = 0; i < enroute.length; i++) {
            const wpt = enroute[i];
            const segment = plan.getSegment(currentSegment);
            if (wpt.airwayIdent) {
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) ;
                else {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airwayIdent);
                        currentSegment += 1;
                        // plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                    }
                }
                for (let j = i + 1; j < enroute.length; j++) {
                    i++;
                    const airwayLeg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: enroute[j].icao
                    });
                    plan.addLeg(currentSegment, airwayLeg);
                    if (enroute[j].airwayIdent !== wpt.airwayIdent) {
                        lastLegWasAirway = enroute[j].airwayIdent ? true : false;
                        break;
                    }
                }
                plan.setAirway(currentSegment, wpt.airwayIdent + '.' + enroute[i].ident);
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? enroute[i].airwayIdent : undefined);
            }
            else {
                let skip = false;
                if (currentSegment == 1 && lastDepartureLegIcao == wpt.icao) {
                    skip = true;
                }
                let leg = undefined;
                if (!skip && wpt.icao.trim() == '') {
                    const re = /(?:[D][\d])|(?:DLast)|(?:TIMEVERT)|(?:TIMECLIMB)|(?:TIMECRUIS)|(?:TIMEDSCNT)|(?:TIMEAPPROACH)/;
                    skip = wpt.ident.match(re) !== null;
                }
                if (!skip && (wpt.ident === 'Custom' || wpt.icao.trim() == '')) {
                    const userFacility = UserFacilityUtils.createFromLatLon(`U      USR${custIdx.toString().padStart(2, '0')}`, wpt.lla.lat, wpt.lla.long, true, wpt.icao.trim() === '' ? wpt.ident : `Custom ${custIdx.toString().padStart(2, '0')}`);
                    fms.addUserFacility(userFacility);
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: userFacility.icao,
                        lat: wpt.lla.lat,
                        lon: wpt.lla.long
                    });
                    custIdx++;
                }
                else if (!skip && wpt.icao.trim() !== '') {
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                }
                if (leg) {
                    plan.addLeg(currentSegment, leg);
                    if (lastLegWasAirway) {
                        plan.setAirway(currentSegment, segment.airway + '.' + wpt.ident);
                        currentSegment += 1;
                        plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                    }
                    lastLegWasAirway = false;
                }
            }
        }
        if (plan.getSegment(currentSegment).airway) {
            currentSegment += 1;
            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
        }
        return currentSegment;
    }
    /**
     * Sets the first leg of the enroute plan as the first leg in the world map plan, but as an IF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     */
    static buildNonAirportOriginLeg(data, plan, fms) {
        const wpt = data.waypoints[0];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTD', wpt.lla.lat, wpt.lla.long, true, 'Custom Origin');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: 'U      CUSTD',
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(1, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: wpt.icao
            });
            plan.addLeg(1, leg);
        }
    }
    /**
     * Sets the last leg of the enroute plan as the last leg in the world map plan, but as an TF leg
     * @param data is the flight plan sync data object from the world map
     * @param plan an instance of the flight plan
     * @param fms an instance of FMS
     * @param lastEnrouteSegment is the last enroute segment
     */
    static buildNonAirportDestLeg(data, plan, fms, lastEnrouteSegment) {
        const wpt = data.waypoints[data.waypoints.length - 1];
        if (wpt.ident === 'CUSTD' || wpt.ident === 'CUSTA') {
            const userFacility = UserFacilityUtils.createFromLatLon('U      CUSTA', wpt.lla.lat, wpt.lla.long, true, 'Custom Destination');
            fms.addUserFacility(userFacility);
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: userFacility.icao,
                lat: wpt.lla.lat,
                lon: wpt.lla.long
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
        else if (wpt.icao.trim() !== '') {
            const leg = FlightPlan.createLeg({
                type: LegType.TF,
                fixIcao: wpt.icao
            });
            plan.addLeg(lastEnrouteSegment, leg);
        }
    }
}
// public static fpChecksum = 0;
FlightPlanAsoboSync.fpListenerInitialized = false;
FlightPlanAsoboSync.nonSyncableLegTypes = [
    LegType.Discontinuity,
    LegType.ThruDiscontinuity,
    LegType.Unknown,
    LegType.HM,
    LegType.HA,
    LegType.HF,
];

const definitions = {
    'manualZfw': {
        defaultValue: null,
    },
    'manualGw': {
        defaultValue: null,
    },
    'takeoffGw': {
        defaultValue: null,
    },
    'cruiseCg': {
        defaultValue: null,
    },
    'manualLateralRnp': {
        defaultValue: null,
    },
    'manualVerticalRnp': {
        defaultValue: null,
    },
    'takeoffFlaps': {
        defaultValue: null,
    },
    'takeoffCg': {
        defaultValue: null,
    },
    'takeoffAssumedTemp': {
        defaultValue: null,
    },
    'takeoffThrustMode': {
        defaultValue: TakeoffThrustMode.TO,
    },
    'takeoffThrustReductionPoint': {
        defaultValue: 1500,
    },
    'takeoffAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffEoAccelerationHeight': {
        defaultValue: 1500,
    },
    'takeoffTemp': {
        defaultValue: null,
    },
    'takeoffWind': {
        defaultValue: null,
    },
    'takeoffRunwayWind': {
        defaultValue: null,
    },
    'takeoffRunwaySlope': {
        defaultValue: 0,
    },
    'takeoffRunwayCondition': {
        defaultValue: RunwayCondition.DRY,
    },
    'climbSpeedMaxAngle': {
        defaultValue: 215, // TODO Replace with actual value
    },
    'climbThrustMode': {
        defaultValue: ClimbThrustMode.CLB,
    },
    'climbSegmentExists': {
        defaultValue: false,
    },
    'cruiseRequiredTpr': {
        defaultValue: 0, // TODO Replace with actual value
    },
    'takeoffAirportIcao': {
        defaultValue: null,
    },
    'originRunway': {
        defaultValue: null,
    },
    'takeoffRunway': {
        defaultValue: null,
    },
    'takeoffRunwayPositionShift': {
        defaultValue: null,
    },
    'approachAirportIcao': {
        defaultValue: null,
    },
    'approachRunway': {
        defaultValue: null,
    },
    'approachLandingRef': {
        defaultValue: 1,
    },
    'glideSlope': {
        defaultValue: GlideslopeStatus.ON,
        differentiateInModPlan: true,
    },
    'approachWindCorrection': {
        defaultValue: 5,
    },
    'approachFlapSpeed': {
        defaultValue: null,
    },
    'cruiseAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedLimitCas': {
        defaultValue: 250,
    },
    'climbSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'climbSpeedRestrCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'climbSpeedRestrAltitude': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'descentSpeedLimitCas': {
        defaultValue: 240,
    },
    'descentSpeedLimitAltitude': {
        defaultValue: 10000,
    },
    'descentSpeedRestrCas': {
        defaultValue: null,
    },
    'descentSpeedRestrAltitude': {
        defaultValue: null,
    },
    'transitionAltitude': {
        defaultValue: 18000,
    },
    'transitionLevel': {
        defaultValue: 18000,
    },
    'stepSize': {
        defaultValue: 'ICAO',
    },
    'reserveFuel': {
        defaultValue: null,
    },
    'costIndex': {
        defaultValue: null,
    },
    'currentThrustMode': {
        defaultValue: null,
    },
    'speedMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedClimbEconCas': {
        defaultValue: 310,
    },
    'speedClimbEconMach': {
        defaultValue: .85,
    },
    'speedClimbSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedClimbSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedCruiseEconCas': {
        defaultValue: 310,
    },
    'speedCruiseEconMach': {
        defaultValue: .850,
    },
    'speedCruiseEconUnit': {
        defaultValue: 'cas',
    },
    'speedCruiseSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedCruiseSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentMode': {
        defaultValue: SpeedMode.ECON,
        differentiateInModPlan: true,
    },
    'speedDescentEconCas': {
        defaultValue: 290,
    },
    'speedDescentEconMach': {
        defaultValue: .850,
    },
    'speedDescentSelectCas': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'speedDescentSelectMach': {
        defaultValue: null,
        differentiateInModPlan: true,
    },
    'thermalAntiIceAltitude': {
        defaultValue: null,
    },
    'alternateCruiseAltitude': {
        defaultValue: 37000,
    },
    'alternateSpeedValue': {
        defaultValue: 250,
    },
    'alternateSpeedIsMach': {
        defaultValue: false,
    },
};

/**
 * Proxied `MutableSubscribable` that mirrors a property desired to be accessed by {@link PerformancePlanProxy}
 */
class ProxiedPerformancePlanProperty extends AbstractSubscribable {
    /**
     * Ctor
     *
     * @param key property key
     * @param proxy the proxy this property belongs to
     * @param editInPlace whether the property can be edited without a new flight plan being created
     */
    constructor(key, proxy, editInPlace = false) {
        super();
        this.key = key;
        this.proxy = proxy;
        this.editInPlace = editInPlace;
        this.targetPlan = null;
        this.isSubscribable = true;
        this.isMutableSubscribable = true;
        this.subject = Subject.create(null);
        this.backSubjectSubscription = undefined;
    }
    /**
     * Switches the target plan
     *
     * @param plan the new target plan
     */
    switchToPlan(plan) {
        var _a;
        this.targetPlan = plan;
        (_a = this.backSubjectSubscription) === null || _a === void 0 ? void 0 : _a.destroy();
        this.backSubjectSubscription = this.backingSubject().sub((it) => {
            this.subject.set(it);
        }, true);
    }
    /**
     * Returns the backing subject in the target plan for the property
     *
     * @returns the subject
     *
     * @throws if no target plan exists
     */
    backingSubject() {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        return this.targetPlan[this.key];
    }
    /**
     * Resets the property to its default value according to the default values performance plan
     */
    resetToDefault() {
        const defaultValue = this.proxy.defaultValuesPlan[this.key];
        this.proxy.onBeforeEdit(this, defaultValue);
        this.backingSubject().set(defaultValue.get());
        this.proxy.onAfterEdit(this, defaultValue);
    }
    /** @inheritDoc */
    get() {
        if (!this.targetPlan) {
            return null;
        }
        return this.backingSubject().get();
    }
    /** @inheritDoc */
    set(value) {
        if (!this.targetPlan) {
            throw new Error('No current target plan');
        }
        this.proxy.onBeforeEdit(this, value);
        this.backingSubject().set(value);
        this.proxy.onAfterEdit(this, value);
    }
    /** @inheritDoc */
    sub(handler, initialNotify, paused) {
        return this.subject.sub(handler, initialNotify, paused);
    }
    /** @inheritDoc */
    unsub(handler) {
        return this.subject.unsub(handler);
    }
}

/**
 * Utils for performance plans
 */
class PerformancePlanUtils {
    /**
     * Serializes a plan
     *
     * @param plan the plan to serialize
     *
     * @returns the serialized JSON string
     */
    static serialize(plan) {
        const tmpObj = {};
        Object.keys(plan).forEach((key) => {
            tmpObj[key] = plan[key].get();
        });
        return JSON.stringify(tmpObj);
    }
    /**
     * Deserializes a serialized performance plan into a plan
     *
     * @param data the serialized data string
     * @param plan the plan to deserialize into
     */
    static deserializeInto(data, plan) {
        const customData = JSON.parse(data);
        Object.keys(customData).forEach((key) => {
            const value = customData[key];
            if (value !== undefined) {
                plan[key].set(value);
            }
        });
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @returns a performance plan with default values filled
     */
    static createPlanFromDefinitions() {
        const plan = {};
        for (const [key, definition] of Object.entries(definitions)) {
            plan[key] = Subject.create(definition.defaultValue);
        }
        return plan;
    }
    /**
     * Creates a performance plan from the {@link PerformancePlanDefinitions} object
     *
     * @param partialProxy an object containing the callbacks to attach to the proxy
     *
     * @returns a performance plan with default values filled
     */
    static createProxyFromDefinitions(partialProxy) {
        const proxy = {
            defaultValuesPlan: partialProxy.defaultValuesPlan,
            /** @inheritDoc */
            switchToPlan(plan, initial) {
                for (const [key, definition] of Object.entries(definitions)) {
                    if (initial || definition.differentiateInModPlan) {
                        this[key].switchToPlan(plan);
                    }
                }
            },
            /** @inheritDoc */
            onBeforeEdit(property, newValue) {
                partialProxy.onBeforeEdit(property, newValue);
            },
            /** @inheritDoc */
            onAfterEdit(property, newValue) {
                partialProxy.onAfterEdit(property, newValue);
            },
        };
        for (const [key, definition] of Object.entries(definitions)) {
            const property = new ProxiedPerformancePlanProperty(key, proxy, !definition.differentiateInModPlan);
            proxy[key] = property;
        }
        return proxy;
    }
}

var AlternateDiversionMode;
(function (AlternateDiversionMode) {
    AlternateDiversionMode[AlternateDiversionMode["Direct"] = 0] = "Direct";
    AlternateDiversionMode[AlternateDiversionMode["Offset"] = 1] = "Offset";
    AlternateDiversionMode[AlternateDiversionMode["Overhead"] = 2] = "Overhead";
})(AlternateDiversionMode || (AlternateDiversionMode = {}));
var AlternateSpeedScheduleMode;
(function (AlternateSpeedScheduleMode) {
    AlternateSpeedScheduleMode["Econ"] = "ECON";
    AlternateSpeedScheduleMode["Lrc"] = "LRC";
    AlternateSpeedScheduleMode["EO"] = "EO";
    AlternateSpeedScheduleMode["EOLrc"] = "EOLRC";
    AlternateSpeedScheduleMode["CO"] = "CO";
})(AlternateSpeedScheduleMode || (AlternateSpeedScheduleMode = {}));
/**
 * Boeing alternates
 */
class BoeingAlternates {
    /**
     * Ctor
     *
     * @param bus the event bus
     * @param fms the fns
     * @param isOnPrimaryFms whether this is on the primary FMS
     */
    constructor(bus, fms, isOnPrimaryFms) {
        this.bus = bus;
        this.fms = fms;
        this.isOnPrimaryFms = isOnPrimaryFms;
        this.ignoreSync = false;
        this._alternateSub = new Map();
        this._alternatePredictionsSub = new Map();
        this.alternatesPredictionsEntries = new Map();
        this.alternatesPredictionsForcedUpdates = new Map();
        this.alternates = ArraySubject.create([null, null, null, null]);
        this.activeLeg = Subject.create(null);
        this.alternates.sub((index, type, item) => {
            var _a, _b;
            if (type === SubscribableArrayEventType.Added) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_a = this._alternateSub.get(index + i)) === null || _a === void 0 ? void 0 : _a.set(item[i]);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(item);
                }
            }
            else if (type === SubscribableArrayEventType.Removed || type === SubscribableArrayEventType.Cleared) {
                if (Array.isArray(item)) {
                    const arr = item;
                    for (let i = 0; i < arr.length; i++) {
                        if (this._alternateSub.has(index + i)) {
                            (_b = this._alternateSub.get(index + i)) === null || _b === void 0 ? void 0 : _b.set(null);
                        }
                    }
                }
                else {
                    const sub = this._alternateSub.get(index);
                    sub === null || sub === void 0 ? void 0 : sub.set(null);
                }
            }
        });
        const sub = this.bus.getSubscriber();
        sub.on('realTime').whenChangedBy(1000 * 60 * 5).handle(() => this.handleUpdatePredictions());
        sub.on('fplLoaded').handle((event) => this.handleFlightPlanLoaded(event));
        sub.on('fplUserDataSet').handle((event) => this.handleFlightPlanUserDataChanged(event));
        sub.on('fplActiveLegChange').handle(() => this.handleUpdateActiveLeg());
        sub.on('fplCopied').handle(() => this.handleUpdateActiveLeg());
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            this.tryForceUpdatePredictions();
        });
    }
    /**
     * Tries to force update predictions.
     */
    tryForceUpdatePredictions() {
        var _a;
        const alternates = this.alternates.getArray();
        for (let i = 0; i < alternates.length; i++) {
            const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(i));
            const sub = this._alternatePredictionsSub.get(i);
            if (!sub) {
                continue;
            }
            if (this.alternatesPredictionsForcedUpdates.get(i) || (predictions === null || predictions === void 0 ? void 0 : predictions.valid) !== ((_a = sub.get()) === null || _a === void 0 ? void 0 : _a.fob)) {
                this.alternatesPredictionsForcedUpdates.set(i, false);
                sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
                sub.notify();
            }
        }
    }
    /**
     * Handles updating alternate predictions
     */
    handleUpdatePredictions() {
        const alternates = this.alternates.getArray();
        for (let i = 0; i < alternates.length; i++) {
            const predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(i));
            const sub = this._alternatePredictionsSub.get(i);
            if (!sub) {
                continue;
            }
            sub.set(predictions !== null && predictions !== void 0 ? predictions : null);
            sub.notify();
        }
    }
    /**
     * Handles `fplLoaded` events
     *
     * @param event the event
     */
    handleFlightPlanLoaded(event) {
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles `fplUserDataSet` events
     *
     * @param event the event
     */
    handleFlightPlanUserDataChanged(event) {
        if (this.ignoreSync) {
            return;
        }
        if (event.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX) {
            return;
        }
        if (event.key !== BoeingFms.USER_DATA_KEY_ALTN) {
            return;
        }
        this.readPlanAlternates();
    }
    /**
     * Handles updating the active leg
     */
    handleUpdateActiveLeg() {
        const plan = this.fms.getPrimaryFlightPlan();
        const leg = plan.tryGetLeg(plan.activeLateralLeg);
        this.activeLeg.set(leg);
    }
    /**
     * Returns whether an alternate exists for the specified index
     *
     * @param index the index
     *
     * @returns a boolean
     */
    hasAlternate(index) {
        return !!this.alternates.getArray()[index];
    }
    /**
     * Returns the index of an alternate from an ICAO, or -1 if the facility is not entered as an alternate
     *
     * @param fixIcao the airport ICAO
     *
     * @returns a number
     */
    getAlternateIndexByIcao(fixIcao) {
        return this.alternates.getArray().findIndex((it) => (it === null || it === void 0 ? void 0 : it.facilityIcao) === fixIcao);
    }
    /**
     * Returns a {@link Subscribable} for a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     * @param initialNotify whether to initially notify
     *
     * @returns a subscribable
     */
    alternateSub(index, initialNotify = false) {
        let sub = this._alternateSub.get(index);
        if (!sub) {
            const subject = Subject.create(this.alternates.length > index ? this.alternates.get(index) : null);
            this._alternateSub.set(index, subject);
            if (initialNotify) {
                subject.set(this.alternates.length > index ? this.alternates.get(index) : null);
            }
            sub = subject;
        }
        return sub;
    }
    /**
     * Returns a {@link Subscribable} for predictions of a position in the alternates array
     *
     * @param index the index for which to return a subscribable
     *
     * @returns a subscribable
     */
    alternatePredictionsSub(index) {
        var _a;
        let sub = this._alternatePredictionsSub.get(index);
        if (!sub) {
            const trackingEntry = this.getFacilityTrackingEntryForAlternate(index);
            const subject = Subject.create(this.alternates.length > index && trackingEntry ?
                (_a = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.facilityTrackingID(index))) !== null && _a !== void 0 ? _a : null
                : null);
            this._alternatePredictionsSub.set(index, subject);
            sub = subject;
        }
        return sub;
    }
    /**
     * Sets the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    setAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        if (this.alternates.length > index) {
            this.alternates.removeAt(index);
        }
        if (existing) {
            if (this.isOnPrimaryFms) {
                this.fms.activeRoutePredictor.stopTrackingFacility(this.facilityTrackingID(index));
            }
        }
        if (data) {
            const entry = {};
            this.createPredictionsTrackingEntryFromAlternateData(entry, data);
            this.alternatesPredictionsEntries.set(index, entry);
            this.alternatesPredictionsForcedUpdates.set(index, true);
            if (this.isOnPrimaryFms) {
                this.fms.activeRoutePredictor.startTrackingFacility(this.facilityTrackingID(index), entry);
            }
        }
        this.alternates.insert(data, index);
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Modifies the alternate in a position
     *
     * @param index the position
     * @param data the alternate data
     * @param notify whether to sync this change
     */
    modifyAlternate(index, data, notify = true) {
        const existing = this.alternates.get(index);
        Object.assign(existing, data);
        this.alternates.removeAt(index);
        this.alternates.insert(existing, index);
        const predictionsTrackingEntry = this.alternatesPredictionsEntries.get(index);
        if (predictionsTrackingEntry) {
            this.updatePredictionsTrackingEntryFromAlternateData(predictionsTrackingEntry, data);
            setTimeout(() => this.handleUpdatePredictions(), 1100);
        }
        if (notify) {
            this.writePlanAlternates();
        }
    }
    /**
     * Returns the facility predictions tracking entry, if applicable, for the given alternate index
     *
     * @param index the position
     *
     * @returns a {@link FacilityPredictionsTrackingEntry} object
     */
    getFacilityTrackingEntryForAlternate(index) {
        return this.alternatesPredictionsEntries.get(index);
    }
    /**
     * Creates a facility predictions tracking entry's values from alternate data
     *
     * @param entry the tracking entry
     * @param data the alternate data
     */
    createPredictionsTrackingEntryFromAlternateData(entry, data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const alternateSpeedMode = this.fms.activePerformancePlan.alternateSpeedValue.get();
        const alternateSpeedIsMach = this.fms.activePerformancePlan.alternateSpeedIsMach.get();
        const alternateCruiseAltitude = this.fms.activePerformancePlan.alternateCruiseAltitude.get();
        if (data.facilityIcao) {
            entry.facIcao = data.facilityIcao;
        }
        entry.predictionSpeed = alternateSpeedMode;
        entry.predictionSpeedIsMach = alternateSpeedIsMach;
        entry.predictionsAltitude = UnitType.METER.convertFrom(alternateCruiseAltitude !== null && alternateCruiseAltitude !== void 0 ? alternateCruiseAltitude : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatAltitude = UnitType.METER.convertFrom((_a = data.oatAltitude) !== null && _a !== void 0 ? _a : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        entry.predictionsOatTemperature = (_b = data.oatTemperature) !== null && _b !== void 0 ? _b : -50; // TODO investigate proper placeholder value
        entry.predictionsWind = { direction: (_d = (_c = data.wind) === null || _c === void 0 ? void 0 : _c.direction) !== null && _d !== void 0 ? _d : 0, speed: (_f = (_e = data.wind) === null || _e === void 0 ? void 0 : _e.speed) !== null && _f !== void 0 ? _f : 0, trueDegrees: (_h = (_g = data.wind) === null || _g === void 0 ? void 0 : _g.trueDegrees) !== null && _h !== void 0 ? _h : false };
        switch (data.diversion.mode) {
            case AlternateDiversionMode.Overhead: {
                entry.startAfterFlightPlanLeg = data.diversion.legIndex;
                break;
            }
            default:
            case AlternateDiversionMode.Offset:
                entry.startAfterFlightPlanLeg = 'direct';
                break;
        }
    }
    /**
     * Update a facility predictions tracking entry's values from alternate data
     *
     * @param entry the tracking entry
     * @param data the alternate data
     */
    updatePredictionsTrackingEntryFromAlternateData(entry, data) {
        var _a, _b, _c;
        const alternateSpeedMode = this.fms.activePerformancePlan.alternateSpeedValue.get();
        const alternateSpeedIsMach = this.fms.activePerformancePlan.alternateSpeedIsMach.get();
        const alternateCruiseAltitude = this.fms.activePerformancePlan.alternateCruiseAltitude.get();
        if (data.facilityIcao) {
            entry.facIcao = data.facilityIcao;
        }
        entry.predictionSpeed = alternateSpeedMode;
        entry.predictionSpeedIsMach = alternateSpeedIsMach;
        entry.predictionsAltitude = UnitType.METER.convertFrom(alternateCruiseAltitude !== null && alternateCruiseAltitude !== void 0 ? alternateCruiseAltitude : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        if (data.oatAltitude) {
            entry.predictionsOatAltitude = UnitType.METER.convertFrom((_a = data.oatAltitude) !== null && _a !== void 0 ? _a : 37000, UnitType.FOOT); // TODO investigate proper placeholder value
        }
        if (data.oatTemperature) {
            entry.predictionsOatTemperature = (_b = data.oatTemperature) !== null && _b !== void 0 ? _b : -50; // TODO investigate proper placeholder value
        }
        if (data.wind) {
            Object.assign(entry.predictionsWind, data.wind);
        }
        if (data.diversion) {
            switch ((_c = data.diversion) === null || _c === void 0 ? void 0 : _c.mode) {
                case AlternateDiversionMode.Overhead: {
                    entry.startAfterFlightPlanLeg = data.diversion.legIndex;
                    break;
                }
                default:
                case AlternateDiversionMode.Offset:
                    entry.startAfterFlightPlanLeg = 'direct';
                    break;
            }
        }
    }
    /**
     * Reads the alternates from the RTE 1 primary flight plan
     */
    readPlanAlternates() {
        const alternates = this.fms.getFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (!alternates) {
            return;
        }
        for (let i = 0; i < alternates.length; i++) {
            const alternate = alternates[i];
            this.setAlternate(i, alternate !== null && alternate !== void 0 ? alternate : null, false);
        }
    }
    /**
     * Writes the alternates to the RTE 1 primary flight plan
     */
    writePlanAlternates() {
        this.ignoreSync = true;
        this.fms.setFlightPlanAlternates(BoeingFms.ACT_RTE_PLAN_INDEX, this.alternates.getArray());
        this.ignoreSync = false;
    }
    /**
     * Returns a facility tracking ID from an alternate index
     * @param alternateIndex the alternate index
     * @returns a string
     */
    facilityTrackingID(alternateIndex) {
        return `altn-${alternateIndex}`;
    }
}

/**
 *
 */
class BoeingDevFlightPlan {
    /**
     * Method to temporarily insert a flight plan on init
     * @param fms The FMS.
     */
    static async insertDevPlan(fms) {
        setTimeout(async () => {
            await fms.emptyFlightPlan();
            const originResults = await fms.facLoader.searchByIdent(FacilitySearchType.Airport, 'KDTW', 1);
            if (originResults && originResults.length === 1) {
                const origin = await fms.facLoader.getFacility(FacilityType.Airport, originResults[0]);
                if (origin) {
                    fms.setOrigin(origin);
                    const oneWayRunway = RunwayUtils.matchOneWayRunway(origin, 21, RunwayDesignator.RUNWAY_DESIGNATOR_RIGHT);
                    await fms.insertDeparture(origin, 9, 5, -1, oneWayRunway);
                }
            }
            const destinationResults = await fms.facLoader.searchByIdent(FacilitySearchType.Airport, 'KCLE', 1);
            if (destinationResults && destinationResults.length === 1) {
                const destination = await fms.facLoader.getFacility(FacilityType.Airport, destinationResults[0]);
                if (destination) {
                    fms.setDestination(destination);
                    await fms.insertArrival(destination, 0, 1, 2, undefined);
                    await fms.insertApproach({ facility: destination, approachIndex: 0, approachTransitionIndex: 1, visualRunwayOffset: 5 });
                }
            }
            fms.removeWaypoint(2, 0, false, true);
            fms.activateLeg(0, 1);
            // setup perf
            const perfPlan = fms.activePerformancePlan;
            const gw = SimVar.GetSimVarValue('TOTAL WEIGHT', 'pounds');
            const fob = SimVar.GetSimVarValue('FUEL TOTAL QUANTITY WEIGHT', 'pounds');
            perfPlan.manualZfw.set(gw - fob);
            perfPlan.reserveFuel.set(10000);
            perfPlan.cruiseAltitude.set(16000);
            perfPlan.costIndex.set(100);
            perfPlan.takeoffFlaps.set(10);
            if (Math.abs(gw - 440000) < 5000) {
                const vSpeedSettings = VSpeedUserSettings.getManager(fms.bus);
                vSpeedSettings.getSettings(VSpeedType.V1).value.resetToDefault();
                vSpeedSettings.getSettings(VSpeedType.Vr).value.resetToDefault();
                vSpeedSettings.getSettings(VSpeedType.V2).value.resetToDefault();
                SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', SimVarValueType.Number, 153);
                perfPlan.approachFlapSpeed.set([30, 155]);
            }
        }, 3000);
    }
}

var _a;
/** A calculator for fix info intersections and predictions data */
class BoeingFixInfoCalculator {
    /**
     * Instantiates a Fix Info Calculator
     * @param bus The event bus
     * @param maxDistance Maximum distance in metres
     * @param activeRoutePredictor The active route predictor
     */
    constructor(bus, maxDistance, activeRoutePredictor) {
        this.bus = bus;
        this.maxDistance = maxDistance;
        this.activeRoutePredictor = activeRoutePredictor;
        /** sim time as a unix timestamp in milliseconds */
        this.simTime = ConsumerValue.create(null, 0);
        this.ppos = new GeoPoint(0, 0);
        this.activeLegDtg = ConsumerValue.create(null, 0);
        /** FIXME hook up when true ref exists */
        this.trueRef = Subject.create(false);
        /** Whether FMS position is currently available */
        this.fmsPositionAvailable = true;
        this.simTime.setConsumer(this.bus.getSubscriber().on('simTime'));
        this.bus.getSubscriber().on('fms_pos_anp_1').whenChangedBy(1).handle((anp) => this.fmsPositionAvailable = anp > 0);
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.activeLegDtg.setConsumer(this.bus.getSubscriber().on('lnav_leg_distance_remaining'));
    }
    /**
     * Calculates the time or altitude distance prediction
     * @param plan Active flight plan
     * @param fixInfo The pilot-entered input data
     * @param calcData Output data for the CDU page
     */
    calculateEtaAltitudePrediction(plan, fixInfo, calcData) {
        // calculate predicted distance to altitude or time
        if (fixInfo.predictedTime !== null && fixInfo.predictedTime > this.simTime.get()) {
            const prediction = this.activeRoutePredictor.getPredictionsForTime(fixInfo.predictedTime / 1000);
            calcData.etaAltitudePrediction = prediction && isFinite(prediction.distance) ? prediction.distance : null;
            if (calcData.etaAltitudePrediction !== null) {
                this.calculatePointFromDistanceAlongPlan(plan, calcData.etaAltitudePrediction, fixInfo.etaAltitudePoint);
            }
            else {
                fixInfo.etaAltitudePoint.set(NaN, NaN);
            }
        }
        else if (fixInfo.predictedAltitude !== null) {
            const prediction = this.activeRoutePredictor.getPredictionsForAltitude(fixInfo.predictedAltitude);
            calcData.etaAltitudePrediction = prediction && isFinite(prediction.distance) ? prediction.distance : null;
            if (calcData.etaAltitudePrediction !== null) {
                this.calculatePointFromDistanceAlongPlan(plan, calcData.etaAltitudePrediction, fixInfo.etaAltitudePoint);
            }
            else {
                fixInfo.etaAltitudePoint.set(NaN, NaN);
            }
        }
        else {
            calcData.etaAltitudePrediction = null;
            fixInfo.etaAltitudePoint.set(NaN, NaN);
        }
    }
    /**
     * Calculate a point along the flight plan given a distance relative to the active leg (i.e. from BoeingFlightPlanPredictionsProvider)
     * @param plan Active flight plan
     * @param distance Distance along the plan in metres
     * @param out GeoPoint to write the result to
     * @todo Easier to calculate this in the predictions provider interpolation functions.. move code there and refactor
     * @returns The GeoPoint given as {@link out}, set to NaN/NaN if no point could be calculated
     */
    calculatePointFromDistanceAlongPlan(plan, distance, out) {
        var _b;
        const activeLeg = plan.tryGetLeg(plan.activeLateralLeg);
        if (!activeLeg || !activeLeg.calculated) {
            out.set(NaN, NaN);
            return out;
        }
        const pposCumulativeDistance = activeLeg.calculated.cumulativeDistanceWithTransitions - UnitType.METER.convertFrom(this.activeLegDtg.get(), UnitType.NMILE);
        for (const leg of plan.legs(false, plan.activeLateralLeg)) {
            if (!leg.calculated) {
                break;
            }
            if (distance <= ((_b = leg.calculated.cumulativeDistanceWithTransitions) !== null && _b !== void 0 ? _b : 0)) {
                const legStartDistance = leg.calculated.cumulativeDistanceWithTransitions - leg.calculated.distanceWithTransitions - pposCumulativeDistance;
                if (legStartDistance >= distance) {
                    break;
                }
                let accumulatedVectorDistance = 0;
                for (const vector of leg.calculated.flightPath) {
                    const desiredDistanceAlongVector = distance - legStartDistance - accumulatedVectorDistance;
                    if (desiredDistanceAlongVector <= vector.distance) {
                        const vecCircle = FlightPathUtils.setGeoCircleFromVector(vector, BoeingFixInfoCalculator.geoCircleCache[0]);
                        const vecStart = BoeingFixInfoCalculator.geoPointCache[0].set(vector.startLat, vector.startLon);
                        const point = vecCircle.offsetDistanceAlong(vecStart, UnitType.GA_RADIAN.convertFrom(desiredDistanceAlongVector, UnitType.METER), BoeingFixInfoCalculator.vec3Cache[0], MathUtils.HALF_PI);
                        out.setFromCartesian(point);
                        return out;
                    }
                    accumulatedVectorDistance += vector.distance;
                }
            }
        }
        out.set(NaN, NaN);
        return out;
    }
    /**
     * Calculates fix info predictions and intersections
     * @param plan Active flight plan
     * @param fixInfo The pilot-entered input data
     * @param calcData Output data for the CDU page
     */
    calculateFixPredictions(plan, fixInfo, calcData) {
        if (fixInfo.fix === null || !plan) {
            this.clearCalculatedFixData(calcData);
            return;
        }
        calcData.fixIdent = fixInfo.fixIdent;
        // calculate the bearing/distance from the fix to ppos
        if (this.fmsPositionAvailable) {
            calcData.fixDistance = MathUtils.clamp(UnitType.GA_RADIAN.convertTo(this.ppos.distance(fixInfo.fix.lat, fixInfo.fix.lon), UnitType.METER), 0, this.maxDistance);
            const trueBearing = this.ppos.bearingFrom(fixInfo.fix.lat, fixInfo.fix.lon);
            calcData.fixBearing = this.trueRef.get() ? trueBearing : MagVar.trueToMagnetic(trueBearing, fixInfo.fixMagVar);
        }
        else {
            calcData.fixDistance = null;
            calcData.fixBearing = null;
        }
        calcData.abeamCalculated = fixInfo.calculateAbeamPoint;
        this.predictIntersection(plan, fixInfo, fixInfo.abeamIntersection, calcData.abeamPredictions);
        for (const [i, intersection] of fixInfo.bearingDistanceIntersections.entries()) {
            const predictions = calcData.bearingDistancePredictions[i];
            this.predictIntersection(plan, fixInfo, intersection, predictions);
        }
    }
    /**
     * Clear all the calculated data from the object
     * @param calcData Calculated data object
     */
    clearCalculatedFixData(calcData) {
        calcData.abeamPredictions.bearing = null;
        calcData.abeamPredictions.distance = null;
        calcData.abeamPredictions.eta = null;
        calcData.abeamPredictions.dtg = null;
        calcData.abeamPredictions.altitude = null;
        calcData.bearingDistancePredictions.forEach((p) => {
            p.bearing = null;
            p.distance = null;
            p.eta = null;
            p.dtg = null;
            p.altitude = null;
        });
        calcData.fixBearing = null;
        calcData.fixDistance = null;
        calcData.fixIdent = null;
    }
    /**
     * Predict the bearing/distance/eta/dtg/altitude for a flight plan intersection
     * @param plan Flight plan
     * @param fixInfo Fix Info
     * @param intersection Intersection to predict
     * @param predictions Object to store the results
     */
    predictIntersection(plan, fixInfo, intersection, predictions) {
        if (!this.fmsPositionAvailable || !this.isIntersectionValid(intersection)) {
            this.resetIntersectionPrediction(predictions);
            return;
        }
        const distanceFromPpos = this.calculateDistanceFromPpos(plan, intersection);
        const prediction = distanceFromPpos !== null ? this.activeRoutePredictor.getPredictionsForDistance(distanceFromPpos) : undefined;
        if ((prediction === null || prediction === void 0 ? void 0 : prediction.valid) && isFinite(prediction.estimatedTimeOfArrival) && isFinite(prediction.distance) && isFinite(prediction.altitude)) {
            predictions.eta = prediction.estimatedTimeOfArrival * 1000;
            predictions.dtg = prediction.distance;
            predictions.altitude = prediction.altitude;
        }
        else {
            this.resetIntersectionPrediction(predictions);
            // dtg is still filled if possible
            if (distanceFromPpos !== null) {
                predictions.dtg = distanceFromPpos;
            }
        }
    }
    /**
     * Reset on intersection prediction object to empty values
     * @param predictions Object to store the results
     */
    resetIntersectionPrediction(predictions) {
        predictions.eta = null;
        predictions.dtg = null;
        predictions.altitude = null;
    }
    /**
     * Checks if an intersection is valid
     * @param intersection Flight plan intersection data
     * @returns true if the intersection is valid/calculated
     */
    isIntersectionValid(intersection) {
        return intersection.distanceAlongLeg !== null && intersection.flightPlanLeg !== null;
    }
    /**
     * Calculate the cumulative distance for a distance along a flight plan leg
     * @param plan Flight plan
     * @param intersection Intersection to predict
     * @returns distance in metres or null
     */
    calculateDistanceFromPpos(plan, intersection) {
        if (intersection.flightPlanLeg === null || intersection.distanceAlongLeg === null) {
            return null;
        }
        const leg = plan.tryGetLeg(intersection.flightPlanLeg);
        if (!leg || !leg.calculated) {
            return null;
        }
        return leg.calculated.cumulativeDistanceWithTransitions - leg.calculated.distanceWithTransitions + intersection.distanceAlongLeg;
    }
    /**
     * Reset a flight plan intersection bearing and distance to null values
     * @param predictions The predictions object to reset bearing/distance on
     */
    resetIntersectionBearingDistance(predictions) {
        predictions.bearing = null;
        predictions.distance = null;
    }
    /**
     * Calculate the bearing and distance from the fix info fix to a flight plan intersection point
     * @param fixInfo The fix info this relates to
     * @param intersection The flight plan ntersection
     * @param predictions The predictions object for output
     * @param pilotBearing Pilot entered bearing in true degrees or null if none
     * @param pilotDistance Pilot entered distance in metres or null if none
     */
    calculateIntersectionBearingDistance(fixInfo, intersection, predictions, pilotBearing = null, pilotDistance = null) {
        let trueBearing = pilotBearing;
        let distance = pilotDistance;
        if (this.isIntersectionValid(intersection)) {
            if (trueBearing === null) {
                trueBearing = fixInfo.fixLocationSpherical.bearingTo(intersection.point);
            }
            if (distance === null) {
                distance = UnitType.METER.convertFrom(fixInfo.fixLocationSpherical.distance(intersection.point), UnitType.GA_RADIAN);
            }
        }
        predictions.bearing = this.trueRef.get() || trueBearing === null ? trueBearing : MagVar.trueToMagnetic(trueBearing, fixInfo.fixMagVar);
        predictions.distance = distance;
    }
    /**
     * Calculates the bearings and distances from the fix to flight plan intersections
     * @param fixInfos All of the fix infos
     * @param calcDatas Corresponding calculated data objects
     */
    calculateIntersectionBearingDistances(fixInfos, calcDatas) {
        for (const [i, fixInfo] of fixInfos.entries()) {
            const calcData = calcDatas[i];
            if (fixInfo.calculateAbeamPoint) {
                this.calculateIntersectionBearingDistance(fixInfo, fixInfo.abeamIntersection, calcData.abeamPredictions);
            }
            else {
                this.resetIntersectionBearingDistance(calcData.abeamPredictions);
            }
            for (const [j, intersection] of fixInfo.bearingDistanceIntersections.entries()) {
                const [pilotBearing, pilotDistance] = fixInfo.bearingDistances[j];
                this.calculateIntersectionBearingDistance(fixInfo, intersection, calcData.bearingDistancePredictions[j], pilotBearing, pilotDistance);
            }
        }
    }
    /**
     * Clear data from a calculated flight plan intersection
     * @param intersection Flight plan intersection object to clear
     */
    clearIntersection(intersection) {
        intersection.distanceAlongLeg = null;
        intersection.flightPlanLeg = null;
    }
    /**
     * Clear data from a calculated flight plan intersection
     * @param fixInfo The fix info to clear
     */
    clearFixIntersections(fixInfo) {
        this.clearIntersection(fixInfo.abeamIntersection);
        for (const intersection of fixInfo.bearingDistanceIntersections) {
            this.clearIntersection(intersection);
        }
    }
    /**
     * Reset flight plan intersections to null values for all fix infos
     * @param fixInfos All of the fix infos
     */
    clearAllFixIntersections(fixInfos) {
        for (const fixInfo of fixInfos) {
            this.clearFixIntersections(fixInfo);
        }
    }
    /**
     * Calculates intersections with the active flight plan for fix infos
     * @param plan The active flight plan
     * @param fixInfos All of the fix infos
     */
    calculateAllIntersections(plan, fixInfos) {
        this.clearAllFixIntersections(fixInfos);
        if (plan.length < 2) {
            return;
        }
        for (let globalLegIndex = plan.activeLateralLeg - 1;; globalLegIndex++) {
            const leg = plan.tryGetLeg(globalLegIndex);
            if (!leg) {
                break;
            }
            const allIntersectionsFound = this.calculateIntersectionsForLeg(leg, globalLegIndex, fixInfos);
            if (allIntersectionsFound) {
                return;
            }
        }
    }
    /**
     * Calculates intersections with the flightplan for the given set of fix infos, where intersections don't already exist
     * @param leg Flight plan leg to intersect
     * @param globalLegIndex Index of this leg
     * @param fixInfos The fix infos that should try to intersect the vector
     * @returns true if there are no remaining intersections to find
     */
    calculateIntersectionsForLeg(leg, globalLegIndex, fixInfos) {
        if (!leg.calculated || leg.calculated.flightPath.length < 1) {
            return false;
        }
        let remainingIntersections = false;
        let accumulatedDistance = 0;
        for (const vector of leg.calculated.flightPath) {
            // make a great circle through the centre of the flight path arc, and the fix... find intercepts with the flight path circle
            const vectorCircle = FlightPathUtils.setGeoCircleFromVector(vector, BoeingFixInfoCalculator.geoCircleCache[0]);
            const vectorStart = BoeingFixInfoCalculator.geoPointCache[0].set(vector.startLat, vector.startLon);
            const vectorEnd = BoeingFixInfoCalculator.geoPointCache[1].set(vector.endLat, vector.endLon);
            const vectorDistance = FlightPathUtils.getAlongArcSignedDistance(vectorCircle, vectorStart, vectorEnd, vectorEnd);
            for (const fixInfo of fixInfos) {
                if (fixInfo.fix === null) {
                    continue;
                }
                if (fixInfo.calculateAbeamPoint && fixInfo.abeamIntersection.flightPlanLeg === null) {
                    const abeamCircle = this.calculateAbeamCircle(fixInfo, vectorCircle);
                    if (!this.calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, abeamCircle, vectorCircle, vectorStart, vectorEnd, fixInfo.abeamIntersection)) {
                        remainingIntersections = true;
                    }
                }
                for (const [i, [pilotBearing, pilotDistance]] of fixInfo.bearingDistances.entries()) {
                    let bearingDistanceCircle;
                    // intersections are only calculated if pilot enteres either bearing *or* distance, not both
                    if (pilotBearing !== null && pilotDistance === null) {
                        bearingDistanceCircle = this.calculateFixBearingCircle(fixInfo, pilotBearing);
                    }
                    else if (pilotBearing === null && pilotDistance !== null) {
                        bearingDistanceCircle = this.calculateFixDistanceCircle(fixInfo, pilotDistance);
                    }
                    else {
                        continue;
                    }
                    if (!this.calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, bearingDistanceCircle, vectorCircle, vectorStart, vectorEnd, fixInfo.bearingDistanceIntersections[i])) {
                        remainingIntersections = true;
                    }
                }
            }
            if (!remainingIntersections) {
                break;
            }
            accumulatedDistance += vectorDistance;
        }
        return !remainingIntersections;
    }
    /**
     * Create a great circle from a fix info fix through the centre of a flight path vector circle
     * @param fixInfo A fix info
     * @param pathCircle A flight path vector circle
     * @returns A great circle
     */
    calculateAbeamCircle(fixInfo, pathCircle) {
        return BoeingFixInfoCalculator.geoCircleCache[1].setAsGreatCircle(fixInfo.fixLocationCartesian, pathCircle.center);
    }
    /**
     * Create a great circle from a fix info fix at a true bearing
     * @param fixInfo A fix info
     * @param bearing Bearing from the fix info in true degrees
     * @returns A great circle
     */
    calculateFixBearingCircle(fixInfo, bearing) {
        return BoeingFixInfoCalculator.geoCircleCache[1].setAsGreatCircle(fixInfo.fixLocationCartesian, bearing);
    }
    /**
     * Create a small circle around a fix info fix at a given radius/distance
     * @param fixInfo A fix info
     * @param distance Distance from the fix info in metres
     * @returns A small circle
     */
    calculateFixDistanceCircle(fixInfo, distance) {
        return BoeingFixInfoCalculator.geoCircleCache[1].set(fixInfo.fixLocationCartesian, UnitType.GA_RADIAN.convertFrom(distance, UnitType.METER));
    }
    /**
     * Finds an intersection with a flight path vector
     * @param globalLegIndex index of the flight plan leg this vector belongs to
     * @param accumulatedDistance distance along the leg up to the start of this vector in great circle radians
     * @param vectorDistance distance along this vector in great circle radians
     * @param intersectionCircle the small or great circle defined by the fix info, must be centred at the fix info fix
     * @param vectorCircle the flight path circle
     * @param vectorStart starting point of the flight path vector
     * @param vectorEnd ending point of the flight path vector
     * @param intersectionData output data if an intersection is found
     * @returns true if intersection found
     */
    calculateFlightPathIntersection(globalLegIndex, accumulatedDistance, vectorDistance, intersectionCircle, vectorCircle, vectorStart, vectorEnd, intersectionData) {
        let foundIntersection = false;
        const numIntersections = intersectionCircle.intersection(vectorCircle, BoeingFixInfoCalculator.vec3Cache);
        if (numIntersections > 0) {
            for (let i = 0; i < numIntersections; i++) {
                const intersection = BoeingFixInfoCalculator.vec3Cache[i];
                const alongPathDistance = FlightPathUtils.getAlongArcNormalizedDistance(vectorCircle, vectorStart, vectorEnd, intersection);
                if (alongPathDistance >= 0 && alongPathDistance <= 1) {
                    const distanceAlongLeg = Math.abs(UnitType.METER.convertFrom(accumulatedDistance + alongPathDistance * vectorDistance, UnitType.GA_RADIAN));
                    // only take a closer intersection
                    if (intersectionData.distanceAlongLeg !== null && distanceAlongLeg >= intersectionData.distanceAlongLeg) {
                        continue;
                    }
                    intersectionData.flightPlanLeg = globalLegIndex;
                    intersectionData.distanceAlongLeg = Math.abs(UnitType.METER.convertFrom(accumulatedDistance + alongPathDistance * vectorDistance, UnitType.GA_RADIAN));
                    intersectionData.point.setFromCartesian(intersection);
                    foundIntersection = true;
                }
            }
        }
        return foundIntersection;
    }
}
_a = BoeingFixInfoCalculator;
BoeingFixInfoCalculator.vec3Cache = [Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create(), Vec3Math.create()];
BoeingFixInfoCalculator.geoCircleCache = [new GeoCircle(_a.vec3Cache[0], 0), new GeoCircle(_a.vec3Cache[0], 0)];
BoeingFixInfoCalculator.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];

/** FMS Operating Phases of flight */
var FmsOperatingPhase;
(function (FmsOperatingPhase) {
    FmsOperatingPhase[FmsOperatingPhase["PREFLIGHT"] = 0] = "PREFLIGHT";
    FmsOperatingPhase[FmsOperatingPhase["TAKEOFF"] = 1] = "TAKEOFF";
    FmsOperatingPhase[FmsOperatingPhase["CLIMB"] = 2] = "CLIMB";
    FmsOperatingPhase[FmsOperatingPhase["CRUISE"] = 3] = "CRUISE";
    FmsOperatingPhase[FmsOperatingPhase["DESCENT"] = 4] = "DESCENT";
    FmsOperatingPhase[FmsOperatingPhase["APPROACH"] = 5] = "APPROACH";
    FmsOperatingPhase[FmsOperatingPhase["COMPLETE"] = 6] = "COMPLETE";
})(FmsOperatingPhase || (FmsOperatingPhase = {}));
/**
 * L Var names for FMS phase-related data.
 */
var FmsOperatingPhaseDataVars;
(function (FmsOperatingPhaseDataVars) {
    /** The current nominal desired track, in degrees true. */
    FmsOperatingPhaseDataVars["FmsOperatingPhaseVar"] = "L:WT_Boeing_Fms_Operating_Phase";
})(FmsOperatingPhaseDataVars || (FmsOperatingPhaseDataVars = {}));
/**
 * A publisher for LNAV-related data sim var events.
 */
class FmsOperatingPhasePublisher extends SimVarPublisher {
    /**
     * Constructor.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(FmsOperatingPhasePublisher.simvars, bus);
    }
}
FmsOperatingPhasePublisher.simvars = new Map([
    ['fms_operating_phase', { name: FmsOperatingPhaseDataVars.FmsOperatingPhaseVar, type: SimVarValueType.Enum }],
]);

/** Boeing Fix Info Implementation */
class BoeingFixInfoManager {
    /**
     * Instantiates the Fix Info subsystem
     * @param bus Event Bus
     * @param facLoader Facility Loader
     * @param activeRoutePlanIndex Index of the active route flight plan
     * @param activeRoutePredictor The active route predictor
     * @param flightPlanner The flight planner
     */
    constructor(bus, facLoader, activeRoutePlanIndex, activeRoutePredictor, flightPlanner) {
        this.bus = bus;
        this.facLoader = facLoader;
        this.activeRoutePlanIndex = activeRoutePlanIndex;
        this.activeRoutePredictor = activeRoutePredictor;
        this.flightPlanner = flightPlanner;
        this.needPredictionsUpdate = false;
        this.needIntersectionsUpdate = false;
        this.ignoreSync = false;
        this.syncDataCache = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIcao: null,
            bearingDistances: [],
            predictedTime: null,
            predictedAltitude: null,
            calculateAbeamPoint: false,
        }));
        this.fixInfos = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIcao: null,
            fix: null,
            fixIdent: null,
            fixLocationSpherical: new GeoPoint(NaN, NaN),
            fixLocationCartesian: Vec3Math.create(),
            fixMagVar: 0,
            bearingDistances: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => [null, null]),
            calculateAbeamPoint: false,
            predictedTime: null,
            predictedAltitude: null,
            bearingDistanceIntersections: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => ({
                flightPlanLeg: null,
                distanceAlongLeg: null,
                point: new GeoPoint(NaN, NaN),
            })),
            abeamIntersection: {
                flightPlanLeg: null,
                distanceAlongLeg: null,
                point: new GeoPoint(NaN, NaN),
            },
            etaAltitudePoint: new GeoPoint(NaN, NaN),
        }));
        /** FIX INFO page data, {@link BoeingFixInfoManager.NUM_FIXES} elements */
        this.calculatedData = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            fixIdent: null,
            fixBearing: null,
            fixDistance: null,
            bearingDistancePredictions: Array.from({ length: BoeingFixInfoManager.NUM_BRG_DIST }, () => ({ bearing: null, distance: null, eta: null, dtg: null, altitude: null })),
            abeamCalculated: false,
            abeamPredictions: { bearing: null, distance: null, eta: null, dtg: null, altitude: null },
            etaAltitudePrediction: null,
        }));
        this.ndMarkers = ArraySubject.create();
        this.ndMarkersCache = Array.from({ length: BoeingFixInfoManager.NUM_FIXES }, () => ({
            location: new GeoPoint(NaN, NaN),
            altitude: null,
            estimatedTimeOfArrival: null,
        }));
        this.ndWaypoints = ArraySubject.create();
        this.ndWaypointsCache = [];
        this.calculator = new BoeingFixInfoCalculator(this.bus, BoeingFixInfoManager.MAX_DISTANCE, this.activeRoutePredictor);
        /** FIXME hook up when true ref exists */
        this.trueRef = Subject.create(false);
        const sub = this.bus.getSubscriber();
        sub.on('simTime').atFrequency(1 / 3).handle(() => this.needPredictionsUpdate = true);
        sub.on('realTime').handle(this.onUpdate.bind(this));
        sub.on('fms_operating_phase').handle((phase) => phase === FmsOperatingPhase.COMPLETE && this.clearAllFixes());
        sub.on('fplCalculated').handle((ev) => ev.planIndex === this.activeRoutePlanIndex && (this.needIntersectionsUpdate = true));
        this.trueRef.sub(() => this.needIntersectionsUpdate = true);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplUserDataSet').handle(this.onPlanUserDataSet.bind(this));
        planEvents.on('fplLoaded').handle(x => x.planIndex === this.activeRoutePlanIndex && this.readFixInfoFromUserData());
    }
    /**
     * Handle the flightplan user data changed event
     * @param event User data event
     */
    onPlanUserDataSet(event) {
        if (event.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && event.key === BoeingFms.USER_DATA_KEY_FIX_INFO) {
            this.onFlightPlanFixInfoDataChanged();
        }
    }
    /**
     * Handle the flightplan user data changed event
     */
    onFlightPlanFixInfoDataChanged() {
        if (this.ignoreSync) {
            return;
        }
        this.readFixInfoFromUserData();
    }
    /**
     * Read the pilot-entered fix info data from the flightplan.
     * Used for syncing data from other FMS instances
     */
    async readFixInfoFromUserData() {
        const userData = this.getFlightPlanFixInfos(this.activeRoutePlanIndex);
        if (!userData) {
            return;
        }
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            const planData = userData[i];
            const fixInfo = this.fixInfos[i];
            if (fixInfo.fixIcao !== (planData === null || planData === void 0 ? void 0 : planData.fixIcao)) {
                // fill in all the data that is cached locally
                if (planData === null || planData === void 0 ? void 0 : planData.fixIcao) {
                    const fix = await this.facLoader.getFacility(ICAO.getFacilityType(planData.fixIcao), planData.fixIcao);
                    fixInfo.fix = fix;
                    fixInfo.fixIdent = ICAO.getIdent(fix.icao);
                    fixInfo.fixLocationSpherical.set(fix.lat, fix.lon);
                    fixInfo.fixLocationSpherical.toCartesian(fixInfo.fixLocationCartesian);
                    fixInfo.fixMagVar = FacilityUtils.getMagVar(fix);
                }
                else {
                    fixInfo.fix = null;
                    fixInfo.fixIdent = null;
                    fixInfo.fixMagVar = 0;
                }
            }
            Object.assign(fixInfo, userData[i]);
        }
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
    }
    /**
     * Write the pilot-entered fix info data to the flightplan.
     * Used for syncing data to other FMS instances.
     */
    writeFixInfoToUserData() {
        this.ignoreSync = true;
        for (const [i, fixInfo] of this.fixInfos.entries()) {
            this.syncDataCache[i].fixIcao = fixInfo.fixIcao;
            this.syncDataCache[i].bearingDistances = fixInfo.bearingDistances;
            this.syncDataCache[i].predictedAltitude = fixInfo.predictedAltitude;
            this.syncDataCache[i].predictedTime = fixInfo.predictedTime;
            this.syncDataCache[i].calculateAbeamPoint = fixInfo.calculateAbeamPoint;
        }
        this.setFlightPlanFixInfos(this.activeRoutePlanIndex, this.syncDataCache);
        this.ignoreSync = false;
    }
    /**
     * Periodic update of fix info calculated data
     */
    onUpdate() {
        if (!this.flightPlanner.hasFlightPlan(this.activeRoutePlanIndex)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(this.activeRoutePlanIndex);
        if (this.needIntersectionsUpdate) {
            this.needIntersectionsUpdate = false;
            this.calculator.calculateAllIntersections(plan, this.fixInfos);
            this.calculator.calculateIntersectionBearingDistances(this.fixInfos, this.calculatedData);
            this.refreshNdWaypoints();
            this.needPredictionsUpdate = true;
            // punt the predictions onto another frame
            return;
        }
        if (!this.needPredictionsUpdate) {
            return;
        }
        this.needPredictionsUpdate = false;
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            const fixInfo = this.fixInfos[i];
            const calculated = this.calculatedData[i];
            // update the time/altitude prediction
            this.calculator.calculateEtaAltitudePrediction(plan, fixInfo, calculated);
            // update CDU data
            this.calculator.calculateFixPredictions(plan, fixInfo, calculated);
            this.bus.getPublisher().pub('fix_info_calculated', i, false, false);
        }
        this.refreshNdMarkers();
    }
    /**
     * Refresh the set of ND ETA/altitude prediction markers
     */
    refreshNdMarkers() {
        const newMarkers = this.gatherNdMarkers();
        // remove markers that don't exist any more
        for (let i = this.ndMarkers.length - 1; i >= 0; i--) {
            const oldMarker = this.ndMarkers.get(i);
            if (newMarkers.find((m) => this.ndMarkerEquality(oldMarker, m)) === undefined) {
                this.ndMarkers.removeAt(i);
            }
        }
        // insert new/updated markers
        for (const newMarker of newMarkers) {
            // we use latitude being finite as a proxy for "this marker is valid"
            if (isFinite(newMarker.location.lat) && this.ndMarkers.getArray().find((m) => this.ndMarkerEquality(newMarker, m)) === undefined) {
                this.ndMarkers.insert(newMarker);
            }
        }
    }
    /**
     * Gather current ND ETA/altitude prediction markers
     * @returns the current markers that should be displayed
     */
    gatherNdMarkers() {
        for (const [i, fixInfo] of this.fixInfos.entries()) {
            const ndMarker = this.ndMarkersCache[i];
            if (!isFinite(fixInfo.etaAltitudePoint.lat) || !isFinite(fixInfo.etaAltitudePoint.lon)) {
                ndMarker.location.set(NaN, NaN);
                ndMarker.altitude = null;
                ndMarker.estimatedTimeOfArrival = null;
            }
            else if (fixInfo.predictedAltitude !== null) {
                ndMarker.location.set(fixInfo.etaAltitudePoint);
                ndMarker.altitude = UnitType.FOOT.convertFrom(fixInfo.predictedAltitude, UnitType.METER);
                ndMarker.estimatedTimeOfArrival = null;
            }
            else if (fixInfo.predictedTime !== null) {
                ndMarker.location.set(fixInfo.etaAltitudePoint);
                ndMarker.altitude = null;
                ndMarker.estimatedTimeOfArrival = fixInfo.predictedTime;
            }
        }
        return this.ndMarkersCache;
    }
    /**
     * Check if two {@link BoeingFixInfoMarker} instances are equal
     * @param a first instance
     * @param b second instance
     * @returns true if the two instances are equal
     */
    ndMarkerEquality(a, b) {
        return a.altitude === b.altitude
            && b.estimatedTimeOfArrival === b.estimatedTimeOfArrival
            && a.location.equals(b.location);
    }
    /**
     * Refresh the set of ND waypoints
     */
    refreshNdWaypoints() {
        const newData = this.gatherNdWaypoints();
        // remove any fixes no longer existing
        for (let i = this.ndWaypoints.length - 1; i >= 0; i--) {
            const ndData = this.ndWaypoints.get(i);
            if (newData.find((f) => f.fixIcao === ndData.fixIcao) === undefined) {
                this.ndWaypoints.removeAt(i);
            }
        }
        for (let i = 0; i < newData.length; i++) {
            const newFix = newData[i];
            const oldFixIndex = this.ndWaypoints.getArray().findIndex((f) => f.fixIcao === newFix.fixIcao);
            const oldFix = this.ndWaypoints.tryGet(oldFixIndex);
            // old data is equal to new, so no need to send anything to the ND/mangle the DOM
            if (oldFix && this.ndWaypointEquality(newFix, oldFix)) {
                continue;
            }
            // remove the stale data if it exists, and insert new data
            if (oldFixIndex >= 0) {
                this.ndWaypoints.removeAt(oldFixIndex);
            }
            const insertFix = oldFix ? oldFix : Object.assign({}, newFix);
            insertFix.abeamIntersections = [...newFix.abeamIntersections];
            insertFix.bearings = [...newFix.bearings];
            insertFix.circleRadii = [...newFix.circleRadii];
            this.ndWaypoints.insert(insertFix);
        }
    }
    /**
     * Get ND data for all of the fix infos
     * @returns ND waypoint data
     */
    gatherNdWaypoints() {
        // remove any fixes no longer existing, and reset calculated data
        for (let i = this.ndWaypointsCache.length - 1; i >= 0; i--) {
            const ndData = this.ndWaypointsCache[i];
            if (this.fixInfos.find((f) => f.fixIcao === ndData.fixIcao) === undefined) {
                this.ndWaypointsCache.splice(i, 1);
            }
            else {
                ndData.abeamIntersections.length = 0;
                ndData.bearings.length = 0;
                ndData.circleRadii.length = 0;
            }
        }
        for (const fixInfo of this.fixInfos) {
            if (fixInfo.fixIdent === null || fixInfo.fixIcao === null) {
                continue;
            }
            let ndFix = this.ndWaypointsCache.find((f) => f.fixIcao === fixInfo.fixIcao);
            if (!ndFix) {
                ndFix = {
                    fixIdent: fixInfo.fixIdent,
                    fixIcao: fixInfo.fixIcao,
                    location: fixInfo.fixLocationSpherical,
                    circleRadii: [],
                    bearings: [],
                    abeamIntersections: [],
                    magVar: fixInfo.fixMagVar,
                };
                this.ndWaypointsCache.push(ndFix);
            }
            for (const [bearing, distance] of fixInfo.bearingDistances) {
                if (bearing !== null && !ndFix.bearings.includes(Math.round(bearing))) {
                    ndFix.bearings.push(Math.round(bearing));
                }
                if (distance !== null && !ndFix.circleRadii.includes(Math.round(distance))) {
                    ndFix.circleRadii.push(Math.round(distance));
                }
            }
            if (this.calculator.isIntersectionValid(fixInfo.abeamIntersection)) {
                ndFix.abeamIntersections.push(fixInfo.abeamIntersection.point);
            }
        }
        return this.ndWaypointsCache;
    }
    /**
     * Check if two {@link BoeingFixInfoWaypoint} instances are equal
     * @param a first instance
     * @param b second instance
     * @returns true if the two instances are equal
     */
    ndWaypointEquality(a, b) {
        return a.fixIcao === b.fixIcao
            && a.circleRadii.length === b.circleRadii.length
            && a.circleRadii.every((r, i) => r === b.circleRadii[i])
            && a.bearings.length === b.bearings.length
            && a.bearings.every((r, i) => r === b.bearings[i])
            && a.abeamIntersections.length === b.abeamIntersections.length
            && a.abeamIntersections.every((p, i) => p.equals(b.abeamIntersections[i]));
    }
    /** Clear all fixes on flight completion */
    clearAllFixes() {
        for (let i = 0; i < BoeingFixInfoManager.NUM_FIXES; i++) {
            this.clearFix(i, true);
        }
        // no sync to user data as we assume other FMS instances also got complete phase
    }
    /**
     * Set a pilot-entered bearing and/or distance.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param brgDistIndex Index/row of the bearing/dist pair (0-based).
     * @param bearing Bearing in degrees, true or magnetic depending on reference mode,
     * or null to allow FMS intersection computation.
     * @param distance Distance/radius in metres, or null to allow FMS intersection
     * computation.
     * @returns true if the operation succeeded.
     */
    setBearingDistance(fixIndex, brgDistIndex, bearing, distance) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES || brgDistIndex >= BoeingFixInfoManager.NUM_BRG_DIST || this.fixInfos[fixIndex].fix === null) {
            return false;
        }
        const fixInfo = this.fixInfos[fixIndex];
        const trueBearing = (this.trueRef.get() || bearing === null) ? bearing : MagVar.magneticToTrue(bearing, fixInfo.fixMagVar);
        fixInfo.bearingDistances[brgDistIndex][0] = trueBearing;
        fixInfo.bearingDistances[brgDistIndex][1] = distance;
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
        this.writeFixInfoToUserData();
        return true;
    }
    /**
     * Clear a pilot-entered bearing/distance pair
     * @param fixIndex Index of the fix info/page (0-based).
     * @param brgDistIndex Index/row of the bearing/dist pair (0-based).
     * @returns true if the operation succeeded.
     */
    clearBearingDistance(fixIndex, brgDistIndex) {
        return this.setBearingDistance(fixIndex, brgDistIndex, null, null);
    }
    /**
     * Set the fix for a fix info page, clearing all other data on the page
     * @param fixIndex Index of the fix info/page (0-based).
     * @param fix The fix facility
     * @returns true if the operation succeeded.
     */
    setFix(fixIndex, fix) {
        var _a;
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES || !fix) {
            return false;
        }
        // don't clear data if it's the same fix... nothing to do
        if (((_a = this.fixInfos[fixIndex].fix) === null || _a === void 0 ? void 0 : _a.icao) === (fix === null || fix === void 0 ? void 0 : fix.icao)) {
            return true;
        }
        if (this.fixInfos[fixIndex].fix !== null) {
            this.clearFix(fixIndex, true);
        }
        const fixInfo = this.fixInfos[fixIndex];
        fixInfo.fix = fix;
        fixInfo.fixIcao = fix.icao;
        fixInfo.fixIdent = ICAO.getIdent(fix.icao);
        fixInfo.fixLocationSpherical = new GeoPoint(fix.lat, fix.lon);
        fixInfo.fixLocationSpherical.toCartesian(fixInfo.fixLocationCartesian);
        fixInfo.fixMagVar = FacilityUtils.getMagVar(fix);
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Clear a fix info page
     * @param fixIndex Index of the fix info/page (0-based).
     * @param omitSync true if the flight plan user data sync will be done later
     * @returns true if the operation succeeded.
     */
    clearFix(fixIndex, omitSync = false) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const fixInfo = this.fixInfos[fixIndex];
        fixInfo.fix = null;
        fixInfo.fixIcao = null;
        fixInfo.fixIdent = null;
        fixInfo.fixMagVar = 0;
        fixInfo.bearingDistances.forEach((v) => { v[0] = null; v[1] = null; });
        fixInfo.calculateAbeamPoint = false;
        this.calculator.clearFixIntersections(fixInfo);
        if (!omitSync) {
            this.writeFixInfoToUserData();
        }
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Set a time to predict the distance/along-track location for.
     * This will clear the altitude to predict if set.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param time Unix timestamp in milliseconds
     * @returns true if the operation succeeded.
     */
    setTimePrediction(fixIndex, time) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = null;
        data.predictedTime = time;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Set an altitude to predict the distance/along-track location for.
     * This will clear the time to predict if set.
     * @param fixIndex Index of the fix info/page (0-based).
     * @param altitude Altitude in metres.
     * @returns true if the operation succeeded.
     */
    setAltitudePrediction(fixIndex, altitude) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = altitude;
        data.predictedTime = null;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Clear the time or altitude to predict along-track location for.
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns true if the operation succeeded.
     */
    clearPrediction(fixIndex) {
        if (fixIndex >= BoeingFixInfoManager.NUM_FIXES) {
            return false;
        }
        const data = this.fixInfos[fixIndex];
        data.predictedAltitude = null;
        data.predictedTime = null;
        this.writeFixInfoToUserData();
        this.needPredictionsUpdate = true;
        return true;
    }
    /**
     * Attempts to find the closest abeam intersection and saves it on this fix info
     * @param fixIndex of the fix info/page (0-based).
     * @returns true on success
     */
    createAbeamPoint(fixIndex) {
        const fixInfo = this.fixInfos[fixIndex];
        if (!fixInfo) {
            return false;
        }
        fixInfo.calculateAbeamPoint = true;
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
        this.writeFixInfoToUserData();
        return true;
    }
    /**
     * Removes the abeam fix calculation.
     * @param fixIndex of the fix info/page (0-based).
     * @returns true on success
     */
    deleteAbeamPoint(fixIndex) {
        const fixInfo = this.fixInfos[fixIndex];
        if (!fixInfo) {
            return false;
        }
        fixInfo.calculateAbeamPoint = false;
        this.needIntersectionsUpdate = true;
        this.needPredictionsUpdate = true;
        this.writeFixInfoToUserData();
        return true;
    }
    /**
     * Get the calculated data for CDU page rendering
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns the calculated data
     */
    getCalculatedData(fixIndex) {
        return this.calculatedData[fixIndex];
    }
    /**
     * Get the entered data for CDU page rendering
     * @param fixIndex Index of the fix info/page (0-based).
     * @returns the entered data
     */
    getEnteredData(fixIndex) {
        return this.fixInfos[fixIndex];
    }
    /**
     * Gets the fix infos of a flight plan
     * @param planIndex the flight plan index
     * @returns the fix infos, or undefined
     */
    getFlightPlanFixInfos(planIndex) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        return plan.getUserData(BoeingFms.USER_DATA_KEY_FIX_INFO);
    }
    /**
     * Sets the fix infos of a flight plan
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingFixInfo` instead
     * @param planIndex the plan index to use
     * @param fixInfos the fix info data
     */
    setFlightPlanFixInfos(planIndex, fixInfos) {
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        plan.setUserData(BoeingFms.USER_DATA_KEY_FIX_INFO, fixInfos);
    }
}
BoeingFixInfoManager.NUM_FIXES = 4;
BoeingFixInfoManager.NUM_BRG_DIST = 3;
/** Maximum distance that can be shown */
BoeingFixInfoManager.MAX_DISTANCE = UnitType.METER.convertFrom(9999, UnitType.NMILE);

/**
 * A utility class for working with Boeing flight path calculations.
 */
class BoeingFlightPathUtils {
}
/** The flight path calculator plans turns at these bank angles */
BoeingFlightPathUtils.flightPathBankAngleTable = [
    [15, 0],
    [25, 100],
    [25, 375],
    [19, 450],
];

/**
 * Sources of FMS-computed speed targets.
 */
var FmsSpeedTargetSource;
(function (FmsSpeedTargetSource) {
    /** No source. Used when FMS has no computed speed target. */
    FmsSpeedTargetSource["None"] = "None";
    /** Speed target is derived from aircraft configuration limits (flaps, gear, etc). */
    FmsSpeedTargetSource["Configuration"] = "Configuration";
    /** Speed target is derived from takeoff/go-around target */
    FmsSpeedTargetSource["ToGa"] = "ToGa";
    /** Speed target is derived from user-defined altitude speed limits (e.g. 250 knots below 10000 feet). */
    FmsSpeedTargetSource["Altitude"] = "Altitude";
    /** Speed target is derived from speed constraints in the flight plan. */
    FmsSpeedTargetSource["Constraint"] = "Constraint";
    /** Speed target is derived from VNAV climb schedule. */
    FmsSpeedTargetSource["ClimbSchedule"] = "ClimbSchedule";
    /** Speed target is derived from VNAV cruise. */
    FmsSpeedTargetSource["CruiseSchedule"] = "CruiseSchedule";
    /** Speed target is derived from VNAV descent schedule. */
    FmsSpeedTargetSource["DescentSchedule"] = "DescentSchedule";
})(FmsSpeedTargetSource || (FmsSpeedTargetSource = {}));

const TARGET_IAS_COMMANDED_TOLERANCE = 1;
const TARGET_MACH_COMMANDED_TOLERANCE = 0.01;
var BoeingAltitudeEntryType;
(function (BoeingAltitudeEntryType) {
    BoeingAltitudeEntryType["At"] = "At";
    BoeingAltitudeEntryType["Above"] = "Above";
    BoeingAltitudeEntryType["Below"] = "Below";
    BoeingAltitudeEntryType["Step"] = "Step";
})(BoeingAltitudeEntryType || (BoeingAltitudeEntryType = {}));
/**
 * Utilities for input/output of vertical leg data
 */
class BoeingVerticalIOUtils {
    /**
     * Generates vertical display data for a leg
     *
     * @param lateralLeg the lateral flight plan leg
     * @param predictions the Boeing vertical leg
     * @param transitionAltitude the currently used transition altitude
     * @param transitionLevel the currently used transition level
     * @param commandedFmcAlt the currently commanded FMC altitude
     * @param commandedFmcSpeed the currently commanded FMC speed
     * @param commandedFmcSpeedIsMach whether the currently commanded FMC speed is a Mach value
     * @param commandedFmcSpeedSource the currently commanded FMC speed source
     *
     * @returns a {@link BoeingVerticalDisplayData}
     */
    static getDisplayDataForLeg(lateralLeg, predictions, transitionAltitude, transitionLevel, commandedFmcAlt, commandedFmcSpeed, commandedFmcSpeedIsMach, commandedFmcSpeedSource) {
        let speed = undefined;
        let speedIsMach = false;
        let speedIsPredicted = false;
        if (lateralLeg.verticalData.speed > 0) {
            speed = lateralLeg.verticalData.speed;
            speedIsMach = lateralLeg.verticalData.speedUnit === SpeedUnit.MACH;
            speedIsPredicted = lateralLeg.verticalData.speedDesc === SpeedRestrictionType.Unused;
        }
        else if (predictions !== undefined && isFinite(predictions.speed)) {
            speed = predictions.speed;
            speedIsMach = predictions.isSpeedMach;
            speedIsPredicted = true;
        }
        // TODO ECON/LRC/RTA
        let speedIsCommanded = false;
        if (speed !== undefined && !speedIsPredicted && commandedFmcSpeedSource === FmsSpeedTargetSource.Constraint) {
            if (commandedFmcSpeedIsMach && speedIsMach) {
                const targetMachValid = commandedFmcSpeed > 0;
                if (targetMachValid && Math.abs(speed - commandedFmcSpeed) < TARGET_MACH_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
            else if (!commandedFmcSpeedIsMach && !speedIsMach) {
                const targetIasValid = commandedFmcSpeed > 0;
                if (targetIasValid && Math.abs(speed - commandedFmcSpeed) < TARGET_IAS_COMMANDED_TOLERANCE) {
                    speedIsCommanded = true;
                }
            }
        }
        const altitudes = [];
        const altitudeSuffixes = [];
        const altitudesAreFlightLevels = [];
        let altitudesArePredicted = false;
        const phase = lateralLeg.verticalData.phase;
        const alt1Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude1, UnitType.METER);
        const alt2Feet = UnitType.FOOT.convertFrom(lateralLeg.verticalData.altitude2, UnitType.METER);
        switch (lateralLeg.verticalData.altDesc) {
            case AltitudeRestrictionType.At: {
                altitudes.push(alt1Feet);
                altitudeSuffixes.push(' ');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            }
            case AltitudeRestrictionType.AtOrAbove:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('A');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.AtOrBelow:
                altitudes.push(alt1Feet);
                altitudeSuffixes.push('B');
                altitudesAreFlightLevels.push(alt1Feet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                break;
            case AltitudeRestrictionType.Between:
                if (lateralLeg.verticalData.phase === VerticalFlightPhase.Climb) {
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionAltitude);
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionAltitude);
                }
                else {
                    altitudes.push(alt1Feet);
                    altitudeSuffixes.push('B');
                    altitudesAreFlightLevels.push(alt1Feet > transitionLevel);
                    altitudes.push(alt2Feet);
                    altitudeSuffixes.push('A');
                    altitudesAreFlightLevels.push(alt2Feet > transitionLevel);
                }
                break;
            case AltitudeRestrictionType.Unused: {
                if (predictions !== undefined && isFinite(predictions.altitude)) {
                    const endAltitudeFeet = UnitType.FOOT.convertFrom(predictions.altitude, UnitType.METER);
                    altitudes.push(endAltitudeFeet);
                    altitudeSuffixes.push(' ');
                    altitudesAreFlightLevels.push(endAltitudeFeet > (phase === VerticalFlightPhase.Climb ? transitionAltitude : transitionLevel));
                    altitudesArePredicted = true;
                }
                break;
            }
        }
        const alt1WholeFeet = MathUtils.round(alt1Feet);
        const alt2WholeFeet = MathUtils.round(alt2Feet);
        const altitudeIsCommanded = alt2Feet
            ? Math.min(alt1WholeFeet, alt2WholeFeet) <= commandedFmcAlt && commandedFmcAlt <= Math.max(alt1WholeFeet, alt2WholeFeet)
            : alt1WholeFeet === commandedFmcAlt;
        // TODO step climbs
        return {
            speed,
            speedIsMach,
            speedIsPredicted,
            speedIsCommanded,
            altitudes,
            altitudeSuffixes,
            altitudesAreFlightLevels,
            altitudesArePredicted,
            altitudeIsCommanded,
        };
    }
    /**
     * Applies a parsed modification to vertical display data to a vertical data object
     *
     * @param verticalData the vertical data object to modify
     * @param modification the modification to apply
     */
    static applyDisplayModificationToVerticalData(verticalData, modification) {
        // Handle speed modification
        if (modification.setSpeed) {
            if (typeof modification.setSpeed === 'string') ;
            else {
                verticalData.speed = modification.setSpeed;
                verticalData.speedUnit = modification.setSpeedIsMach ? SpeedUnit.MACH : SpeedUnit.IAS;
                verticalData.speedDesc = SpeedRestrictionType.At;
            }
        }
        // Handle altitude modification
        if (modification.setAltitudes.length > 0) {
            const firstEntryType = modification.setAltitudeTypes[0];
            if (firstEntryType === BoeingAltitudeEntryType.Step) ;
            else if (firstEntryType === BoeingAltitudeEntryType.At) {
                verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                verticalData.altDesc = AltitudeRestrictionType.At;
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Above) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Below
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrAbove;
                }
            }
            else if (firstEntryType === BoeingAltitudeEntryType.Below) {
                const secondEntryType = modification.setAltitudeTypes[1];
                // We know this must be Above
                if (secondEntryType) {
                    verticalData.altitude2 = UnitType.METER.convertFrom(modification.setAltitudes[1], UnitType.FOOT);
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.Between;
                }
                else {
                    verticalData.altitude1 = UnitType.METER.convertFrom(modification.setAltitudes[0], UnitType.FOOT);
                    verticalData.altDesc = AltitudeRestrictionType.AtOrBelow;
                }
            }
        }
    }
    /**
     * Renders vertical display data for copying into the scratchpad of an FMC
     *
     * @param data the vertical display data
     *
     * @returns a string
     */
    static renderDataForScratchpad(data) {
        let str = '';
        if (data.speed !== undefined) {
            if (typeof data.speed === 'string') {
                str += data.speed.toUpperCase();
            }
            else if (data.speedIsMach) {
                str += data.speed.toFixed(3).substring(1);
            }
            else {
                str += data.speed.toFixed(0);
            }
        }
        str += '/';
        if (data.altitudes.length > 0) {
            for (let i = 0; i < data.altitudes.length; i++) {
                const altitude = data.altitudes[i];
                const isFlightLevel = data.altitudesAreFlightLevels[i];
                if (isFlightLevel) {
                    str += `FL${(altitude / 100).toFixed(0)}`;
                }
                else {
                    str += altitude.toFixed(0);
                }
                const suffix = data.altitudeSuffixes[i];
                if (suffix !== ' ') {
                    str += suffix;
                }
            }
        }
        return str;
    }
}

const VNAV_ETA_CALCS_DEBOUNCE = 750;
var CurrentFmsSpeedMode;
(function (CurrentFmsSpeedMode) {
    CurrentFmsSpeedMode["ECON"] = "ECON";
    CurrentFmsSpeedMode["LIM_SPD"] = "LIM SPD";
    CurrentFmsSpeedMode["MCP_SPD"] = "MCP SPD";
    CurrentFmsSpeedMode["EO"] = "EO";
    CurrentFmsSpeedMode["CAS"] = "CAS";
    CurrentFmsSpeedMode["MACH"] = "MACH";
})(CurrentFmsSpeedMode || (CurrentFmsSpeedMode = {}));
/**
 * Data provider for various vnav related data for the FMS VNAV Pages.
 */
class BoeingFmsVNavDataProvider {
    /**
     * CTOR
     * @param bus The event bus
     * @param fms The BoeingFms
     * @param useSyncData Whether or not to use ETA and constraint data sync'd from the event bus.
     */
    constructor(bus, fms, useSyncData) {
        this.bus = bus;
        this.fms = fms;
        this.useSyncData = useSyncData;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.simTimeValue = ConsumerValue.create(this.bus.getSubscriber().on('simTime'), -1);
        this.lateralLegIndex = ConsumerSubject.create(null, -1);
        // private readonly nominalLegIndex = ConsumerSubject.create(this.bus.getSubscriber<BoeingLNavDataEvents>()
        //   .on('lnavdata_nominal_leg_index'), -1);
        // private readonly distRemainingInLeg = ConsumerSubject.create(this.bus.getSubscriber<LNavEvents>()
        //   .on('lnav_vector_distance_remaining'), -1);
        // private readonly groundSpeed = ConsumerSubject.create(this.bus.getSubscriber<GNSSEvents>()
        //   .on('ground_speed'), -1);
        this.fmsTargetType = ConsumerSubject.create(null, FmsSpeedTargetSource.None);
        this.fmsTargetIsMach = ConsumerSubject.create(null, false);
        this.mcpSpeedActive = ConsumerSubject.create(null, false);
        this._distanceDest = ConsumerSubject.create(null, -1);
        this._distanceToc = ConsumerSubject.create(null, -1);
        this._distanceTod = ConsumerSubject.create(null, -1);
        this._distanceBod = ConsumerSubject.create(null, -1);
        this._tocLegIndex = ConsumerSubject.create(null, -1);
        this._todLegIndex = ConsumerSubject.create(null, -1);
        this._eodLegIndex = ConsumerSubject.create(null, -1);
        this._distanceTodLeg = ConsumerSubject.create(null, -1);
        this.distanceDest = this._distanceDest;
        this.distanceToc = this._distanceToc;
        this.distanceTod = this._distanceTod;
        this.distanceBod = this._distanceBod;
        this.tocLegIndex = this._tocLegIndex;
        this.todLegIndex = this._todLegIndex;
        this.bodLegIndex = this._eodLegIndex;
        this.distanceTodLeg = this._distanceTodLeg;
        this.commandedFmsAlt = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.speedSub = this.bus.getSubscriber();
        this.commandedFmsSpeedIas = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_ias'), -1);
        this.commandedFmsSpeedMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_mach'), -1);
        this.commandedFmsSpeedIsMach = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_is_mach'), false);
        this.commandedFmsSpeedSource = ConsumerSubject.create(this.speedSub.on('fms_speed_computed_target_source'), FmsSpeedTargetSource.None);
        this._currentFmsClimbSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsClimbMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.ClimbSchedule:
                    if (fmsClimbMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedClimbMode, this.fmsTargetIsMach);
        this.currentFmsClimbSpeedMode = this._currentFmsClimbSpeedMode;
        this._currentFmsDescentSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsDescentMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.DescentSchedule:
                    if (fmsDescentMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                case FmsSpeedTargetSource.ToGa:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    return CurrentFmsSpeedMode.ECON;
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedDescentMode, this.fmsTargetIsMach);
        this.currentFmsDescentSpeedMode = this._currentFmsDescentSpeedMode;
        this._currentFmsCruiseSpeedMode = MappedSubject.create((([fmsSpeedTargetType, speedIsMcp, fmsCruiseMode, fmsTargetIsMach]) => {
            if (speedIsMcp) {
                return CurrentFmsSpeedMode.MCP_SPD;
            }
            switch (fmsSpeedTargetType) {
                case FmsSpeedTargetSource.Configuration:
                    return CurrentFmsSpeedMode.LIM_SPD;
                case FmsSpeedTargetSource.ToGa:
                case FmsSpeedTargetSource.Altitude:
                case FmsSpeedTargetSource.Constraint:
                    return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                default:
                    if (fmsCruiseMode === SpeedMode.SEL) {
                        return fmsTargetIsMach ? CurrentFmsSpeedMode.MACH : CurrentFmsSpeedMode.CAS;
                    }
                    else {
                        return CurrentFmsSpeedMode.ECON;
                    }
            }
        }), this.fmsTargetType, this.mcpSpeedActive, this.fms.activePerformancePlan.speedCruiseMode, this.fmsTargetIsMach);
        this.currentFmsCruiseSpeedMode = this._currentFmsCruiseSpeedMode;
        this._destinationPredictions = Subject.create(null);
        this.destinationPredictions = this._destinationPredictions;
        this._currentClimbConstraint = Subject.create(null);
        this.currentClimbConstraint = this._currentClimbConstraint;
        this._currentClimbConstraintLegDef = Subject.create(null);
        this.currentClimbConstraintLegDef = this._currentClimbConstraintLegDef;
        this._currentClimbConstraintDisplayData = Subject.create(null);
        this.currentClimbConstraintDisplayData = this._currentClimbConstraintDisplayData;
        this._currentDescentConstraint = Subject.create(null);
        this.currentDescentConstraint = this._currentDescentConstraint;
        this._currentDescentConstraintLegDef = Subject.create(null);
        this.currentDescentConstraintLegDef = this._currentDescentConstraintLegDef;
        this._currentDescentConstraintDisplayData = Subject.create(null);
        this.currentDescentConstraintDisplayData = this._currentDescentConstraintDisplayData;
        this.fmsOperatingPhaseEvents = this.bus.getSubscriber();
        this._fmsOperatingPhase = ConsumerSubject.create(this.fmsOperatingPhaseEvents.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.fmsOperatingPhase = this._fmsOperatingPhase;
        this.nextConstraintLegDef = MappedSubject.create(([climbConstraint, descentConstraint, phase]) => {
            return BoeingFmsVNavDataProvider.phasesBeforeCruise.includes(phase)
                ? climbConstraint
                : descentConstraint;
        }, this.currentClimbConstraintLegDef, this.currentDescentConstraintLegDef, this.fmsOperatingPhase);
        this._destAirportFacility = Subject.create(null);
        this.destAirportFacility = this._destAirportFacility;
        this.planChanged = false;
        this._tocEta = Subject.create(null);
        this._todEta = Subject.create(null);
        this._eodEta = Subject.create(null);
        this.tocEta = this._tocEta;
        this.todEta = this._todEta;
        this.eodEta = this._eodEta;
        this.etaTimer = new DebounceTimer();
        const fmsSpeedEventsEventSubscriber = bus.getSubscriber();
        this.fmsTargetType.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_computed_target_source'));
        this.fmsTargetIsMach.setConsumer(fmsSpeedEventsEventSubscriber.on('fms_speed_active_target_is_mach'));
        const vnavSub = bus.getSubscriber();
        this._distanceDest.setConsumer(vnavSub.on('lnavdata_destination_distance'));
        this._distanceToc.setConsumer(vnavSub.on('vnav_toc_distance'));
        this._distanceTod.setConsumer(vnavSub.on('vnav_tod_distance'));
        this._distanceBod.setConsumer(vnavSub.on('vnav_bod_distance'));
        this._tocLegIndex.setConsumer(vnavSub.on('vnav_toc_global_leg_index'));
        this._todLegIndex.setConsumer(vnavSub.on('vnav_tod_global_leg_index'));
        this._eodLegIndex.setConsumer(vnavSub.on('vnav_bod_global_leg_index'));
        this._distanceTodLeg.setConsumer(vnavSub.on('vnav_tod_leg_distance'));
        this.mcpSpeedActive.setConsumer(bus.getSubscriber().on('ap_selected_speed_is_manual'));
        this.lateralLegIndex.setConsumer(bus.getSubscriber().on('lnav_tracked_leg_index'));
        this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => {
            var _a;
            this._destinationPredictions.set((_a = this.fms.activeRoutePredictor.getDestinationPredictions()) !== null && _a !== void 0 ? _a : null);
            this._destinationPredictions.notify();
        });
        const fpSub = bus.getSubscriber();
        fpSub.on('fplLegChange').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplLoaded').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplCopied').handle(({ planIndex }) => {
            this.onPlanChanged(planIndex);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        fpSub.on('fplOriginDestChanged').handle(({ planIndex, type, airport }) => {
            if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                switch (type) {
                    case OriginDestChangeType.DestinationAdded:
                        airport && this._destAirportFacility.set(airport);
                        break;
                    case OriginDestChangeType.DestinationRemoved:
                        this._destAirportFacility.set(null);
                        break;
                }
            }
        });
        this.lateralLegIndex.sub(() => {
            if (!this.fms.hasPrimaryFlightPlan()) {
                return;
            }
            this.onPlanChanged(BoeingFms.ACT_RTE_PLAN_INDEX);
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, BoeingFms.ACT_RTE_PLAN_INDEX), VNAV_ETA_CALCS_DEBOUNCE);
        });
        MappedSubject.create(this.commandedFmsSpeedIas, this.commandedFmsSpeedMach, this.commandedFmsSpeedIsMach, this.commandedFmsSpeedSource, this.commandedFmsAlt).sub(() => {
            this.planChanged = true;
            this.setCurrentConstraint();
        });
        // Update the current constraints each time the path is recalculated, every three seconds
        vnavSub.on('vnav_path_calculated').handle((planIndex) => {
            this.setCurrentConstraint();
            this.etaTimer.schedule(this.calculateEtasForPlan.bind(this, planIndex), VNAV_ETA_CALCS_DEBOUNCE);
        });
        if (this.useSyncData) {
            this.bus.getSubscriber().on('boeing_vnav_data_constraints').handle(this.syncCurrentConstraint.bind(this));
            this.bus.getSubscriber().on('boeing_vnav_data_etas').handle(this.syncEtas.bind(this));
        }
        this.setCurrentConstraint();
        this.calculateEtasForPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Handler for flight plan changing
     *
     * @param planIndex the index of the flight plan
     */
    onPlanChanged(planIndex) {
        var _a;
        this.planChanged = true;
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            const plan = this.fms.getFlightPlan(planIndex);
            this._destAirportFacility.set((_a = plan.destinationAirport) !== null && _a !== void 0 ? _a : null);
        }
    }
    /**
     * Sets the current constraints shown by VNAV pages
     */
    setCurrentConstraint() {
        var _a, _b;
        if (this.useSyncData) {
            return;
        }
        // Only do the lookup if the flight plan has changed since the last lookup
        if (this.planChanged && this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getFlightPlan(this.fms.getPlanIndexForFmcPage());
            const verticalPlan = this.fms.verticalPathCalculator.getVerticalFlightPlan(this.fms.getPlanIndexForFmcPage());
            const climbConstraint = VNavUtils.getCurrentClimbConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentClimbConstraint.set(climbConstraint ? climbConstraint : null);
            this._currentClimbConstraintLegDef.set(climbConstraint ? lateralPlan.tryGetLeg(climbConstraint.index) : null);
            this._currentClimbConstraintDisplayData.set(climbConstraint ? this.getVerticalDisplayData(climbConstraint.index) : null);
            const descentConstraint = VNavUtils.getNextDescentTargetConstraint(verticalPlan, this.lateralLegIndex.get());
            this._currentDescentConstraint.set(descentConstraint ? descentConstraint : null);
            this._currentDescentConstraintLegDef.set(descentConstraint ? lateralPlan.tryGetLeg(descentConstraint.index) : null);
            this._currentDescentConstraintDisplayData.set(descentConstraint ? this.getVerticalDisplayData(descentConstraint.index) : null);
            this.planChanged = false;
            this.bus.getPublisher().pub('boeing_vnav_data_constraints', {
                currentClimbConstraint: this._currentClimbConstraint.get(),
                currentClimbConstraintLegDef: (_a = climbConstraint === null || climbConstraint === void 0 ? void 0 : climbConstraint.index) !== null && _a !== void 0 ? _a : null,
                currentClimbConstraintDisplayData: this._currentClimbConstraintDisplayData.get(),
                currentDescentConstraint: this._currentDescentConstraint.get(),
                currentDescentConstraintLegDef: (_b = descentConstraint === null || descentConstraint === void 0 ? void 0 : descentConstraint.index) !== null && _b !== void 0 ? _b : null,
                currentDescentConstraintDisplayData: this._currentClimbConstraintDisplayData.get()
            }, true);
        }
    }
    /**
     * Handles sync'ing constraints from the bus.
     * @param data The constraint data to sync.
     */
    syncCurrentConstraint(data) {
        if (this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getFlightPlan(this.fms.getPlanIndexForFmcPage());
            this._currentClimbConstraint.set(data.currentClimbConstraint);
            this._currentClimbConstraintDisplayData.set(data.currentClimbConstraintDisplayData);
            if (data.currentClimbConstraintLegDef !== null) {
                this._currentClimbConstraintLegDef.set(lateralPlan.tryGetLeg(data.currentClimbConstraintLegDef));
            }
            else {
                this._currentClimbConstraintLegDef.set(null);
            }
            this._currentDescentConstraint.set(data.currentDescentConstraint);
            this._currentDescentConstraintDisplayData.set(data.currentDescentConstraintDisplayData);
            if (data.currentDescentConstraintLegDef !== null) {
                this._currentDescentConstraintLegDef.set(lateralPlan.tryGetLeg(data.currentDescentConstraintLegDef));
            }
            else {
                this._currentDescentConstraintLegDef.set(null);
            }
        }
    }
    /**
     * Handles sync'ing ETAs from the bus.
     * @param data The ETA data to sync.
     */
    syncEtas(data) {
        this._tocEta.set(data.toc);
        this._todEta.set(data.tod);
        this._eodEta.set(data.eod);
    }
    /**
     * Calculates display data for a constraint.
     * @param globalLegIndex The global leg index of the VNAV constraint.
     * @returns An object used for rendering constraint data.
     */
    getVerticalDisplayData(globalLegIndex) {
        const legDefinition = this.fms.getPlanForFmcRender().tryGetLeg(globalLegIndex);
        const predictions = this.fms.activeRoutePredictor.getPredictionsForLeg(globalLegIndex);
        if (legDefinition) {
            const fmsCommandedSpeedValue = this.commandedFmsSpeedIsMach.get() ?
                this.commandedFmsSpeedMach.get() : this.commandedFmsSpeedIas.get();
            return BoeingVerticalIOUtils.getDisplayDataForLeg(legDefinition, predictions, this.fms.activePerformancePlan.transitionAltitude.get(), this.fms.activePerformancePlan.transitionLevel.get(), this.commandedFmsAlt.get(), fmsCommandedSpeedValue, this.commandedFmsSpeedIsMach.get(), this.commandedFmsSpeedSource.get());
        }
        else {
            return null;
        }
    }
    /**
     * Calculates leg and T/D ETAs for a plan at a given index
     *
     * @param planIndex the index of the flight plan
     */
    calculateEtasForPlan(planIndex) {
        if (this.useSyncData) {
            return;
        }
        if (!this.fms.hasFlightPlan(planIndex)) {
            return;
        }
        const lateralPlan = this.fms.getFlightPlan(planIndex);
        const verticalPath = this.fms.verticalPathCalculator.getVerticalFlightPath(this.fms.getPlanIndexForFmcPage());
        const tocLegIndex = this.tocLegIndex.get();
        const todLegIndex = this.todLegIndex.get();
        const eodLegIndex = this.bodLegIndex.get();
        if (tocLegIndex === -1) {
            this._tocEta.set(null);
        }
        if (todLegIndex === -1) {
            this._todEta.set(null);
        }
        if (eodLegIndex === -1) {
            this._eodEta.set(null);
        }
        let timestampAccumulator = this.simTimeValue.get();
        const unixDayStartMs = this.simTimeValue.get() - (this.simTimeValue.get() % (1000 * 60 * 60 * 24));
        for (let i = 0; i < lateralPlan.length; i++) {
            const leg = lateralPlan.tryGetLeg(i);
            if (leg) {
                const matchingVerticalLeg = verticalPath.legs[i];
                if (matchingVerticalLeg) {
                    let verticalLegDurationMs;
                    if (matchingVerticalLeg.vectors.length > 0) {
                        verticalLegDurationMs = matchingVerticalLeg.simDuration * 1000;
                    }
                    else {
                        const previousLeg = lateralPlan.tryGetLeg(i - 1);
                        const nextLeg = lateralPlan.tryGetLeg(i + 1);
                        const nextLegMatchingVerticalLeg = verticalPath.legs[i + 1];
                        // This is a special case for handling a situation where an IF leg is not predicted due to it following a discontinuity.
                        // We need to calculate this so that the T/D ETA can be roughly figured out (it is displayed on the VNAV CRZ page)
                        // Once BoeingVerticalPathCalculator handles predicting through discontinuities, we can remove this.
                        // FIXME remove this once the above is done
                        if (previousLeg && nextLeg && nextLegMatchingVerticalLeg && nextLegMatchingVerticalLeg.vectors.length > 0) {
                            const legEndPointExists = BoeingFmsUtils.writeLegCalculatedEndPoint(leg, this.geoPointCache[0]);
                            if (leg.leg.type === LegType.IF && legEndPointExists && BoeingFmsUtils.isDiscontinuityLeg(previousLeg.leg.type)) {
                                const legBeforeDiscontinuity = lateralPlan.tryGetLeg(i - 2);
                                const legBeforeDiscontinuityEndPointExists = legBeforeDiscontinuity && BoeingFmsUtils.writeLegCalculatedEndPoint(legBeforeDiscontinuity, this.geoPointCache[1]);
                                if (legBeforeDiscontinuityEndPointExists) {
                                    const distanceInDiscontinuity = this.geoPointCache[0].distance(this.geoPointCache[1]);
                                    const distanceInDiscontinuityNm = UnitType.NMILE.convertFrom(distanceInDiscontinuity, UnitType.GA_RADIAN);
                                    const nextLegStartAltitude = nextLegMatchingVerticalLeg.vectors[0].startAltitude;
                                    const nextLegStartPressure = AeroMath.isaPressure(nextLegStartAltitude);
                                    const nextLegSimulatedStartCas = nextLegMatchingVerticalLeg.vectors[0].startCas;
                                    const nextLegSimulatedStartTas = AeroMath.casToTas(nextLegSimulatedStartCas, nextLegStartPressure, AeroMath.isaTemperature(nextLegStartAltitude));
                                    // FIXME when we have wind/temp plan, we can use the right pressure + find ground speed
                                    const timeInDiscontinuitySeconds = (distanceInDiscontinuityNm / nextLegSimulatedStartTas) * 3600;
                                    verticalLegDurationMs = timeInDiscontinuitySeconds * 1000;
                                }
                            }
                        }
                    }
                    // Accumulate time
                    if (verticalLegDurationMs !== undefined) {
                        if (i === lateralPlan.activeLateralLeg) {
                            const activeLegPredictions = this.fms.activeRoutePredictor.getPredictionsForLeg(i);
                            if (activeLegPredictions) {
                                timestampAccumulator = activeLegPredictions.estimatedTimeOfArrival * 1000;
                            }
                        }
                        else if (i > lateralPlan.activeLateralLeg) {
                            timestampAccumulator += verticalLegDurationMs;
                        }
                    }
                    // Process TOC if on this leg
                    if (i === tocLegIndex && verticalLegDurationMs !== undefined) {
                        const tocLegDistance = this.distanceTodLeg.get();
                        let tocVector;
                        let durationToEndOfTocVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTocVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < tocLegDistance) {
                                tocVector = vector;
                                break;
                            }
                        }
                        if (tocVector) {
                            this._tocEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTocVectorMs);
                        }
                        else {
                            this._tocEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process TOD if on this leg
                    if (i === todLegIndex && verticalLegDurationMs !== undefined) {
                        const todLegDistance = this.distanceTodLeg.get();
                        let todVector;
                        let durationToEndOfTodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfTodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < todLegDistance) {
                                todVector = vector;
                                break;
                            }
                        }
                        if (todVector) {
                            this._todEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfTodVectorMs);
                        }
                        else {
                            this._todEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                    // Process EOD if on this leg
                    if (i === eodLegIndex && verticalLegDurationMs !== undefined) {
                        const eodLegDistance = this.distanceTodLeg.get();
                        let eodVector;
                        let durationToEndOfEodVectorMs = 0;
                        for (let j = 0; j < matchingVerticalLeg.vectors.length; j++) {
                            const vector = matchingVerticalLeg.vectors[j];
                            durationToEndOfEodVectorMs += vector.duration * 1000;
                            if (vector.endDistanceToLegEnd < eodLegDistance) {
                                eodVector = vector;
                                break;
                            }
                        }
                        if (eodVector) {
                            this._eodEta.set((timestampAccumulator - verticalLegDurationMs - unixDayStartMs) + durationToEndOfEodVectorMs);
                        }
                        else {
                            this._eodEta.set(timestampAccumulator - unixDayStartMs);
                        }
                    }
                }
            }
        }
        this.bus.getPublisher().pub('boeing_vnav_data_etas', {
            toc: this._tocEta.get(),
            tod: this._todEta.get(),
            eod: this._eodEta.get()
        }, true);
    }
}
BoeingFmsVNavDataProvider.phasesBeforeCruise = [
    FmsOperatingPhase.PREFLIGHT,
    FmsOperatingPhase.TAKEOFF,
    FmsOperatingPhase.CLIMB,
];

/**
 * Store for flight phase computations
 */
class FmsOperatingPhaseStore {
    /**
     * Ctor
     * @param bus the event bus
     * @param fms the fms
     */
    constructor(bus, fms) {
        this.bus = bus;
        this.fms = fms;
        this.subs = this.bus.getSubscriber();
        // private apFmaData = ConsumerSubject.create<BoeingFmaData>(this.subs.on('fma_data'),
        //   {
        //     verticalActive: 0,
        //     verticalArmed: 0,
        //     lateralActive: 0,
        //     lateralArmed: 0,
        //     lateralDegraded:
        //       false,
        //     autothrottleDegraded: false,
        //     autothrottleActive: AutothrottleTargetMode.None,
        //     verticalDegraded: false
        //   })
        this.togaSelected = Subject.create(false);
        this.airborne = ConsumerSubject.create(this.subs.on('on_ground'), true).map((onGround) => !onGround);
        this.indicatedAltitude = ConsumerSubject.create(this.subs.on('indicated_alt'), 0);
        /** The indicated altitude in feet the last time the plane was on the ground or 0 if never */
        this.lastGroundAltitude = MappedSubject.create(([airborne, indicatedAltitude], previous) => airborne ? (previous !== null && previous !== void 0 ? previous : 0) : indicatedAltitude, this.airborne, this.indicatedAltitude);
        this.cruisingAltitude = this.fms.activePerformancePlan.cruiseAltitude;
        this.activeLegIndex = ConsumerSubject.create(this.subs.on('lnav_tracked_leg_index'), -1);
        this.reachedCruiseAlt = MappedSubject.create(this.indicatedAltitude, this.cruisingAltitude).map(([indicatedAlt, cruiseAlt]) => {
            if (!cruiseAlt) {
                return false;
            }
            return Math.abs(cruiseAlt - indicatedAlt) < 100;
        });
        this.descentInitiated = Subject.create(false);
        this.approachLegActive = Subject.create(false);
        this.runwayLegActive = Subject.create(false);
        // TODO
        this.dtg = ConsumerSubject.create(this.subs.on('lnavdata_destination_distance'), -1);
        // TODO
        this.flapsLeft = ConsumerSubject.create(this.subs.on('flaps_left_angle'), 0);
        this.flapsRight = ConsumerSubject.create(this.subs.on('flaps_right_angle'), 0);
        this.flaps = MappedSubject.create(this.flapsLeft, this.flapsRight).map(([left, right]) => Math.max(left, right));
        this.engine1Combustion = ConsumerSubject.create(this.subs.on('eng_combustion_1').atFrequency(2), false);
        this.engine2Combustion = ConsumerSubject.create(this.subs.on('eng_combustion_2').atFrequency(2), false);
        this.anyEngineCombustion = MappedSubject.create(this.engine1Combustion, this.engine2Combustion).map(([eng1, eng2]) => eng1 || eng2);
        this.enginesShutdown30SecondsAgo = false;
        this.vnavTrackingPhase = ConsumerSubject.create(this.subs.on('vnav_boeing_vnav_tracking_phase'), BoeingVNavTrackingPhase.None);
        // TODO
        this.dataCleared = Subject.create(false);
        this.subs.on('fma_data').handle(data => {
            this.togaSelected.set(data.verticalActive === APVerticalModes.TO || data.verticalActive === APVerticalModes.GA);
        });
    }
}

/**
 * Determines the current FMS Operating Phase
 */
class FmsOperatingPhaseController {
    /**
     * Ctor
     * @param bus the event bus
     * @param fms the fms
     */
    constructor(bus, fms) {
        this.bus = bus;
        this.fms = fms;
        this.store = new FmsOperatingPhaseStore(this.bus, this.fms);
        this.engineShutdownTimer = new DebounceTimer();
        this.currentPhase = Subject.create(FmsOperatingPhase.PREFLIGHT);
        //Sub to the operating phase LVAR so that when it is set externally via FLT files, that change is reflected in the Controller.
        this.bus.getSubscriber().on('fms_operating_phase').whenChanged().handle(v => this.currentPhase.set(v));
        //Publish the current phase back to the LVAR on change.
        this.currentPhase.sub((phase) => SimVar.SetSimVarValue(FmsOperatingPhaseDataVars.FmsOperatingPhaseVar, SimVarValueType.Enum, phase), true);
    }
    /**
     * Update callback
     */
    update() {
        this.updateInputState();
        this.currentPhase.set(this.nextPhase());
    }
    /**
     * Updates the input state
     */
    updateInputState() {
        var _a, _b;
        const enginesShutdown = !this.store.anyEngineCombustion.get();
        if (enginesShutdown && !this.engineShutdownTimer.isPending()) {
            this.engineShutdownTimer.schedule(() => this.store.enginesShutdown30SecondsAgo = true, 30000);
        }
        else if (!enginesShutdown) {
            this.engineShutdownTimer.clear();
            this.store.enginesShutdown30SecondsAgo = false;
        }
        const phase = this.currentPhase.get();
        switch (phase) {
            case FmsOperatingPhase.CLIMB:
            case FmsOperatingPhase.CRUISE: {
                if (this.store.vnavTrackingPhase.get() === BoeingVNavTrackingPhase.Descent) {
                    this.store.descentInitiated.set(true);
                }
                break;
            }
            case FmsOperatingPhase.DESCENT: {
                const activeLegIndex = this.store.activeLegIndex.get();
                if (activeLegIndex !== -1 && this.fms.hasPrimaryFlightPlan()) {
                    const plan = this.fms.getPrimaryFlightPlan();
                    const leg = plan.tryGetLeg(activeLegIndex);
                    if (leg) {
                        const segment = plan.getSegmentFromLeg(leg);
                        this.store.approachLegActive.set(((_a = (segment === null || segment === void 0 ? void 0 : segment.segmentType) === FlightPlanSegmentType.Approach) !== null && _a !== void 0 ? _a : false)
                            && (plan.activeLateralLeg - ((_b = segment === null || segment === void 0 ? void 0 : segment.offset) !== null && _b !== void 0 ? _b : Infinity) > 0));
                        this.store.runwayLegActive.set(BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.FAF));
                    }
                }
                break;
            }
            case FmsOperatingPhase.COMPLETE: {
                this.store.descentInitiated.set(false);
                this.store.approachLegActive.set(false);
                this.store.runwayLegActive.set(false);
                // FIXME check that all FMS data is cleared?
                this.store.dataCleared.set(true);
                break;
            }
        }
    }
    /**
     * Returns the phase to be switched to. If the phase does not need to change, the current phase is returned.
     *
     * @returns a flight phase
     */
    nextPhase() {
        switch (this.currentPhase.get()) {
            case FmsOperatingPhase.PREFLIGHT:
                if (this.store.togaSelected.get()) {
                    return FmsOperatingPhase.TAKEOFF;
                }
                if (this.store.airborne.get()) {
                    return FmsOperatingPhase.CLIMB;
                }
                break;
            case FmsOperatingPhase.TAKEOFF:
                {
                    const flaps = this.store.flaps.get();
                    const altitude = this.store.indicatedAltitude.get();
                    const thrRedSetting = this.fms.activePerformancePlan.takeoffThrustReductionPoint.get();
                    const originRunway = this.fms.hasPrimaryFlightPlan() ? this.fms.getPrimaryFlightPlan().procedureDetails.originRunway : undefined;
                    const fieldElevation = originRunway ? UnitType.FOOT.convertFrom(originRunway.elevation, UnitType.METER) : this.store.lastGroundAltitude.get();
                    const thrRedMsl = fieldElevation + thrRedSetting;
                    if (this.store.airborne.get() && thrRedSetting !== null && ((thrRedSetting < 100 && flaps <= thrRedSetting) || (thrRedSetting >= 100 && altitude >= thrRedMsl))) {
                        return FmsOperatingPhase.CLIMB;
                    }
                }
                break;
            case FmsOperatingPhase.CLIMB:
                if (this.store.reachedCruiseAlt.get()) {
                    return FmsOperatingPhase.CRUISE;
                }
                if (this.store.descentInitiated.get()) {
                    return FmsOperatingPhase.DESCENT;
                }
                break;
            case FmsOperatingPhase.CRUISE:
                if (this.store.descentInitiated.get()) {
                    return FmsOperatingPhase.DESCENT;
                }
                break;
            case FmsOperatingPhase.DESCENT:
                if (this.store.approachLegActive.get() || (this.store.runwayLegActive.get() && this.store.dtg.get() < 25) || this.store.flaps.get() !== 0) {
                    return FmsOperatingPhase.APPROACH;
                }
                break;
            case FmsOperatingPhase.APPROACH:
                if (this.store.enginesShutdown30SecondsAgo) {
                    return FmsOperatingPhase.COMPLETE;
                }
                break;
            case FmsOperatingPhase.COMPLETE:
                if (this.store.dataCleared.get()) {
                    this.store.dataCleared.set(false);
                    return FmsOperatingPhase.PREFLIGHT;
                }
                break;
        }
        return this.currentPhase.get();
    }
}

var SpeedStateMachineEvents;
(function (SpeedStateMachineEvents) {
    SpeedStateMachineEvents[SpeedStateMachineEvents["IasMachWindSpeedChanged"] = 0] = "IasMachWindSpeedChanged";
    SpeedStateMachineEvents[SpeedStateMachineEvents["ApStatusChanged"] = 1] = "ApStatusChanged";
    SpeedStateMachineEvents[SpeedStateMachineEvents["TogaPressed"] = 2] = "TogaPressed";
    SpeedStateMachineEvents[SpeedStateMachineEvents["Rotation"] = 3] = "Rotation";
    SpeedStateMachineEvents[SpeedStateMachineEvents["FlightPhaseChanged"] = 4] = "FlightPhaseChanged";
    SpeedStateMachineEvents[SpeedStateMachineEvents["AltitudeCapture"] = 5] = "AltitudeCapture";
})(SpeedStateMachineEvents || (SpeedStateMachineEvents = {}));
var SpeedStateMachineState;
(function (SpeedStateMachineState) {
    SpeedStateMachineState[SpeedStateMachineState["Takeoff"] = 0] = "Takeoff";
    SpeedStateMachineState[SpeedStateMachineState["Climb"] = 1] = "Climb";
    SpeedStateMachineState[SpeedStateMachineState["Cruise"] = 2] = "Cruise";
    SpeedStateMachineState[SpeedStateMachineState["Descent"] = 3] = "Descent";
    SpeedStateMachineState[SpeedStateMachineState["Approach"] = 4] = "Approach";
    SpeedStateMachineState[SpeedStateMachineState["GoAround"] = 5] = "GoAround";
})(SpeedStateMachineState || (SpeedStateMachineState = {}));
/** Takeoff state; from preflight, up to acceleration height (or alt capture below accel height) */
class SpeedStateMachineTakeoff {
    /**
     * constructs the takeoff state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
        this.accelerationAltitude = -1;
        this.eoAccelerationAltitude = -1;
        this.rotationSpeed = -1;
        this.overrideSpeed = -1;
        this.speedAboveTargetTimer = new DebounceTimer();
    }
    /** @inheritdoc */
    onEnter() {
        this.rotationSpeed = -1;
        this.overrideSpeed = -1;
    }
    /** @inheritdoc */
    onLeave() {
        this.speedAboveTargetTimer.clear();
    }
    /** @inheritdoc */
    update() {
        // if we're above the speed target for 5 seconds, it increases to current speed (within limits applied in targetCas)
        const aboveTarget = this.targetCas() > 0 && this.speedManager.getCurrentCas() > (this.targetCas() + 1);
        if (aboveTarget && !this.speedAboveTargetTimer.isPending()) {
            this.speedAboveTargetTimer.schedule(() => this.overrideSpeed = this.speedManager.getCurrentCas(), 5000);
        }
        else if (!aboveTarget && this.speedAboveTargetTimer.isPending()) {
            this.speedAboveTargetTimer.clear();
        }
        // check if we're above the acceleration altitude
        if (this.speedManager.isAnEngineOut()) {
            if (this.speedManager.getIndicatedAltitude() > this.speedManager.getEngineOutAccelerationAltitude()) {
                return SpeedStateMachineState.Climb;
            }
        }
        else if (this.speedManager.getIndicatedAltitude() > this.speedManager.getAccelerationAltitude()) {
            return SpeedStateMachineState.Climb;
        }
        return SpeedStateMachineState.Takeoff;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            case SpeedStateMachineEvents.Rotation:
                this.rotationSpeed = this.speedManager.getCurrentCas();
                break;
            case SpeedStateMachineEvents.AltitudeCapture:
                return SpeedStateMachineState.Climb;
            case SpeedStateMachineEvents.FlightPhaseChanged:
                {
                    switch (this.speedManager.getFlightPhase()) {
                        case FmsOperatingPhase.CRUISE:
                            return SpeedStateMachineState.Cruise;
                        case FmsOperatingPhase.DESCENT:
                            return SpeedStateMachineState.Descent;
                        case FmsOperatingPhase.APPROACH:
                            return SpeedStateMachineState.Approach;
                    }
                }
                break;
        }
        return SpeedStateMachineState.Takeoff;
    }
    /** @inheritdoc */
    targetCas() {
        // The AFDS uses the IAS/MACH window reference as V2... it doesn't care about the FMS V2
        const v2 = this.speedManager.getIasMachWindowSpeed();
        if (this.rotationSpeed <= 0) {
            return v2;
        }
        if (this.speedManager.isAnEngineOut()) {
            // in engine out scenario the target is v2 if below v2, current speed if between v2 and v2 + 15, and v2 + 15 otherwise
            return MathUtils.clamp(this.speedManager.getCurrentCas(), v2, v2 + 15);
        }
        return MathUtils.clamp(Math.max(this.rotationSpeed + 15, this.overrideSpeed), v2 + 15, v2 + 25);
    }
    /** @inheritdoc */
    targetMach() {
        return -1;
    }
    /** @inheritdoc */
    destroy() {
        this.speedAboveTargetTimer.clear();
    }
}
/** Climb state; from acceleration height up to cruise altitude */
class SpeedStateMachineClimb {
    /**
     * constructs the climb state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            case SpeedStateMachineEvents.FlightPhaseChanged:
                {
                    switch (this.speedManager.getFlightPhase()) {
                        case FmsOperatingPhase.CRUISE:
                            return SpeedStateMachineState.Cruise;
                        case FmsOperatingPhase.DESCENT:
                            return SpeedStateMachineState.Descent;
                        case FmsOperatingPhase.APPROACH:
                            return SpeedStateMachineState.Approach;
                        case FmsOperatingPhase.COMPLETE:
                            return SpeedStateMachineState.Takeoff;
                    }
                }
                break;
        }
        return SpeedStateMachineState.Climb;
    }
    /** @inheritdoc */
    targetCas() {
        // FmsSpeedManager takes care of limit speeds, so we just need to return the VNAV profile speed
        return this.speedManager.getEconClimbSpeed();
    }
    /** @inheritdoc */
    targetMach() {
        return this.speedManager.getEconClimbMach();
    }
}
/** Cruise state; from ToC to ToD */
class SpeedStateMachineCruise {
    /**
     * constructs the cruise state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            // TODO what about step climbs?
            case SpeedStateMachineEvents.FlightPhaseChanged:
                {
                    switch (this.speedManager.getFlightPhase()) {
                        case FmsOperatingPhase.CLIMB:
                            return SpeedStateMachineState.Climb;
                        case FmsOperatingPhase.DESCENT:
                            return SpeedStateMachineState.Descent;
                        case FmsOperatingPhase.APPROACH:
                            return SpeedStateMachineState.Approach;
                        case FmsOperatingPhase.COMPLETE:
                            return SpeedStateMachineState.Takeoff;
                    }
                }
                break;
        }
        return SpeedStateMachineState.Cruise;
    }
    /** @inheritdoc */
    targetCas() {
        // FmsSpeedManager takes care of limit speeds, so we just need to return the VNAV profile speed
        return this.speedManager.getEconCruiseSpeed();
    }
    /** @inheritdoc */
    targetMach() {
        return this.speedManager.getEconCruiseMach();
    }
}
/** Descent state; from ToD to end of descent/start of approach phase */
class SpeedStateMachineDescent {
    /**
     * constructs the descent state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            case SpeedStateMachineEvents.FlightPhaseChanged:
                {
                    switch (this.speedManager.getFlightPhase()) {
                        case FmsOperatingPhase.CLIMB:
                            return SpeedStateMachineState.Climb;
                        case FmsOperatingPhase.CRUISE:
                            return SpeedStateMachineState.Cruise;
                        case FmsOperatingPhase.APPROACH:
                            return SpeedStateMachineState.Approach;
                        case FmsOperatingPhase.COMPLETE:
                            return SpeedStateMachineState.Takeoff;
                    }
                }
                break;
        }
        return SpeedStateMachineState.Descent;
    }
    /** @inheritdoc */
    targetCas() {
        // FmsSpeedManager takes care of limit speeds, so we just need to return the VNAV profile speed
        return this.speedManager.getEconDescentSpeed();
    }
    /** @inheritdoc */
    targetMach() {
        return this.speedManager.getEconDescentMach();
    }
}
/** Approach state; from start of approach until end of flight, or go around */
class SpeedStateMachineApproach {
    /**
     * constructs the approach state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            case SpeedStateMachineEvents.FlightPhaseChanged:
                {
                    switch (this.speedManager.getFlightPhase()) {
                        case FmsOperatingPhase.CLIMB:
                            return SpeedStateMachineState.Climb;
                        case FmsOperatingPhase.CRUISE:
                            return SpeedStateMachineState.Cruise;
                        case FmsOperatingPhase.DESCENT:
                            return SpeedStateMachineState.Descent;
                        case FmsOperatingPhase.COMPLETE:
                            return SpeedStateMachineState.Takeoff;
                    }
                }
                break;
            case SpeedStateMachineEvents.TogaPressed:
                return SpeedStateMachineState.GoAround;
        }
        return SpeedStateMachineState.Approach;
    }
    /** @inheritdoc */
    targetCas() {
        return this.speedManager.getApproachSpeed();
    }
    /** @inheritdoc */
    targetMach() {
        return -1;
    }
}
/** Go-around state; after toga pressed during approach, until end of flight or certain AP mode changes */
class SpeedStateMachineGoAround {
    /**
     * constructs the go-around state
     * @param bus Event bus to listen
     * @param speedManager Parent speed manager instance
     */
    constructor(bus, speedManager) {
        this.bus = bus;
        this.speedManager = speedManager;
        this.isActive = false;
        this.iasMachWindowSpeed = -1;
        this.levelOffSpeed = 250;
        this.overrideSpeed = -1;
        this.useLevelOffSpeed = false;
        this.speedAboveTargetTimer = new DebounceTimer();
        this.radioHeight = ConsumerValue.create(null, 0).pause();
    }
    /** @inheritdoc */
    init() {
        this.radioHeight.setConsumer(this.bus.getSubscriber().on('radio_alt').atFrequency(1));
    }
    /** @inheritdoc */
    onEnter() {
        this.radioHeight.resume();
        this.overrideSpeed = -1;
        this.levelOffSpeed = 250;
        this.useLevelOffSpeed = false;
        this.isActive = true;
    }
    /** @inheritdoc */
    onLeave() {
        this.radioHeight.pause();
        this.speedAboveTargetTimer.clear();
        this.isActive = false;
    }
    /** @inheritdoc */
    update() {
        const aboveTarget = this.speedManager.getCurrentCas() > (this.targetCas() + 1);
        if (aboveTarget && !this.speedAboveTargetTimer.isPending()) {
            this.speedAboveTargetTimer.schedule(() => this.overrideSpeed = this.speedManager.getCurrentCas(), 5000);
        }
        else if (!aboveTarget && this.speedAboveTargetTimer.isPending()) {
            this.speedAboveTargetTimer.clear();
        }
        return SpeedStateMachineState.Takeoff;
    }
    /** @inheritdoc */
    onEvent(event) {
        switch (event) {
            case SpeedStateMachineEvents.IasMachWindSpeedChanged:
                this.iasMachWindowSpeed = this.speedManager.getIasMachWindowSpeed();
                if (this.isActive) {
                    this.levelOffSpeed = this.iasMachWindowSpeed;
                }
                break;
            case SpeedStateMachineEvents.AltitudeCapture:
                this.useLevelOffSpeed = true;
                return SpeedStateMachineState.GoAround;
            case SpeedStateMachineEvents.ApStatusChanged:
                {
                    const lateralMode = this.speedManager.getApLateralMode();
                    const verticalMode = this.speedManager.getApVerticalMode();
                    if (this.radioHeight.get() < 400) {
                        if (!this.speedManager.isApOrFdEngaged() || lateralMode === APLateralModes.GPSS) {
                            return SpeedStateMachineState.Climb;
                        }
                    }
                    else if (lateralMode !== APLateralModes.GA || verticalMode !== APVerticalModes.GA) {
                        return SpeedStateMachineState.Climb;
                    }
                }
                break;
        }
        return SpeedStateMachineState.GoAround;
    }
    /** @inheritdoc */
    targetCas() {
        if (this.useLevelOffSpeed) {
            return this.levelOffSpeed;
        }
        if (this.iasMachWindowSpeed < 0) {
            return -1;
        }
        return MathUtils.clamp(this.overrideSpeed, this.iasMachWindowSpeed, this.iasMachWindowSpeed + 25);
    }
    /** @inheritdoc */
    targetMach() {
        return -1;
    }
    /** @inheritdoc */
    destroy() {
        this.radioHeight.destroy();
        this.speedAboveTargetTimer.clear();
    }
}

/* eslint-disable jsdoc/require-jsdoc */
/**
 * TODO: This needs to have the aircraft specific performance values split out from the static constants and methods.
 * Boeing Performance Math Utility Class.
 */
class BoeingAeroMath {
    // TODO: Clean up these various delta/pressure ratio methods....
    /**
     * Calculates the current dynamic pressure ratio.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg.
     * @param mach The current aircraft mach number.
     * @returns the current dynamic pressure ratio.
     */
    static calcDynamicPressureRatio(ambientPressure, mach) {
        return 1481.4 * Math.pow(mach, 2) * BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure);
    }
    /**
     * Calculate atmospheric pressure ratio from pressure altitude
     * @todo belongs somewhere else
     * @param zp Pressure altitude in feet
     * @param tropopause Tropopause altitude in feet
     * @returns Atmospheric pressure ratio (delta)
     */
    static deltaFromPressureAlt(zp, tropopause = 36089.24) {
        return zp < tropopause ? ((288.15 - 0.0019812 * zp) / 288.15) ** 5.25588 : 0.22336 * Math.E ** ((36089.24 - zp) / 20805.7);
    }
    /**
     * Calculate the Delta Pressure Ratio for a given altitude above sea level.
     * @param altitude The altitude, in Ft.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAltitude(altitude) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
        return isa[1] * 100 / BoeingAeroMath.slIsaPres;
    }
    /**
     * Calculate the Delta Pressure Ratio for a given ambient pressure.
     * @param ambientPressure The ambient pressure, in inHg.
     * @returns The Delta Pressure Ratio.
     */
    static calcDeltaPressureRatioFromAmbientPressure(ambientPressure) {
        return ambientPressure / 29.92;
    }
    /**
     * Calculate the Delta Total Pressure Ratio for a given Delta Pressure Ratio and Mach.
     * @param deltaPressureRatio The Delta Pressure Ratio.
     * @param mach The Mach.
     * @returns The Delta Total Pressure Ratio.
     */
    static calcDeltaTotalPressureRatio(deltaPressureRatio, mach) {
        return deltaPressureRatio * Math.pow(1 + 0.2 * (Math.pow(mach, 2)), 3.5);
    }
    /**
     * Calculates a thrust correction factor. Multiplying the correction factor by uncorrected thrust yields corrected
     * thrust.
     * @param mach The mach number.
     * @param ambientPressure The ambient pressure in inHg.
     * @returns The thrust correction factor for the specified parameters.
     */
    static calculateThrustCorrectionFactor(mach, ambientPressure) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        return 1 / (deltaPressureRatio * totalInletPressureMachRise);
    }
    /**
     * Gets the ISA Standard Temp and Press from Altitude.
     * @param altitude The altitude in feet.
     * @param isaPresDeviation Optional Pressure Deviation, in inHg.
     * @param isaTempDeviation Optional Temperature Deviation, in C.
     * @returns an array of [temp K, pressure HPA]
     */
    static calcIsaFromAltitude(altitude, isaPresDeviation, isaTempDeviation) {
        if (isaPresDeviation !== undefined) {
            altitude = BoeingAeroMath.calcPressureAltitude(altitude, 29.92 + isaPresDeviation);
        }
        let temp = 0.0;
        let pressure = 0.0;
        if (altitude <= 36089) {
            // 36089 is the altitude of the top of the troposphere
            temp = BoeingAeroMath.slIsaTemp + (-BoeingAeroMath.lapseFt * altitude);
            pressure = BoeingAeroMath.slIsaPres * Math.pow((BoeingAeroMath.slIsaTemp / temp), (0.034163203 / -0.0065));
        }
        else if (altitude <= 65616) {
            // 65616 is the altitude of the tropopause
            // 22335.6 is the pressure at the base of the tropopause in PA
            // const tropoPres = 22335.6;
            // tropoTemp = 216.65;
            temp = 216.65;
            pressure = 0.223356 * 101325 * Math.exp(-0.000157688 * (altitude - 36089));
        }
        else {
            temp = NaN;
            pressure = NaN;
        }
        return [temp + (isaTempDeviation !== null && isaTempDeviation !== void 0 ? isaTempDeviation : 0), pressure / 100];
    }
    /**
     * Calculate the speed of sound from temperature.
     * @param ambientTemperature The ambient temperature, in C.
     * @returns The speed of sound in ft/s.
     */
    static calcSpeedOfSoundFromTemp(ambientTemperature) {
        return Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE));
    }
    /**
     * Calculate the pressure altitude from Indicated Altitude and Sea Level Pressure.
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Pressure Altitude.
     */
    static calcPressureAltitude(indicatedAltitude, baroSettingInHg) {
        return indicatedAltitude + (1000 * (29.92 - baroSettingInHg));
    }
    /**
     * Calculate the static pre
     * @param indicatedAltitude The indicated altitude.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns The Static Pressure in inHg.
     */
    static calcStaticPressure(indicatedAltitude, baroSettingInHg) {
        return UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(BoeingAeroMath.calcPressureAltitude(indicatedAltitude, baroSettingInHg))[1], UnitType.IN_HG);
    }
    /**
     * Calculate the Impact Pressure from CAS.
     * @param cas Calibrated Airspeed in knots.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromCas(cas) {
        return BoeingAeroMath.airDensity * Math.pow(UnitType.KNOT.convertTo(cas, UnitType.MPS), 2) / 2;
    }
    /**
     * Calculate the Impact Pressure.
     * @param mach Mach Number.
     * @param ambientPressure The Ambient Pressure, in inHg.
     * @returns the Impact Pressure in Pa.
     */
    static calcImpactPressureFromMach(mach, ambientPressure) {
        return 100 * (UnitType.IN_HG.convertTo(ambientPressure, UnitType.HPA) * (Math.pow(1 + Math.pow(0.2 * mach, 2), 2 / 7) - 1));
    }
    /**
     * Calculate the Mach number from airspeed, altitude and pressure.
     * @param cas Calibrated Airspeed in knots.
     * @param indicatedAltitude Indicated Altitude in Feet.
     * @param baroSettingInHg The local altimeter setting in inHg.
     * @returns The current Mach Number.
     */
    static calcMachFromCasAltitudePressure(cas, indicatedAltitude, baroSettingInHg) {
        const impactPressure = BoeingAeroMath.calcImpactPressureFromCas(cas);
        const staticPressure = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        return Math.sqrt(5 * (Math.pow((impactPressure / staticPressure) + 1, 2 / 7) - 1));
    }
    /**
     * Calculate static air temperature (SAT, also OAT), from total air temperature (TAT) and Mach.
     * @param tat Total Air Temp in degrees C.
     * @param mach Mach number.
     * @returns The Static Air Temperature in degrees C.
     */
    static calcSatFromTatAndMach(tat, mach) {
        // Gamma minus 1 / 2 = 0.2
        return UnitType.KELVIN.convertTo(UnitType.CELSIUS.convertTo(tat, UnitType.KELVIN) / (1 + (Math.pow(mach, 2) * 0.2)), UnitType.CELSIUS);
    }
    /**
     * Calculate the True Airspeed from Altitude, Temperature and Calibrated Airspeed.
     * @param altitude Altitude in Feet.
     * @param tat Total Air Temp in degrees C.
     * @param cas Calibrated Airspeed in KT.
     * @param baroSettingInHg The altimeter setting in inHg.
     * @returns True Airspeed in KT.
     */
    static calcTasFromCas(altitude, tat, cas, baroSettingInHg) {
        const pressureAltitude = BoeingAeroMath.calcPressureAltitude(altitude, baroSettingInHg);
        const isa = BoeingAeroMath.calcIsaFromAltitude(pressureAltitude);
        const isaPres = isa[1];
        const mach = BoeingAeroMath.calcMachFromCasAltitudePressure(cas, altitude, baroSettingInHg);
        const temp = UnitType.CELSIUS.convertTo(BoeingAeroMath.calcSatFromTatAndMach(tat, mach), UnitType.KELVIN);
        const alpha = Math.sqrt(BoeingAeroMath.gammaGasVolume * temp);
        const tas = Math.sqrt(5) * alpha * Math.sqrt(Math.pow(((BoeingAeroMath.slIsaPres / isaPres) *
            (Math.pow((cas * cas / BoeingAeroMath.sqrtGammaGasSlNmSqd5) + 1, BoeingAeroMath.gammaOverGammaMinus1) - 1) + 1), BoeingAeroMath.gammaMinus1OverGamma) - 1);
        return UnitType.FPS.convertTo(tas, UnitType.KNOT);
    }
    /**
     * Calculate EAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientPressure Ambient Pressure, in inHg.
     * @returns The Equivalent Airspeed (EAS).
     */
    static calcEasFromMachAndAmbientPressure(mach, ambientPressure) {
        return UnitType.FPS.convertTo(BoeingAeroMath.sound * mach *
            Math.sqrt(BoeingAeroMath.calcDeltaPressureRatioFromAmbientPressure(ambientPressure)), UnitType.KNOT);
    }
    /**
     * Calculate CAS from EAS.
     * @param eas Equivalent Airspeed in knots
     * @param pressureAlt The current pressure altitude, in Feet.
     * @returns Calibrated airspeed in knots
     */
    static easToCas(eas, pressureAlt) {
        const delta = BoeingAeroMath.deltaFromPressureAlt(pressureAlt);
        return 1479.1 * Math.sqrt((1 + delta * ((1 + 1 / delta * (eas / 1479.1) ** 2) ** 3.5 - 1)) ** (1 / 3.5) - 1);
    }
    /**
     * Calculate CAS from Mach and Ambient Pressure.
     * @param mach Mach Number.
     * @param ambientTemp Ambient Temperature, in C.
     * @returns The True Airspeed (TAS).
     */
    static calcTasFromMachAndTemp(mach, ambientTemp) {
        return mach * BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemp);
    }
    /**
     * Calculate density altitude from indicated altitude, barometer setting and static air temperature.
     * @param indicatedAltitude indicated altitude in feet (ft)
     * @param baroSettingInHg barometer setting in inches of mercury (inHg)
     * @param sat static air temperature in degrees celsius (°C)
     * @returns density altitude in feet (ft)
     */
    static calcDensityAltitude(indicatedAltitude, baroSettingInHg, sat) {
        const stationPressurePa = BoeingAeroMath.calcStaticPressure(indicatedAltitude, baroSettingInHg);
        const stationPressureinHg = UnitType.HPA.convertTo(stationPressurePa / 100, UnitType.IN_HG);
        const tempR = 459.67 + UnitType.CELSIUS.convertTo(sat, UnitType.FAHRENHEIT);
        // NWS Calculation for ASOS/AWOS
        return 145422.16 * (1 - Math.pow(17.326 * stationPressureinHg / tempR, 0.235));
    }
    /**
     * Calculate observed wind from true airspeed, ground speed, magnetic heading and magnetic track.
     * @param tas The true airspeed in KT.
     * @param gs The ground speed in KT.
     * @param heading The current magnetic heading in degrees.
     * @param track The current magnetic ground track in degrees.
     * @returns Array of [wind direction degrees mag, wind speed kt].
     */
    static calcWind(tas, gs, heading, track) {
        const headingRad = UnitType.DEGREE.convertTo(heading, UnitType.RADIAN);
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windComponentNorth = gs * Math.cos(trackRad) - tas * Math.cos(headingRad);
        const windComponentEast = gs * Math.sin(trackRad) - tas * Math.sin(headingRad);
        const windDirection = NavMath.normalizeHeading(90 - Math.round(UnitType.RADIAN.convertTo(Math.atan2(-windComponentNorth, -windComponentEast), UnitType.DEGREE)));
        const windSpeed = Math.sqrt(Math.pow(windComponentNorth, 2) + Math.pow(windComponentEast, 2));
        return [windDirection, windSpeed];
    }
    /**
     * Calculate headwind and crosswind components from the current ground track, wind speed and wind direction.
     * @param track Current magnetic ground track.
     * @param windSpeed Current wind speed in kt.
     * @param windDirection Current wind direction in degrees magnetic.
     * @returns Array of [headwind component in kt (+ is headwind, - is tailwind),
     * crosswind component in kt (+ is Left crosswind, - is Right crosswind)].
     */
    static calcRelativeWindComponents(track, windSpeed, windDirection) {
        const trackRad = UnitType.DEGREE.convertTo(track, UnitType.RADIAN);
        const windDirectionRad = UnitType.DEGREE.convertTo(windDirection, UnitType.RADIAN);
        return [
            Math.round(windSpeed * (Math.cos(trackRad - windDirectionRad))),
            Math.round(windSpeed * (Math.sin(trackRad - windDirectionRad)))
        ];
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingAeroMath.slIsaTemp = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingAeroMath.slIsaPres = 101325;
/** Specific heat ratio for air  */
BoeingAeroMath.gamma = 1.4;
/** Constant: gamma over gamma minus 1 */
BoeingAeroMath.gammaOverGammaMinus1 = BoeingAeroMath.gamma / (BoeingAeroMath.gamma - 1);
/** Constant: gamma minus 1 over gamma */
BoeingAeroMath.gammaMinus1OverGamma = (BoeingAeroMath.gamma - 1) / BoeingAeroMath.gamma;
/** Specific gas constant in Kelvin (from the world)  */
BoeingAeroMath.gasKelvin = 287.05;
/** Specific gas constant in Rankine (from sim code) */
BoeingAeroMath.gasRankine = 1716;
/** Specific heat ratio for air times gas constant.  */
BoeingAeroMath.gammaGas = BoeingAeroMath.gamma * BoeingAeroMath.gasKelvin;
/** Specific heat ratio for air times gas constant divided per cubic ft.  */
BoeingAeroMath.gammaGasVolume = BoeingAeroMath.gammaGas / Math.pow(UnitType.FOOT.convertTo(1, UnitType.METER), 2);
/** Constant: gammaGas * slIsaTemp */
BoeingAeroMath.gammaGasSl = BoeingAeroMath.gammaGas * BoeingAeroMath.slIsaTemp;
/** Constant: sqrt gammaGasSl * nm */
BoeingAeroMath.sqrtGammaGasSlNm = Math.sqrt(BoeingAeroMath.gammaGasSl) * UnitType.METER.convertTo(3600.0, UnitType.NMILE);
/** Constant: 5 * sqrtGammaGasSlNm squared  */
BoeingAeroMath.sqrtGammaGasSlNmSqd5 = 5.0 * BoeingAeroMath.sqrtGammaGasSlNm * BoeingAeroMath.sqrtGammaGasSlNm;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingAeroMath.lapseFt = 0.0019812;
/** Fluid density of Air in kg/m^3.  */
BoeingAeroMath.airDensity = 1.225;
/** Gravity at SL ft/s^2.  */
BoeingAeroMath.gravity = 32.17405;
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;
/** Speed of Sound at SL ft/s.  */
BoeingAeroMath.sound = Math.sqrt(BoeingAeroMath.gamma * BoeingAeroMath.gasRankine * BoeingAeroMath.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE);

/* eslint-disable max-len */
/**
 * An interface for accessing aircraft specific performance data.
 */
class BoeingPerformanceDataProvider {
    constructor() {
        /** Aircraft Specific values from flight_model.cfg and engines.cfg files.  */
        this.aircraftFlightModel = this.getAircraftFlightModel();
        this.aspectRatio = Math.pow(this.aircraftFlightModel.wing_span, 2) / this.aircraftFlightModel.wing_area;
    }
    /**
     * Calculate the Optimum (best range) Altitude for a specific Mach.
     * @param mach The Mach number.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude, in FT.
     */
    calcOptimumAltitudeFromCruiseMach(mach, weight) {
        const rangeTable = [];
        let altitude = 25000;
        while (altitude <= 41000) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            altitude += 1000;
        }
        const maxRange = Math.max(...rangeTable);
        const optAltitude = 25000 + 1000 * rangeTable.findIndex(v => v === maxRange);
        return optAltitude;
    }
    /**
     * Calculate the Optimum (best range) Mach for a specific Altitude.
     * @param altitude The Altitude, in FT.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Mach.
     */
    calcOptimumCruiseMachFromAltitude(altitude, weight) {
        const rangeTable = [];
        let mach = .7;
        while (mach <= 0.9) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach, ambientTemperature);
            const cl = this.calculateCL(weight, ambientPressure, mach);
            const netThrust = this.calculateThrustRequired(weight, cl, 0);
            const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach, altitude, ambientTemperature, ambientPressure);
            const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
            const rangePerThousandPounds = (1000 / fuelFlow) * tas;
            rangeTable.push(rangePerThousandPounds);
            mach += 0.01;
        }
        const maxRange = Math.max(...rangeTable);
        const optMach = .7 + (0.01 * rangeTable.findIndex(v => v === maxRange));
        return optMach;
    }
    /**
     * Calculate the Optimum (best range) Mach and Altitude for a specific aircraft weight.
     * @param weight The aircraft weight, in LBS.
     * @returns The Optimum Altitude and Mach as [Alt in FT, Mach].
     */
    calcOptimumCruiseMachAndAltitude(weight) {
        const rangeTable = [];
        let mach = 70;
        let altitude = 25000;
        while (Math.round(altitude) <= 41000) {
            while (Math.round(mach) <= 90) {
                const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
                const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
                const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
                const tas = BoeingAeroMath.calcTasFromMachAndTemp(mach / 100, ambientTemperature);
                const cl = this.calculateCL(weight, ambientPressure, mach / 100);
                const netThrust = this.calculateThrustRequired(weight, cl, 0);
                const grossThrust = this.findGrossThrustFromNetThrust(netThrust / 2, mach / 100, altitude, ambientTemperature, ambientPressure);
                const fuelFlow = this.calculateFuelFlowFromThrust(grossThrust) * 2;
                const rangePerThousandPounds = (1000 / fuelFlow) * tas;
                rangeTable.push(rangePerThousandPounds);
                mach += 1;
            }
            altitude += 1000;
            mach = 70;
        }
        //21 values per altitude
        const maxRange = Math.max(...rangeTable);
        const index = rangeTable.findIndex(v => v === maxRange);
        const altIndex = Math.floor(index / 21);
        const machIndex = index - (altIndex * 21);
        const optMach = .7 + (0.01 * machIndex);
        const optAlt = 25000 + (altIndex * 1000);
        return [optAlt, optMach];
    }
    /**
     * Calculates the current Lift Coefficient.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param ambientPressure The Ambient Pressure at the aircraft location in inHg
     * @param mach The current aircraft mach number.
     * @returns the current lift coefficient.
     */
    calculateCL(aircraftWeight, ambientPressure, mach) {
        return aircraftWeight / (BoeingAeroMath.calcDynamicPressureRatio(ambientPressure, mach) * this.aircraftFlightModel.wing_area);
    }
    /**
     * Gets the number of possible aircraft configurations, clean and flaps.
     * @returns The number of aircraft configurations.
     */
    getNumberOfConfigurations() {
        return this.aircraftFlightModel.cl_cd.length;
    }
    /**
     * Calculates the current drag coefficient.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The Drag Coefficient
     */
    calculateCD(cl, flapsIndex) {
        const correctedCl = cl - this.aircraftFlightModel.cl_cd[flapsIndex][0];
        const parasiticDrag = this.aircraftFlightModel.cl_cd[flapsIndex][1];
        const inducedDrag = (Math.pow(correctedCl, 2) * this.aircraftFlightModel.induced_drag_scalar) /
            (Math.PI * this.aircraftFlightModel.oswald_efficiency_factor * this.aspectRatio);
        return parasiticDrag + inducedDrag;
    }
    /**
     * Calculates the efficiency factor.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the efficiency factor.
     */
    calculateEfficiency(cl, flapsIndex) {
        return cl / this.calculateCD(cl, flapsIndex);
    }
    /**
     * Calculates the best L/D speed by finding a mach value at the altitude that produces the highest L/D ratio.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param altitude Altitude to find the best econ speed for.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best Econ Speed in Mach.
     */
    calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex) {
        const ambientPressure = UnitType.HPA.convertTo(BoeingAeroMath.calcIsaFromAltitude(altitude)[1], UnitType.IN_HG);
        let machTarget = 0.5;
        let clTarget = 0;
        let ldTarget = 0;
        let iterations = 0;
        while (iterations < 300) {
            clTarget = this.calculateCL(aircraftWeight, ambientPressure, machTarget);
            const newldTarget = this.calculateEfficiency(clTarget, flapsIndex);
            if (newldTarget > ldTarget) {
                ldTarget = newldTarget;
                machTarget += .01;
            }
            else {
                return machTarget -= .01;
            }
            iterations++;
        }
        return machTarget;
    }
    /**
     * Gets the best econ speed based on CAFE/Carson Speed multiplier against best L/D speed.
     * @param aircraftWeight The aircraft weight.
     * @param altitude The altitide to find the best speed at.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The best econ speed.
     */
    calculateBestEconSpeed(aircraftWeight, altitude, flapsIndex) {
        return 1.32 * this.calculateLDMaxSpeed(aircraftWeight, altitude, flapsIndex);
    }
    /**
     * Calculates the total required net thrust to maintain the current speed and altitude.
     * @param aircraftWeight Current aircraft weight in pounds.
     * @param cl The current Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The total required net thrust.
     */
    calculateThrustRequired(aircraftWeight, cl, flapsIndex) {
        return aircraftWeight / this.calculateEfficiency(cl, flapsIndex);
    }
    /**
     * Calculates an FPA for a total net thrust at a constant speed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns The predicted FPA in Degrees.
     */
    calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex) {
        return Avionics.Utils.RAD2DEG * Math.asin((totalNetThrust / aircraftWeight) - (1 / this.calculateEfficiency(cl, flapsIndex)));
    }
    /**
     * Calculates a vertical speed for a total net thrust for a constant true airspeed.
     * @param totalNetThrust Total Net Thrust in LBS.
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns the predicted VS in FPM
     */
    calculateConstantSpeedVerticalSpeedFromThrust(totalNetThrust, tas, aircraftWeight, cl, flapsIndex) {
        return VNavUtils.getVerticalSpeedFromFpa(this.calculateConstantSpeedFpaFromThrust(totalNetThrust, aircraftWeight, cl, flapsIndex), tas);
    }
    /**
     * Calculates a total net thrust at a constant speed for a given FPA
     * @param fpa Flight Path Angle in degrees (+ve = up)
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForFpa(fpa, aircraftWeight, cl, flapsIndex) {
        return aircraftWeight * (Math.sin(fpa * Avionics.Utils.DEG2RAD) + 1 / this.calculateEfficiency(cl, flapsIndex));
    }
    /**
     * Calculates a total net thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param cl The Lift Coefficient.
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex) {
        return this.calculateConstantSpeedThrustForFpa(VNavUtils.getFpaFromVerticalSpeed(vs, tas), aircraftWeight, cl, flapsIndex);
    }
    /**
     * Calculates a gross thrust at a constant speed for a given vertical speed and true airspeed
     * @param vs Vertical speed in feet/sec
     * @param tas TAS in KTS.
     * @param aircraftWeight Aircraft weight in pounds.
     * @param enginesAvailable The number of engines currently running to provide the thrust
     * @param altitude Altitude in feet
     * @param isaDeviation ISA temperature deviation in °C
     * @param flapsIndex The flaps index to use, with zero for clean configuration.
     * @returns Total Net Thrust in LBS.
     */
    calculateCorrectedN1ForVerticalSpeed(vs, tas, aircraftWeight, enginesAvailable, altitude, isaDeviation, flapsIndex) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(altitude, undefined, isaDeviation);
        const ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
        const mach = AeroMath.tasToMach(UnitType.KNOT.convertTo(tas, UnitType.MPS), AeroMath.soundSpeedAir(ambientTemperature));
        const cl = this.calculateCL(aircraftWeight, ambientPressure, mach);
        const netThrust = this.calculateConstantSpeedThrustForVerticalSpeed(vs, tas, aircraftWeight, cl, flapsIndex);
        const netThrustPerEngine = netThrust / Math.max(1, enginesAvailable);
        const grossThrustPerEngine = this.findGrossThrustFromNetThrust(netThrustPerEngine, mach, altitude, ambientTemperature, ambientPressure) * BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        return this.calculateCorrectedN1FromThrust(grossThrustPerEngine, mach);
    }
    /**
     * Calculates fuel flow from a corrected thrust and corrected ram drag.
     * @param thrust Corrected Net thrust (if ram drag is given) or corrected gross thrust, in LBS.
     * @param ramDrag An optional corrected ram drag, in LBS.
     * @returns The calculated fuel flow, in LBS/HR.
     */
    calculateFuelFlowFromThrust(thrust, ramDrag) {
        if (ramDrag !== undefined) {
            return (thrust + ramDrag) * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
        }
        return thrust * this.aircraftFlightModel.ThrustSpecificFuelConsumption;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param n1 The corrected N1 percent.
     * @param mach The mach number.
     * @returns The corrected gross thrust, in pounds, at the specified corrected N1 and mach.
     */
    calculateThrustFromCorrectedN1(n1, mach) {
        return this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(n1, mach) * this.aircraftFlightModel.static_thrust;
    }
    /**
     * Calculates corrected gross thrust from corrected N1 and mach.
     * @param grossThrust The corrected gross thrust, in pounds
     * @param mach The mach number.
     * @returns The corrected N1 percent.
     */
    calculateCorrectedN1FromThrust(grossThrust, mach) {
        return this.aircraftFlightModel.thrust_and_mach_on_n1_table.get(grossThrust / this.aircraftFlightModel.static_thrust, mach);
    }
    /**
     * Calculates idle corrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @returns The idle corrected N1 (%) at the specified mach number.
     */
    calculateIdleCorrectedN1(ambientTemperature, mach) {
        // TODO Should this use ambient or TAT? We call it with TAT right now
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        return (mach * this.aircraftFlightModel.mach_influence_on_n1) + (this.aircraftFlightModel.low_idle_n1 / Math.sqrt(thetaTotalTempRatio));
    }
    /**
     * Calculates uncorrected N1 (%).
     * @param ambientTemperature The ambient temperature, in degrees Celsius.
     * @param mach The mach number.
     * @param correctedN1 The corrected n1.
     * @returns The uncorrected N1 (%) at the specified mach number.
     */
    uncorrectN1(ambientTemperature, mach, correctedN1) {
        const totalInletTempMachRise = 1.0 + 0.2 * mach * mach;
        const StandardSeaLevelTemperature = BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE;
        const ambientRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const theta_temperature_ratio = ambientRankine / StandardSeaLevelTemperature;
        const thetaTotalTempRatio = theta_temperature_ratio * totalInletTempMachRise;
        return correctedN1 * Math.sqrt(thetaTotalTempRatio);
    }
    /**
     * Calculates idle corrected gross thrust, in LBS, for one engine.
     * @param ambientTemperature The Ambient Temperature at the aircraft location in C.
     * @param mach The current aircraft mach number.
     * @returns The idle corrected gross thrust, in LBS, for one engine.
     */
    calculateIdleThrust(ambientTemperature, mach) {
        return this.calculateThrustFromCorrectedN1(this.calculateIdleCorrectedN1(ambientTemperature, mach), mach);
    }
    /**
     * Calculates the uncorrected ram drag provided by an engine, in pounds.
     * @param mach The airplane's mach number.
     * @param n1 The engine's corrected N1, as a percent.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius.
     * @param ambientPressure The ambient pressure, in inches of mercury.
     * @param inletTemp The engine inlet temperature, in Rankine.
     * @returns The uncorrected ram drag provided by an engine, in pounds, with the specified parameters.
     */
    calculateRamDrag(mach, n1, ambientTemperature, ambientPressure, inletTemp) {
        const airflowTableResult = this.aircraftFlightModel.corrected_airflow_table.get(n1, mach);
        const correctedAirflow = airflowTableResult * this.aircraftFlightModel.inlet_area;
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
        const deltaPressureRatio = ambientPressure / 29.92;
        const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
        const thetaTotalTempRatio = inletTemp / BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE; //Divide by sim normal SL temp constant to get thetaTTR
        const airflow = correctedAirflow * deltaTotalPressureRatio / Math.sqrt(thetaTotalTempRatio);
        const speedOfSound = BoeingAeroMath.calcSpeedOfSoundFromTemp(ambientTemperature);
        return speedOfSound * mach * airflow / BoeingAeroMath.gravity; // Ram Drag in pounds
    }
    /**
     * Finds the uncorrected gross thrust, in pounds, provided by an engine when it is providing a given uncorrected net
     * thrust.
     * @param netThrust The uncorrected net thrust, in pounds, for which to find the gross thrust.
     * @param mach The airplane's mach number.
     * @param altitude The airplane's pressure altitude, in feet.
     * @param ambientTemperature The ambient (static) temperature, in degrees Celsius. Defaults to ISA temperature for
     * the specified pressure altitude.
     * @param ambientPressure The ambient pressure, in inches of mercury. Defaults to ISA pressure for the specified
     * pressure altitude.
     * @param idleN1 The engine's idle corrected N1, as a percent. If not defined, it will be calculated from the specified mach
     * number and temperature.
     * @returns The uncorrected gross thrust, in pounds, provided by the engine with the specified parameters when it is
     * providing the specified uncorrected net thrust.
     */
    findGrossThrustFromNetThrust(netThrust, mach, altitude, ambientTemperature, ambientPressure, idleN1) {
        if (!ambientTemperature || !ambientPressure) {
            const isa = BoeingAeroMath.calcIsaFromAltitude(altitude);
            if (!ambientTemperature) {
                ambientTemperature = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
            }
            if (!ambientPressure) {
                ambientPressure = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
            }
        }
        idleN1 !== null && idleN1 !== void 0 ? idleN1 : (idleN1 = this.calculateIdleCorrectedN1(ambientTemperature, mach));
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(ambientTemperature, UnitType.RANKINE);
        const thrustCorrectionFactor = BoeingAeroMath.calculateThrustCorrectionFactor(mach, ambientPressure);
        const correctedNetThrust = netThrust * thrustCorrectionFactor;
        let lowCorrectedN1 = idleN1;
        let highCorrectedN1 = 110;
        let numIterations = 0;
        let estimatedCorrectedGrossThrust = 0;
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        const lowCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(lowCorrectedN1, mach) * this.aircraftFlightModel.static_thrust;
        let lowCorrectedNetThrust = lowCorrectedGrossThrust - this.calculateRamDrag(mach, lowCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        if (correctedNetThrust <= lowCorrectedNetThrust) {
            return lowCorrectedGrossThrust / thrustCorrectionFactor;
        }
        const highCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(highCorrectedN1, mach) * this.aircraftFlightModel.static_thrust;
        let highCorrectedNetThrust = highCorrectedGrossThrust - this.calculateRamDrag(mach, highCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor;
        const epsilon = this.aircraftFlightModel.static_thrust * 0.001;
        while (numIterations < 100) {
            const estimatedCorrectedN1 = MathUtils.lerp(correctedNetThrust, lowCorrectedNetThrust, highCorrectedNetThrust, lowCorrectedN1, highCorrectedN1);
            estimatedCorrectedGrossThrust = this.aircraftFlightModel.n1_and_mach_on_thrust_table.get(estimatedCorrectedN1, mach)
                * this.aircraftFlightModel.static_thrust;
            /** corrected net thrust estimate */
            const estimatedNetThrust = estimatedCorrectedGrossThrust
                - (this.calculateRamDrag(mach, estimatedCorrectedN1, ambientTemperature, ambientPressure, inletTemp) * thrustCorrectionFactor);
            if (Math.abs(estimatedNetThrust - correctedNetThrust) < epsilon) {
                return estimatedCorrectedGrossThrust / thrustCorrectionFactor;
            }
            const errorSign = Math.sign(estimatedNetThrust - correctedNetThrust);
            if (errorSign < 0) {
                lowCorrectedN1 = estimatedCorrectedN1;
                lowCorrectedNetThrust = estimatedNetThrust;
            }
            else {
                highCorrectedN1 = estimatedCorrectedN1;
                highCorrectedNetThrust = estimatedNetThrust;
            }
            numIterations++;
        }
        return estimatedCorrectedGrossThrust / thrustCorrectionFactor;
    }
}
// This is pulled from the native sim code. Commonly used when correcting N1.
BoeingPerformanceDataProvider.MSFS_STANDARD_SEA_LEVEL_TEMP_RANKINE = 518.69;

/**
 * The abstract class to calculate the stab trim green zone data for the actual/FMC-calculated trim values
 */
class BoeingStabTrimCalculator {
    /**
     * Constructor for the BoeingStabTrimCalculator
     * @param bus The bus used to publish the calculator data
     * @param activePerfPlan The active perf plan from the FMC
     * @param stabTrimData The current stab trim data from the sim
     */
    constructor(bus, activePerfPlan, stabTrimData) {
        this.bus = bus;
        this.activePerfPlan = activePerfPlan;
        this.stabTrimData = stabTrimData;
        // publsh the calc stab trim onto the bus
        this.publisher = this.bus.getPublisher();
        this.sub = this.bus.getSubscriber();
        this.grossWeightKg = MappedSubject.create(([zfw, fuelWeight]) => zfw !== null ? UnitType.POUND.convertTo((zfw + fuelWeight), UnitType.KILOGRAM) : null, this.activePerfPlan.manualZfw, ConsumerSubject.create(this.sub.on('fuel_total_weight').atFrequency(0.5), 0));
        this.calculatedStabTrim = MappedSubject.create(([flaps, cg, thrust]) => {
            const weightKg = this.grossWeightKg.get();
            if (weightKg === null || cg === null || flaps === null) {
                return null;
            }
            const rawCalcTrim = this.stabTrimData.getStabTrimSetting(thrust, flaps, weightKg, cg);
            return this.roundCalcStabTrim(rawCalcTrim);
        }, this.activePerfPlan.takeoffFlaps, this.activePerfPlan.takeoffCg, this.activePerfPlan.takeoffThrustMode);
        this.greenZone = this.calculatedStabTrim.map(this.calculateGreenZone.bind(this));
        this.elevatorTrimAngle = ConsumerSubject.create(this.sub.on('elevator_trim_angle').atFrequency(6), 0);
        this.stabTrimValueRaw = this.elevatorTrimAngle.map(this.convertElevatorTrimAngleToGaugeRange.bind(this));
        this.stabTrimValueRounded = this.stabTrimValueRaw.map(x => this.roundCalcStabTrim(x));
        this.stabTrimInGreenZone = MappedSubject.create(([greenZone, stabTrimValue]) => {
            return stabTrimValue >= greenZone.min && stabTrimValue <= greenZone.max;
        }, this.greenZone, this.stabTrimValueRounded);
        this.calculatedStabTrim.sub((v) => {
            this.publisher.pub('calculated_stab_trim', v);
        }, true);
        this.greenZone.sub((v) => {
            this.publisher.pub('stab_trim_green_zone', v);
        }, true);
        this.stabTrimInGreenZone.sub((v) => {
            this.publisher.pub('stab_trim_is_in_green_zone', v);
        }, true);
        this.stabTrimValueRaw.sub((v) => {
            this.publisher.pub('stab_trim_value_raw', v);
        }, true);
        this.stabTrimValueRounded.sub((v) => {
            this.publisher.pub('stab_trim_value', v);
        }, true);
    }
}

/**
 * An default implementation of {@link BoeingPathPerformanceProvider} which derives performance data from a
 * {@link BoeingPerformanceDataProvider}.
 */
class DefaultBoeingPathPerformanceProvider {
    /**
     * Creates an instance of DefaultBoeingPathPerformanceProvider.
     * @param performanceData The aircraft's performance data provider.
     */
    constructor(performanceData) {
        this.performanceData = performanceData;
    }
    /** @inheritdoc */
    getWingArea() {
        return this.performanceData.aircraftFlightModel.wing_area * 0.09290304;
    }
    /** @inheritdoc */
    getThrustCorrectionFactor(pressure, mach) {
        return BoeingAeroMath.calculateThrustCorrectionFactor(mach, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineIdleCorrectedN1(temperature, mach) {
        return this.performanceData.calculateIdleCorrectedN1(temperature, mach);
    }
    /** @inheritdoc */
    getEngineCorrectedGrossThrust(n1, mach) {
        return this.performanceData.calculateThrustFromCorrectedN1(n1, mach);
    }
    /** @inheritdoc */
    getEngineRamDrag(n1, mach, pressure, temperature) {
        const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
        const ambientTemperatureRankine = UnitType.CELSIUS.convertTo(temperature, UnitType.RANKINE);
        const inletTemp = ambientTemperatureRankine * totalInletTempMachRise;
        return this.performanceData.calculateRamDrag(mach, n1, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG), inletTemp);
    }
    /** @inheritdoc */
    getEngineUncorrectedNetThrust(n1, mach, pressure, temperature) {
        return this.getEngineCorrectedGrossThrust(n1, mach) / this.getThrustCorrectionFactor(pressure, mach) - this.getEngineRamDrag(n1, mach, pressure, temperature);
    }
    /** @inheritdoc */
    estimateGrossThrustFromNetThrust(netThrust, mach, pressure, temperature) {
        return this.performanceData.findGrossThrustFromNetThrust(netThrust, mach, 0, temperature, UnitType.HPA.convertTo(pressure, UnitType.IN_HG));
    }
    /** @inheritdoc */
    getEngineFuelFlow(grossThrust) {
        return this.performanceData.calculateFuelFlowFromThrust(grossThrust);
    }
    /** @inheritdoc */
    getRequiredThrust(weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return weight * (sin + this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos));
    }
    /** @inheritdoc */
    getLevelFlightRequiredThrust(weight, cl, flapsIndex) {
        return this.performanceData.calculateThrustRequired(weight, cl, flapsIndex);
    }
    /** @inheritdoc */
    getVerticalSpeed(netThrust, weight, cl, tas, flapsIndex) {
        return UnitType.FPM.convertTo(this.performanceData.calculateConstantSpeedVerticalSpeedFromThrust(netThrust, UnitType.MPS.convertTo(tas, UnitType.KNOT), weight, cl, flapsIndex), UnitType.MPS);
    }
    /** @inheritdoc */
    getAcceleration(netThrust, weight, cl, tas, vs, flapsIndex) {
        const sin = vs / tas;
        const cos = Math.sqrt(1 - sin * sin);
        return UnitType.G_ACCEL.convertTo(netThrust / weight - sin - this.performanceData.calculateCD(cl, flapsIndex) / (cl * cos), UnitType.MPS_PER_SEC);
    }
    /** @inheritdoc */
    estimateTimeAndDistanceToAccelerate(initialTas, finalTas, vs, engineNetThrust, engineCount, wingArea, flapsIndex, weight, pressure, temperature, out, density, soundSpeed, minAccel = 0.1) {
        let totalTime = 0;
        let totalDistance = 0;
        if (density === undefined) {
            density = AeroMath.densityAir(pressure, temperature);
        }
        // For performance reasons, only calculate engine fuel flow at the starting speed.
        const initialMach = AeroMath.tasToMach(initialTas, soundSpeed !== null && soundSpeed !== void 0 ? soundSpeed : AeroMath.soundSpeedAir(temperature));
        const grossThrustPerEngineRequired = this.estimateGrossThrustFromNetThrust(engineNetThrust, initialMach, pressure, temperature);
        const engineFuelFlow = this.getEngineFuelFlow(grossThrustPerEngineRequired) / 3600;
        let currentTas = initialTas;
        while (Math.abs(finalTas - currentTas) > 0.1) {
            const weightNewtons = weight * 4.44822;
            let acceleration = this.getAcceleration(engineNetThrust * engineCount, weight, AeroMath.liftCoefficient(weightNewtons, wingArea, density, currentTas), currentTas, vs, flapsIndex);
            if (finalTas - currentTas > 0) {
                acceleration = Math.max(minAccel, acceleration);
            }
            else {
                acceleration = Math.min(-minAccel, acceleration);
            }
            const tasStep = MathUtils.clamp(finalTas - currentTas, -3, 3);
            const timeStep = tasStep / acceleration;
            totalTime += timeStep;
            totalDistance += currentTas * timeStep + acceleration * timeStep * timeStep / 2;
            currentTas += acceleration * timeStep;
            weight = Math.max(0, weight - engineFuelFlow * timeStep);
        }
        return Vec2Math.set(totalTime, totalDistance, out);
    }
}

/**
 * {@link Formatter} for displaying a string without a takeValue call
 */
class SimpleStringFormat {
    /** ctor
     * @param value the string value
     */
    constructor(value) {
        this.nullValueString = value;
    }
    /** @inheritDoc */
    format(value) {
        return value !== null && value !== void 0 ? value : this.nullValueString;
    }
}
/**
 * Format for number with unit entries
 */
class NumberAndUnitFormat {
    /**
     * CTOR
     * @param unit A unit
     * @param options Format options
     * @param nullValueString null value string
     */
    constructor(unit, options = {}, nullValueString = '') {
        this.unit = unit;
        this.nullValueString = nullValueString;
        const defaults = {
            precision: 0,
            padStart: 0,
            padString: '-',
            maxValue: Number.MAX_SAFE_INTEGER,
            minValue: 0,
            spaceBetween: true,
            forceSign: false,
            type: 'display',
            fontSize: 'large',
            unitSize: 'small',
            prefix: '',
            absoluteValue: false,
        };
        this.options = Object.assign(defaults, options);
        if (nullValueString === '') {
            const unitString = SubscribableUtils.isSubscribable(unit) ? unit.get() : unit;
            this.nullValueString = `${''.padStart(this.options.padStart, '-')}[d-text]${this.options.spaceBetween ? ' ' : ''}${unitString}[s-text]`;
        }
        if (options.type === 'input') {
            this.nullValueString = inputBox(this.nullValueString);
        }
        this.format = B787FmcFormatters.Unit(this.unit, this.options, this.nullValueString);
    }
    /** @inheritDoc */
    parse(input) {
        // const tmp = Number(value);
        const tmp = this.options.precision > 0 ? parseFloat(input) : parseInt(input);
        if (isNaN(tmp)) {
            return null;
        }
        if (tmp > this.options.maxValue || tmp < this.options.minValue) {
            return null;
        }
        return tmp;
    }
}
const IcaoIdentFormatter = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value !== null ? ICAO.getIdent(value) : '';
    }
};
/**
 * {@link Formatter} for displaying page number values
 */
const PageNumberDisplay = {
    nullValueString: '',
    /** @inheritDoc */
    format(value) {
        return value ? value + '[blue] ' : '1/1[blue] ';
    }
};
/**
 * {@link FmcFormat} for displaying a nav frequency
 *
 * Accepts a XXX.YY or XXXYY string.
 */
class NavFrequencyFormat {
    /**
     * Constructs a `NavFrequencyFormat`.
     *
     * @param screen The FmcScreen.
     * @param fms The BoeingFms.
     * @param index 1 for VOR Left, 2 for VOR Right.
     */
    constructor(screen, fms, index) {
        this.screen = screen;
        this.fms = fms;
        this.index = index;
        this.NAV_RAD_ID_REGEX = /^[A-Z]{1,4}$/;
        this.FREQUENCY_NO_DECIMAL_REGEX = /^\d+$/;
        this.FREQUENCY_REGEX = /\d{1,3}\.\d{1,2}/;
        this.formatter = NumberFormatter.create({ precision: 0.01 });
        this.nullValueString = '---.--';
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    format({ freq, ident }) {
        let identString = '     ';
        if (ident && !RadioUtils.isLocalizerFrequency(freq)) {
            if (this.index === 1) {
                identString = `M[s-text]${ident.padEnd(4, ' ')}[green]`;
            }
            else if (this.index === 2) {
                identString = `${ident.padStart(4, ' ')}[green]M[s-text]`;
            }
        }
        const styledFreqString = `${this.formatter(freq)}[green]`;
        if (this.index === 1) {
            return inputBox(styledFreqString + identString);
        }
        else {
            return inputBox(identString + styledFreqString);
        }
    }
    /** @inheritDoc */
    async parse(input) {
        const isNavRadId = input.match(this.NAV_RAD_ID_REGEX);
        if (isNavRadId) {
            try {
                const facility = await this.screen.selectWaypointByIdent(input, this.fms.ppos, FacilitySearchType.Vor, true);
                if (facility) {
                    return Math.round(facility.freqMHz * 100) / 100;
                }
                return Promise.reject('FACILITY NOT FOUND');
            }
            catch (e) {
                return Promise.reject('FACILITY NOT FOUND');
            }
        }
        let formattedInput = input;
        const isFrequencyWithNoDecimal = input.match(this.FREQUENCY_NO_DECIMAL_REGEX);
        if (isFrequencyWithNoDecimal) {
            switch (input.length) {
                case 1:
                    formattedInput = `10${input}.00`;
                    break;
                case 2:
                    formattedInput = `1${input}.00`;
                    break;
                case 3:
                case 4:
                    formattedInput = `1${input.substring(0, 2)}.${input.substring(2).padEnd(2, '0')}`;
                    break;
                case 5:
                    formattedInput = `${input.substring(0, 3)}.${input.substring(3)}`;
                    break;
            }
        }
        const isFrequency = formattedInput.match(this.FREQUENCY_REGEX);
        if (isFrequency) {
            let freq = parseFloat(formattedInput);
            if (freq < 100) {
                freq += 100;
            }
            // TODO: See why RadioNav does not get imported event if
            //       /// <reference types="@microsoft/msfs-types/js/radionav" /> is included
            //       both in WTB78xFsInstrument.ts and WTB78x_PFD.html
            // if (freq >= 108 && freq <= 117.95 && RadioNav.isHz50Compliant(freq)) {
            if (freq >= 108 && freq <= 117.95) {
                return freq;
            }
            return null;
        }
        return null;
    }
}
/**
 * {@link FmcFormat} for displaying an ADF frequency
 *
 * Accepts a (X)XXX.X(A|B) string.
 */
class AdfFrequencyFormat {
    /**
     * Constructs an `AdfFrequencyFormat`.
     *
     * @param index 1 for ADF Left, 2 for ADF Right.
     */
    constructor(index) {
        this.index = index;
        this.FREQUENCY_REGEX = /^(\d{3,4})(\.\d){1}$/;
        this.FREQUENCY_WITH_TUNING_MODE_REGEX = /^(\d{3,4})(\.\d){1}([A,B]?)$/;
        this.formatter = NumberFormatter.create({ precision: 0.1 });
        this.nullValueString = inputBox(this.index === 1 ? '------  ' : '  ------');
    }
    /** @inheritDoc */
    format({ freq, ident }) {
        const styledFreqString = `${this.formatter(freq)}[cyan]`;
        let styledIdentString = '    ';
        if (ident) {
            if (this.index === 1) {
                styledIdentString = ident.padEnd(4, ' ');
            }
            else {
                styledIdentString = ident.padStart(4, ' ');
            }
        }
        if (this.index === 1) {
            return inputBox(styledFreqString + styledIdentString);
        }
        return inputBox(styledIdentString + styledFreqString);
    }
    /** @inheritDoc */
    async parse(input) {
        let parsed = this.FREQUENCY_REGEX.test(input);
        if (parsed) {
            const freq = parseFloat(input);
            if ((freq >= 200.0 && freq <= 999.9) || (freq >= 1000.0 && freq <= 1699.9)) {
                return { freq, ident: '' };
            }
            return null;
        }
        parsed = this.FREQUENCY_WITH_TUNING_MODE_REGEX.test(input);
        if (parsed) {
            const freq = parseFloat(input.substring(0, input.length - 1));
            const ident = input.substring(input.length - 1, input.length) === 'A' ? 'ANT' : 'BFO';
            if ((freq >= 200.0 && freq <= 999.9) || (freq >= 1000.0 && freq <= 1699.9)) {
                return { freq, ident };
            }
        }
        return null;
    }
}
/** Format for altitude input */
class AltitudeInputFormat {
    /** @inheritDoc */
    constructor(type, transitionAlt, nullValueDisplay = '□□□□□') {
        this.type = type;
        this.transitionAlt = transitionAlt;
        this.nullValueDisplay = nullValueDisplay;
        /** @inheritDoc */
        this.parse = B787FmcParsers.Altitude;
        /** @inheritDoc */
        this.format = B787FmcFormatters.Altitude(this.type, this.transitionAlt);
        this.nullValueString = this.type === 'input' ? inputBox(this.nullValueDisplay) : this.nullValueDisplay;
    }
}
/** Format for altitude input with display in feet only (no flight level)*/
class AltitudeFeetInputFormat {
    /** @inheritDoc */
    constructor(type, nullValueDisplay = '□□□□□') {
        this.type = type;
        this.nullValueDisplay = nullValueDisplay;
        /** @inheritDoc */
        this.parse = B787FmcParsers.Altitude;
        /** @inheritDoc */
        this.format = B787FmcFormatters.AltitudeFeet(this.type);
        this.nullValueString = this.type === 'input' ? inputBox(this.nullValueDisplay) : this.nullValueDisplay;
    }
}
/** Format for flight level input (accepts altitudes as well but always displays flight level) */
class FlightLevelInputFormat {
    /** @inheritDoc */
    constructor(type, nullValueDisplay = '□□□□□') {
        this.type = type;
        this.nullValueDisplay = nullValueDisplay;
        /** @inheritDoc */
        this.parse = B787FmcParsers.Altitude;
        /** @inheritDoc */
        this.format = B787FmcFormatters.FlightLevel(this.type);
        this.nullValueString = this.type === 'input' ? inputBox(this.nullValueDisplay) : this.nullValueDisplay;
    }
}
/**
 * Validator/Formatter for string, string input fields
 */
class StringInputFormat {
    /**
     * Ctor
     * @param options The format options.
     */
    constructor(options = {}) {
        this.nullValueString = '';
        this.options = Object.assign({
            maxLength: 16,
            nullValueString: '',
        }, options);
        this.nullValueString = inputBox(this.options.nullValueString);
    }
    /** @inheritDoc */
    format(value) {
        return inputBox(value);
    }
    /** @inheritDoc */
    parse(text) {
        if (!text) {
            return null;
        }
        else if (text.length > this.options.maxLength) {
            return null;
        }
        return text;
    }
}
/**
 * Format for lla entries
 */
class LatLongTextFormat {
    /** @inheritDoc */
    constructor(options) {
        var _a, _b, _c, _d, _e;
        this.dmsFormatter = new DmsFormatter();
        this.options = {
            acceptShortFormInput: (_a = options === null || options === void 0 ? void 0 : options.acceptShortFormInput) !== null && _a !== void 0 ? _a : true,
            placeholderAsSquare: (_b = options === null || options === void 0 ? void 0 : options.placeholderAsSquare) !== null && _b !== void 0 ? _b : false,
            onlyFormatLat: (_c = options === null || options === void 0 ? void 0 : options.onlyFormatLat) !== null && _c !== void 0 ? _c : false,
            onlyFormatLong: (_d = options === null || options === void 0 ? void 0 : options.onlyFormatLong) !== null && _d !== void 0 ? _d : false,
            inputBox: (_e = options === null || options === void 0 ? void 0 : options.inputBox) !== null && _e !== void 0 ? _e : false,
        };
        const latPlaceholderString = this.options.placeholderAsSquare ? '□□□°□□.□' : '---°--.-';
        const longPlaceholderString = this.options.placeholderAsSquare ? '□□□□°□□.□' : '----°--.-';
        if (this.options.onlyFormatLat) {
            this.nullValueString = latPlaceholderString;
        }
        else if (this.options.onlyFormatLong) {
            this.nullValueString = longPlaceholderString;
        }
        else {
            this.nullValueString = `${latPlaceholderString} ${longPlaceholderString}`;
        }
        if (this.options.inputBox) {
            this.nullValueString = inputBox(this.nullValueString);
        }
    }
    /** @inheritDoc */
    format(value) {
        const latDmsStr = this.dmsFormatter.getLatDmsStr(value.lat, false, false, 1);
        const lonDmsStr = this.dmsFormatter.getLonDmsStr(value.long, false, 1);
        let returnStr;
        if (this.options.onlyFormatLat) {
            returnStr = latDmsStr;
        }
        else if (this.options.onlyFormatLong) {
            returnStr = lonDmsStr;
        }
        else if (!value.lat && !value.long) {
            returnStr = this.nullValueString;
        }
        else {
            returnStr = `${latDmsStr} ${lonDmsStr}`;
        }
        return this.options.inputBox ? inputBox(returnStr) : returnStr;
    }
    /** @inheritDoc */
    parse(text) {
        const llaObject = BoeingCoordinatesUtils.parseLatLong(text, this.options.acceptShortFormInput);
        return llaObject ? new LatLong(llaObject.lat, llaObject.long) : null;
    }
}
/** Format Mag Var value from Ref Nav Data page according to ref ident type. */
class RefNavDataMagVarTextFormat {
    constructor() {
        this.nullValueString = '';
    }
    /** @inheritDoc */
    format(data) {
        if (data.identType === 'navaid') {
            // Force any finite magnetic variation value into the domain of [-180, 180].
            // Force an unavailable magnetic variation to be 0.
            const magVarCorrected = data.value ? ((data.value + 540) % 360 - 180) : 0;
            // Rendering this way means we may variously show W0 or E0 depending on the fractional
            // part of the value, but this is accurate to testing with the trainer. Start at a
            // place where the plane's magvar on the setup page is shown as W0, then fly west, and
            // eventually it switches to 0E before proceeding on to E1.  A value of precisely 0
            // will be shown as east, which also seems to match how the trainer displays VORs with
            // a 0 station magvar: they, empirically, all seem to show E0.
            return `${Math.round(magVarCorrected) < 0 ? 'W' : 'E'}${Math.abs(magVarCorrected).toFixed(0)}`;
        }
        else if (data.identType === 'runway') {
            return data.value.toFixed(0);
        }
        else ;
        return '';
    }
}
/** Format facility elevation in XXXFT format. */
class RefNavDataElevationTextFormat {
    constructor() {
        this.nullValueString = '';
    }
    /** @inheritDoc */
    format(value) {
        return value + '[d-text]' + 'FT[s-text]';
    }
}
/**
 * Formats a text using input box styling
 *
 * @param text the text to surround with an input box
 *
 * @returns the styled text for FMC display
 */
function inputBox(text) {
    const regex = /([^[\]\n]+)(\[[^[\]\n]+])*/g;
    let finalString = '';
    let pos = 0;
    let endPos = 0;
    let match = regex.exec(text);
    if (match) {
        while (match !== null) {
            endPos += match[0].length;
            // Special case if we only have one match for the whole string
            if (pos === 0 && endPos === text.length) {
                if (match[2]) {
                    if (match[1].length > 2) {
                        const startStr = match[1][0];
                        const startStyle = match[2].replace(']', ' box-s]');
                        const midStr = match[1].substring(1, match[1].length - 1);
                        const midStyle = match[2].replace(']', ' box-m]');
                        const endStr = match[1][match[1].length - 1];
                        const endStyle = match[2].replace(']', ' box-e]');
                        finalString = `${startStr}${startStyle}${midStr}${midStyle}${endStr}${endStyle}`;
                    }
                    else if (match[1].length > 1) {
                        const startStr = match[1][0];
                        const startStyle = match[2].replace(']', ' box-s]');
                        const endStr = match[1][match[1].length - 1];
                        const endStyle = match[2].replace(']', ' box-e]');
                        finalString = `${startStr}${startStyle}${endStr}${endStyle}`;
                    }
                    else {
                        const str = match[1][0];
                        const style = match[2].replace(']', ' box-s box-e]');
                        finalString = `${str}${style}`;
                    }
                    return finalString;
                }
                else {
                    if (match[1].length > 2) {
                        const startStr = match[1][0];
                        const midStr = match[1].substring(1, match[1].length - 1);
                        const endStr = match[1][match[1].length - 1];
                        finalString = `${startStr}[box-s]${midStr}[box-m]${endStr}[box-e]`;
                    }
                    else if (match[1].length > 1) {
                        const startStr = match[1][0];
                        const endStr = match[1][match[1].length - 1];
                        finalString = `${startStr}[box-s]${endStr}[box-e]`;
                    }
                    else {
                        finalString = `${match[1]}[box-s box-e]`;
                    }
                    return finalString;
                }
            }
            if (pos === 0) {
                // Style fragment is at the start of the string
                if (match[2]) {
                    finalString += match[1][0] + match[2].replace(']', ' box-s]') + match[1].substring(1) + match[2].replace(']', ' box-m]');
                }
                else {
                    finalString += match[1][0] + '[box-s]' + match[1].substring(1);
                }
            }
            else if (endPos === text.length) {
                // Style fragment is at the end of the string
                if (match[2]) {
                    if (match[1].length > 1) {
                        finalString += match[1].substring(0, match[1].length - 1) + match[2].replace(']', ' box-m]') + match[1][match[1].length - 1] + match[2].replace(']', ' box-e]');
                    }
                    else {
                        finalString += match[1][match[1].length - 1] + match[2].replace(']', ' box-e]');
                    }
                }
                else {
                    if (match[1].length > 1) {
                        finalString += match[1].substring(0, match[1].length - 1) + '[box-m]' + match[1][match[1].length - 1] + '[box-e]';
                    }
                    else {
                        finalString += match[1] + '[box-e]';
                    }
                }
            }
            else {
                // Style fragment is in the middle of the string
                if (match[2]) {
                    finalString += match[1] + match[2].replace(']', ' box-m]');
                }
                else {
                    finalString += match[1] + '[box-m]';
                }
            }
            pos += match[0].length;
            match = regex.exec(text);
        }
    }
    return finalString;
}
/** A formatter which can be configured with custom `parse`, `format`, and `nullValueString` values. */
class ConfigurableFormatter {
    /** @inheritDoc */
    constructor(params) {
        var _a, _b, _c;
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        this.parse = (_a = params.parse) !== null && _a !== void 0 ? _a : ((value) => parseFloat(value));
        this.format = (_b = params.format) !== null && _b !== void 0 ? _b : ((value) => typeof value === 'number' ? value.toString() : this.nullValueString);
        this.nullValueString = (_c = params.nullValueString) !== null && _c !== void 0 ? _c : '';
    }
}
/** Contains B787 FMC parse functions and parse function factories. */
class B787FmcParsers {
    /**
     * A calibrated airspeed parser.
     * @param input The airspeed input string.
     * @returns A parsed CAS value.
     */
    static AirspeedCas(input) {
        const regex = /^\d{3}$/;
        if (!regex.test(input)) {
            return null;
        }
        const int = parseInt(input);
        return !isNaN(int) && 100 <= int && int <= 400 ? int : null;
    }
    /**
     * A Mach airspeed parser.
     * @param input The airspeed input string.
     * @param minimumValue Optionally, a minimum Mach number. Defaults to .100
     * @returns A parsed Mach value.
     */
    static AirspeedMach(input, minimumValue = .100) {
        const regex = /^.\d{1,3}$/;
        if (!regex.test(input)) {
            return null;
        }
        const int = parseFloat(input);
        return !isNaN(int) && minimumValue <= int && int <= .990 ? int : null;
    }
    /**
     * A CAS/Mach pair parser factory.
     * @param side Which side of the CDU the field is on.
     * @param order In which order the CAS/Mach pair should be entered.
     * @param minimumMach Optionally, a minimum Mach number. Defaults to .100
     * @returns A CAS/Mach parser that returns a tuple with elements of type
     * number if the input component was valid, or null if it was not.
     */
    static AirspeedCasMachPair(side, order, minimumMach) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            let casStr;
            let machStr;
            if (order === 'cas_mach') {
                [casStr, machStr] = dataPairParserResult;
            }
            else {
                [machStr, casStr] = dataPairParserResult;
            }
            let parsedCas = null;
            if (casStr) {
                parsedCas = B787FmcParsers.AirspeedCas(casStr);
                if (parsedCas === null) {
                    return null;
                }
            }
            let parsedMach = null;
            if (machStr) {
                parsedMach = B787FmcParsers.AirspeedMach(machStr, minimumMach);
                if (parsedMach === null) {
                    return null;
                }
            }
            return parsedCas === null && parsedMach === null ? null : [parsedCas, parsedMach];
        };
    }
    /**
     * A CAS or Mach airspeed parser.
     * @param input The input string.
     * @param minimumMach Optionally, a minimum Mach number. Defaults to .100
     * @returns A tuple containing either a parsed CAS or parsed Mach (but never both), or `null` if neither.
     * If the returned tuple is non-null, then either the CAS or Mach value is guaranteed to be non-null.
     */
    static AirspeedCasOrMach(input, minimumMach) {
        const parsedCas = B787FmcParsers.AirspeedCas(input);
        const parsedMach = B787FmcParsers.AirspeedMach(input, minimumMach);
        return parsedCas === null && parsedMach === null ? null : [parsedCas, parsedMach];
    }
    /**
     * A parser which validates altitudes.
     * @param input The altitude input string.
     * @returns A parsed altitude in feet.
     */
    static Altitude(input) {
        if (!/^(\d{3,5}|FL\d{3}|-\d{4})$/.test(input)) {
            return null;
        }
        const int = /^(FL)?\d{3}$/.test(input) ?
            parseInt(input.replace('FL', '')) * 100 : // FLXXX or XXX
            MathUtils.round(parseInt(input), 10); // -XXXX or XXXX or XXXXX
        return (Number.isNaN(int) ||
            !(-1000 <= int && int <= 43100) ||
            (/^\d{4}$/.test(input) && int > 9994) ? // XXXX cannot exceed 9994
            null : int);
    }
    /**
     * A parser which validates Celsius temperatures.
     * @param input The temperature input
     * @param lowerBound the lower accepted bound, inclusive, default -Infinity
     * @param upperBound the upper accepted bound, inclusive, default Infinity.
     * @returns The temperature in Celsius or null.
     */
    static CelsiusTemperature(input, lowerBound = -Infinity, upperBound = Infinity) {
        // Valid entry is X, XX
        const regex = /^[+-]?\d{1,2}$/;
        if (!regex.test(input)) {
            return null;
        }
        const inputC = parseInt(input);
        return (!Number.isNaN(inputC) && lowerBound <= inputC && inputC <= upperBound)
            ? inputC
            : null;
    }
    /**
     * A parser which validates assumed thrust temperatures.
     * @param input The temperature input.
     * @returns The temperature in Celsius or null.
     */
    static AssumedTemp(input) {
        // Valid entry is X, XX, XXF, or XXXF
        const regex = /^(\d{1,2})|(\d{2,3}F)$/;
        if (!regex.test(input)) {
            return null;
        }
        const isF = input.endsWith('F');
        if (isF) {
            const inputF = parseInt(input.replace('F', ''));
            return (!Number.isNaN(inputF) && 32 <= inputF && inputF <= 210) ?
                UnitType.CELSIUS.convertFrom(inputF, UnitType.FAHRENHEIT) : null;
        }
        else {
            const inputC = parseInt(input);
            return (!Number.isNaN(inputC) && 0 <= inputC && inputC <= 99) ?
                inputC : null;
        }
    }
    /**
     * A cruise altitude parser factory.
     * @param onGroundSub Whether the aircraft is on the ground.
     * @param currentAltSub The indicated altitude.
     * @param currentCruiseAltSub The current cruise altitude.
     * @returns A cruise altitude parser.
     */
    static CruiseAltitude(onGroundSub, currentAltSub, currentCruiseAltSub) {
        return (input) => {
            const parsedAlt = B787FmcParsers.Altitude(input);
            if (parsedAlt === null) {
                return null;
            }
            if (onGroundSub.get()) {
                return parsedAlt > currentAltSub.get() ? parsedAlt : null;
            }
            else {
                return currentCruiseAltSub.get() === null ? parsedAlt : null;
            }
        };
    }
    /**
     * A parser for validating slash-seperated data pairs.
     * @param side Which side of the CDU the field is on.
     * @param input The string input.
     * @returns A tuple with either the parsed strings or null for each value.
     */
    static DataPair(side, input) {
        if (input === '/') {
            return null;
        }
        const [valA, valB] = input.split('/');
        const slashEntered = input.includes('/');
        const outboard = side === 'left' ? valA : side === 'right' && !slashEntered ? input : valB;
        const inboard = side === 'left' ? valB : side === 'right' && !slashEntered ? '' : valA;
        if (outboard && slashEntered && inboard) {
            return side === 'left' ? [outboard, inboard] : [inboard, outboard];
        }
        else if (outboard && !inboard) {
            return side === 'left' ? [outboard, null] : [null, outboard];
        }
        else if (!outboard && slashEntered && inboard) {
            return side === 'left' ? [null, inboard] : [inboard, null];
        }
        else {
            return [null, null];
        }
    }
    /**
     * A digit-only parser function factory.
     * @param maxDigits The maximum number of digits to accept.
     * @param minDigits The minimum number of digits to accept, defaults to 1.
     * @throws If `minDigits` is greater than `maxDigits`, or either value is less than 1.
     * @returns A digit-only parser.
     * */
    static DigitOnly(maxDigits, minDigits = 1) {
        if (minDigits > maxDigits || maxDigits < 1 || minDigits < 1) {
            throw new Error('Misconfigured DigitOnly parser');
        }
        return (input) => new RegExp(`^\\d{${minDigits},${maxDigits}}$`).test(input) ? parseInt(input) : null;
    }
    /**
     * A digit-only parser function factory that allows decimals.
     * @param maxIntegerDigits The maximum number of digits before the decimal point to accept.
     * @param minIntegerDigits The minimum number of digits before the decimal point to accept, defaults to 1.
     * @param maxDecimalDigits The maximum number of digits after the decimal point to accept, defaults to 1.
     * @throws If `minIntegerDigits` is greater than `maxIntegerDigits`, or either of those values is less than 1,
     * or `maxDecimalDigits` is less than 0.
     * @returns A digit-only parser.
     * */
    static DigitWithDecimalOnly(maxIntegerDigits, minIntegerDigits = 1, maxDecimalDigits = 1) {
        if (minIntegerDigits > maxIntegerDigits || maxIntegerDigits < 1 || minIntegerDigits < 1 || maxDecimalDigits < 0) {
            throw new Error('Misconfigured DigitOnly parser');
        }
        const regExStr = `^\\d{${minIntegerDigits},${maxIntegerDigits}}(\\.\\d{0,${maxDecimalDigits}})?$`;
        return (input) => new RegExp(regExStr).test(input) ? parseFloat(input) : null;
    }
    /**
     * A parser which accepts speed-only or flap/speed combination entries.
     * @param side Which side of the CDU the field is on.
     * @returns The parsed flap/speed tuple or null.
     */
    static FlapSpeed(side) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            const [flapStr, speedStr] = dataPairParserResult;
            const parsedFlap = flapStr === null ? null :
                B787FmcParsers.LimitedChoice(['20', '25', '30'])(flapStr);
            const parsedSpeed = speedStr === null ? null : B787FmcParsers.AirspeedCas(speedStr);
            return parsedSpeed === null ? null : [parsedFlap, parsedSpeed];
        };
    }
    /**
     * A positive integer range parser function factory.
     * @param maxDigits The maximum number of digits to accept.
     * @param minDigits The minimum number of digits to accept.
     * @param maxValue The maximum value to accept.
     * @param minValue The minimum value to accept.
     * @returns A digit-only parser.
     * */
    static IntegerRangePositive(maxDigits, minDigits, maxValue, minValue) {
        return (input) => {
            const parsedNumber = B787FmcParsers.DigitOnly(maxDigits, minDigits)(input);
            if (parsedNumber === null) {
                return null;
            }
            return minValue <= parsedNumber && parsedNumber <= maxValue ? parsedNumber : null;
        };
    }
    /**
     * A factory which produces an integer range parser/validator functions.
     * @param maxValue The maximum allowable value.
     * @param minValue The minimum allowable value.
     * @returns A parser/validator function.
     */
    static IntegerRange(maxValue, minValue = 0) {
        return (input) => {
            if (!/^-?\d+$/.test(input)) {
                return null;
            }
            const inputNum = parseInt(input);
            return minValue <= inputNum && inputNum <= maxValue ? inputNum : null;
        };
    }
    /**
     * A factory which produces a float range parser/validator functions.
     * @param maxValue The maximum allowable value.
     * @param minValue The minimum allowable value.
     * @returns A parser/validator function.
     */
    static FloatRange(maxValue, minValue = 0) {
        return (input) => {
            const parsed = parseFloat(input);
            if (!Number.isFinite(parsed)) {
                return null;
            }
            return minValue <= parsed && parsed <= maxValue ? parsed : null;
        };
    }
    /**
     * A positive float range parser function factory.
     * @param maxIntegerDigits The maximum number of digits before the decimal point to accept.
     * @param minIntegerDigits The minimum number of digits before the decimal point to accept.
     * @param maxDecimalDigits The maximum number of digits after the decimal point to accept.
     * @param maxValue The maximum value to accept.
     * @param minValue The minimum value to accept.
     * @returns A digit-only parser.
     * */
    static FloatRangePositive(maxIntegerDigits, minIntegerDigits, maxDecimalDigits, maxValue, minValue) {
        return (input) => {
            const parsedNumber = B787FmcParsers.DigitWithDecimalOnly(maxIntegerDigits, minIntegerDigits, maxDecimalDigits)(input);
            if (parsedNumber === null) {
                return null;
            }
            const isWithinBounds = minValue <= parsedNumber && parsedNumber <= maxValue;
            return isWithinBounds ? parsedNumber : null;
        };
    }
    /**
     * A leg airspeed/altitude constraint parser.
     * @param input The input string.
     * @param side Which side of the CDU the field is on.
     * @param cruiseAlt The current cruise altitude, if it exists.
     * @param phase The vertical flight phase.
     * @returns A `BoeingVerticalDisplayModification` object if the input was valid.
     * */
    static LegAirspeedAltConstraint(input, side, cruiseAlt, phase) {
        const dataPairParserResult = B787FmcParsers.DataPair(side, input);
        if (dataPairParserResult === null) {
            return null;
        }
        const [speedStr, altStr] = dataPairParserResult;
        let setSpeed;
        let setSpeedIsMach = false;
        if (speedStr) {
            // Null if neither a CAS nor Mach can be parsed, otherwise one, and only one, of the values is guaranteed to be non-null.
            const speedTuple = B787FmcParsers.AirspeedCasOrMach(speedStr, .400);
            if (speedTuple) {
                const [cas, mach] = speedTuple;
                if (cas !== null) {
                    setSpeed = cas;
                }
                else if (mach) {
                    setSpeed = mach;
                    setSpeedIsMach = true;
                }
            }
            else {
                switch (speedStr) {
                    case 'E':
                    case 'ECON':
                        setSpeed = 'econ';
                        break;
                    case 'L':
                    case 'LRC':
                        setSpeed = 'lrc';
                        break;
                    case 'R':
                    case 'RTA':
                        setSpeed = 'rta';
                        break;
                    default:
                        return null;
                }
            }
        }
        const setAltitudes = [];
        const setAltitudeTypes = [];
        if (altStr) {
            const ALT_REGEX = /(\d{3,5}|FL\d{3}|-\d{4})([ABS])?(\d{3,5}|FL\d{3}|-\d{4})?([AB])?/;
            const matches = ALT_REGEX.exec(altStr);
            if (matches) {
                const firstAlt = matches[1];
                const firstSuffix = matches[2];
                const secondAlt = matches[3];
                const secondSuffix = matches[4];
                // Ensure all characters were captured correctly and there was nothing extraneous
                if (matches.slice(1).join('') !== matches[0]) {
                    return null;
                }
                // Ensure pattern is valid
                if (!((firstAlt && !firstSuffix && !secondAlt && !secondSuffix) || // Single number without suffix
                    (firstAlt && firstSuffix && !secondAlt && !secondSuffix) || // Single number with suffix
                    (firstAlt && firstSuffix && secondAlt && secondSuffix) // Two numbers, both with suffixes
                )) {
                    return null;
                }
                const firstAltParsed = B787FmcParsers.Altitude(firstAlt);
                if (firstAltParsed !== null) {
                    // If a cruise altitude has been set, don't allow a constraint at or above it
                    if (cruiseAlt !== null && firstAltParsed >= cruiseAlt) {
                        return null;
                    }
                    setAltitudes.push(firstAltParsed);
                }
                else {
                    return null;
                }
                if (firstSuffix) {
                    switch (firstSuffix) {
                        case 'A':
                            setAltitudeTypes.push(BoeingAltitudeEntryType.Above);
                            break;
                        case 'B':
                            setAltitudeTypes.push(BoeingAltitudeEntryType.Below);
                            break;
                        case 'S':
                            setAltitudeTypes.push(BoeingAltitudeEntryType.Step);
                            break;
                        default:
                            return null;
                    }
                }
                else {
                    setAltitudeTypes.push(BoeingAltitudeEntryType.At);
                }
                const secondAltParsed = B787FmcParsers.Altitude(secondAlt);
                if (secondAltParsed !== null) {
                    // If a cruise altitude has been set, don't allow a constraint at or above it
                    if ((cruiseAlt !== null) && (secondAltParsed >= cruiseAlt)) {
                        return null;
                    }
                    // Check to ensure that altitudes are entered in the correct order depending on the phase of flight.
                    if (((phase === VerticalFlightPhase.Climb) && (firstAltParsed >= secondAltParsed)) ||
                        ((phase === VerticalFlightPhase.Descent) && (firstAltParsed <= secondAltParsed))) {
                        return null;
                    }
                    setAltitudes.push(secondAltParsed);
                }
                else if (secondAlt) {
                    return null;
                }
                if (secondSuffix) {
                    switch (secondSuffix) {
                        case 'A':
                            setAltitudeTypes.push(BoeingAltitudeEntryType.Above);
                            break;
                        case 'B':
                            setAltitudeTypes.push(BoeingAltitudeEntryType.Below);
                            break;
                        default:
                            return null;
                    }
                }
                else if (secondAltParsed) {
                    setAltitudeTypes.push(BoeingAltitudeEntryType.At);
                }
            }
        }
        const frags = {
            [BoeingAltitudeEntryType.At]: 0,
            [BoeingAltitudeEntryType.Above]: 0,
            [BoeingAltitudeEntryType.Below]: 0,
            [BoeingAltitudeEntryType.Step]: 0,
        };
        for (const type of setAltitudeTypes) {
            frags[type]++;
        }
        // Don't allow multiple fragments with the same type
        if (setAltitudeTypes.length > 1 && Object.entries(frags).some((it) => it[1] > 1)) {
            return null;
        }
        // Don't allow more than one altitude fragment if a step is present
        if (setAltitudeTypes.length > 1 && setAltitudeTypes.some((it) => it === BoeingAltitudeEntryType.Step)) {
            return null;
        }
        // Don't allow nonsensical window constraints
        if (setAltitudeTypes.length > 1 &&
            setAltitudeTypes[0] === BoeingAltitudeEntryType.Above &&
            setAltitudeTypes[1] === BoeingAltitudeEntryType.Below) {
            if (setAltitudes[0] > setAltitudes[1] || setAltitudes[0] === setAltitudes[1]) {
                return null;
            }
        }
        if (setAltitudeTypes.length > 1 &&
            setAltitudeTypes[0] === BoeingAltitudeEntryType.Below &&
            setAltitudeTypes[1] === BoeingAltitudeEntryType.Above) {
            if (setAltitudes[1] > setAltitudes[0] || setAltitudes[0] === setAltitudes[1]) {
                return null;
            }
        }
        return {
            setSpeed,
            setSpeedIsMach,
            setAltitudes,
            setAltitudeTypes,
        };
    }
    /**
     * A factory which produces limited-choice parser/validator functions.
     * @param validInputs An array of valid input values.
     * @returns A parser/validator function.
     */
    static LimitedChoice(validInputs) {
        return (input) => validInputs.includes(input) ? parseInt(input) : null;
    }
    /**
     * A factory which produces regular expression parser/validator public static s.
     * @param expression A regular expression to test the input against.
     * @returns A parser/validator function.
     */
    static RegExp(expression) {
        return (input) => expression.test(input) ? parseInt(input) : null;
    }
    /**
     * A reserve fuel parser factory.
     * @param maxReserves Maximum reserve fuel weight.
     * @returns A reserve fuel parser which takes a value in thousands and returns a value in ones.
     */
    static ReservesWeight(maxReserves) {
        return (input) => {
            let invalidCount = 0;
            let decimalCount = 0;
            let numeralCount = 0;
            Array.from(input).forEach((char) => {
                if (!/^\d|\.$/.test(char)) {
                    invalidCount++;
                }
                char === '.' ? decimalCount++ : numeralCount++;
            });
            if (!(decimalCount <= 1 && numeralCount <= 4) || (invalidCount > 0)) {
                return null;
            }
            const parsedVal = parseFloat(input);
            if (isNaN(parsedVal)) {
                return null;
            }
            return parsedVal <= (maxReserves.get() / 1000) ? parsedVal * 1000 : null;
        };
    }
    /**
     * A runway entry parser.
     * @param plan The flight plan for FMC render.
     * @param facLoader An instance of {@link FacilityLoader}
     * @param checkSid Whether to reject the input if it is not found in the departure procedure.
     * @returns A {@link OneWayRunway} or `null` if not found.
     */
    static Runway(plan, facLoader, checkSid) {
        return async (input) => {
            let runwayDesignation = input;
            if (input.slice(0, 2) === 'RW') {
                runwayDesignation = input.slice(2);
            }
            if (plan.originAirport) {
                const originAirport = await facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                const departureIndex = plan.procedureDetails.departureIndex;
                const onewayRunway = RunwayUtils.matchOneWayRunwayFromDesignation(originAirport, runwayDesignation);
                if (!onewayRunway) {
                    return null;
                }
                if (checkSid && departureIndex !== -1) {
                    // SID is departure procedure in this context.
                    const procedure = originAirport.departures[departureIndex];
                    const index = procedure.runwayTransitions.findIndex((transition) => transition.runwayNumber === (onewayRunway === null || onewayRunway === void 0 ? void 0 : onewayRunway.direction) && transition.runwayDesignation === onewayRunway.runwayDesignator);
                    if (index === -1) {
                        return Promise.reject(BoeingFmcErrorKeys.RunwayNaForSid);
                    }
                }
                return onewayRunway !== null && onewayRunway !== void 0 ? onewayRunway : null;
            }
            return null;
        };
    }
    /**
     * A runway/position shift parser factory.
     * @param side Which side of the CDU the field is on.
     * @param plan The flight plan for FMC render.
     * @param facLoader An instance of {@link FacilityLoader}
     * @returns A runway/position shift parser for a given CDU side.
     */
    static RunwayPositionShift(side, plan, facLoader) {
        return async (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return [null, null];
            }
            const [rwyStr, posStr] = dataPairParserResult;
            const parsedRwy = rwyStr ?
                await B787FmcParsers.Runway(plan, facLoader, false)(rwyStr) : null;
            // The display of M or FT is determined by the metric runway OPC option.
            // Valid position shift entries when FT is displayed range from 0 to 99 followed by two zeros (00).
            // Valid entries when M is displayed range from 0 to 30 followed by two zeros (00).
            // Position entries can be preceded by an optional minus (-) or plus (+) sign.
            // Currently only supporting FT
            let parsedPos = posStr ? parseInt(posStr) : null;
            if (parsedPos === null || isNaN(parsedPos) || parsedPos < -9900 || 9900 < parsedPos || parsedPos % 100 !== 0) {
                parsedPos = null;
            }
            return parsedRwy === null && parsedPos === null ? null : [parsedRwy, parsedPos];
        };
    }
    /**
     * A factory for runway slope and condition parsers.
     * @param side Which side of the CDU the field is located.
     * @param currentSlopeSub The current runway slope value.
     * @param currentCondSub The current runway condition value.
     * @returns A tuple of runway slope/runway condition, which passes through the current value if one is omitted.
     */
    static RunwaySlopeAndCondition(side, currentSlopeSub, currentCondSub) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            const [slopeStr, condStr] = dataPairParserResult;
            let parsedSlope = currentSlopeSub.get();
            let parsedCond = currentCondSub.get();
            if (slopeStr !== null) {
                if (/^[UD]?(\d|\.\d|\d\.\d)$/.test(slopeStr)) {
                    const slopeNumber = parseFloat(slopeStr.replace(/[UD]/, ''));
                    if (slopeNumber < 0 || slopeNumber > 2) {
                        return null;
                    }
                    parsedSlope = slopeStr.startsWith('D') ? -1 * slopeNumber : slopeNumber;
                }
                else {
                    return null;
                }
            }
            if (condStr !== null) {
                if (/^[DWS]$/.test(condStr)) {
                    parsedCond =
                        condStr === 'D' ? RunwayCondition.DRY :
                            condStr === 'W' ? RunwayCondition.WET :
                                RunwayCondition.WET_SKID_RES;
                }
                else {
                    return null;
                }
            }
            return [parsedSlope, parsedCond];
        };
    }
    /**
     * A factory that returns a climb speed restriction parser.
     * @param side Which side of the CDU the field is on.
     * @param climbSpeed The current programmed climb speed.
     * @param currentAlt The current altitude.
     * @param cruiseAlt The set cruise altitude.
     * @returns A speed restriction parser/validator.
     */
    static SpeedRestrictionClimb(side, climbSpeed, currentAlt, cruiseAlt) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            const [casStr, altStr] = dataPairParserResult;
            const parsedCas = casStr === null ? null : B787FmcParsers.AirspeedCas(casStr);
            const parsedAlt = altStr === null ? null : B787FmcParsers.Altitude(altStr);
            const climbSpeedVal = climbSpeed.get();
            const cruiseAltVal = cruiseAlt.get();
            if (parsedCas && parsedAlt) {
                const speedLTOETClimbSpeed = climbSpeedVal ? parsedCas <= climbSpeedVal : true;
                const altGTOETCurrentAlt = parsedAlt >= currentAlt.get();
                const altLTCruiseAlt = cruiseAltVal ? parsedAlt < cruiseAltVal : false;
                if (speedLTOETClimbSpeed && altGTOETCurrentAlt && altLTCruiseAlt) {
                    return [parsedCas, parsedAlt];
                }
            }
            return null;
        };
    }
    /**
     * A factory that returns a descent speed restriction parser.
     * @param side Which side of the CDU the field is on.
     * @param descentSpeedSub The current programmed descent speed.
     * @param currentAlt The current altitude.
     * @param cruiseAltSub The set cruise altitude.
     * @param endOfDescentDispDataSub An end of descent display data object.
     * @param climbSegmentExists Whether or not a climb segment exists in the flight plan.
     * @returns A speed restriction parser/validator.
     */
    static SpeedRestrictionDescent(side, descentSpeedSub, currentAlt, cruiseAltSub, endOfDescentDispDataSub, climbSegmentExists) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            const [casStr, altStr] = dataPairParserResult;
            const parsedCas = casStr === null ? null : B787FmcParsers.AirspeedCas(casStr);
            const parsedAlt = altStr === null ? null : B787FmcParsers.Altitude(altStr);
            const descentSpeed = descentSpeedSub.get();
            const cruiseAlt = cruiseAltSub.get();
            const endOfDescentDispData = endOfDescentDispDataSub.get();
            if (parsedCas && parsedAlt) {
                const speedLTOETDescentSpeed = descentSpeed === null ? true : parsedCas <= descentSpeed;
                const altGTEndOfDescent = endOfDescentDispData === null ? false : parsedAlt > ArrayUtils.last(endOfDescentDispData.altitudes);
                const altLTCruiseAlt = cruiseAlt === null ? false : parsedAlt < cruiseAlt;
                const altLTOETCurrentAlt = climbSegmentExists.get() ? true : parsedAlt <= currentAlt.get();
                if (speedLTOETDescentSpeed && altGTEndOfDescent && altLTCruiseAlt && altLTOETCurrentAlt) {
                    return [parsedCas, parsedAlt];
                }
            }
            return null;
        };
    }
    /**
     * A thrust reduction parser.
     * @param input The input string.
     * @returns A flap setting of 1 or 5, or an altitude between 400 and 9999 feet.
     */
    static ThrustReduction(input) {
        const parsedFlap = B787FmcParsers.DigitOnly(1)(input);
        const parsedAlt = B787FmcParsers.IntegerRangePositive(4, 3, 9999, 400)(input);
        if (parsedFlap === 1 || parsedFlap === 5) {
            return parsedFlap;
        }
        else if (parsedAlt !== null) {
            return parsedAlt;
        }
        else {
            return null;
        }
    }
    /**
     * A parser for weights.
     * @param input The weight string.
     * @returns A parsed weight.
     */
    static Weight(input) {
        // Valid entry is XXX or XXX.X.
        return /^\d{3}(\.\d)?$/.test(input) ? parseFloat(input) * 1000 : null;
    }
    /**
     * A runway wind parser factory.
     * @param runwaySub The selected runway, may be null.
     * @returns A runway head/tailwind parser.
     */
    static WindRunway(runwaySub) {
        return (input) => {
            const runway = runwaySub.get();
            if (runway === null) {
                return null;
            }
            const inputIsValid = /^\d\d[HT]?$/.test(input);
            if (!inputIsValid) {
                return null;
            }
            const isTailwind = input.endsWith('T');
            const runwayDir = runway.course - Facilities.getMagVar(runway.latitude, runway.longitude);
            const direction = isTailwind ? NavMath.reciprocateHeading(runwayDir) : runwayDir;
            const speedString = input.replace(/[HT]/, '');
            const speed = parseInt(speedString);
            return { direction, speed, trueDegrees: false };
        };
    }
    /**
     * A wind vector parser factory.
     * @param side Which side of the CDU the field is on.
     * @param currentWindSub The current wind entry subscribable, may be null.
     * @returns A wind vector parser for a given CDU side.
     */
    static WindVector(side, currentWindSub) {
        return (input) => {
            const dataPairParserResult = B787FmcParsers.DataPair(side, input);
            if (dataPairParserResult === null) {
                return null;
            }
            const [dirStr, magStr] = dataPairParserResult;
            let parsedDir = dirStr ?
                B787FmcParsers.DigitOnly(3, 3)(dirStr) : null;
            if (parsedDir !== null) {
                if (parsedDir < 0 || parsedDir > 360) {
                    return null;
                }
                else if (parsedDir === 360) {
                    parsedDir = 0;
                }
            }
            const parsedMag = magStr ?
                B787FmcParsers.DigitOnly(3)(magStr) : null;
            if (parsedMag !== null && (parsedMag < 0 || parsedMag > 250)) {
                return null;
            }
            const currentWind = currentWindSub.get();
            if (parsedDir !== null && parsedMag !== null) {
                // Both dir and mag exist, so assign new values to both
                return {
                    direction: parsedDir,
                    speed: parsedMag,
                    trueDegrees: false,
                };
            }
            else if (currentWind) {
                // At least one new value is absent, but have a previous value, so fall back to it
                return {
                    direction: parsedDir !== null && parsedDir !== void 0 ? parsedDir : currentWind.direction,
                    speed: parsedMag !== null && parsedMag !== void 0 ? parsedMag : currentWind.speed,
                    trueDegrees: false,
                };
            }
            else {
                // The initial entry must contain both a direction and a magnitude
                return null;
            }
        };
    }
    /**
     * A UTC time parser factory.
     * The parser will find the next occurence of the specified time in the future (according to sim time).
     * @param simTime Simtime as a unix timestamp in ms
     * @returns A UTC time parser.
     */
    static UtcTime(simTime) {
        return (input) => {
            const match = input.match(/^(\d{2})(\d{2})Z$/);
            if (match === null) {
                return null;
            }
            const hour = parseInt(match[1]);
            const minute = parseInt(match[2]);
            B787FmcParsers.dateCache.setTime(simTime.get());
            let desired = Date.UTC(B787FmcParsers.dateCache.getUTCFullYear(), B787FmcParsers.dateCache.getUTCMonth(), B787FmcParsers.dateCache.getUTCDate(), hour, minute);
            if (desired <= B787FmcParsers.dateCache.getTime()) {
                desired = Date.UTC(B787FmcParsers.dateCache.getUTCFullYear(), B787FmcParsers.dateCache.getUTCMonth(), B787FmcParsers.dateCache.getUTCDate() + 1, hour, minute);
            }
            return desired;
        };
    }
    /**
     * A zero fuel weight parser factory.
     * @param maxGw Maximum gross weight.
     * @param minZfw Minimum zero fuel weight.
     * @param maxZfw Maximum zero fuel weight.
     * @returns A zero fuel weight parser which takes a value in thousands and returns a value in ones.
     */
    static ZeroFuelWeight(maxGw, minZfw, maxZfw) {
        return (input) => {
            const parsedVal = B787FmcParsers.Weight(input);
            if (parsedVal === null) {
                return null;
            }
            const lowerThanMaxGW = parsedVal <= maxGw.get();
            const inZfwRange = minZfw.get() <= parsedVal && parsedVal <= maxZfw.get();
            return lowerThanMaxGW && inZfwRange ? parsedVal : null;
        };
    }
    /**
     * A bearing parser factory
     *
     * @returns A bearing parser
     */
    static Bearing() {
        return (input) => {
            const match = input.match(/^(\d{1,3})(T?)$/);
            if (!match) {
                return null;
            }
            const bearingStr = match[1];
            const isTrueRef = !!match[2];
            let bearingInt = parseInt(bearingStr);
            if (!Number.isFinite(bearingInt)) {
                return null;
            }
            if (bearingInt === 360) {
                bearingInt = 0;
            }
            return { value: bearingInt, isTrueRef };
        };
    }
}
B787FmcParsers.dateCache = new Date();
/** Contains B748 FMC format functions and format function factories. */
class B748FmcFormatters {
    /**
     * A formatter for the Assumed Temp field.
     * @param data The data.
     * @param data."0" The assumed temperature.
     * @param data."1" The takeoff thrust mode.
     * @returns A formatted string.
     */
    static AssumedTempInput([temp, limit]) {
        return `${temp ? `${temp.toFixed(0).padStart(3)}°C` : '---  '} ${limit}`;
    }
    /**
     * A formatter for Assumed Temp/Outside Air Temp pairs.
     * @param data The data.
     * @param data."0" The assumed temperature.
     * @param data."1" The outside air temperature.
     * @returns A formatted assumed temp/oat pair.
     */
    static AssumedOatTempPair([assumedTemp, outsideTemp]) {
        const assumedTempFormatter = B787FmcFormatters.Unit('°[d-text]C', { spaceBetween: false, padString: ' ', padStart: 3, type: 'display' });
        const outsideTempFormatter = B787FmcFormatters.Unit('°[d-text]C', { spaceBetween: false });
        // Don't show the unit when null
        return `${assumedTemp === null ? '---  ' : assumedTempFormatter(assumedTemp)}     ${outsideTempFormatter(outsideTemp)}`;
    }
    /**
     * A formatter for center of gravity and trim.
     * @param data The data.
     * @param data.0 Center of gravity (as a value between 0 and 100).
     * @param data.1 Stabilizer trim setting.
     * @returns The center of gravity in an input box and the trim setting, if it exists.
     */
    static CenterOfGravityTrim([cg, trim]) {
        const cgOutput = cg === null ? '□□' : B787FmcFormatters.Unit('%', {
            type: 'input',
            spaceBetween: false,
            padStart: 2,
            padString: '0',
        })(cg);
        const trimOutput = trim === null ? '' : trim.toFixed(1).padStart(4, ' ');
        return `${cgOutput}  ${trimOutput}`;
    }
    /**
     * A climb/descent waypoint constraint field formatter.
     * @param page Which page to return the formatter for.
     * @returns A formatter which takes a {@link BoeingVerticalDisplayData} input.
     */
    static ConstraintField(page) {
        return (verticalDisplayData) => {
            if (verticalDisplayData) {
                const speed = verticalDisplayData.speed;
                let speedConstraintString = '';
                if (typeof speed === 'number' && !verticalDisplayData.speedIsPredicted) {
                    speedConstraintString = verticalDisplayData.speedIsMach ?
                        speed.toFixed(3).substring(1) :
                        speed.toFixed(0);
                    if (verticalDisplayData.speedIsCommanded) {
                        speedConstraintString += '[magenta]';
                    }
                    speedConstraintString += '/[d-text]';
                }
                let altitudeConstraintString = '';
                if (verticalDisplayData.altitudes.length > 0) {
                    const alt = page === 'CLB' ?
                        Math.max(...verticalDisplayData.altitudes) :
                        Math.min(...verticalDisplayData.altitudes);
                    const altIndex = verticalDisplayData.altitudes.indexOf(alt);
                    altitudeConstraintString = verticalDisplayData.altitudesAreFlightLevels[altIndex] ?
                        `FL${(alt / 100).toFixed(0).padStart(3, '0')}` :
                        alt.toFixed(0).padStart(5, ' ');
                    altitudeConstraintString += verticalDisplayData.altitudeSuffixes[altIndex];
                    const altStyleStr = [];
                    if (verticalDisplayData.altitudeIsCommanded) {
                        altStyleStr.push('magenta');
                    }
                    altStyleStr.push(verticalDisplayData.altitudesArePredicted ? 's-text' : 'd-text');
                    altitudeConstraintString += `[${altStyleStr.join(' ')}]`;
                }
                else {
                    altitudeConstraintString = '------';
                }
                return `${speedConstraintString}${altitudeConstraintString}`;
            }
            else {
                return '';
            }
        };
    }
}
/** Contains B787 FMC format functions and format function factories. */
class B787FmcFormatters {
    /**
     * A formatter for calibrated airspeeds.
     * @param type Whether the field is an input or a display.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` if the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @returns A CAS airspeed formatter.
     */
    static AirspeedCas(type, targetCas) {
        return (cas) => {
            const spdStr = cas.toString().padStart(3, ' ');
            const spdStrWithStyling = targetCas && targetCas.get() === cas ? `${spdStr}[magenta]` : spdStr;
            return type === 'input' ? inputBox(spdStrWithStyling) : spdStrWithStyling;
        };
    }
    /**
     * A formatter for Mach airspeeds.
     * @param type Whether the field is an input or a display.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @returns A Mach airspeed formatter.
     */
    static AirspeedMach(type, targetMach) {
        return (mach) => {
            const target = targetMach === null || targetMach === void 0 ? void 0 : targetMach.get();
            const isFmsCommand = typeof target === 'number' && Math.round(target * 1000) === Math.round(mach * 1000);
            const spdStr = `.${Math.round(mach * 1000)}${isFmsCommand ? '[magenta]' : ''}`;
            return type === 'input' ? inputBox(spdStr) : spdStr;
        };
    }
    /**
     * A formatter factory for airspeed CAS/Mach pairs.
     * @param modality Whether the field is an input or a display.
     * @param displayType Whether the field displays a single value or a pair of values.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @throws If type 'single' is passed and both values are null or both values are numbers.
     * @returns A CAS/Mach airspeed pair formatter.
     */
    static AirspeedCasAndOrMach(modality, displayType, targetCas, targetMach) {
        return ([cas, mach]) => {
            const casStr = cas === null ? '---' : B787FmcFormatters.AirspeedCas('display', targetCas)(cas);
            const machStr = mach === null ? '----' : B787FmcFormatters.AirspeedMach('display', targetMach)(mach);
            let valueStr;
            switch (displayType) {
                case 'cas_mach':
                    valueStr = `${casStr}/[d-text]${machStr}`;
                    break;
                case 'mach_cas':
                    valueStr = `${machStr}/[d-text]${casStr}`;
                    break;
                case 'single':
                    if ((cas === null && mach === null) || (cas !== null && mach !== null)) {
                        throw new Error('AirspeedCasAndOrMach formatter cannot be used in "single" mode unless one value is null and the other is a number');
                    }
                    valueStr = cas ? casStr : machStr;
                    break;
            }
            return modality === 'input' ? inputBox(valueStr) : valueStr;
        };
    }
    /**
     * A calibrated airspeed/altitude pair formatter factory.
     * @param type Whether the field is an input or a display.
     * @param transitionAlt The transition altitude, in feet.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @returns A formatted CAS/Alt pair formatter.
     */
    static AirspeedCasAltitudePair(type, transitionAlt, targetCas) {
        return ([cas, alt]) => {
            const casStr = cas === null ? '---' : B787FmcFormatters.AirspeedCas('display', targetCas)(cas);
            const altStr = alt === null ? '-----' : B787FmcFormatters.Altitude(type, transitionAlt)(alt);
            const str = `${casStr}/${altStr}`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A CAS or Mach airspeed formatter, depending on the speed unit type.
     * @param targetCas Optional: The CAS which the FMS is actively targeting (or `null` when the FMS is targeting Mach).
     * The speed will appear magenta when it is equal to this value.
     * @param targetMach Optional: The Mach which the FMS is actively targeting (or `null` when the FMS is targeting CAS).
     * The speed will appear magenta when it is equal to this value.
     * @returns A formatted CAS or Mach, depending on the speed unit type.
     */
    static AirspeedCasOrMach(targetCas, targetMach) {
        return ([cas, mach, unit]) => unit === 'cas' ?
            cas === null ? '' : B787FmcFormatters.AirspeedCas('input', targetCas)(cas) :
            mach === null ? '' : B787FmcFormatters.AirspeedMach('input', targetMach)(mach);
    }
    /**
     * An altitude formatter factory.
     * @param type Whether the field is an input or a display.
     * @param transitionAltSub The transition altitude, in feet.
     * @param targetAltSub Optional: The altitude which the FMS is actively targeting.
     * The altitude will appear magenta when it is equal to this value.
     * @returns An altitude formatter.
     */
    static Altitude(type, transitionAltSub, targetAltSub) {
        return (value) => {
            const altStr = (value < transitionAltSub.get()) ?
                `${Math.round(value).toString().padStart(5, ' ')}` :
                `FL${Math.round(value / 100).toString().padStart(3, '0').substring(0, 3)}`;
            const altStrWithStyling = (targetAltSub === null || targetAltSub === void 0 ? void 0 : targetAltSub.get()) === value ? `${altStr}[magenta]` : altStr;
            return type === 'input' ? inputBox(altStrWithStyling) : altStrWithStyling;
        };
    }
    /**
     * A formatter factory for altitudes in feet.
     * @param type Whether the field is an input or a display.
     * @returns A altitude in feet formatter.
     */
    static AltitudeFeet(type) {
        return (alt) => {
            const str = alt.toString().padStart(5, ' ');
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A climb/descent waypoint constraint header formatter factory.
     * @param leg The constraint's associated {@link LegDefinition}, if it exists.
     * @returns A climb/descent waypoint constraint header formatter.
     */
    static ConstraintHeader(leg) {
        var _a;
        if (leg) {
            const prefix = BoeingFmsUtils.isHoldAtLeg(leg.leg.type) ? 'HOLD ' : '';
            let suffix;
            switch (leg.leg.type) {
                case LegType.FM:
                case LegType.VM:
                    suffix = 'VECTORS';
                    break;
                case LegType.CI:
                case LegType.VI:
                case LegType.PI:
                    suffix = '(INTC)';
                    break;
                default:
                    suffix = (_a = leg.name) !== null && _a !== void 0 ? _a : '';
                    break;
            }
            return `${prefix}AT ${suffix}`;
        }
        else {
            return '';
        }
    }
    /**
     * A climb/descent waypoint constraint field formatter.
     * @param verticalDisplayData An object containing vertical display data.
     * @returns A formatted climb/descent constraint.
     */
    static ConstraintField(verticalDisplayData) {
        if (verticalDisplayData) {
            const speed = verticalDisplayData.speed;
            let speedConstraintString = '';
            if (typeof speed === 'number' && !verticalDisplayData.speedIsPredicted) {
                speedConstraintString = verticalDisplayData.speedIsMach ?
                    speed.toFixed(3).substring(1) :
                    speed.toFixed(0);
                if (verticalDisplayData.speedIsCommanded) {
                    speedConstraintString += '[magenta]';
                }
                speedConstraintString += '/[d-text]';
            }
            let altitudeConstraintString = '';
            if (verticalDisplayData.altitudes.length > 0) {
                for (let i = 0; i < verticalDisplayData.altitudes.length; i++) {
                    const altitude = verticalDisplayData.altitudes[i];
                    const isFlightLevel = verticalDisplayData.altitudesAreFlightLevels[i];
                    const suffix = verticalDisplayData.altitudeSuffixes[i];
                    let str = '';
                    if (isFlightLevel) {
                        str += `FL${(altitude / 100).toFixed(0).padStart(3, '0')}`;
                    }
                    else {
                        str += altitude.toFixed(0).padStart(5, ' ');
                    }
                    str += suffix;
                    altitudeConstraintString += str;
                }
                const altStyleStr = [];
                if (verticalDisplayData.altitudeIsCommanded) {
                    altStyleStr.push('magenta');
                }
                altStyleStr.push(verticalDisplayData.altitudesArePredicted ? 's-text' : 'd-text');
                altitudeConstraintString += `[${altStyleStr.join(' ')}]`;
            }
            else {
                altitudeConstraintString = '------';
            }
            return `${speedConstraintString}${altitudeConstraintString}`;
        }
        else {
            return '';
        }
    }
    /**
     * A flight level formatter factory.
     * @param type Whether the field is an input or a display.
     * @returns A flight level formatter.
     */
    static FlightLevel(type) {
        return (value) => {
            const str = `FL${Math.round(value / 100).toString().padStart(3, '0').substring(0, 3)}`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A formatter for the Assumed Temp field.
     * @param type the formatter type
     * @returns A formatted string.
     */
    static AssumedTempInput(type) {
        return ([temp, limit]) => {
            const formatted = temp ? temp.toFixed(0).padStart(3) : '---';
            return `${type === 'display' ? formatted : inputBox(formatted)}°C ${limit}`;
        };
    }
    /**
     * A formatter for Assumed Temp/Outside Air Temp pairs.
     * @param data The data.
     * @param data."0" The assumed temperature.
     * @param data."1" The outside air temperature.
     * @returns A formatted assumed temp/oat pair.
     */
    static AssumedOatTempPair([assumedTemp, outsideTemp]) {
        const assumedTempFormatter = B787FmcFormatters.Unit('°C', { spaceBetween: false, padString: ' ', padStart: 3, type: 'inputWithUnit' }, '---');
        const outsideTempFormatter = B787FmcFormatters.Unit('°C', { spaceBetween: false, fontSize: 'small' });
        return `${assumedTempFormatter(assumedTemp)}/${outsideTempFormatter(outsideTemp)}`;
    }
    /**
     * A formatter for center of gravity and trim.
     * @param type the formatter type
     * @returns The center of gravity in an input box and the trim setting, if it exists.
     */
    static CenterOfGravityTrim(type) {
        const cgFormatter = B787FmcFormatters.Unit('%', { type, spaceBetween: false, padStart: 2, padString: ' ' }, '□□');
        const trimFormatter = NumberFormatter.create({ precision: 0.25 });
        return ([cg, trim]) => {
            const trimOutput = trim === null ? '' : trimFormatter(trim);
            return `${cgFormatter(cg)}  ${trimOutput}`;
        };
    }
    /**
     * A formatter for the Flap/Speed field.
     * @param input The input
     * @param input."0" The flap setting.
     * @param input."1" The airspeed.
     * @returns A formatted string.
     */
    static FlapSpeed([flap, speed]) {
        return `${inputBox(`${flap === null ? '--' : flap.toString().padStart(2, ' ')}°/${speed.toString().padStart(3, ' ')}[d-text]`)}KT[s-text]`;
    }
    /**
     * A formatter for the Flight Path Angle/Vertical Bearing/Vertical Speed field.
     * @param spacing The reference spacing.
     * @returns A formatting function.
     */
    static FpaVbVs(spacing) {
        return ([distToWaypointRad, waypointAltFt, currentAltFt, groundSpeedKts, verticalSpeedFpm]) => {
            if (distToWaypointRad === null || waypointAltFt === null || currentAltFt < waypointAltFt) {
                return '';
            }
            const fpa = VNavUtils.getFpa(UnitType.KNOT.convertTo(groundSpeedKts, UnitType.FPM), verticalSpeedFpm);
            const vb = VNavUtils.getFpa(UnitType.FOOT.convertFrom(distToWaypointRad, UnitType.GA_RADIAN), currentAltFt - waypointAltFt);
            const vs = VNavUtils.getRequiredVs(UnitType.NMILE.convertFrom(distToWaypointRad, UnitType.GA_RADIAN), waypointAltFt, currentAltFt, groundSpeedKts);
            const fpaClamped = MathUtils.clamp(-1 * fpa, 0, 9.9);
            const vbClamped = MathUtils.clamp(vb, 0, 9.9);
            const vsClamped = MathUtils.clamp(-1 * vs, 0, 9999);
            const fpaStr = isNaN(fpa) || fpa > -0.02 ? '' : fpaClamped.toFixed(1);
            const vbStr = vbClamped.toFixed(1).padStart(spacing + 2, ' ');
            const vsStr = vsClamped.toFixed(0).padStart(spacing + 3, ' ');
            return `${fpaStr}${vbStr}${vsStr}`;
        };
    }
    /**
     * A formatter for the line six FMC PREFLIGHT COMPLETE header.
     * @param preflightComplete Whether preflight has been completed.
     * @param isOnGround Whether the aircraft is on the ground.
     * @param isAfterTakeoff Whether the flight phase is after takeoff.
     * @returns A PRE-FLT message, white-on-green FMC PREFLIGHT COMPLETE message, or a dashed line.
     */
    static PreflightCompleteHeader(preflightComplete, isOnGround, isAfterTakeoff) {
        const line6HeaderOnGroundBeforeTakeoff = preflightComplete ?
            ['------------------', '------------------', 'F[bg-dark-green bg-start]MC PREFLIGHT COMPLET[bg-dark-green]E[bg-dark-green bg-end]'] :
            ['--------------------------------------', ' PRE-FLT'];
        const line6HeaderInAir = ['--------------------------------------'];
        return !isOnGround || isAfterTakeoff ? line6HeaderInAir : line6HeaderOnGroundBeforeTakeoff;
    }
    /**
     * A formatter for takeoff runway/position shift.
     * @param type The formatter type.
     * @param textSize The text size.
     * @returns A formatted runway/position shift pair.
     */
    static RunwayPositionShift(type, textSize) {
        const posFormatter = B787FmcFormatters.Unit('FT', { type, spaceBetween: false, forceSign: true, fontSize: textSize });
        return ([originRwy, takeoffRwy, takeoffRwyPos]) => {
            const rwy = takeoffRwy !== null && takeoffRwy !== void 0 ? takeoffRwy : originRwy;
            const rwyStr = rwy ? rwy.designation.padEnd(3, ' ') : '---';
            const posStr = takeoffRwyPos !== null ? posFormatter(takeoffRwyPos) : '----';
            return type !== 'display' ? inputBox(`${rwyStr}/${posStr}`) : `${rwyStr}/${posStr}`;
        };
    }
    /**
     * A formatter for runway slope and condition.
     * @param input The input
     * @param input."0" The runway slope (negative is downhill, positive is uphill).
     * @param input."1" The runway condition.
     * @returns A formatted runway slope/condition pair.
     */
    static RunwaySlopeAndCondition([slope, cond]) {
        const slopeStr = `${slope < 0 ? 'D' : 'U'}${NumberFormatter.create({ precision: 0.1 })(Math.abs(slope))}`;
        return inputBox(`${slopeStr}/${cond.padEnd(8, ' ')}`);
    }
    /**
     * A formatter factory for the Takeoff Gross Weight field.
     * @param unit The unit subscribable.
     * @param spacing The amount of spacing to use.
     * @param type The formatter type.
     * @param fontSize The text size.
     * @returns A formatter.
     */
    static TakeoffGrossWeightInput(unit, spacing, type, fontSize) {
        const gwDisplayFormatter = B787FmcFormatters.Weight('display', unit, fontSize);
        const inputFormatter = B787FmcFormatters.Weight(type, unit, fontSize);
        const textStyle = `${fontSize === 'large' ? 'd' : 's'}-text`;
        return ([grwt, togw]) => {
            let togwDisplay;
            if (togw) {
                togwDisplay = inputFormatter(togw);
            }
            else {
                const nullString = type === 'input' ? inputBox(`---.-[${textStyle}]`) : `---.-[${textStyle}]`;
                togwDisplay = grwt ? nullString : inputFormatter(togw);
            }
            return `${gwDisplayFormatter(grwt)}${' '.repeat(spacing)}[${textStyle}]${togwDisplay}`;
        };
    }
    /**
     * A thrust reduction point formatter.
     * @param type The formatter type.
     * @param altitudeFontSize The altitude font size.
     * @returns The climb thrust mode and thrust reduction point as either a flap setting or altitude.
     */
    static ThrustReduction(type, altitudeFontSize) {
        const altitudeFormatter = B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type, fontSize: altitudeFontSize });
        return ([climbThrust, thrustReduction]) => {
            const reductionStr = thrustReduction > 100 ?
                // Thrust reduction point is an altitude
                altitudeFormatter(thrustReduction) :
                // Thrust reduction point is a single-digit flap setting
                `FLAPS [s-text]${type !== 'display' ? inputBox(thrustReduction.toString()) : thrustReduction.toString()}`;
            return `${climbThrust.padEnd(6, ' ')}[s-text]${reductionStr}`;
        };
    }
    /**
     * Formats a value with a unit.
     * @param unit The unit to display.
     * @param suppliedOptions The options object.
     * @param nullValueString The string to display when the value is null.
     * @returns A unit formatter function.
     */
    static Unit(unit, suppliedOptions, nullValueString = '') {
        const defaults = {
            precision: 0,
            padStart: 0,
            padString: '-',
            spaceBetween: true,
            forceSign: false,
            type: 'display',
            fontSize: 'large',
            unitSize: 'small',
            prefix: '',
            absoluteValue: false,
        };
        const options = Object.assign(defaults, suppliedOptions);
        return (value) => {
            const signString = options.forceSign && (value === null || value >= 0) ? '+[d-text]' : '';
            let valueString = value === null
                ? nullValueString.padStart(options.padStart, options.padString)
                : (options.absoluteValue ? Math.abs(value) : value).toFixed(options.precision).padStart(options.padStart, options.padString);
            if (valueString) {
                valueString = `${valueString}${options.fontSize === 'large' ? '[d-text]' : '[s-text]'}`;
            }
            const inputString = options.type === 'input' ? inputBox(valueString) : valueString;
            const spaceString = options.spaceBetween ? ' ' : '';
            const unitString = unit ? `${SubscribableUtils.isSubscribable(unit) ? unit.get() : unit}${options.unitSize === 'large' ? '[d-text]' : '[s-text]'}` : '';
            const inputSpaceUnitString = options.type === 'inputWithUnit'
                ? inputBox(`${inputString}${spaceString}${unitString}`)
                : `${inputString}${spaceString}${unitString}`;
            return `${options.prefix}${signString}${inputSpaceUnitString}`;
        };
    }
    /**
     * UTC time formatter factory.
     * The formatter outputs the format HHMMZ from a unix timestamp in ms.
     * @param type 'input' for an inputBox or 'display' for a plain string
     * @param suffix Suffix after the 4-digit time value, default 'Z'
     * @returns A UTC time formatter.
     */
    static UtcTime(type, suffix) {
        return (value) => {
            B787FmcFormatters.dateCache.setTime(value);
            const formatted = `${B787FmcFormatters.dateCache.getUTCHours().toFixed(0).padStart(2, '0')}${B787FmcFormatters.dateCache.getUTCMinutes().toFixed(0).padStart(2, '0')}${suffix !== null && suffix !== void 0 ? suffix : 'Z'}`;
            return type === 'input' ? inputBox(formatted) : formatted;
        };
    }
    /**
     * A formatter for weights.
     * @param type Whether the field is an input or a display.
     * @param unitSub A subscribable to unit to show the value in.
     * @param fontSize The font size. Defaults to `large`.
     * @returns The formatted weight in kilo-units.
     */
    static Weight(type, unitSub, fontSize) {
        const textStyle = fontSize === 'small' ? 's-text' : 'd-text';
        return (weight) => {
            var _a;
            const weightValue = weight === null || weight === void 0 ? void 0 : weight.asUnit((_a = unitSub === null || unitSub === void 0 ? void 0 : unitSub.get()) !== null && _a !== void 0 ? _a : weight.unit);
            const str = weightValue === undefined ? `□□□.□[${textStyle}]` : `${(weightValue / 1000).toFixed(1).padStart(5, ' ')}[${textStyle}]`;
            return type === 'input' ? inputBox(str) : str;
        };
    }
    /**
     * A wind vector formatter.
     * @param windEntry A {@link WindEntry} input.
     * @param showSpeedUnit whether to show KT at the end
     * @returns A formatted wind vector.
     */
    static WindVector(windEntry, showSpeedUnit = true) {
        const nonZeroDirection = windEntry.direction === 0 ? 360 : windEntry.direction;
        const dirStr = nonZeroDirection.toString().padStart(3, '0');
        const speedStr = windEntry.speed.toString().padStart(3, ' ');
        const degreesStr = windEntry.trueDegrees ? 'T' : '°';
        const formattedStr = `${dirStr}${degreesStr}/${speedStr}`;
        const speedUnitText = showSpeedUnit ? 'KT[s-text]' : '';
        return `${inputBox(`${formattedStr}[d-text]`)}${speedUnitText}`;
    }
    /** A wind component formatter factory for runway winds.
     * @param runwaySub The runway to which the winds are to be displayed relative to.
     * @returns A formatter for displaying wind components relative to the given runway's heading.
     */
    static WindComponentsRunway(runwaySub) {
        return (wind) => {
            const runway = runwaySub.get();
            if (runway === null) {
                return B787FmcFormatters.Unit('KT', { spaceBetween: false, type: 'input' }, '---')(null);
            }
            const magVar = Facilities.getMagVar(runway.latitude, runway.longitude);
            const [headwind, crosswind] = BoeingAeroMath.calcRelativeWindComponents(runway.course - magVar, wind.speed, wind.direction);
            const headwindStr = B787FmcFormatters.Unit('KT', { spaceBetween: false, padStart: 2, padString: ' ', absoluteValue: true, type: 'input' })(headwind);
            const crosswindStr = B787FmcFormatters.Unit('KT', { spaceBetween: false, padStart: 2, padString: ' ', absoluteValue: true })(crosswind);
            return `${headwindStr}${(headwind >= 0 ? 'H' : 'T')} ${crosswindStr}${(crosswind >= 0 ? 'L' : 'R')}`;
        };
    }
    /**
     * A zulu time formatter.
     * @param suffix The suffix to include after the time digits.
     * @returns A four digit time with suffix.
     * */
    static ZuluTime(suffix) {
        return ([time, gpsIsAvailable]) => {
            const hrsStr = Math.floor(time / 60 / 60).toFixed(0).padStart(2, '0');
            const minStr = Math.floor(time / 60 % 60).toFixed(0).padStart(2, '0');
            return gpsIsAvailable ? `${hrsStr}${minStr}${suffix}` : '';
        };
    }
    /**
     * A bearing formatter factory
     *
     * @param type the formatter type
     *
     * @returns A bearing formatter
     */
    static Bearing(type) {
        return (bearing) => {
            let fontSize;
            if ('pilotEdited' in bearing) {
                fontSize = bearing.pilotEdited ? 'large' : 'small';
            }
            else {
                fontSize = 'large';
            }
            const renderValue = bearing.value === 0 ? 360 : bearing.value;
            return B787FmcFormatters.Unit(bearing.isTrueRef ? 'T' : '°', { type, padStart: 3, padString: '0', fontSize, unitSize: 'large', spaceBetween: false })(renderValue);
        };
    }
}
B787FmcFormatters.dateCache = new Date();
/** Factory functions for creating instance of common fmc components. */
class BoeingFmcComponentFactory {
    /**
     * Creates a new flight number text input field.
     * @param page the fmc page.
     * @param min the min char count.
     * @param max the max char count.
     * @param flightNumberUserSetting The flight number user setting.
     * @param useInputBox Whether to use input box.
     * @returns the new flight number field.
     */
    static createFlightNumberTextInputField(page, min, max, flightNumberUserSetting, useInputBox) {
        const nullValueChar = useInputBox ? '□' : '-';
        return new TextInputField(page, {
            formatter: {
                nullValueString: nullValueChar.repeat(max),
                /** @inheritDoc */
                format(value) {
                    const formatted = (value ? value : nullValueChar.repeat(max)).padStart(max, ' ');
                    return useInputBox
                        ? inputBox(formatted)
                        : formatted;
                },
                /** @inheritDoc */
                parse(input) {
                    const isAlphanumeric = /^[A-Z0-9]+$/.test(input);
                    const isValidLength = min <= input.length && input.length <= max;
                    return isAlphanumeric && isValidLength ? input : null;
                }
            },
            onDelete: async () => {
                flightNumberUserSetting.set('');
                return true;
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.length > 0) {
                    return false;
                }
                const flightNumber = flightNumberUserSetting.get();
                if (!flightNumber) {
                    return false;
                }
                return flightNumber;
            }
        });
    }
}
/**
 * RNP/ANP format
 */
class RnpAnpFormat {
    constructor() {
        this.nullValueString = '';
    }
    /** @inheritdoc */
    parse(input) {
        if (input.length === 0 || input.match(/^\d{0,2}(\.\d{0,2})?\/?$/) === null) {
            return null;
        }
        const tmp = parseFloat(input.replace('/', ''));
        if (tmp > 99.9 || tmp < 0.01) {
            return null;
        }
        return tmp;
    }
    /**
     * Format NM value with 2 dp below 10, or 1 dp above
     * @param value value in NM
     * @returns formatted value
     */
    formatValue(value) {
        if (value === null || value < 0) {
            return '-.--';
        }
        return value < 10 ? value.toFixed(2) : value.toFixed(1);
    }
    /** @inheritDoc */
    format(value) {
        const [rnp, isManual, anp] = value;
        // TODO only pilot value is large
        return `${this.formatValue(rnp)}[${isManual ? 'd' : 's'}-text]/${this.formatValue(anp)}[d-text]NM[s-text]`;
    }
}
/** Format for Wind Direction and Speed entries */
class WindDirSpdFormat {
    constructor() {
        this.nullValueString = inputBox('---°/---') + 'KT[s-text]';
    }
    /** @inheritdoc */
    parse(input) {
        // we can take dir/speed, dir/, /speed, or speed
        const match = input.match(/^((\d{3})\/)?(\/?(\d{1,3}))?$/);
        if (match === null || input === '' || input.indexOf('//') !== -1) {
            return null;
        }
        const dir = match[2] !== undefined ? parseInt(match[2]) : null;
        const spd = match[4] !== undefined ? parseInt(match[4]) : null;
        if (dir !== null && dir > 360) {
            return null;
        }
        if (spd !== null && (spd < 1 || spd > 250)) {
            return null;
        }
        return [dir, spd];
    }
    /** @inheritDoc */
    format(record) {
        var _a, _b, _c, _d;
        return inputBox(`${(_b = (_a = record.direction) === null || _a === void 0 ? void 0 : _a.toFixed(0).padStart(3, '0')) !== null && _b !== void 0 ? _b : '---'}°/${(_d = (_c = record.speed) === null || _c === void 0 ? void 0 : _c.toFixed(0).padStart(3, ' ')) !== null && _d !== void 0 ? _d : '---'}${record.windPropagated ? '[s-text]' : '[d-text]'}`) + 'KT[s-text]';
    }
}
/** Input format for Wind Altitude/Temperature entries */
class WindAltitudeTemperatureFormat {
    /** @inheritdoc */
    constructor(transitionAlt, bigAltitude = true, windAltitudeTemperatureNullValueString = inputBox('-----')) {
        this.transitionAlt = transitionAlt;
        this.bigAltitude = bigAltitude;
        this.nullValueString = inputBox('-----');
        this.altFormatter = B787FmcFormatters.Altitude('display', this.transitionAlt);
        this.nullValueString = windAltitudeTemperatureNullValueString;
    }
    /** @inheritdoc */
    parse(input) {
        // we can take alt/temp, or alt
        const dataPairParserResult = B787FmcParsers.DataPair('left', input);
        if (dataPairParserResult === null) {
            return null;
        }
        const [altStr, tempStr] = dataPairParserResult;
        const alt = B787FmcParsers.Altitude(altStr !== null && altStr !== void 0 ? altStr : '');
        if (alt === null) {
            return null;
        }
        const temp = B787FmcParsers.IntegerRange(60, -99)(tempStr !== null && tempStr !== void 0 ? tempStr : '');
        if (tempStr && temp === null) {
            // a temp was entered, but it's bad format
            return null;
        }
        return [alt, temp];
    }
    /** @inheritDoc */
    format(record) {
        var _a, _b;
        const alt = (record === null || record === void 0 ? void 0 : record.altitude) ? this.altFormatter(record.altitude) : '-----';
        const altSize = this.bigAltitude ? '[d-text]' : '';
        const temp = (_b = (_a = record === null || record === void 0 ? void 0 : record.temperature) === null || _a === void 0 ? void 0 : _a.toFixed(0).padStart(3, ' ')) !== null && _b !== void 0 ? _b : '---';
        const tempPropagated = (record === null || record === void 0 ? void 0 : record.temperaturePropagated) ? '[s-text]' : '[d-text]';
        const unit = '°[d-text]C[s-text]';
        return inputBox(`${alt}/${altSize}${temp}${tempPropagated}`) + unit;
    }
}

/**
 * A 787 FMC page
 */
class BoeingFmcPage extends AbstractFmcPage {
    /**
     * Ctor
     *
     * @param bus the event bus
     * @param screen the FMC screen instance
     * @param fms the fms to use
     * @param renderCallback the render callback
     */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.PagingFormat = {
            nullValueString: '',
            /** @inheritDoc */
            format(value) {
                return `${value[0]}/${value[1]}[s-text] `;
            }
        };
        this.PagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        }).bind(MappedSubject.create(this.screen.currentSubpageIndex, this.screen.currentSubpageCount));
        this.fms = fms;
    }
    /**
     * Called when the CDU needs to check if an LSK at a given position is active.
     *
     * This is used to bypass the logic in `FmcScreen` for manually rendered pages.
     *
     * @param row the LSK row
     * @param col the LSk column
     *
     * @returns whether the LSK is active or inactive according to the page
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    isLskActive(row, col) {
        return false;
    }
    /**
     * Converts a template row index to an LSK index
     *
     * @param row the row index
     *
     * @returns an LSK index
     */
    rowToLsk(row) {
        return row / 2;
    }
    /** @inheritDoc */
    render() {
        return [];
    }
}

/**
 * Store for the XXXX ALTN page
 */
class BoeingAlternateDisplayPageStore {
    /**
     * Ctor
     * @param bus the event bus
     * @param fms the fms
     */
    constructor(bus, fms) {
        this.bus = bus;
        this.fms = fms;
        this.gameUnitsSub = ConsumerSubject.create(this.bus.getSubscriber().on('game_units_metric'), false);
        this.alternateIndex = Subject.create(0);
        this.alternate = Subject.create(null);
        this.alternatePredictions = Subject.create(null, () => false);
        this.overheadFix = MappedSubject.create(this.alternate, this.fms.alternates.activeLeg).map(([alternate, activeLeg]) => {
            var _a, _b, _c;
            const plan = this.fms.getPlanForFmcRender();
            let ret;
            if (((_a = alternate === null || alternate === void 0 ? void 0 : alternate.diversion) === null || _a === void 0 ? void 0 : _a.mode) === AlternateDiversionMode.Overhead && alternate.diversion.legIndex !== undefined && plan.tryGetLeg(alternate.diversion.legIndex)) {
                const leg = plan.getLeg(alternate.diversion.legIndex);
                ret = [leg.leg.fixIcao, true];
            }
            else {
                ret = [(_c = (_b = activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.leg) === null || _b === void 0 ? void 0 : _b.fixIcao) !== null && _c !== void 0 ? _c : null, false];
            }
            return ret;
        });
        this.alternatePipeSub = null;
        this.alternatePredictionsPipeSub = null;
    }
}

/**
 * XXXX ALTN page
 */
class BoeingAlternateDisplayPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingAlternateDisplayPageStore(this.bus, this.fms);
        this.TitleField = new DisplayField(this, {
            formatter: {
                nullValueString: '---- ALTN',
                /** @inheritDoc */
                format(value) {
                    const identStr = ICAO.getIdent(value.facilityIcao).padStart(4, ' ');
                    return `${identStr} ALTN`;
                }
            }
        }).bind(this.store.alternate);
        this.PagingField = new DisplayField(this, {
            formatter: {
                nullValueString: '-/4[s-text]',
                /** @inheritDoc */
                format(value) {
                    return `${value + 1}/4[s-text]`;
                },
            },
        }).bind(this.store.alternateIndex);
        this.DirectField = new DisplayField(this, {
            formatter: {
                nullValueString: 'DIRECT TO',
                /** @inheritDoc */
                format(selectedMode) {
                    return `DIRECT TO ${selectedMode === AlternateDiversionMode.Direct ? '<SEL>' : ''}`;
                }
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.trim() === '') {
                    this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { diversion: { mode: AlternateDiversionMode.Direct } });
                    return true;
                }
                return false;
            },
        }).bind(this.store.alternate.map((it) => { var _a; return (_a = it === null || it === void 0 ? void 0 : it.diversion.mode) !== null && _a !== void 0 ? _a : null; }));
        this.OverheadFixField = new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('-----  [s-text]'),
                /** @inheritDoc */
                format([selectedMode, [icao, isPilotEntry]]) {
                    const inputBoxStr = icao ? inputBox(`${ICAO.getIdent(icao).padEnd(7, ' ')}[${isPilotEntry ? 'd-text' : 's-text'}]`) : inputBox('-----  [s-text]');
                    return `${inputBoxStr} ${selectedMode === AlternateDiversionMode.Overhead ? '<SEL>' : ''}`;
                },
                parse: async (input) => {
                    const plan = this.fms.getPrimaryFlightPlan();
                    const legs = Array.from(plan.legs());
                    let matchingLegIndex = -1;
                    for (let i = 0; i < legs.length; i++) {
                        const legDefinition = plan.getLeg(i);
                        if (ICAO.getIdent(legDefinition.leg.fixIcao) === input.trim()) {
                            matchingLegIndex = i;
                        }
                    }
                    return matchingLegIndex;
                },
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.trim() === '') {
                    this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { diversion: { mode: AlternateDiversionMode.Overhead } });
                    return true;
                }
                return false;
            },
            onDelete: async () => {
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { diversion: { mode: AlternateDiversionMode.Overhead, legIndex: -1 } });
                return true;
            },
            onModified: async (legIndex) => {
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { diversion: { mode: AlternateDiversionMode.Overhead, legIndex } });
                return true;
            }
        }).bind(MappedSubject.create(this.store.alternate.map((it) => { var _a; return (_a = it === null || it === void 0 ? void 0 : it.diversion.mode) !== null && _a !== void 0 ? _a : null; }), this.store.overheadFix));
        this.AltitudeFormatter = B787FmcFormatters.Altitude('input', Subject.create(18000));
        this.AltitudeField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                nullValueString: inputBox('-----'),
                format: (input) => this.AltitudeFormatter(input),
                parse: (input) => B787FmcParsers.Altitude(input),
            }),
            onDelete: async () => {
                this.fms.performancePlanProxy.alternateCruiseAltitude.set(null);
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), {});
                return true;
            },
            onModified: async (cruiseAltitude) => {
                this.fms.performancePlanProxy.alternateCruiseAltitude.set(cruiseAltitude);
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), {});
                return true;
            },
        }).bind(this.fms.performancePlanProxy.alternateCruiseAltitude);
        this.SpeedModeHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    const speed = value[0];
                    if (typeof speed === 'number') {
                        return value[1] ? 'MACH' : 'SPD';
                    }
                    else {
                        return speed.toUpperCase();
                    }
                },
            },
        }).bind(MappedSubject.create(this.fms.activePerformancePlan.alternateSpeedValue, this.fms.activePerformancePlan.alternateSpeedIsMach));
        // TODO for the speed field, we need to calculate the speed schedule value and show it, not the schedule name
        this.SpeedModeField = new TextInputField(this, {
            formatter: {
                nullValueString: '---',
                /** @inheritDoc */
                format(value) {
                    const speed = value[0];
                    const isMach = value[1];
                    let str;
                    if (typeof speed === 'number') {
                        str = isMach ? speed.toFixed(3).substring(1) : speed.toFixed(0).padStart(4, ' ');
                    }
                    else {
                        str = speed.toUpperCase();
                    }
                    return inputBox(str);
                },
                /** @inheritDoc */
                parse(input) {
                    const regex = /\.\d{2,3}|\d{3}|ECON|LRC|EOLRC|EO|CO/;
                    const match = input.match(regex);
                    if (!match) {
                        return null;
                    }
                    if (match[0].startsWith('.')) {
                        const mach = parseFloat(`0${match[0]}`);
                        if (mach < 0.100 || mach > 0.990) {
                            return null;
                        }
                        return [mach, true];
                    }
                    const cas = parseInt(match[0]);
                    if (Number.isFinite(cas)) {
                        if (cas < 100 || cas > 400) {
                            return null;
                        }
                        return [cas, false];
                    }
                    return [match[0], false];
                },
            },
            onModified: async (data) => {
                this.fms.performancePlanProxy.alternateSpeedValue.set(data[0]);
                this.fms.performancePlanProxy.alternateSpeedIsMach.set(data[1]);
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), {});
                return true;
            },
        }).bind(MappedSubject.create(this.fms.performancePlanProxy.alternateSpeedValue, this.fms.performancePlanProxy.alternateSpeedIsMach));
        this.WindField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                format: (value) => value.wind ? B787FmcFormatters.WindVector(value.wind, false) : inputBox('---°/---'),
                parse: B787FmcParsers.WindVector('right', this.store.alternate.map((it) => { var _a; return (_a = it === null || it === void 0 ? void 0 : it.wind) !== null && _a !== void 0 ? _a : null; })),
            }),
            onDelete: async () => {
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { wind: null });
                return true;
            },
            onModified: async (wind) => {
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { wind });
                return true;
            }
        }).bind(this.store.alternate);
        this.OatAltitudeFormatter = B787FmcFormatters.Altitude('display', Subject.create(18000));
        this.AltitudeOatField = new TextInputField(this, {
            formatter: {
                nullValueString: `${inputBox('-----/---')}[d-text]°C[s-text]`,
                /** @inheritDoc */
                format: (value) => {
                    const altStr = value.oatAltitude ? this.OatAltitudeFormatter(value.oatAltitude) : '-----';
                    const tempStr = value.oatTemperature ? ((Math.sign(value.oatTemperature) > 0 ? '+' : '-') + Math.abs(value.oatTemperature).toFixed(0)).padStart(3, ' ') : '---';
                    return `${inputBox(`${altStr}/${tempStr}[d-text]`)}°C[s-text]`;
                },
                /** @inheritDoc */
                parse(input) {
                    const pair = B787FmcParsers.DataPair('right', input);
                    if (!pair) {
                        return null;
                    }
                    const [altStr, oatStr] = pair;
                    if (altStr === null || oatStr === null) {
                        return null;
                    }
                    const parseAltitude = B787FmcParsers.Altitude(altStr);
                    const parsedOat = B787FmcParsers.CelsiusTemperature(oatStr, -99, 60);
                    if (parseAltitude === null || parsedOat === null) {
                        return null;
                    }
                    return [parseAltitude, parsedOat];
                },
            },
            onDelete: async () => {
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { oatAltitude: null, oatTemperature: null });
                return true;
            },
            onModified: async (newValue) => {
                var _a, _b;
                this.fms.alternates.modifyAlternate(this.store.alternateIndex.get(), { oatAltitude: (_a = newValue === null || newValue === void 0 ? void 0 : newValue[0]) !== null && _a !== void 0 ? _a : null, oatTemperature: (_b = newValue === null || newValue === void 0 ? void 0 : newValue[1]) !== null && _b !== void 0 ? _b : null });
                return true;
            }
        }).bind(this.store.alternate);
        this.EtaFuelHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return `${ICAO.getIdent(value.facilityIcao)} ETA/FUEL`;
                },
            },
        }).bind(this.store.alternate);
        this.EtaFuelField = new DisplayField(this, {
            formatter: {
                nullValueString: '----z/ --.-',
                /** @inheritDoc */
                format: (value) => {
                    const etaStr = BoeingAlternateDisplayPage.ETA_FORMATTER(value.estimatedTimeOfArrival * 1000);
                    let fuelStr = ' --.-';
                    if (Number.isFinite(value.fob)) {
                        const efobUserUnits = (this.store.gameUnitsSub.get() ? UnitType.KILOGRAM : UnitType.POUND).convertFrom(value.fob, UnitType.POUND);
                        fuelStr = (efobUserUnits / 1000).toFixed(1).padStart(5, ' ');
                    }
                    return `${etaStr}/${fuelStr}`;
                }
            }
        }).bind(this.store.alternatePredictions);
        this.FooterField = new DisplayField(this, {
            formatter: {
                nullValueString: '--------------------------------------',
                /** @inheritDoc */
                format(value) {
                    const identStr = ICAO.getIdent(value.facilityIcao).padStart(4, ' ');
                    return `--------------------------------- ${identStr}`;
                }
            }
        }).bind(this.store.alternate);
        this.AltnLink = PageLinkField.createLink(this, '<ALTN', '/altn');
        this.DivertNowButton = new DisplayField(this, {
            formatter: new SimpleStringFormat('DIVERT NOW>'),
            onSelected: async () => {
                const alternate = this.store.alternate.get();
                if (alternate) {
                    this.fms.createAlternateDiversion(alternate);
                    this.screen.navigateTo('/legs');
                    return true;
                }
                return false;
            },
        });
    }
    /** @inheritDoc */
    onInit() {
        super.onInit();
        this.addBinding(this.store.alternateIndex.sub((index) => {
            if (this.store.alternatePipeSub) {
                this.store.alternatePipeSub.destroy();
            }
            if (this.store.alternatePredictionsPipeSub) {
                this.store.alternatePredictionsPipeSub.destroy();
            }
            this.store.alternatePipeSub = this.fms.alternates.alternateSub(index).pipe(this.store.alternate);
            this.store.alternatePredictionsPipeSub = this.fms.alternates.alternatePredictionsSub(index).pipe(this.store.alternatePredictions);
        }, true));
        this.addBinding(this.store.gameUnitsSub.sub(() => this.invalidate()));
    }
    /** @inheritDoc */
    onResume() {
        super.onResume();
        // TODO this is actually handled via subpages
        const altnIndex = this.params.get('altnIndex');
        if (Number.isFinite(altnIndex) && altnIndex >= 0 && altnIndex < 4) {
            this.store.alternateIndex.set(altnIndex);
        }
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', this.PagingField, this.TitleField],
                ['VIA', 'ALT'],
                [this.DirectField, this.AltitudeField],
                ['', this.SpeedModeHeader],
                [`${inputBox('L00[disabled s-text]')} OFFSET[disabled]`, this.SpeedModeField],
                [' OVERHEAD', 'WIND'],
                [this.OverheadFixField, this.WindField],
                ['', 'ALT/OAT'],
                ['', this.AltitudeOatField],
                ['', this.EtaFuelHeader],
                ['<ENG OUT[disabled]', this.EtaFuelField],
                [this.FooterField],
                [this.AltnLink, this.DivertNowButton],
            ]
        ];
    }
    /**
     * Scroll page forward
     */
    scrollForward() {
        const current = this.store.alternateIndex.get();
        this.store.alternateIndex.set((current + 1) % 4);
    }
    /**
     * Scroll page backward
     */
    scrollBackward() {
        const current = this.store.alternateIndex.get();
        this.store.alternateIndex.set((current - 1) >= 0 ? (current - 1) : 3);
    }
    /** @inheritDoc */
    async onHandleScrolling(event) {
        if (event === 'pageRight') {
            this.scrollForward();
            return true;
        }
        else if (event === 'pageLeft') {
            this.scrollBackward();
            return true;
        }
        return super.onHandleScrolling(event);
    }
}
BoeingAlternateDisplayPage.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z', { nanString: '----z' });

/**
 * Format for fields showing ALTN row data
 */
class AltnRowFormat {
    /**
     * Ctor
     * @param page the FMC page
     * @param gameUnitMetric a subscribable to the game units being metric or not
     */
    constructor(page, gameUnitMetric) {
        this.page = page;
        this.gameUnitMetric = gameUnitMetric;
        this.nullValueString = this.page.getAlternateNullValueString();
    }
    /** @inheritDoc */
    format(value) {
        const identStr = inputBox(ICAO.getIdent(value.altnIcao).padEnd(4, ' '));
        const etaStr = value.eta ? AltnRowFormat.ETA_FORMATTER(value.eta * 1000) : '----z';
        let fobStr = ' --.-';
        if (value.efob) {
            const efobUserUnits = (this.gameUnitMetric.get() ? UnitType.KILOGRAM : UnitType.POUND).convertFrom(value.efob, UnitType.POUND);
            fobStr = (efobUserUnits / 1000).toFixed(1).padStart(5, ' ');
        }
        return this.page.getAlternateFormattedString(identStr, etaStr, fobStr);
    }
    /** @inheritDoc */
    async parse(input) {
        if (input.length < 1) {
            return null;
        }
        const airport = await this.page.screen.selectWaypointByIdent(input, this.page.fms.ppos, FacilitySearchType.Airport);
        if (!airport) {
            return Promise.reject(BoeingFmcErrorKeys.NotInDataBase);
        }
        return airport;
    }
}
AltnRowFormat.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z', { nanString: '----z' });
/**
 * The 787 ALTN page.
 */
class BoeingAlternateListPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.gameUnitsSub = ConsumerSubject.create(this.bus.getSubscriber().on('game_units_metric'), false);
        this.Altn1Field = new TextInputField(this, {
            formatter: new AltnRowFormat(this, this.gameUnitsSub),
            onDelete: async () => {
                this.fms.alternates.setAlternate(0, null);
                return true;
            },
        }).bindSource(this.alternateData(0));
        this.Altn2Field = new TextInputField(this, {
            formatter: new AltnRowFormat(this, this.gameUnitsSub),
            onDelete: async () => {
                this.fms.alternates.setAlternate(1, null);
                return true;
            },
        }).bindSource(this.alternateData(1));
        this.Altn3Field = new TextInputField(this, {
            formatter: new AltnRowFormat(this, this.gameUnitsSub),
            onDelete: async () => {
                this.fms.alternates.setAlternate(2, null);
                return true;
            },
        }).bindSource(this.alternateData(2));
        this.Altn4Field = new TextInputField(this, {
            formatter: new AltnRowFormat(this, this.gameUnitsSub),
            onDelete: async () => {
                this.fms.alternates.setAlternate(3, null);
                return true;
            },
        }).bindSource(this.alternateData(3));
    }
    /**
     * Gets a {@link DataInterface} for an alternate
     *
     * @param index the index
     *
     * @returns a DataInterface
     */
    alternateData(index) {
        return new DataInterface(MappedSubject.create(this.fms.alternates.alternateSub(index, true), this.fms.alternates.alternatePredictionsSub(index))
            .map(([altn, predictions]) => {
            var _a, _b, _c;
            return (altn ? {
                altnIcao: (_a = altn === null || altn === void 0 ? void 0 : altn.facilityIcao) !== null && _a !== void 0 ? _a : '',
                efob: (_b = predictions === null || predictions === void 0 ? void 0 : predictions.fob) !== null && _b !== void 0 ? _b : null,
                eta: (_c = predictions === null || predictions === void 0 ? void 0 : predictions.estimatedTimeOfArrival) !== null && _c !== void 0 ? _c : null,
                isSelected: false
            } : null);
        }), (altn) => this.fms.alternates.setAlternate(index, {
            facilityIcao: altn.icao,
            diversion: { mode: AlternateDiversionMode.Direct },
            wind: null,
            oatAltitude: null,
            oatTemperature: null,
        }));
    }
    /** @inheritDoc */
    onInit() {
        super.onInit();
        this.addBinding(this.gameUnitsSub.sub(() => this.invalidate()));
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '1/2[s-text] ', 'ALTN       '],
                ['', 'FUEL   ', 'ETA'],
                [this.Altn1Field],
                [''],
                [this.Altn2Field],
                [''],
                [this.Altn3Field],
                [''],
                [this.Altn4Field],
                [this.altnRequestHeaderString, 'ALTN INHIBIT[disabled]'],
                [this.altnRequestLinkString, '----/----[disabled]'],
                [this.weatherRequestHeaderString, '----[disabled]'],
                [this.weatherRequestLinkString, 'DIVERT NOW>[disabled]'],
            ],
        ];
    }
    /** @inheritDoc */
    isLskActive(row, col) {
        if (col === 1) {
            switch (row) {
                case 2:
                    return this.fms.alternates.hasAlternate(0);
                case 4:
                    return this.fms.alternates.hasAlternate(1);
                case 6:
                    return this.fms.alternates.hasAlternate(2);
                case 8:
                    return this.fms.alternates.hasAlternate(3);
            }
        }
        return super.isLskActive(row, col);
    }
    /** @inheritDoc */
    async onHandleSelectKey(event) {
        if (event.col === 1) {
            switch (event.row) {
                case 2: {
                    if (this.fms.alternates.hasAlternate(0)) {
                        this.screen.navigateTo('/altn-display', { altnIndex: 0 });
                        return true;
                    }
                    return false;
                }
                case 4: {
                    if (this.fms.alternates.hasAlternate(1)) {
                        this.screen.navigateTo('/altn-display', { altnIndex: 1 });
                        return true;
                    }
                    return false;
                }
                case 6: {
                    if (this.fms.alternates.hasAlternate(2)) {
                        this.screen.navigateTo('/altn-display', { altnIndex: 2 });
                        return true;
                    }
                    return false;
                }
                case 8: {
                    if (this.fms.alternates.hasAlternate(3)) {
                        this.screen.navigateTo('/altn-display', { altnIndex: 3 });
                        return true;
                    }
                    return false;
                }
            }
        }
        return super.onHandleSelectKey(event);
    }
}

/**
 * Utils for Boeing FMCs
 */
class BoeingFmcUtils {
    /**
     * Creates a {@link DataInterface} for interfacing a `MutableSubscribable<number | null>` as input
     * and a `NumberUnitInterface<UnitFamily.Weight> | null` as output.
     *
     * This converts any `NaN` values in {@link from} to `null` values for the input, and converts output values
     * into the unit specified by {@link intoUnit}.
     *
     * @param gameUnitSub a subscribable on the game unit being used for display
     * @param from the input
     * @param into the output
     * @param intoUnit the output unit
     *
     * @returns a `DataInterface`
     */
    static gameUnitsWeightDataInterface(gameUnitSub, from, into, intoUnit = UnitType.POUND) {
        return new DataInterface(from.map((it) => Number.isNaN(it.number) ? null : it, () => false), (value) => into.set(value !== null ? gameUnitSub.get().convertTo(value, intoUnit) : value));
    }
}

/** A Boeing APPROACH REF page. */
class BoeingApproachRefPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, speedData, enableLandingRefField, showDepartureRwyWithinNm, flapSettings) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.speedData = speedData;
        this.enableLandingRefField = enableLandingRefField;
        this.showDepartureRwyWithinNm = showDepartureRwyWithinNm;
        this.flapSettings = flapSettings;
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.ThrustLink = PageLinkField.createLink(this, 'THRUST LIM>', '/thrust-lim');
        this.perfPlan = this.fms.performancePlanProxy;
        this.showLandingRefField = true;
        this.sub = this.bus.getSubscriber();
        this.gameUnit = ConsumerSubject.create(this.sub.on('game_units_metric'), false);
        this.gameUnitSub = this.gameUnit.map((metric) => metric ? UnitType.KILOGRAM : UnitType.POUND);
        this.gpsPosition = ConsumerSubject.create(this.sub.on('gps-position').atFrequency(1), null);
        this.fuelWeight = ConsumerSubject.create(this.sub.on('fuel_total_weight'), 0);
        this.apprDetails = ConsumerSubject.create(this.sub.on('approach_details_set'), null);
        this.apprType = this.apprDetails.map((app) => app === null || app === void 0 ? void 0 : app.approachType);
        this.flightPhase = ConsumerSubject.create(this.sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.baroIsStd = ConsumerSubject.create(this.sub.on('altimeter_baro_is_std_1'), false);
        this.apprIsLocBased = this.apprType.map(type => type ? BoeingFmsUtils.isLocalizerApproach(type) : false);
        this.icaoToDisplay = Subject.create(null);
        this.runwayToDisplay = Subject.create(null);
        this.autoGw = MappedSubject.create(([zfw, fuelWeight]) => zfw !== null ? zfw + fuelWeight : null, this.perfPlan.manualZfw, this.fuelWeight);
        this.manualGw = Subject.create(null);
        this.grossWeight = MappedSubject.create(([auto, manual]) => manual !== null && manual !== void 0 ? manual : auto, this.autoGw, this.manualGw);
        this.displayGrossWeight = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.flapVRefs = this.flapSettings.map((flap) => [flap, Subject.create(null)]);
        this.runwayAltitudeFeet = Subject.create(0);
        this.GrossWeightField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.Weight,
                format: B787FmcFormatters.Weight('input', this.gameUnitSub),
                nullValueString: inputBox('□□□.□'),
            }),
        }).bindSource(BoeingFmcUtils.gameUnitsWeightDataInterface(this.gameUnitSub, this.displayGrossWeight, this.manualGw));
        this.LandingRefField = new SwitchLabel(this, {
            optionStrings: ['QFE', 'QNH'],
            caret: 'left',
            separator: 'arrows',
        }).bind(this.perfPlan.approachLandingRef);
        this.RunwayLengthHeader = new DisplayField(this, {
            formatter: {
                nullValueString: ' ----',
                format: ([icao, rw]) => 
                // TODO No idea what this should return if only one of the values is null
                icao === null ? ' ----' : ` ${ICAO.getIdent(icao)}${rw ? rw.designation : ''}`,
            },
        }).bind(MappedSubject.create(this.icaoToDisplay, this.runwayToDisplay));
        this.RunwayLengthField = new DisplayField(this, {
            formatter: {
                nullValueString: '----',
                format: (lengthM) => `${UnitType.FOOT.convertFrom(lengthM !== null && lengthM !== void 0 ? lengthM : 0, UnitType.METER).toFixed(0)}[d-text]FT[s-text]${lengthM === null || lengthM === void 0 ? void 0 : lengthM.toFixed(0)}[d-text]M[s-text]`,
            },
        }).bind(this.runwayToDisplay.map(runway => runway ? runway.length : null));
        this.GlideSlopeField = new SwitchLabel(this, {
            optionStrings: ['ON', 'OFF'],
            caret: 'left',
            separator: 'arrows',
        }).bind(this.fms.activePerformancePlan.glideSlope);
        this.VRefFields = this.flapVRefs.map(([flap, speedSetting]) => new DisplayField(this, {
            formatter: {
                nullValueString: ` ${flap}°    ---[d-text]KT[s-text]`,
                format: (speed) => ` ${flap}°    ${speed}[d-text]KT[s-text]`,
            },
            onSelected: async () => {
                const speed = speedSetting.get();
                return speed === null ? false : `${flap}/${speed}`;
            },
        }).bind(speedSetting));
        this.FlapSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.FlapSpeed('right'),
                nullValueString: inputBox('--/---'),
                format: B787FmcFormatters.FlapSpeed,
            }),
            onDelete: async () => {
                this.perfPlan.approachFlapSpeed.set(null);
                return true;
            },
        }).bind(this.perfPlan.approachFlapSpeed);
        this.WindCorrectionField = new TextInputField(this, {
            formatter: new NumberAndUnitFormat('KT', {
                maxValue: 20,
                padStart: 2,
                padString: '0',
                forceSign: true,
                spaceBetween: false,
                type: 'input',
            })
        }).bind(this.perfPlan.approachWindCorrection);
    }
    /** @inheritDoc */
    onInit() {
        this.addBinding(this.gameUnitSub.sub(() => this.invalidate()));
        this.addBinding(this.grossWeight.sub((gw) => {
            // TODO does it need to support QNH? It doesn't know the QNH of destination yet
            const pressAlt = this.runwayAltitudeFeet.get() - UnitType.METER.convertTo(AeroMath.baroPressureAltitudeOffset(1013.25), UnitType.FOOT);
            this.flapVRefs.forEach(([flapSetting, speedSubject]) => speedSubject.set(gw === null ? null : Math.round(this.speedData.getVrefSpeed(flapSetting, gw, pressAlt))));
            this.displayGrossWeight.set(gw !== null && gw !== void 0 ? gw : NaN, UnitType.POUND);
        }, true));
        this.enableLandingRefField && this.addBinding(MappedSubject.create(this.flightPhase, this.baroIsStd)
            .sub(([flightPhase, baroIsStd]) => {
            this.showLandingRefField = flightPhase !== FmsOperatingPhase.CLIMB && !baroIsStd;
            this.invalidate();
        }, true));
        this.addBinding(this.runwayToDisplay.sub((rw) => { var _a; return this.runwayAltitudeFeet.set(UnitType.METER.convertTo((_a = rw === null || rw === void 0 ? void 0 : rw.elevation) !== null && _a !== void 0 ? _a : 0, UnitType.FOOT)); }));
        this.addBinding(MappedSubject.create(this.gpsPosition, this.perfPlan.takeoffAirportIcao, this.perfPlan.originRunway, this.perfPlan.approachAirportIcao, this.perfPlan.approachRunway).sub(() => {
            const originFac = this.fms.facilityInfo.originFacility;
            const destFac = this.fms.facilityInfo.destinationFacility;
            if (originFac && destFac) {
                const distanceFromOriginNM = UnitType.GA_RADIAN.convertTo(this.fms.ppos.distance(originFac), UnitType.NMILE);
                const distanceToDestinationNM = UnitType.GA_RADIAN.convertTo(this.fms.ppos.distance(destFac), UnitType.NMILE);
                const moreThanCertainDistanceFromOrigin = distanceFromOriginNM > this.showDepartureRwyWithinNm;
                const moreThanHalfwayToDest = distanceFromOriginNM > distanceToDestinationNM;
                if (moreThanCertainDistanceFromOrigin || moreThanHalfwayToDest) {
                    this.perfPlan.approachAirportIcao.pipe(this.icaoToDisplay);
                    this.perfPlan.approachRunway.pipe(this.runwayToDisplay);
                }
                else {
                    this.perfPlan.takeoffAirportIcao.pipe(this.icaoToDisplay);
                    this.perfPlan.originRunway.pipe(this.runwayToDisplay);
                }
            }
            else if (originFac && !destFac) {
                this.perfPlan.takeoffAirportIcao.pipe(this.icaoToDisplay);
                this.perfPlan.originRunway.pipe(this.runwayToDisplay);
            }
            else if (!originFac && destFac) {
                this.perfPlan.approachAirportIcao.pipe(this.icaoToDisplay);
                this.perfPlan.approachRunway.pipe(this.runwayToDisplay);
            }
            else {
                this.icaoToDisplay.set(null);
                this.runwayToDisplay.set(null);
            }
        }, true));
        this.addBinding(this.apprIsLocBased.sub(() => this.invalidate(), true));
    }
    /** @inheritDoc */
    onResume() {
        // Re-initialize manual gross weight to FMC-calculated value when page is entered.
        this.manualGw.set(this.autoGw.get());
        this.gameUnit.resume();
        this.gpsPosition.resume();
        this.apprDetails.resume();
        this.fuelWeight.resume();
        this.flightPhase.resume();
        this.baroIsStd.resume();
    }
    /** @inheritDoc */
    onPause() {
        this.gameUnit.pause();
        this.gpsPosition.pause();
        this.apprDetails.pause();
        this.fuelWeight.pause();
        this.flightPhase.pause();
        this.baroIsStd.pause();
    }
    /** @inheritDoc */
    render() {
        const landingRefHeader = this.enableLandingRefField ? ' LANDING REF' : '';
        const landingRefField = this.enableLandingRefField && this.showLandingRefField ? this.LandingRefField : '';
        const glideSlopeField = this.apprIsLocBased.get() ? this.GlideSlopeField : '';
        return [
            [
                ['', '', 'APPROACH REF'],
                [' GROSS WT', 'FLAPS    VREF'],
                [this.GrossWeightField, this.VRefFields[0]],
                [''],
                ['', this.VRefFields[1]],
                [landingRefHeader],
                [landingRefField, this.VRefFields[2]],
                [this.RunwayLengthHeader, 'FLAP/SPEED'],
                [this.RunwayLengthField, this.FlapSpeedField],
                [' G/S', 'WIND CORR'],
                [glideSlopeField, this.WindCorrectionField],
                ['--------------------------------------'],
                [this.IndexLink, this.ThrustLink],
            ],
        ];
    }
}

/** Departure Arrival View Enum */
var DepArrView;
(function (DepArrView) {
    DepArrView[DepArrView["INDEX"] = 0] = "INDEX";
    DepArrView[DepArrView["DEP"] = 1] = "DEP";
    DepArrView[DepArrView["ARR"] = 2] = "ARR";
})(DepArrView || (DepArrView = {}));
/**
 * Dep Arr Page Store
 */
class BoeingDepArrPageStore {
    /**
     * Creates the store.
     */
    constructor() {
        this.selectedFacility = Subject.create(undefined);
        this._departureRunways = ArraySubject.create();
        this.departureRunways = this._departureRunways;
        this._hudDepartureRunways = ArraySubject.create();
        this.hudDepartureRunways = this._hudDepartureRunways;
        this.selectedDepartureRunway = Subject.create(undefined);
        this.selectedDepartureRunwayTransitionIndex = Subject.create(-1);
        this.selectedDepartureHudTakeoffRunway = Subject.create(undefined);
        this._departures = ArraySubject.create();
        this.departures = this._departures;
        this.selectedDeparture = Subject.create(undefined);
        this._departureTransitions = ArraySubject.create();
        this.departureTransitions = this._departureTransitions;
        this.selectedDepartureTransition = Subject.create(undefined);
        this._arrivals = ArraySubject.create();
        this.arrivals = this._arrivals;
        this.selectedArrival = Subject.create(undefined);
        this.selectedArrivalRunwayTransitionIndex = Subject.create(-1);
        this._arrivalTransitions = ArraySubject.create();
        this.arrivalTransitions = this._arrivalTransitions;
        this.selectedArrivalTransition = Subject.create(undefined);
        this._approaches = ArraySubject.create();
        this.approaches = this._approaches;
        this.selectedApproach = Subject.create(undefined);
        this._approachTransitions = ArraySubject.create();
        this.approachTransitions = this._approachTransitions;
        this.selectedApproachTransition = Subject.create(undefined);
        this.visualApproachOffset = Subject.create(5);
        this.vfrApproachSelected = Subject.create(false);
        this.vfrApproachFpa = Subject.create(3);
        this.origin = Subject.create('');
        this.destination = Subject.create('');
        this.selectedFacility.sub(this.onSelectedFacilityChanged.bind(this));
        this.selectedDepartureRunway.sub(this.onSelectedDepartureRunwayChanged.bind(this));
        this.selectedDeparture.sub(this.onSelectedDepartureChanged.bind(this));
        this.selectedArrival.sub(this.onSelectedArrivalChanged.bind(this));
        this.selectedApproach.sub(this.onSelectedApproachChanged.bind(this));
    }
    /**
     * Destroys this store.
     */
    destroy() {
        this.selectedFacility.unsub(this.onSelectedFacilityChanged.bind(this));
        this.selectedDepartureRunway.unsub(this.onSelectedDepartureRunwayChanged.bind(this));
        this.selectedDeparture.unsub(this.onSelectedDepartureChanged.bind(this));
        this.selectedArrival.unsub(this.onSelectedArrivalChanged.bind(this));
        this.selectedApproach.unsub(this.onSelectedApproachChanged.bind(this));
    }
    /**
     * Responds to changes in the selected airport facility.
     * @param facility The selected airport facility.
     */
    onSelectedFacilityChanged(facility) {
        this.resetStore();
        this._departures.set(this.getDepartures(facility));
        this._arrivals.set(this.getArrivals(facility));
        this._approaches.set(this.getApproaches(facility));
        this._departureRunways.set(this.getDepartureRunways(facility));
        this._hudDepartureRunways.set(this.getHudDepartureRunways(this.departureRunways.getArray()));
    }
    /**
     * Responds to changes in the selected departure.
     * @param proc The selected departure.
     */
    onSelectedDepartureChanged(proc) {
        this._departureTransitions.set(proc ? this.getDepArrTransitions(proc.procedure) : []);
        this._departureRunways.set(this.getDepartureRunways(this.selectedFacility.get(), proc ? proc.procedure : undefined));
        this._hudDepartureRunways.set(this.getHudDepartureRunways(this.departureRunways.getArray()));
        this.trySetDepartureRunwayTransitionIndex();
    }
    /**
     * Responds to changes in the selected departure.
     * @param runway The selected one way runway.
     */
    onSelectedDepartureRunwayChanged(runway) {
        this._departures.set(this.getDepartures(this.selectedFacility.get(), runway));
        this.trySetDepartureRunwayTransitionIndex();
        this._hudDepartureRunways.set(this.getHudDepartureRunways(this.departureRunways.getArray()));
    }
    /**
     * Responds to changes in the selected arrival.
     * @param proc The selected arrival.
     */
    onSelectedArrivalChanged(proc) {
        this._arrivalTransitions.set(proc ? this.getDepArrTransitions(proc.procedure) : []);
        this._approaches.set(this.getApproaches(this.selectedFacility.get(), proc ? proc.procedure : undefined));
        this.trySetArrivalRunwayTransitionIndex();
    }
    /**
     * Responds to changes in the selected approach.
     * @param proc The selected approach.
     */
    onSelectedApproachChanged(proc) {
        this._approachTransitions.set(proc ? this.getApproachTransitions(proc) : []);
        this._arrivals.set(this.getArrivals(this.selectedFacility.get(), proc ? proc.procedure : undefined));
        this.trySetArrivalRunwayTransitionIndex();
    }
    /**
     * Gets the departures array from an airport.
     * @param airport An airport facility.
     * @param runway A one way runway, if selected.  (optional)
     * @returns The departures array from the specified airport.
     */
    getDepartures(airport, runway) {
        const departures = [];
        if (airport !== undefined) {
            airport.departures.forEach((proc, index) => {
                if (!runway || this.checkIfProcedureHasRunway(proc, runway.direction, runway.runwayDesignator)) {
                    departures.push({
                        procedure: proc,
                        index,
                        isVisualApproach: false,
                        isVfrApproach: false,
                    });
                }
            });
        }
        return departures;
    }
    /**
     * Gets the arrivals array from an airport.
     * @param airport An airport facility.
     * @param approach An approach procedure to choose arrivals for (optional)
     * @returns The arrivals array from the specified airport.
     */
    getArrivals(airport, approach) {
        const arrivals = [];
        if (airport !== undefined) {
            airport.arrivals.forEach((arrival, index) => {
                if (!approach || this.checkIfProcedureHasRunway(arrival, approach.runwayNumber, approach.runwayDesignator)) {
                    arrivals.push({
                        procedure: arrival,
                        index,
                        isVisualApproach: false,
                        isVfrApproach: false,
                    });
                }
            });
        }
        return arrivals;
    }
    /**
     * Gets an array of approaches from an airport.
     * @param airport An airport.
     * @param arrival An arrival procedure to find approaches for (optional).
     * @returns An array of approaches.
     */
    getApproaches(airport, arrival) {
        if (airport !== undefined) {
            const approaches = [];
            airport.approaches.forEach((approach, index) => {
                if (!arrival || this.checkIfProcedureHasRunway(arrival, approach.runwayNumber, approach.runwayDesignator)) {
                    approaches.push({
                        procedure: approach,
                        index,
                        isVisualApproach: false,
                        isVfrApproach: false,
                    });
                }
            });
            this.getVisualApproaches(airport).forEach(va => {
                if (!arrival || this.checkIfProcedureHasRunway(arrival, va.runwayNumber, va.runwayDesignator)) {
                    approaches.push({
                        procedure: va,
                        index: -1,
                        isVisualApproach: true,
                        isVfrApproach: false,
                    });
                }
            });
            return sortApproaches(approaches);
        }
        return [];
    }
    /**
     * Gets the visual approaches for the facility.
     * @param facility is the facility.
     * @returns The Approach Procedures.
     */
    getVisualApproaches(facility) {
        const runways = [];
        for (let i = 0; i < facility.runways.length; i++) {
            RunwayUtils.getOneWayRunways(facility.runways[i], i).forEach(rw => { runways.push(rw); });
        }
        const approaches = [];
        runways.forEach(r => {
            approaches.push({
                name: `VISUAL ${r.designation}`,
                runway: r.designation,
                icaos: [],
                transitions: [{ name: 'STRAIGHT', legs: [] }],
                finalLegs: [],
                missedLegs: [],
                approachType: AdditionalApproachType.APPROACH_TYPE_VISUAL,
                approachSuffix: '',
                runwayDesignator: r.runwayDesignator,
                runwayNumber: r.direction,
                rnavTypeFlags: RnavTypeFlags.None
            });
        });
        return approaches;
    }
    /**
     * Gets the one way runways of an airport facility.
     * @param airport The airport facility.
     * @param proc The departure procedure to collect one way runways for (optional)
     * @returns The one way runways of the airport facility.
     */
    getDepartureRunways(airport, proc) {
        const runways = [];
        // If the proc.runwayTransitions is empty, that means it supports all runways
        if ((!proc || proc.runwayTransitions.length === 0) && airport !== undefined) {
            airport.runways.forEach((rw, index) => RunwayUtils.getOneWayRunways(rw, index).forEach(owr => runways.push(owr)));
        }
        else if (proc && airport !== undefined) {
            proc.runwayTransitions.forEach(trans => {
                const oneWayRunway = RunwayUtils.matchOneWayRunway(airport, trans.runwayNumber, trans.runwayDesignation);
                oneWayRunway && runways.push(oneWayRunway);
            });
        }
        return sortRunways(runways);
    }
    /**
     * Gets the one way runways with HUD takeoff from a list of candidate runways
     * @param candidateRunways the candidate runways to select from
     * @returns The one way runways with HUD takeoff available
     */
    getHudDepartureRunways(candidateRunways) {
        const selectedRunway = this.selectedDepartureRunway.get();
        if (selectedRunway !== undefined) {
            return runwayHasHudTakeoff(selectedRunway) ? [selectedRunway] : [];
        }
        return candidateRunways.filter(runwayHasHudTakeoff);
    }
    /**
     * Gets the enroute transitions of a departure or arrival procedure.
     * @param procedure A procedure.
     * @returns The enroute transitions of the procedure.
     */
    getDepArrTransitions(procedure) {
        const transitions = [];
        for (let i = 0; i < procedure.enRouteTransitions.length; i++) {
            const transition = procedure.enRouteTransitions[i];
            transitions.push({
                name: transition.name,
                transitionIndex: i
            });
        }
        return transitions;
    }
    /**
     * Gets the transitions of a selected approach.
     * @param approachListItem The Approach procedure list item.
     * @returns The transitions of the procedure.
     */
    getApproachTransitions(approachListItem) {
        var _a;
        const transitions = [];
        const approach = approachListItem === null || approachListItem === void 0 ? void 0 : approachListItem.procedure;
        if (approachListItem && approach) {
            for (let i = 0; i < approach.transitions.length; i++) {
                const transition = approach.transitions[i];
                const firstLeg = transition.legs[0];
                const name = (_a = transition.name) !== null && _a !== void 0 ? _a : (firstLeg ? ICAO.getIdent(firstLeg.fixIcao) : '');
                transitions.push({
                    name: name,
                    transitionIndex: i
                });
            }
        }
        return transitions;
    }
    /**
     * Checks a procedure's runway transitions for a match to a one way runway.
     * @param proc The Departure or Arrival Procedure
     * @param runwayNumber The runway number.
     * @param runwayDesignator The runway designator.
     * @returns Whether the procedure has a runway transition for the specified runway.
     */
    checkIfProcedureHasRunway(proc, runwayNumber, runwayDesignator) {
        let found = false;
        // If the proc.runwayTransitions is empty, that means it supports all runways
        if (proc.runwayTransitions.length < 1) {
            return true;
        }
        proc.runwayTransitions.forEach(trans => {
            if (trans.runwayNumber === runwayNumber && trans.runwayDesignation === runwayDesignator) {
                found = true;
                return;
            }
        });
        return found;
    }
    /**
     * Tries to set the departure runway transition index subject, or sets it to -1;
     */
    trySetDepartureRunwayTransitionIndex() {
        var _a;
        const procedure = (_a = this.selectedDeparture.get()) === null || _a === void 0 ? void 0 : _a.procedure;
        const runway = this.selectedDepartureRunway.get();
        if (procedure !== undefined && runway !== undefined) {
            const index = procedure.runwayTransitions.findIndex(trans => trans.runwayNumber === runway.direction && trans.runwayDesignation === runway.runwayDesignator);
            this.selectedDepartureRunwayTransitionIndex.set(index);
        }
        else {
            this.selectedDepartureRunwayTransitionIndex.set(-1);
        }
    }
    /**
     * Tries to set the arrival runway transition index subject, or sets it to -1;
     */
    trySetArrivalRunwayTransitionIndex() {
        var _a, _b;
        const procedure = (_a = this.selectedArrival.get()) === null || _a === void 0 ? void 0 : _a.procedure;
        const approach = (_b = this.selectedApproach.get()) === null || _b === void 0 ? void 0 : _b.procedure;
        if (procedure !== undefined && approach !== undefined) {
            const index = procedure.runwayTransitions.findIndex(trans => trans.runwayNumber === approach.runwayNumber && trans.runwayDesignation === approach.runwayDesignator);
            this.selectedArrivalRunwayTransitionIndex.set(index);
        }
        else {
            this.selectedArrivalRunwayTransitionIndex.set(-1);
        }
    }
    /**
     * Gets the procedure from an index
     * @param procedures is the list of procedures
     * @param index the procedure index to match
     * @returns a procedure list item, or undefined
     */
    getProcedureFromIndex(procedures, index) {
        return procedures.find(val => val.index === index);
    }
    /**
     * Gets the transition from an index
     * @param transitions is the list of transitions
     * @param index the transition index to match
     * @returns a transition list item or undefined
     */
    getTransitionFromIndex(transitions, index) {
        return transitions.find(val => val.transitionIndex === index);
    }
    /**
     * Loads the current flight plan procedure data into the store.
     * @param fms The Fms
     * @param view The Current Dep/Arr View
     */
    loadCurrentProcedureData(fms, view) {
        const plan = fms.getPlanForFmcRender();
        const procedureDetails = plan.procedureDetails;
        const planVisualApproachDesignation = fms.getFlightPlanVisualApproach(plan.planIndex);
        if (view === DepArrView.DEP) {
            this.selectedDeparture.set(this.getProcedureFromIndex(this.departures.getArray(), procedureDetails.departureIndex));
            this.selectedDepartureTransition.set(this.departureTransitions.tryGet(procedureDetails.departureTransitionIndex));
            this.selectedDepartureRunwayTransitionIndex.set(procedureDetails.departureRunwayIndex);
            this.selectedDepartureRunway.set(procedureDetails.originRunway);
            this.selectedDepartureHudTakeoffRunway.set(fms.getFlightPlanHudTakeoff(plan.planIndex));
        }
        else if (view === DepArrView.ARR) {
            this.selectedArrival.set(this.getProcedureFromIndex(this.arrivals.getArray(), procedureDetails.arrivalIndex));
            this.selectedArrivalTransition.set(this.arrivalTransitions.tryGet(procedureDetails.arrivalTransitionIndex));
            this.selectedArrivalRunwayTransitionIndex.set(procedureDetails.arrivalRunwayTransitionIndex);
            if (procedureDetails.approachIndex >= 0) {
                this.selectedApproach.set(this.getProcedureFromIndex(this.approaches.getArray(), procedureDetails.approachIndex));
                this.selectedApproachTransition.set(this.getTransitionFromIndex(this.approachTransitions.getArray(), procedureDetails.approachTransitionIndex));
            }
            else if (planVisualApproachDesignation !== undefined) {
                const approaches = this._approaches.getArray();
                for (const vis of approaches) {
                    if (vis.isVisualApproach) {
                        const proc = vis.procedure;
                        if (proc.runway === planVisualApproachDesignation) {
                            this.selectedApproach.set(vis);
                            this.selectedApproachTransition.set(undefined);
                            const visualApproachVpa = fms.getFlightPlanVisualApproachVfrVpa(plan.planIndex);
                            if (visualApproachVpa !== undefined && Number.isFinite(visualApproachVpa)) {
                                this.vfrApproachSelected.set(true);
                                this.vfrApproachFpa.set(visualApproachVpa);
                            }
                            else {
                                this.vfrApproachSelected.set(false);
                                this.vfrApproachFpa.set(3.0);
                            }
                            break;
                        }
                    }
                }
            }
            else {
                this.selectedApproach.set(undefined);
                this.selectedApproachTransition.set(undefined);
            }
        }
    }
    /**
     * Resets the Store Values
     */
    resetStore() {
        this.selectedApproach.set(undefined);
        this.selectedApproachTransition.set(undefined);
        this.selectedArrival.set(undefined);
        this.selectedArrivalTransition.set(undefined);
        this.selectedDeparture.set(undefined);
        this.selectedDepartureRunway.set(undefined);
        this.selectedDepartureTransition.set(undefined);
    }
}
/** Sorts an array of runways by their designations.
 * @param runways The runways to sort, will be sorted in place.
 * @returns A reference to the array that was passed in. */
function sortRunways(runways) {
    return runways.sort(compareRunways);
}
/** Compares two runways using their designations.
 * @param a First runway.
 * @param b Second runway.
 * @returns A number saying which one should be sorted before or after the other. */
function compareRunways(a, b) {
    if (a.designation < b.designation) {
        return -1;
    }
    if (a.designation > b.designation) {
        return 1;
    }
    return 0;
}
/** Sorts an array of approaches by their procedure name.
 * @param approaches The approaches to sort, will be sorted in place.
 * @returns A reference to the array that was passed in. */
function sortApproaches(approaches) {
    return approaches.sort(compareApproaches);
}
/** Compares two approaches using their procedure name.
 * @param a First approach.
 * @param b Second approach.
 * @returns A number saying which one should be sorted before or after the other. */
function compareApproaches(a, b) {
    // Add the 0 before the runway number if needed.
    const nameA = a.procedure.name.replace(/ (\d[\D ]*)$/, ' 0$1');
    const nameB = b.procedure.name.replace(/ (\d[\D ]*)$/, ' 0$1');
    if (nameA < nameB) {
        return -1;
    }
    if (nameA > nameB) {
        return 1;
    }
    return 0;
}
/**
 * Check if HUD takeoff is available from a runway
 * @param runway The runway to check
 * @returns true if HUD takeoff is available, else false
 */
function runwayHasHudTakeoff(runway) {
    return !!runway.ilsFrequency && runway.ilsFrequency.freqMHz > 0;
}

/**
 * Dep Arr Page Controller
 */
class BoeingDepArrPageController {
    /**
     * Creates the Controller.
     * @param eventBus The event bus
     * @param fms The Fms
     * @param store The DepArr Store
     * @param page The DepArr FMC Page
     */
    constructor(eventBus, fms, store, page) {
        this.eventBus = eventBus;
        this.fms = fms;
        this.store = store;
        this.page = page;
        this.currentView = Subject.create(DepArrView.INDEX);
        this.pageCount = Subject.create(1);
        this.currentPage = Subject.create(1);
        // public departureList: FmcTwoColumnPageableList<ProcedureListItem, OneWayRunway>;
        this.departuresConsumer = this.store.departures;
        this.departureTransitions = this.store.departureTransitions;
        this.departureRunwaysConsumer = this.store.departureRunways;
        this.arrivalsConsumer = this.store.arrivals;
        this.arrivalTransitionsConsumer = this.store.arrivalTransitions;
        this.approachesConsumer = this.store.approaches;
        this.approachTransitionsConsumer = this.store.approachTransitions;
        this.selectedDepartureConsumer = this.store.selectedDeparture;
        this.selectedDepartureTransitionConsumer = this.store.selectedDepartureTransition;
        this.selectedDepartureRunwayConsumer = this.store.selectedDepartureRunway;
        this.selectedArrivalConsumer = this.store.selectedArrival;
        this.selectedArrivalTransitionConsumer = this.store.selectedArrivalTransition;
        this.selectedApproachConsumer = this.store.selectedApproach;
        this.selectedApproachTransitionConsumer = this.store.selectedApproachTransition;
        this.procedureDetailsConsumer = this.eventBus.getSubscriber().on('fplProcDetailsChanged');
        this.originDestinationConsumer = this.eventBus.getSubscriber().on('fplOriginDestChanged');
        this.legsLink = PageLinkField.createLink(this.page, 'ROUTE>', '/rte');
        this.loadingCurrentProcedures = false;
        this.handleOnModExec = (inMod) => {
            if (!inMod) {
                this.loadingCurrentProcedures = true;
                this.store.loadCurrentProcedureData(this.fms, this.currentView.get());
                this.loadingCurrentProcedures = false;
            }
            this.refreshOriginDestination();
            this.invalidate();
        };
        this.handleOnSelectionsUpdate = () => {
            this.invalidate();
        };
        this.handleProcedureDetailsChanged = (e) => {
            if (e.planIndex === this.fms.getPlanIndexForFmcPage()) {
                this.loadingCurrentProcedures = true;
                this.store.loadCurrentProcedureData(this.fms, this.currentView.get());
                this.loadingCurrentProcedures = false;
                this.invalidate();
            }
        };
        this.handleOriginDestinationChanged = (e) => {
            if (e.planIndex === this.fms.getPlanIndexForFmcPage()) {
                this.refreshOriginDestination();
            }
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.handleCurrentPageChange = (page) => {
            this.page.invalidate();
        };
        this.GlideSlopeField = new SwitchLabel(this.page, {
            optionStrings: ['ON', 'OFF'],
            caret: 'right',
            separator: 'arrows',
        }).bind(this.fms.performancePlanProxy.glideSlope);
        this.VfrApproachField = new DisplayField(this.page, {
            formatter: new SimpleStringFormat('VFR APPR>'),
            onSelected: async () => {
                this.store.vfrApproachSelected.set(true);
                this.store.visualApproachOffset.set(8.0);
                this.invalidate();
                return true;
            },
        });
        this.EditableRwyExtField = new TextInputField(this.page, {
            formatter: {
                nullValueString: inputBox('--.-') + '[d-text]NM[s-text]',
                format: B787FmcFormatters.Unit('NM', { type: 'input', spaceBetween: false, precision: 1, padStart: 4, padString: ' ' }),
                parse: B787FmcParsers.FloatRange(25.0, 1.0),
            },
            onDelete: async () => {
                this.store.visualApproachOffset.set(5);
                this.invalidate();
                return true;
            },
        }).bind(this.store.visualApproachOffset);
        this.RwyExtField = new DisplayField(this.page, {
            formatter: {
                nullValueString: '--.-[d-text]NM[s-text]',
                format: B787FmcFormatters.Unit('NM', { type: 'display', spaceBetween: false, precision: 1, padStart: 4, padString: ' ' }),
            },
        }).bind(this.store.visualApproachOffset);
        this.FpaField = new TextInputField(this.page, {
            formatter: {
                nullValueString: inputBox('-.-'),
                format: (value) => inputBox(value.toFixed(1) + (Math.abs(value - 3.0) <= Number.EPSILON ? '[s-text]' : '[d-text]')),
                parse: B787FmcParsers.FloatRange(3.7, 2.4),
            },
            onDelete: async () => {
                this.store.vfrApproachFpa.set(3.0);
                await this.setPlanApproach();
                return true;
            },
            onModified: async (value) => {
                this.store.vfrApproachFpa.set(value);
                await this.setPlanApproach();
                return true;
            }
        }).bind(this.store.vfrApproachFpa);
        this.onLskL6 = async () => {
            const planInMod = this.fms.planInMod.get();
            if (planInMod) {
                this.fms.cancelMod();
            }
            else {
                this.currentView.set(DepArrView.INDEX);
            }
            return true;
        };
        /**
         * Callback when a procedure is selected via LSK
         * @param data The ProcedureListItem selected.
         * @returns If the selection was completed.
         */
        this.onProcedureSelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.DEP:
                    this.store.selectedDeparture.set(data);
                    this.setPlanDeparture();
                    return true;
                case DepArrView.ARR:
                    this.store.selectedArrival.set(data);
                    this.setPlanArrival();
                    return true;
            }
            return false;
        };
        /**
         * Callback when a procedure is deselected via LSK
         * @returns If the selection was completed.
         */
        this.onProcedureDeselected = async () => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.DEP:
                    this.store.selectedDeparture.set(undefined);
                    this.unsetPlanDeparture();
                    return true;
                case DepArrView.ARR:
                    this.store.selectedArrival.set(undefined);
                    this.unsetPlanArrival();
                    return true;
            }
            return false;
        };
        /**
         * Callback when a departure runway is selected via LSK
         * @param data The OneWayRunway selected.
         * @returns If the selection was completed.
         */
        this.onDepartureRunwaySelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            this.store.selectedDepartureRunway.set(data);
            this.setPlanDeparture();
            return true;
        };
        /**
         * Callback when a HUD takeoff is selected via LSK
         * @param data The OneWayRunway selected.
         * @returns If the selection was completed.
         */
        this.onDepartureHudTakeoffSelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            if (this.store.selectedDepartureRunway.get() !== data) {
                await this.onDepartureRunwaySelected(data);
            }
            this.store.selectedDepartureHudTakeoffRunway.set(data);
            this.fms.setFlightPlanHudTakeoff(this.fms.getPlanToModify().planIndex, data);
            this.invalidate();
            return true;
        };
        /**
         * Callback when a departure runway is deselected via LSK
         * @returns If the selection was completed.
         */
        this.onDepartureRunwayDeselected = async () => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            if (this.store.selectedDepartureHudTakeoffRunway.get() !== undefined) {
                await this.onDepartureHudTakeoffDeselected();
            }
            this.store.selectedDepartureRunway.set(undefined);
            this.store.selectedDepartureRunwayTransitionIndex.set(-1);
            this.setPlanDeparture();
            return true;
        };
        /**
         * Callback when a procedure transition is selected via LSK
         * @param data The TransitionListItem selected.
         * @returns If the selection was completed.
         */
        this.onProcedureTransitionSelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.DEP:
                    this.store.selectedDepartureTransition.set(data);
                    this.setPlanDeparture();
                    return true;
                case DepArrView.ARR:
                    this.store.selectedArrivalTransition.set(data);
                    this.setPlanArrival();
                    return true;
            }
            return false;
        };
        /**
         * Callback when a procedure transition is deselected via LSK
         * @returns If the selection was completed.
         */
        this.onProcedureTransitionDeselected = async () => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.DEP:
                    this.store.selectedDepartureTransition.set(undefined);
                    this.setPlanDeparture();
                    return true;
                case DepArrView.ARR:
                    this.store.selectedArrivalTransition.set(undefined);
                    this.setPlanArrival();
                    return true;
            }
            return false;
        };
        /**
         * Callback when a approach procedure is selected via LSK
         * @param data The ProcedureListItem selected.
         * @returns If the selection was completed.
         */
        this.onApproachSelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.ARR:
                    this.store.selectedApproach.set(data);
                    this.store.vfrApproachSelected.set(false);
                    this.store.visualApproachOffset.set(5.0);
                    this.store.vfrApproachFpa.set(3);
                    this.setPlanApproach();
                    return true;
            }
            return false;
        };
        /**
         * Callback when an approach procedure is deselected via LSK
         * @returns If the selection was completed.
         */
        this.onApproachDeselected = async () => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.ARR:
                    this.store.selectedApproach.set(undefined);
                    this.unsetPlanApproach();
                    this.store.selectedArrivalRunwayTransitionIndex.set(-1);
                    this.setPlanArrival();
                    return true;
            }
            return false;
        };
        /**
         * Callback when a approach transition is selected via LSK
         * @param data The TransitionListItem selected.
         * @returns If the selection was completed.
         */
        this.onApproachTransitionSelected = async (data) => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.ARR:
                    this.store.selectedApproachTransition.set(data);
                    this.setPlanApproach();
                    return true;
            }
            return false;
        };
        /**
         * Callback when an approach transition is deselected via LSK
         * @returns If the selection was completed.
         */
        this.onApproachTransitionDeselected = async () => {
            if (!this.fms.canEditPlan()) {
                return Promise.reject('XSIDE EDIT IN PROGRESS');
            }
            switch (this.currentView.get()) {
                case DepArrView.ARR:
                    // Set back to no transition
                    this.store.selectedApproachTransition.set(undefined);
                    this.setPlanApproach();
                    return true;
            }
            return false;
        };
    }
    /**
     * Initializes the Controller
     */
    init() {
        this.procedureDetailsConsumer.handle(this.handleProcedureDetailsChanged);
        this.departuresConsumer.sub(this.handleOnSelectionsUpdate);
        this.departureTransitions.sub(this.handleOnSelectionsUpdate);
        this.departureRunwaysConsumer.sub(this.handleOnSelectionsUpdate);
        this.arrivalsConsumer.sub(this.handleOnSelectionsUpdate);
        this.arrivalTransitionsConsumer.sub(this.handleOnSelectionsUpdate);
        this.approachesConsumer.sub(this.handleOnSelectionsUpdate);
        this.approachTransitionsConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedDepartureConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedDepartureTransitionConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedDepartureRunwayConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedArrivalConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedArrivalTransitionConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedApproachConsumer.sub(this.handleOnSelectionsUpdate);
        this.selectedApproachTransitionConsumer.sub(this.handleOnSelectionsUpdate);
        this.fms.planInMod.sub(this.handleOnModExec);
        this.currentPage.sub(this.handleCurrentPageChange);
        this.originDestinationConsumer.handle(this.handleOriginDestinationChanged);
        this.refreshOriginDestination();
        this.loadStartingView();
    }
    /**
     * Destroys the Controller.
     */
    destroy() {
        this.procedureDetailsConsumer.off(this.handleProcedureDetailsChanged);
        this.departuresConsumer.unsub(this.handleOnSelectionsUpdate);
        this.departureTransitions.unsub(this.handleOnSelectionsUpdate);
        this.departureRunwaysConsumer.unsub(this.handleOnSelectionsUpdate);
        this.arrivalsConsumer.unsub(this.handleOnSelectionsUpdate);
        this.arrivalTransitionsConsumer.unsub(this.handleOnSelectionsUpdate);
        this.approachesConsumer.unsub(this.handleOnSelectionsUpdate);
        this.approachTransitionsConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedDepartureConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedDepartureTransitionConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedDepartureRunwayConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedArrivalConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedArrivalTransitionConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedApproachConsumer.unsub(this.handleOnSelectionsUpdate);
        this.selectedApproachTransitionConsumer.unsub(this.handleOnSelectionsUpdate);
        this.fms.planInMod.unsub(this.handleOnModExec);
        this.currentPage.unsub(this.handleCurrentPageChange);
        this.originDestinationConsumer.off(this.handleOriginDestinationChanged);
    }
    /**
     * Local invalidate method
     */
    invalidate() {
        if (!this.loadingCurrentProcedures) {
            this.currentPage.set(1);
            this.page.invalidate();
        }
    }
    /**
     * Refreshes the origin and destination values for the page
     */
    refreshOriginDestination() {
        var _a, _b;
        const plan = this.fms.getPlanForFmcRender();
        this.store.origin.set((_a = plan.originAirport) !== null && _a !== void 0 ? _a : '');
        this.store.destination.set((_b = plan.destinationAirport) !== null && _b !== void 0 ? _b : '');
    }
    /** Sets the current view on resume based on certain criteria from the manual. */
    loadStartingView() {
        const isAircraftOnGround = !!SimVar.GetSimVarValue('SIM ON GROUND', SimVarValueType.Bool);
        const isAirborne = !isAircraftOnGround;
        const originFac = this.fms.facilityInfo.originFacility;
        const destFac = this.fms.facilityInfo.destinationFacility;
        if (originFac === undefined) {
            this.currentView.set(DepArrView.INDEX);
            return;
        }
        if (destFac === undefined) {
            this.displayDeparture();
            return;
        }
        const ppos = this.fms.ppos;
        const distanceFromOriginNM = originFac && UnitType.GA_RADIAN.convertTo(ppos.distance(originFac), UnitType.NMILE);
        const distanceToDestinationNM = destFac && UnitType.GA_RADIAN.convertTo(ppos.distance(destFac), UnitType.NMILE);
        const isLessThan50NMFromOrigin = distanceFromOriginNM < 50;
        const isLessThanHalfwayToDestination = distanceToDestinationNM > distanceFromOriginNM;
        const isMoreThanHalfwayToDestination = !isLessThanHalfwayToDestination;
        if (isAirborne && isMoreThanHalfwayToDestination) {
            this.displayArrival();
            return;
        }
        if (isAircraftOnGround || isLessThan50NMFromOrigin || isLessThanHalfwayToDestination) {
            this.displayDeparture();
            return;
        }
        this.currentView.set(DepArrView.INDEX);
    }
    /**
     * Returns the Page Header
     * @returns The Page Header as FmcRenderTemplateRow
     */
    getPageHeader() {
        const currentPage = this.currentView.get();
        const selectedFacility = this.store.selectedFacility.get();
        let title = ' '.repeat(currentPage === DepArrView.DEP ? this.page.getTitleDeparturesLeftPadding() : this.page.getTitleArrivalsLeftPadding());
        title += selectedFacility ? ICAO.getIdent(selectedFacility.icao) : 'XXXX';
        title += currentPage === DepArrView.DEP ? ' DEPARTURES' : ' ARRIVALS';
        const page = `${this.currentPage.get()}/${this.pageCount.get()}[s-text] `;
        return [title, page];
    }
    /**
     * Renders the Departures Page Template.
     *
     * @param route the route number
     *
     * @returns The FmcRenderTemplate for the Departures Page.
     */
    renderDepArrTemplate(route) {
        // TODO implement selection for route 2
        var _a, _b, _c;
        const currentPage = this.currentPage.get();
        const currentView = this.currentView.get();
        const rows = [];
        this.pageCount.set(this.getPageCount());
        const pageHeader = this.getPageHeader();
        rows.push(pageHeader);
        const leftColumnRows = this.buildLeftColumnSelectedRows(currentView, currentPage);
        const rightColumnRows = this.buildRightColumnSelectedRows(currentView, currentPage);
        const centreColumnRows = [`RTE ${route}[d-text]`];
        for (let i = 0; i < 10; i++) {
            const row = [(_a = leftColumnRows[i]) !== null && _a !== void 0 ? _a : '', (_b = rightColumnRows[i]) !== null && _b !== void 0 ? _b : '', (_c = centreColumnRows[i]) !== null && _c !== void 0 ? _c : ''];
            rows.push(row);
        }
        const planInMod = this.fms.planInMod.get();
        const lskL6 = new DisplayField(this.page, {
            formatter: RawFormatter,
            onSelected: this.onLskL6.bind(this),
        });
        lskL6.takeValue(planInMod ? '<ERASE' : '<INDEX');
        const footer = [['--------------------------------------'], [lskL6, this.legsLink]];
        footer.forEach(row => rows.push(row));
        return rows;
    }
    /**
     * Gets the page count for the procedure display.
     * @returns the number of pages
     */
    getPageCount() {
        let leftRows = 1;
        let rightRows = 1;
        switch (this.currentView.get()) {
            case DepArrView.DEP:
                leftRows = this.store.selectedDeparture.get() !== undefined ? 1 : this.store.departures.length;
                if (this.store.selectedDeparture.get() !== undefined) {
                    leftRows += this.store.selectedDepartureTransition.get() !== undefined ? 1 : this.store.departureTransitions.length;
                }
                if (this.store.selectedDepartureRunway.get() !== undefined) {
                    rightRows = 1;
                    if (this.page.isHudTakeoffAvailable() && this.store.selectedDepartureHudTakeoffRunway.get() === undefined) {
                        rightRows += this.store.hudDepartureRunways.length;
                    }
                }
                else {
                    rightRows = this.store.departureRunways.length;
                }
                break;
            case DepArrView.ARR:
                leftRows = this.store.selectedArrival.get() !== undefined ? 1 : this.store.arrivals.length;
                if (this.store.selectedArrival.get() !== undefined) {
                    leftRows += this.store.selectedArrivalTransition.get() !== undefined ? 1 : this.store.arrivalTransitions.length;
                }
                rightRows = this.store.selectedApproach.get() !== undefined ? 1 : this.store.approaches.length;
                if (this.store.selectedApproach.get() !== undefined) {
                    rightRows += this.store.selectedApproachTransition.get() !== undefined ? 1 : this.store.approachTransitions.length;
                }
                break;
        }
        return Math.ceil(Math.max(leftRows, rightRows) / 5);
    }
    /**
     * Builds the Left Column for the render (the Departures/Arrivals column)
     * @param currentView The current view
     * @param currentPage The current page
     * @returns an array of FmcRenderTemplateColumn
     */
    buildLeftColumnSelectedRows(currentView, currentPage) {
        const columnRows = [];
        const selectedProcedureData = currentView === DepArrView.DEP ? this.store.selectedDeparture.get() : this.store.selectedArrival.get();
        const selectedTransitionData = currentView === DepArrView.DEP ? this.store.selectedDepartureTransition.get() : this.store.selectedArrivalTransition.get();
        let selectedTransition;
        let header = '';
        if (currentView === DepArrView.DEP) {
            if (currentPage === 1 || !selectedProcedureData) {
                header = ' SIDS';
            }
            else {
                header = ' EO SID';
            }
        }
        else {
            if (currentPage === 1 || !selectedProcedureData) {
                header = ' STARS';
            }
            else {
                header = ' TRANS';
            }
        }
        columnRows.push(header);
        if (selectedTransitionData !== undefined && currentPage === 1) {
            selectedTransition = new DisplayField(this.page, {
                formatter: RawFormatter,
                onSelected: this.onProcedureTransitionDeselected.bind(this),
            });
            selectedTransition.takeValue(`${selectedTransitionData === null || selectedTransitionData === void 0 ? void 0 : selectedTransitionData.name.padEnd(this.page.getLeftColumnRightPadding(), ' ')}<SEL>`);
        }
        if (selectedProcedureData !== undefined) {
            if (currentPage === 1) {
                const selectedProcedure = new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: this.onProcedureDeselected.bind(this),
                });
                selectedProcedure.takeValue(`${selectedProcedureData === null || selectedProcedureData === void 0 ? void 0 : selectedProcedureData.procedure.name.padEnd(this.page.getLeftColumnRightPadding(), ' ')}<SEL>[d-text]`);
                columnRows.push(selectedProcedure !== null && selectedProcedure !== void 0 ? selectedProcedure : '');
                columnRows.push(' TRANS');
            }
            if (selectedTransition) {
                columnRows.push(selectedTransition);
                columnRows.push('');
            }
            else {
                const startIndex = currentPage === 1 ? 0 : 4 + ((currentPage - 2) * 5);
                const itemsPerPage = currentPage === 1 ? 4 : 5;
                const availableTransitionCount = currentView === DepArrView.DEP ? this.store.departureTransitions.length : this.store.arrivalTransitions.length;
                if (availableTransitionCount > 0) {
                    for (let i = startIndex; i < startIndex + itemsPerPage; i++) {
                        const data = currentView === DepArrView.DEP ? this.store.departureTransitions.tryGet(i) : this.store.arrivalTransitions.tryGet(i);
                        const renderItem = data ? new DisplayField(this.page, {
                            formatter: RawFormatter,
                            onSelected: () => this.onProcedureTransitionSelected(data),
                        }) : '';
                        data && renderItem && renderItem.takeValue(data.name);
                        columnRows.push(renderItem);
                        columnRows.push('');
                    }
                }
                else {
                    columnRows.push('-NONE-');
                    columnRows.push('');
                }
            }
        }
        else {
            const startIndex = (currentPage - 1) * 5;
            for (let i = startIndex; i < startIndex + 5; i++) {
                const data = currentView === DepArrView.DEP ? this.store.departures.tryGet(i) : this.store.arrivals.tryGet(i);
                if (currentPage === 1 && i === 0 && !data) {
                    columnRows.push('-NONE-');
                    columnRows.push('');
                    break;
                }
                else {
                    const renderItem = data ? new DisplayField(this.page, {
                        formatter: RawFormatter,
                        onSelected: () => this.onProcedureSelected(data),
                    }) : '';
                    data && renderItem && renderItem.takeValue(data.procedure.name);
                    columnRows.push(renderItem);
                    columnRows.push('');
                }
            }
        }
        return columnRows;
    }
    /**
     * Builds the Right Column for the render (the Runway/Approaches column)
     * @param currentView The current view
     * @param currentPage The current page
     * @returns an array of FmcRenderTemplateColumn
     */
    buildRightColumnSelectedRows(currentView, currentPage) {
        switch (currentView) {
            case DepArrView.INDEX:
                return this.buildRightColumnRowsForIndex(currentPage);
            case DepArrView.DEP:
                return this.buildRightColumnRowsForDeparture(currentPage);
            case DepArrView.ARR:
                return this.buildRightColumnRowsForArrival(currentPage);
        }
    }
    /** Builds the column rows for the right side of the INDEX page.
     * @param currentPage Current page number.
     * @returns The column rows for the right side of the INDEX page. */
    buildRightColumnRowsForIndex(currentPage) {
        const columnRows = [];
        const startIndex = (currentPage - 1) * 5;
        for (let i = startIndex; i < startIndex + 5; i++) {
            columnRows.push('');
            columnRows.push('');
        }
        columnRows.pop();
        return columnRows;
    }
    /** Builds the column rows for the right side of the DEPART page.
     * @param currentPage Current page number.
     * @returns The column rows for the right side of the DEPART page. */
    buildRightColumnRowsForDeparture(currentPage) {
        const columnRows = [];
        const selectedRunway = this.store.selectedDepartureRunway.get();
        const selectedHudTakeoffRunway = this.store.selectedDepartureHudTakeoffRunway.get();
        const numRunwaysToShow = this.store.departureRunways.length;
        const startPosition = (currentPage - 1) * 5;
        const runwaysOnPage = (numRunwaysToShow - 1) - startPosition;
        let header = '';
        if (currentPage === 1 || (!selectedRunway && runwaysOnPage > 0)) {
            header = 'RUNWAYS';
        }
        else {
            header = 'HUD TAKEOFF';
        }
        columnRows.push(header);
        if (selectedRunway) {
            if (currentPage === 1) {
                const selectedRunwayField = new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: this.onDepartureRunwayDeselected.bind(this),
                });
                selectedRunwayField.takeValue(`<SEL>${selectedRunway.designation.padStart(this.page.getRightColumnLeftPadding(), ' ')}[d-text]`);
                columnRows.push(selectedRunwayField);
                if (this.page.isHudTakeoffAvailable() && this.store.hudDepartureRunways.length > 0) {
                    if (currentPage === 1) {
                        columnRows.push('HUD TAKEOFF');
                    }
                    if (selectedHudTakeoffRunway) {
                        const selectedHudRunwayField = new DisplayField(this.page, {
                            formatter: RawFormatter,
                            onSelected: this.onDepartureHudTakeoffDeselected.bind(this),
                        });
                        selectedHudRunwayField.takeValue(`<SEL>${('ILS' + selectedHudTakeoffRunway.designation).padStart(this.page.getRightColumnLeftPadding(), ' ')}[d-text]`);
                        columnRows.push(selectedHudRunwayField);
                        columnRows.push('');
                    }
                    else {
                        const hudRunwayField = new DisplayField(this.page, {
                            formatter: RawFormatter,
                            onSelected: () => this.onDepartureHudTakeoffSelected(selectedRunway),
                        });
                        hudRunwayField.takeValue(`ILS${selectedRunway.designation}[d-text]`);
                        columnRows.push(hudRunwayField);
                        columnRows.push('');
                    }
                }
            }
            else {
                columnRows.push('');
            }
        }
        else {
            let rowsToFill = 5;
            const startIndex = (currentPage - 1) * 5;
            for (let i = startIndex; rowsToFill > 0; i++, rowsToFill--) {
                const runway = this.store.departureRunways.tryGet(i);
                if (runway === undefined) {
                    break;
                }
                // first row has RUNWAY header
                if (i !== startIndex) {
                    columnRows.push('');
                }
                const renderItem = new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: () => this.onDepartureRunwaySelected(runway),
                });
                renderItem.takeValue(`${runway.designation}[d-text]`);
                columnRows.push(renderItem);
            }
            if (rowsToFill > 0 && this.page.isHudTakeoffAvailable() && this.store.hudDepartureRunways.length > 0) {
                // need a header when we start partway down the page, otherwise it's already provided
                if (rowsToFill < 5) {
                    columnRows.push('HUD TAKEOFF');
                }
                const hudStartIndex = Math.max(0, (currentPage - 1) * 5 - this.store.departureRunways.length);
                for (let i = hudStartIndex; rowsToFill > 0; i++, rowsToFill--) {
                    const runway = this.store.hudDepartureRunways.tryGet(i);
                    if (runway === undefined) {
                        break;
                    }
                    // first row has HUD TAKEOFF header
                    if (i !== hudStartIndex) {
                        columnRows.push('');
                    }
                    const renderItem = new DisplayField(this.page, {
                        formatter: RawFormatter,
                        onSelected: () => this.onDepartureHudTakeoffSelected(runway),
                    });
                    renderItem.takeValue(`ILS${runway.designation}[d-text]`);
                    columnRows.push(renderItem);
                }
            }
            if (rowsToFill > 0) {
                for (; rowsToFill > 0; rowsToFill--) {
                    columnRows.push('');
                    columnRows.push('');
                }
            }
        }
        return columnRows;
    }
    /** Builds the column rows for the right side of the ARRIVAL page.
     * @param currentPage Current page number.
     * @returns The column rows for the right side of the ARRIVAL page. */
    buildRightColumnRowsForArrival(currentPage) {
        const columnRows = [];
        const selectedApproach = this.store.selectedApproach.get();
        let header = '';
        if (currentPage === 1 || !selectedApproach) {
            header = 'APPROACHES';
        }
        else {
            header = 'TRANS';
        }
        columnRows.push(header);
        if (selectedApproach) {
            if (currentPage === 1) {
                const selectedApproachField = new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: this.onApproachDeselected.bind(this),
                });
                const formattedApproachName = BoeingDepArrPageController.formatApproachName(selectedApproach, this.store.vfrApproachSelected.get());
                selectedApproachField.takeValue(`<SEL>${formattedApproachName.padStart(this.page.getRightColumnLeftPadding(), ' ')}`);
                columnRows.push(selectedApproachField);
            }
            if (selectedApproach.isVisualApproach) {
                columnRows.push('');
                const vfrApproachSelected = this.store.vfrApproachSelected.get();
                if (currentPage === 1) {
                    if (!vfrApproachSelected) {
                        columnRows.push(this.VfrApproachField);
                    }
                    else {
                        columnRows.push('');
                    }
                    columnRows.push('RWY EXT');
                    const renderItem = vfrApproachSelected ? this.RwyExtField : this.EditableRwyExtField;
                    columnRows.push(renderItem);
                    if (vfrApproachSelected) {
                        columnRows.push('FPA');
                        columnRows.push(this.FpaField);
                    }
                }
            }
            else {
                const gsToggle = selectedApproach && BoeingFmsUtils.isLocalizerApproach((selectedApproach === null || selectedApproach === void 0 ? void 0 : selectedApproach.procedure).approachType);
                if (currentPage === 1 && gsToggle) {
                    columnRows.push('G/S');
                    columnRows.push(this.GlideSlopeField);
                }
                currentPage === 1 && selectedApproach && columnRows.push('TRANS ');
                const selectedTransition = this.store.selectedApproachTransition.get();
                let selectedTransitionField;
                if (selectedTransition && currentPage === 1) {
                    selectedTransitionField = new DisplayField(this.page, {
                        formatter: RawFormatter,
                        onSelected: this.onApproachTransitionDeselected,
                    });
                    selectedTransitionField.takeValue(`<SEL>${selectedTransition === null || selectedTransition === void 0 ? void 0 : selectedTransition.name.padStart(this.page.getRightColumnLeftPadding(), ' ')}`);
                }
                if (selectedTransitionField) {
                    columnRows.push(selectedTransitionField);
                    columnRows.push('');
                }
                else if (this.store.approachTransitions.length === 0) {
                    columnRows.push('-NONE-');
                    columnRows.push('');
                }
                else {
                    const itemsOnFirstPage = gsToggle ? 3 : 4;
                    const startIndex = currentPage === 1 ? 0 : itemsOnFirstPage + ((currentPage - 2) * 5);
                    const itemsPerPage = currentPage === 1 ? itemsOnFirstPage : 5;
                    for (let i = startIndex; i < startIndex + itemsPerPage; i++) {
                        const transition = this.store.approachTransitions.tryGet(i);
                        const renderItem = transition ? new DisplayField(this.page, {
                            formatter: RawFormatter,
                            onSelected: () => this.onApproachTransitionSelected(transition),
                        }) : '';
                        transition && renderItem && renderItem.takeValue(transition.name.padEnd(5, ' '));
                        columnRows.push(renderItem);
                        columnRows.push('');
                    }
                }
            }
        }
        else if (!selectedApproach) {
            const startIndex = (currentPage - 1) * 5;
            for (let i = startIndex; i < startIndex + 5; i++) {
                const approach = this.store.approaches.tryGet(i);
                const renderItem = approach ? new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: () => this.onApproachSelected(approach),
                    style: '[d-text]',
                }) : '';
                approach && renderItem && renderItem.takeValue(BoeingDepArrPageController.formatApproachName(approach, false));
                columnRows.push(renderItem);
                columnRows.push('');
            }
        }
        return columnRows;
    }
    /**
     * Callback when a HUD takeoff is deselected via LSK
     * @returns if the selection was completed.
     */
    async onDepartureHudTakeoffDeselected() {
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        this.store.selectedDepartureHudTakeoffRunway.set(undefined);
        this.fms.setFlightPlanHudTakeoff(this.fms.getPlanToModify().planIndex, undefined);
        this.invalidate();
        return true;
    }
    /**
     * Sets the currently selected departure procedure in the plan.
     */
    setPlanDeparture() {
        const departure = this.store.selectedDeparture.get();
        const facility = this.store.selectedFacility.get();
        const runway = this.store.selectedDepartureRunway.get();
        if (facility && departure) {
            const transition = this.store.selectedDepartureTransition.get();
            this.fms.insertDeparture(facility, departure.index, this.store.selectedDepartureRunwayTransitionIndex.get(), transition ? transition.transitionIndex : -1, runway);
        }
        else if (facility && runway) {
            this.fms.setOrigin(facility, runway);
        }
        else if (facility && !runway) {
            this.fms.setOrigin(facility);
        }
    }
    /**
     * Removes the departure procedure from the plan.
     */
    unsetPlanDeparture() {
        this.fms.removeDeparture();
    }
    /**
     * Sets the currently selected arrival procedure in the plan.
     */
    setPlanArrival() {
        const arrival = this.store.selectedArrival.get();
        const facility = this.store.selectedFacility.get();
        if (facility && arrival) {
            const transition = this.store.selectedArrivalTransition.get();
            this.fms.insertArrival(facility, arrival.index, this.store.selectedArrivalRunwayTransitionIndex.get(), transition ? transition.transitionIndex : -1);
        }
    }
    /**
     * Removes the arrival procedure from the plan.
     */
    unsetPlanArrival() {
        this.fms.removeArrival();
    }
    /**
     * Sets the currently selected approach procedure in the plan.
     */
    async setPlanApproach() {
        var _a;
        const approach = this.store.selectedApproach.get();
        const facility = this.store.selectedFacility.get();
        if (facility && approach) {
            const transition = this.store.selectedApproachTransition.get();
            const proc = approach.procedure;
            if (this.store.vfrApproachSelected.get()) {
                approach.isVfrApproach = true;
            }
            this.setPlanArrival();
            await this.fms.insertApproach({
                facility,
                approachIndex: approach.index,
                approachTransitionIndex: (_a = transition === null || transition === void 0 ? void 0 : transition.transitionIndex) !== null && _a !== void 0 ? _a : -1,
                visualRunwayNumber: approach.isVisualApproach ? proc.runwayNumber : undefined,
                visualRunwayDesignator: approach.isVisualApproach ? proc.runwayDesignator : undefined,
                transStartIndex: transition === null || transition === void 0 ? void 0 : transition.startIndex,
                visualRunwayOffset: this.store.visualApproachOffset.get(),
                vfrVerticalPathAngle: this.store.vfrApproachSelected.get() ? this.store.vfrApproachFpa.get() : undefined,
            });
        }
    }
    /**
     * Removes the approach procedure from the plan.
     */
    unsetPlanApproach() {
        this.fms.removeApproach();
        this.setPlanArrival();
    }
    /** Sets the Selected Facility for the Arrival */
    displayArrival() {
        this.store.selectedFacility.set(this.fms.facilityInfo.destinationFacility);
        this.store.loadCurrentProcedureData(this.fms, this.currentView.get());
        this.currentView.set(DepArrView.ARR);
    }
    /** Sets the Selected Facility for the Departure */
    displayDeparture() {
        this.store.selectedFacility.set(this.fms.facilityInfo.originFacility);
        this.store.loadCurrentProcedureData(this.fms, this.currentView.get());
        this.currentView.set(DepArrView.DEP);
    }
    /**
     * Formats the name of an approach for display on the right side of the ARRIVAL page.
     *
     * @param approach The approach procedure list item.
     * @param vfrApproach Whether the list iem is a VFR approach.
     *
     * @returns The formatted name.
     */
    static formatApproachName(approach, vfrApproach) {
        // Example approach formatting results:
        // ILS 8L    -> ILS   08L
        // RNAV 19 Z -> RNV Z 19
        // RNAV 4    -> RNV   04
        // VOR 7     -> VOR   07
        // NDB       -> NDB
        // eslint-disable-next-line prefer-const
        let [type, rwy = '', alt = ''] = approach.procedure.name.split(' ');
        if (rwy.match(/^\d[A-Z]?$/)) {
            rwy = '0' + rwy;
        }
        rwy = rwy.padEnd(3, ' ');
        // Uncomment these as needed
        // These either don't need any adjustment (like ILS)
        // Or I couldn't find an approach in sim to test with
        // type = type.replace(/ILS/, 'ILS');
        // type = type.replace(/LOC/, 'LOC');
        type = type.replace(/B\/C/, 'BAC');
        // type = type.replace(/LDA/, 'LDA');
        // type = type.replace(/SDF/, 'SDF');
        // type = type.replace(/GPS/, 'GPS');
        // type = type.replace(/VOR/, 'VOR');
        // type = type.replace(/NDB/, 'NDB');
        // type = type.replace(/IGS/, 'IGS');
        // type = type.replace(/VOR\/DME/, 'V/D');
        // type = type.replace(/VORTAC/, 'VOR');
        // type = type.replace(/NDB\/DME/, 'N/D');
        // type = type.replace(/TACAN/, 'TCN');
        type = type.replace(/RNAV/, 'RNV');
        if (type === 'VISUAL') {
            type = type.replace(/VISUAL/, '');
            if (vfrApproach) {
                type = 'VFR';
            }
        }
        type = type.padEnd(3, ' ');
        if (alt) {
            return `${type} ${alt} ${rwy}`;
        }
        else if (rwy) {
            return `${type} ${rwy}`;
        }
        else {
            return type;
        }
    }
}

// TODO Make sure pilot TRANS LVL is cleared when dest changed
/** A Boeing DESCENT FORECAST page. */
class BoeingDescentForecastPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, numberOfWindEntries, numberOfPages, ThermalAntiIceHeader, ThermalAntiIceFieldNullValue, LineTitle) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.numberOfWindEntries = numberOfWindEntries;
        this.numberOfPages = numberOfPages;
        this.ThermalAntiIceHeader = ThermalAntiIceHeader;
        this.ThermalAntiIceFieldNullValue = ThermalAntiIceFieldNullValue;
        this.LineTitle = LineTitle;
        this.perfPlan = this.fms.performancePlanProxy;
        this.windPlanner = this.fms.windPlanner;
        this.windEntries = Array.from({ length: this.numberOfWindEntries }, () => (Subject.create(null)));
        this.TransLvlField = new TextInputField(this, {
            formatter: new FlightLevelInputFormat('input'),
            deleteAllowed: false,
        }).bind(this.perfPlan.transitionLevel);
        // TODO Wire this up once thermal anti-ice altitude(s) are implemented
        /*
        private readonly ThermalAntiIceField = new TextInputField<Nullable<number>>(this, {
          formatter: new AltitudeInputFormat('input', this.perfPlan.transitionLevel, this.ThermalAntiIceFieldNullValue),
          deleteAllowed: true,
        }).bind(this.perfPlan.thermalAntiIceAltitude);
        */
        this.windAltTempFields = this.windEntries.map((record) => new TextInputField(this, {
            formatter: this.windAltTempFormatter(this.perfPlan.transitionLevel),
            deleteAllowed: true,
            onDelete: async () => {
                var _a, _b;
                const oldAlt = (_b = (_a = record.get()) === null || _a === void 0 ? void 0 : _a.altitude) !== null && _b !== void 0 ? _b : null;
                if (oldAlt !== null) {
                    const flightPlan = this.fms.getPlanForFmcRender();
                    this.windPlanner.deleteDescentWindAndTemperature(flightPlan.planIndex, oldAlt);
                    return true;
                }
                else {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
            },
            onModified: async ([alt, temp]) => {
                var _a, _b;
                const flightPlan = this.fms.getPlanForFmcRender();
                const oldAlt = (_b = (_a = record.get()) === null || _a === void 0 ? void 0 : _a.altitude) !== null && _b !== void 0 ? _b : null;
                if (oldAlt !== null) {
                    // replacing the existing record
                    this.windPlanner.deleteDescentWindAndTemperature(flightPlan.planIndex, oldAlt);
                }
                this.windPlanner.setDescentTemperature(flightPlan.planIndex, alt, temp);
                return true;
            }
        }).bind(record));
        this.windDirSpdFormatter = new WindDirSpdFormat();
        this.windDirSpdFields = this.windEntries.map((record) => new TextInputField(this, {
            formatter: this.windDirSpdFormatter,
            deleteAllowed: false,
            onModified: async ([dir, spd]) => {
                const oldData = record.get();
                if (oldData === null) {
                    // this line is inactive as there's no altitude
                    return true;
                }
                else if ((oldData.speed === null || oldData.direction === null) && (dir === null || spd === null)) {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidEntryWindDirSpdInitial);
                }
                else {
                    const flightPlan = this.fms.getPlanForFmcRender();
                    this.windPlanner.setDescentWind(flightPlan.planIndex, oldData.altitude, spd !== null ? spd : oldData.speed, dir !== null ? dir : oldData.direction);
                    return true;
                }
            },
        }).bind(record));
        this.desLink = PageLinkField.createLink(this, 'DES>', '/vnav#3');
    }
    // FIXME this is ineffective since CDU page logic changed...
    /** @inheritdoc */
    isLskActive(row, col) {
        var _a, _b;
        const dataIndex = (this.screen.currentSubpageIndex.get() - 1) * 4 + row;
        if (row > 0 && row < 5) {
            if (col === 0) { // altitude column
                // check if previous alt entry is filled, or we're the first row
                return dataIndex === 0 || !!((_a = this.windEntries[dataIndex - 1].get()) === null || _a === void 0 ? void 0 : _a.altitude);
            }
            else { // dir/spd column
                // check if this row's alt entry is filled
                return !!((_b = this.windEntries[dataIndex].get()) === null || _b === void 0 ? void 0 : _b.altitude);
            }
        }
        return super.isLskActive(row, col);
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.addBinding(this.bus.getSubscriber().on('descent_wind_data_changed').handle(this.onWindDataChanged.bind(this)));
        this.onWindDataChanged();
    }
    /**
     * Handle wind data changes from the store
     * @param ev Wind change event
     */
    onWindDataChanged(ev) {
        var _a, _b, _c;
        const planIndex = (_a = ev === null || ev === void 0 ? void 0 : ev.planIndex) !== null && _a !== void 0 ? _a : this.fms.getPlanForFmcRender();
        if (this.fms.getPlanForFmcRender().planIndex !== planIndex) {
            return;
        }
        const winds = (_c = (_b = this.windPlanner.getDescentWindsAndTemperatures(planIndex)) === null || _b === void 0 ? void 0 : _b.slice().sort((a, b) => b.altitude - a.altitude)) !== null && _c !== void 0 ? _c : [];
        winds.forEach((r, i) => this.windEntries[i].set(r));
        // clear the unused ones in case they were used before
        for (let i = winds.length; i < this.windEntries.length; i++) {
            this.windEntries[i].set(null);
        }
        this.invalidate();
    }
    /** @inheritDoc */
    render() {
        const page1PagingIndicator = this.numberOfPages === 2 ? this.PagingIndicator : '';
        const page1 = [
            ['', page1PagingIndicator, 'DESCENT FORECAST'],
            [' TRANS LVL', `${this.ThermalAntiIceHeader}[disabled]`],
            [this.TransLvlField, `${this.ThermalAntiIceFieldNullValue}[disabled]`],
            [' ALT', 'WIND DIR/SPD'],
            [this.windAltTempFields[0], this.windDirSpdFields[0]],
            ['', ''],
            [this.windAltTempFields[1], this.windDirSpdFields[1]],
            ['', ''],
            [this.windAltTempFields[2], this.windDirSpdFields[2]],
            ['', ''],
            [this.windAltTempFields[3], this.windDirSpdFields[3]],
            [this.LineTitle],
            ['<REQUEST[disabled]', this.desLink], // Note if wind uplink is implemented these fields are dynamic
        ];
        const page2 = [
            ['', this.PagingIndicator, 'DESCENT FORECAST'],
            [' ALT', 'WIND DIR/SPD'],
            [this.windAltTempFields[4], this.windDirSpdFields[4]],
            ['', ''],
            [this.windAltTempFields[5], this.windDirSpdFields[5]],
            ['', ''],
            [this.windAltTempFields[6], this.windDirSpdFields[6]],
            ['', ''],
            [this.windAltTempFields[7], this.windDirSpdFields[7]],
            ['', ''],
            [this.windAltTempFields[8], this.windDirSpdFields[8]],
            [this.LineTitle],
            ['<REQUEST[disabled]', this.desLink], // Note if wind uplink is implemented these fields are dynamic
        ];
        return this.numberOfPages === 1 ? [page1] : [page1, page2];
    }
}

/**
 * The Boeing FMC COMM page.
 */
class BoeingFmcCommPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.RteLink = PageLinkField.createLink(this, '<RTE 1', '/rte');
        this.PerfInitLink = PageLinkField.createLink(this, '<PERF', '/perf-init');
        this.WindLink = PageLinkField.createLink(this, '<WIND', '/wind');
        this.AltnLink = PageLinkField.createLink(this, '<ALTN', '/altn');
        this.TakeoffLink = PageLinkField.createLink(this, '<TAKEOFF', '/takeoff-ref');
        this.PosReportLink = PageLinkField.createLink(this, 'POS REPORT>', '/pos-report');
        this.DesForecastLink = PageLinkField.createLink(this, '<DES FORECAST', '/des-forecast');
    }
    /** @inheritDoc */
    onInit() {
        this.WindLink.getOptions().onSelected = async () => {
            this.fms.getPrimaryFlightPlan().length && this.screen.navigateTo('/wind');
            return true;
        };
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'FMC COMM'],
                [''],
                [this.RteLink, this.PosReportLink],
                [''],
                [this.AltnLink, this.ClbForecastLink()],
                [''],
                [this.PerfInitLink],
                [''],
                [this.TakeoffLink],
                [''],
                [this.WindLink],
                ['', 'DATA LINK[disabled]'],
                [this.DesForecastLink, 'NO COMM[disabled]'],
            ],
        ];
    }
}

const DISTANCE_FORMATTER = NumberFormatter.create({ precision: 1, maxDigits: 3, forceDecimalZeroes: true, nanString: ' ' });
/**
 * LEGS PAGE Controller
 */
class BoeingLegsPageController {
    /**
     * Creates the Controller.
     * @param page The FMC Page
     * @param eventBus The event bus
     * @param fms The Fms
     * @param store The Store
     */
    constructor(page, eventBus, fms, store) {
        this.page = page;
        this.eventBus = eventBus;
        this.fms = fms;
        this.store = store;
        this.isForHoldSelection = false;
        this.currentPage = Subject.create(1);
        this.pageCount = ComputedSubject.create(0, (v) => {
            return Math.max(1, Math.ceil(v / 5));
        });
        this.currentCtrIndex = 0;
        this.legChangeConsumerLegs = this.eventBus.getSubscriber().on('fplLegChange');
        this.planCopiedConsumerLegs = this.eventBus.getSubscriber().on('fplCopied');
        this.planCalculatedConsumerLegs = this.eventBus.getSubscriber().on('fplCalculated');
        this.activeLegChangeConsumerLegs = this.eventBus.getSubscriber().on('fplActiveLegChange');
        this.lnavDataConsumerLegs = this.eventBus.getSubscriber().on('lnavdata_waypoint_distance');
        this.predictionsConsumerLegs = this.fms.activeRoutePredictor.onPredictionsUpdated;
        this.sequencingSuspendedConsumerLegs = this.eventBus.getSubscriber().on('lnav_is_suspended');
        this.effectiveLegIndexConsumerLegs = this.eventBus.getSubscriber().on('lnavdata_nominal_leg_index');
        this.commandedFmsAlt = ConsumerSubject.create(this.eventBus.getSubscriber()
            .on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.commandedFmsSpeedIas = ConsumerSubject.create(this.eventBus.getSubscriber().on('fms_speed_computed_target_ias'), -1);
        this.commandedFmsSpeedMach = ConsumerSubject.create(this.eventBus.getSubscriber().on('fms_speed_computed_target_mach'), -1);
        this.commandedFmsSpeedIsMach = ConsumerSubject.create(this.eventBus.getSubscriber().on('fms_speed_computed_target_is_mach'), false);
        this.commandedFmsSpeedSource = ConsumerSubject.create(this.eventBus.getSubscriber().on('fms_speed_computed_target_source'), FmsSpeedTargetSource.None);
        this.listConsumerLegs = this.store.legs;
        this.activeLegDistance = 0;
        this.effectiveLegIndex = -1;
        this.planChanged = false;
        this.lnavSequencing = true;
        this.ppos = ConsumerSubject.create(this.eventBus.getSubscriber().on('gps-position'), new LatLongAlt());
        this.isPlanMapStepEnabled = Subject.create(false);
        /**
         * Renders a row.
         * @param page The FmcPage
         * @param indexInDisplay the index in the rendered list
         * @param prevData The prev Data as RoutePageLegItem or undefined
         * @param data The Data as RoutePageLegItem or undefined
         * @returns an array of FmcRenderTemplateRows
         */
        this.renderRow = (page, indexInDisplay, prevData, data) => {
            var _a, _b, _c, _d, _e;
            const planInMod = this.fms.planInMod.get();
            const inDirectTo = this.isFmcPageInDirectToExistingState();
            const showDirectToLayout = planInMod && inDirectTo;
            if (data !== undefined) {
                const ident = new DisplayField(this.page, {
                    formatter: {
                        nullValueString: '',
                        /** @inheritDoc */
                        format(value) {
                            return inputBox(value);
                        }
                    },
                    onSelected: (scratchpadContents) => this.leftPressed(data, scratchpadContents, false),
                    onDelete: () => this.leftPressed(data, '', true),
                });
                const altitudeField = new DisplayField(this.page, {
                    formatter: RawFormatter,
                    onSelected: (scratchpadContents) => this.rightPressed(data, scratchpadContents, false),
                    onDelete: () => this.rightPressed(data, '', true),
                });
                const dtkDistance = new DisplayField(this.page, {
                    formatter: RawFormatter,
                });
                const fpa = new DisplayField(this.page, {
                    formatter: RawFormatter,
                });
                // TO Leg is WHITE when in MOD
                const toLegStyle = planInMod ? '' : '[magenta]';
                if (prevData && ((_a = prevData.legDefinition) === null || _a === void 0 ? void 0 : _a.leg.type) === LegType.Discontinuity) {
                    dtkDistance.takeValue(this.page.getDiscontinuityLineString());
                }
                else if (data.legDefinition) {
                    const addHeader = showDirectToLayout && indexInDisplay === 3;
                    dtkDistance.takeValue(this.getAnnotationRowString(data.legDefinition, prevData === null || prevData === void 0 ? void 0 : prevData.legDefinition, data.isToLeg ? this.activeLegDistance : undefined, addHeader));
                }
                if (data.legDefinition) {
                    if (!data.legDefinition.leg.fixIcao) {
                        ident.takeValue('PPOS   ');
                    }
                    if (data.legDefinition.leg.type === LegType.Discontinuity) {
                        dtkDistance.takeValue(BoeingLegsPageController.discoCourseString);
                        ident.takeValue(BoeingLegsPageController.discoIdentString + (data.isToLeg ? toLegStyle : ''));
                    }
                    else {
                        if (showDirectToLayout && data.isToLeg) {
                            ident.takeValue(`${(_c = (_b = data.legDefinition.name) === null || _b === void 0 ? void 0 : _b.padEnd(7, ' ')) !== null && _c !== void 0 ? _c : 'noname'}[r-white]`);
                        }
                        else {
                            if (data.globalLegIndex === this.currentCtrIndex) {
                                ident.getOptions().suffix = this.page.getCtrString();
                            }
                            ident.takeValue(`${(_e = (_d = data.legDefinition.name) === null || _d === void 0 ? void 0 : _d.padEnd(7, ' ')) !== null && _e !== void 0 ? _e : 'noname'}${data.isToLeg ? toLegStyle : ''}`);
                        }
                        let constraintsString = '';
                        if (data.verticalDisplayData) {
                            const suppressMagentaSpeed = this.magentaSpeedFirstGlobalIndex !== undefined && this.magentaSpeedFirstGlobalIndex < data.globalLegIndex;
                            const suppressMagentaAlt = this.magentaAltFirstGlobalIndex !== undefined && this.magentaAltFirstGlobalIndex < data.globalLegIndex;
                            constraintsString = BoeingLegsPageController.getConstraintsString(data.verticalDisplayData, suppressMagentaSpeed, suppressMagentaAlt, this.page.shouldPadConstraintsString());
                        }
                        else {
                            constraintsString = inputBox(this.page.shouldPadConstraintsString() ? '---/------'.padStart(16, ' ') : '---/------');
                        }
                        // Show DTO indications
                        if (showDirectToLayout) {
                            if (indexInDisplay === 3) {
                                altitudeField.takeValue('ABEAM PTS>[disabled]');
                            }
                            else if (indexInDisplay === 4) {
                                altitudeField.takeValue('RTE COPY>[disabled]');
                            }
                            else {
                                altitudeField.takeValue(constraintsString);
                            }
                        }
                        else {
                            altitudeField.takeValue(constraintsString);
                        }
                        const legVpa = data.legDefinition.leg['verticalAngle'];
                        if (Number.isFinite(legVpa) && legVpa !== 0) {
                            fpa.takeValue(`GP ${(360 - legVpa).toFixed(2)}°`);
                        }
                    }
                }
                else {
                    // Show DTO indications
                    if (showDirectToLayout) {
                        if (indexInDisplay === 3) {
                            fpa.takeValue(BoeingLegsPageController.directToOptionsHeaderstring);
                            altitudeField.takeValue('ABEAM PTS>[disabled]');
                        }
                        else if (indexInDisplay === 4) {
                            altitudeField.takeValue('RTE COPY>[disabled]');
                        }
                    }
                    if (data.isLegEntry) {
                        ident.takeValue('-----  ');
                        fpa.takeValue('');
                    }
                }
                return [[dtkDistance, fpa], [ident, altitudeField]];
            }
            return [[''], ['']];
        };
        this.legsList = new FmcListUtility(this.page, this.store.legs, this.renderRow, 5);
        /**
         * Handles when the step function is enabled.
         * @param enabled Whether the Plan Map Step is enabled
         */
        this.handleIsPlanMapStepEnabled = (enabled) => {
            this.resetCtr(enabled ? this.currentPage.get() : -1);
        };
        /**
         * Handles when a Lnav Sequencing event is received over the bus
         * @param isSuspended Whether sequencing is suspended
         */
        this.handleSequencingSuspendedEventLegs = (isSuspended) => {
            this.lnavSequencing = !isSuspended;
            this.invalidate();
        };
        /**
         * Handles when a Flight Plan Change Event is received over the bus
         * @param event is the FlightPlanLegEvent
         */
        this.handleFlightPlanChangeEventLegs = (event) => {
            if (event.planIndex === this.fms.getPlanIndexForFmcPage()) {
                this.planChanged = true;
                this.updateData();
            }
        };
        /**
         * Handles when a Flight Plan Change Event is received over the bus
         */
        this.handleFlightPlanCopyEventLegs = () => {
            this.planChanged = true;
        };
        /**
         * Handles when the Active Leg Changeed Event is received over the bus
         * @param event is the FlightPlanActiveLegEvent
         */
        this.handlePlanActiveLegChangeLegs = (event) => {
            if (this.fms.getPlanIndexForFmcPage() === BoeingFms.RTE_1_MOD_PLAN_INDEX
                && event.planIndex === this.fms.getPlanIndexForFmcPage()) {
                this.planChanged = true;
            }
        };
        /**
         * Handles when the Effective Leg Value Event is received over the bus
         * @param index The Effective Active Leg Index
         */
        this.handleEffectiveLegChangedLegs = (index) => {
            this.effectiveLegIndex = index;
            if (!this.fms.planInMod.get() && index > -1) {
                this.planChanged = true;
                this.updateData();
            }
        };
        /**
         * Handles when the Calculated Event is received over the bus
         * @param event is the FlightPlanCalculatedEvent
         */
        this.handleFlightPlanCalculatedEventLegs = (event) => {
            if (event.planIndex === this.fms.getPlanIndexForFmcPage() && this.planChanged) {
                this.updateData();
            }
            else if (event.planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX) {
                if (this.fms.planInMod.get() && this.fms.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                    this.fms.verticalPathCalculator.requestPathCompute(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                }
            }
        };
        /**
         * Handles when the leg predictions are updated.
         */
        this.handlePredictionsUpdated = () => {
            this.updateData();
        };
        /**
         * Handles when the active leg distance updates once per second.
         * @param dis is the distance to the active waypoint in NM
         */
        this.handleActiveLegDistanceUpdate = (dis) => {
            const rounded = Math.round(dis * 10) / 10;
            if (rounded !== this.activeLegDistance) {
                this.activeLegDistance = rounded;
                this.planChanged = true;
            }
        };
        this.handleOnModExecLegs = () => {
            // Call updateData immediately, which will invalidate the page causing a render,
            // so that the user has immediate feedback after hitting EXEC or ERASE
            this.updateData();
            this.planChanged = true;
        };
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.handleCurrentPageChangeLegs = () => {
            this.resetCtr(this.currentPage.get());
            this.invalidate();
        };
        this.handleOnListUpdateLegs = () => {
            this.invalidate();
        };
    }
    /**
     * Initializes the Controller
     *
     * @param scratchpadContents the scratchpad contents at the time the page is being displayed
     */
    init(scratchpadContents) {
        this.legChangeConsumerLegs.handle(this.handleFlightPlanChangeEventLegs);
        this.activeLegChangeConsumerLegs.handle(this.handlePlanActiveLegChangeLegs);
        this.planCalculatedConsumerLegs.handle(this.handleFlightPlanCalculatedEventLegs);
        this.lnavDataConsumerLegs.atFrequency(1).handle(this.handleActiveLegDistanceUpdate);
        this.planCopiedConsumerLegs.handle(this.handleFlightPlanCopyEventLegs);
        this.sequencingSuspendedConsumerLegs.whenChanged().handle(this.handleSequencingSuspendedEventLegs);
        this.effectiveLegIndexConsumerLegs.whenChanged().handle(this.handleEffectiveLegChangedLegs);
        this.predictionsConsumerLegs.on(this.handlePredictionsUpdated);
        this.fms.planInMod.sub(this.handleOnModExecLegs);
        this.currentPage.sub(this.handleCurrentPageChangeLegs);
        this.listConsumerLegs.sub(this.handleOnListUpdateLegs);
        this.isPlanMapStepEnabled.sub(this.handleIsPlanMapStepEnabled, true);
        MappedSubject.create(this.commandedFmsSpeedIas, this.commandedFmsSpeedMach, this.commandedFmsSpeedIsMach, this.commandedFmsSpeedSource, this.commandedFmsAlt).sub(() => this.updateData());
        if (scratchpadContents !== this.store.selectedLegIdent) {
            this.store.selectedLeg = undefined;
        }
        this.updateData();
    }
    /**
     * Destroys the Controller.
     */
    destroy() {
        this.legChangeConsumerLegs.off(this.handleFlightPlanChangeEventLegs);
        this.activeLegChangeConsumerLegs.off(this.handlePlanActiveLegChangeLegs);
        this.planCalculatedConsumerLegs.off(this.handleFlightPlanCalculatedEventLegs);
        this.lnavDataConsumerLegs.off(this.handleActiveLegDistanceUpdate);
        this.planCopiedConsumerLegs.off(this.handleFlightPlanCopyEventLegs);
        this.sequencingSuspendedConsumerLegs.off(this.handleSequencingSuspendedEventLegs);
        this.effectiveLegIndexConsumerLegs.off(this.handleEffectiveLegChangedLegs);
        this.predictionsConsumerLegs.off(this.handlePredictionsUpdated);
        this.fms.planInMod.unsub(this.handleOnModExecLegs);
        this.currentPage.unsub(this.handleCurrentPageChangeLegs);
        this.isPlanMapStepEnabled.unsub(this.handleIsPlanMapStepEnabled);
        this.listConsumerLegs.unsub(this.handleOnListUpdateLegs);
        this.ppos.destroy();
    }
    /**
     * Ensures this page is not setup for hold selection
     */
    ensureNotInHoldSelection() {
        this.store.holdAtFacilitySubject.set(null);
        this.isForHoldSelection = false;
        this.page.params.delete('isForHoldSelection');
    }
    /**
     * Steps the CTR leg index forward.
     */
    stepCtr() {
        const plan = this.fms.getPlanForFmcRender();
        // if we are at the end of the plan, reset to first page
        if (this.currentCtrIndex === plan.length - 1) {
            this.resetCtr(1);
        }
        this.currentCtrIndex = Math.max(this.currentCtrIndex, plan.activeLateralLeg);
        // find next suitable leg index to show
        for (let i = this.currentCtrIndex + 1; i < plan.length; i++) {
            const leg = plan.tryGetLeg(i);
            if (leg !== undefined && leg !== null && leg.leg.type !== LegType.Discontinuity) {
                this.currentCtrIndex = i;
                break;
            }
        }
        const page = Math.floor((this.currentCtrIndex - plan.activeLateralLeg) / 5);
        this.currentPage.set(page + 1);
        this.sendCtrEvent();
    }
    /**
     * Sends the event to CTR a leg.
     */
    sendCtrEvent() {
        var _a, _b, _c, _d;
        const legToCtr = this.fms.getPlanForFmcRender().tryGetLeg(this.currentCtrIndex);
        if (legToCtr !== undefined && legToCtr !== null) {
            this.eventBus.getPublisher().pub('plan_map_ctr_wpt', {
                // We don't need the ICAO because it's already being displayed, don't want to show 2 icons
                icao: null,
                index: this.page.screen.getSideIndex(),
                position: { lat: (_b = (_a = legToCtr.calculated) === null || _a === void 0 ? void 0 : _a.endLat) !== null && _b !== void 0 ? _b : 0, lon: (_d = (_c = legToCtr.calculated) === null || _c === void 0 ? void 0 : _c.endLon) !== null && _d !== void 0 ? _d : 0 }
            }, true, false);
            this.invalidate();
        }
    }
    /**
     * Resets the CTR leg index.
     * @param page The page we are resetting to
     */
    resetCtr(page) {
        if (page > -1 && this.isPlanMapStepEnabled.get() === true) {
            // center first leg of page
            const plan = this.fms.getPlanForFmcRender();
            this.currentCtrIndex = Math.max(plan.activeLateralLeg, 0) + (page - 1) * 5;
        }
        else {
            this.currentCtrIndex = -1;
        }
        if (this.currentCtrIndex > -1) {
            this.sendCtrEvent();
        }
    }
    /**
     * Local invalidate method
     */
    invalidate() {
        this.page.invalidate();
    }
    /**
     * Renders the Page
     * @returns The FmcRenderTemplate
     */
    renderPageRows() {
        var _a, _b;
        const template = [[this.page.PageHeaderDisplay, this.page.FplnPagingIndicator]];
        const legsArr = this.store.legs.getArray();
        this.magentaSpeedFirstGlobalIndex = (_a = legsArr.find((legPageItem) => { var _a; return Boolean((_a = legPageItem.verticalDisplayData) === null || _a === void 0 ? void 0 : _a.speedIsCommanded); })) === null || _a === void 0 ? void 0 : _a.globalLegIndex;
        this.magentaAltFirstGlobalIndex = (_b = legsArr.find((legPageItem) => { var _a; return Boolean((_a = legPageItem.verticalDisplayData) === null || _a === void 0 ? void 0 : _a.altitudeIsCommanded); })) === null || _b === void 0 ? void 0 : _b.globalLegIndex;
        this.legsList.renderList(this.currentPage.get()).forEach(row => template.push(row));
        return template;
    }
    /**
     * Method to update the data used to render the Legs page.
     */
    updateData() {
        if (this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const lateralPlan = this.fms.getPlanForFmcRender();
            const activeLegIndex = Math.max(lateralPlan.activeLateralLeg, this.effectiveLegIndex);
            const fromLegIndex = Math.max(0, activeLegIndex);
            const startSegmentIndex = Math.max(0, lateralPlan.getSegmentIndex(fromLegIndex));
            const legs = [];
            let isToLeg = true;
            let mapFound = false;
            for (let s = startSegmentIndex; s < lateralPlan.segmentCount; s++) {
                const segment = lateralPlan.getSegment(s);
                let startLegIndex = 0;
                if (s === startSegmentIndex) {
                    startLegIndex = fromLegIndex - segment.offset;
                }
                for (let l = startLegIndex; l < segment.legs.length; l++) {
                    const legDefinition = segment.legs[l];
                    const globalLegIndex = segment.offset + l;
                    const predictions = this.fms.activeRoutePredictor.getPredictionsForLeg(globalLegIndex);
                    const fmsCommandedSpeedValue = this.commandedFmsSpeedIsMach.get() ? this.commandedFmsSpeedMach.get() : this.commandedFmsSpeedIas.get();
                    const verticalDisplayData = BoeingVerticalIOUtils.getDisplayDataForLeg(legDefinition, predictions, this.fms.activePerformancePlan.transitionAltitude.get(), this.fms.activePerformancePlan.transitionLevel.get(), this.commandedFmsAlt.get(), fmsCommandedSpeedValue, this.commandedFmsSpeedIsMach.get(), this.commandedFmsSpeedSource.get());
                    legs.push({
                        globalLegIndex,
                        segmentIndex: segment.segmentIndex,
                        segmentLegIndex: l,
                        isFromLeg: false,
                        isToLeg,
                        isFirstMissedLeg: mapFound,
                        legDefinition,
                        verticalDisplayData,
                    });
                    if (mapFound) {
                        mapFound = false;
                    }
                    if (BitFlags.isAll(legDefinition.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                        mapFound = true;
                    }
                    if (isToLeg) {
                        isToLeg = false;
                    }
                }
            }
            legs.push({ globalLegIndex: -1, segmentIndex: -1, segmentLegIndex: -1, isFromLeg: false, isToLeg: false, isFirstMissedLeg: false, isLegEntry: true });
            while (legs.length % 5 !== 0) {
                legs.push({ globalLegIndex: -1, segmentIndex: -1, segmentLegIndex: -1, isFromLeg: false, isToLeg: false, isFirstMissedLeg: false });
            }
            this.store.setLegs(legs);
            this.pageCount.set(legs.length);
            const pageDiff = this.pageCount.get() - this.currentPage.get();
            if (pageDiff < 0) {
                this.currentPage.set(this.currentPage.get() + pageDiff);
            }
        }
        this.planChanged = false;
    }
    /**
     * Handler called when a LSK is pressed on a SelectableDataField.
     * @param data The Leg Page Item or undefined.
     * @param scratchpadContents The Scratchpad Contents
     * @param isDelete Whether the input was a DELETE
     * @returns whether this leftPressed event was successful
     */
    async leftPressed(data, scratchpadContents, isDelete) {
        var _a, _b, _c;
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        if (this.store.selectedLeg && data) {
            if (scratchpadContents === ((_a = this.store.selectedLeg.legDefinition) === null || _a === void 0 ? void 0 : _a.name)) {
                if (data.isToLeg) {
                    this.fms.createDirectTo(this.store.selectedLeg.segmentIndex, this.store.selectedLeg.segmentLegIndex);
                    this.store.selectedLeg = undefined;
                    return Promise.resolve(true);
                }
                const array = this.store.legs.getArray();
                const selectedLegArrayIndex = array.findIndex(leg => {
                    var _a;
                    // Need to compare the legDefinitions instead of the leg, because the leg store items get recreated on a regular basis
                    return leg.legDefinition === ((_a = this.store.selectedLeg) === null || _a === void 0 ? void 0 : _a.legDefinition);
                });
                if (data.isFromLeg) {
                    const nextLeg = this.store.legs.tryGet(selectedLegArrayIndex + 1);
                    if (nextLeg) {
                        this.fms.activateLeg(nextLeg.segmentIndex, nextLeg.segmentLegIndex);
                        this.store.selectedLeg = undefined;
                        return Promise.resolve(true);
                    }
                    return Promise.reject('UNABLE SET FROM LEG');
                }
                const legsToDelete = this.store.selectedLeg.globalLegIndex - data.globalLegIndex;
                const planToModify = this.fms.getPlanToModify(1); // TODO RTE 2
                for (let i = selectedLegArrayIndex - 1; i >= selectedLegArrayIndex - legsToDelete; i--) {
                    const leg = this.store.legs.tryGet(i);
                    if (leg) {
                        const removed = planToModify.removeLeg(leg.segmentIndex, leg.segmentLegIndex);
                        if (!removed) {
                            this.store.selectedLeg = undefined;
                            if (planToModify.planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX) { // TODO RTE 2
                                this.fms.cancelMod();
                            }
                            // While INVALID DELETE would make more technical sense, this code path usually happens from a non-delete user operation,
                            // meaning INVALID ENTRY is less confusing here
                            return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                        }
                    }
                }
                this.store.selectedLeg = undefined;
                return Promise.resolve(true);
            }
            else {
                this.store.selectedLeg = undefined;
            }
        }
        const holdAtFacility = this.store.holdAtFacilitySubject.get();
        if (holdAtFacility && data) {
            if (scratchpadContents.startsWith('HOLD AT ')) {
                const scratchpadRest = scratchpadContents.replace('HOLD AT ', '');
                const storeFacilityIdent = ICAO.getIdent(holdAtFacility.icao);
                if (scratchpadRest === storeFacilityIdent) {
                    const insertSegmentIndex = data.segmentIndex !== -1 ? data.segmentIndex : undefined;
                    const insertSegmentLegIndex = data.segmentLegIndex !== -1 ? data.segmentLegIndex : undefined;
                    const waypointInserted = this.fms.insertWaypoint(holdAtFacility, insertSegmentIndex, insertSegmentLegIndex);
                    if (!waypointInserted) {
                        throw new Error('Could not insert waypoint for non-flight plan hold');
                    }
                    const plan = this.fms.getPlanForFmcRender();
                    let addedLegGlobalIndex;
                    if (insertSegmentIndex !== undefined && insertSegmentLegIndex !== undefined) {
                        addedLegGlobalIndex = plan.getSegment(data.segmentIndex).offset + data.segmentLegIndex;
                    }
                    else {
                        addedLegGlobalIndex = plan.length - 1;
                    }
                    if (!addedLegGlobalIndex) {
                        throw new Error('Could not find insert waypoint leg for non-flight plan hold');
                    }
                    const holdInserted = this.fms.createHold(addedLegGlobalIndex);
                    if (holdInserted) {
                        this.ensureNotInHoldSelection();
                        this.page.screen.navigateTo('/hold', { atLeg: addedLegGlobalIndex });
                        return true;
                    }
                    return Promise.reject('TOO MANY HOLDS');
                }
                else {
                    return Promise.reject('FACILITY NOT FOUND');
                }
            }
        }
        if (isDelete) {
            if (data && !data.isFromLeg) {
                if (data.isToLeg && this.fms.createDirectToExistingNextValidLeg(data.globalLegIndex)) {
                    return Promise.resolve(true);
                }
                else if (this.fms.removeWaypoint(data.segmentIndex, data.segmentLegIndex)) {
                    return Promise.resolve(true);
                }
            }
            return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
        }
        if (scratchpadContents && !(data === null || data === void 0 ? void 0 : data.isFromLeg)) {
            let pos;
            const plan = this.fms.getPlanForFmcRender();
            const prevLegIndex = (data && data.globalLegIndex >= 0 ? data.globalLegIndex : plan.length) - 1;
            if (prevLegIndex >= 0 && prevLegIndex < plan.length) {
                const prevLeg = plan.getLeg(prevLegIndex);
                pos = prevLeg.calculated ? FlightPathUtils.getLegFinalPosition(prevLeg.calculated, BoeingLegsPageController.geoPointCache[0]) : undefined;
                if (!pos) {
                    switch (prevLeg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                        case LegType.HF:
                        case LegType.HM:
                        case LegType.HA: {
                            const facility = await this.fms.facLoader.getFacility(ICAO.getFacilityType(prevLeg.leg.fixIcao), prevLeg.leg.fixIcao);
                            pos = BoeingLegsPageController.geoPointCache[0].set(facility);
                        }
                    }
                }
            }
            if (!pos) {
                const ppos = this.ppos.get();
                pos = BoeingLegsPageController.geoPointCache[0].set(ppos.lat, ppos.long);
            }
            let selectedFacility = await this.page.screen.selectWaypointByIdent(scratchpadContents, pos);
            let insertAfter = false;
            // Pilot-defined waypoints
            if (!selectedFacility) {
                const result = await BoeingPilotWaypointUtils.createFromScratchpadEntry(this.fms, (ident, refPos) => this.page.screen.selectWaypointByIdent(ident, refPos), scratchpadContents, data === null || data === void 0 ? void 0 : data.globalLegIndex);
                if (result) {
                    const [userFacility] = result;
                    [, insertAfter] = result;
                    this.fms.addUserFacility(userFacility);
                    selectedFacility = userFacility;
                }
            }
            // Do a Direct To Random, by creating and inserting the new waypoint, then calling createDirectToExisting
            if (selectedFacility !== null) {
                let segmentIndex = data && data.segmentIndex > -1 ? data.segmentIndex : undefined;
                let segmentLegIndex = data && data.segmentLegIndex > -1 ? data.segmentLegIndex : undefined;
                if (insertAfter && segmentIndex !== undefined && segmentLegIndex !== undefined) {
                    const segment = plan.getSegment(segmentIndex);
                    const isLastLegInSegment = segmentLegIndex === segment.legs.length - 1;
                    // If we need to insert the waypoint after, we make sure we don't do so in the departure segment
                    if (segment.segmentType === FlightPlanSegmentType.Departure && isLastLegInSegment) {
                        let segmentToInsertIn = Array.from(plan.segmentsOfType(FlightPlanSegmentType.Enroute))[0];
                        if (segmentToInsertIn === null || segmentToInsertIn === void 0 ? void 0 : segmentToInsertIn.airway) {
                            segmentToInsertIn = undefined;
                        }
                        segmentToInsertIn !== null && segmentToInsertIn !== void 0 ? segmentToInsertIn : (segmentToInsertIn = plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute));
                        segmentIndex = segmentToInsertIn.segmentIndex;
                        segmentLegIndex = 0;
                    }
                    else {
                        segmentLegIndex++;
                    }
                }
                // If new waypoint was dropped on a DISCO, try to delete the DISCO first
                if (segmentIndex !== undefined && segmentLegIndex !== undefined && ((_b = data === null || data === void 0 ? void 0 : data.legDefinition) === null || _b === void 0 ? void 0 : _b.leg.type) === LegType.Discontinuity) {
                    const waypointRemoved = this.fms.removeWaypoint(segmentIndex, segmentLegIndex);
                    if (!waypointRemoved) {
                        // If the DISCO could not be deleted, then the new waypoint was dropped on an invalid spot
                        return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                    }
                }
                if (data) {
                    if (data.isToLeg && !insertAfter) {
                        this.fms.createDirectTo(segmentIndex, segmentLegIndex, true, undefined, selectedFacility);
                    }
                    else {
                        this.fms.insertWaypoint(selectedFacility, segmentIndex, segmentLegIndex);
                    }
                }
                return Promise.resolve(true);
            }
            return Promise.reject('FACILITY NOT FOUND');
        }
        if (!this.store.selectedLeg && data && data.legDefinition) {
            switch (data.legDefinition.leg.type) {
                case LegType.CI:
                case LegType.VI:
                case LegType.FA:
                case LegType.CA:
                case LegType.VA:
                case LegType.VM:
                case LegType.Discontinuity:
                    return Promise.reject('INVALID LEG SELECTION');
                default:
                    this.store.selectedLeg = data;
                    this.store.selectedLegIdent = data.legDefinition.name;
                    return Promise.resolve((_c = data.legDefinition.name) !== null && _c !== void 0 ? _c : 'noleg bug');
            }
        }
        return Promise.reject('INVALID LEFT PRESS');
    }
    /** Checks if we are in a Direct To Existing state for ACT plan, or MOD when plan is in MOD.
     * @returns Whether we are in a Direct To Existing state for ACT plan, or MOD when plan is in MOD. */
    isFmcPageInDirectToExistingState() {
        const fmcPlan = this.fms.getPlanForFmcRender();
        if (fmcPlan.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            // When not in MOD, we use effective leg index for things,
            // so here we need to check if the effective leg index mathces what the plan still thinks is the DTO state.
            // We subtract 1 so that we get the index of the effective FROM leg, just in case the TO leg is in a different segment.
            const effectiveFromLegIndex = Math.max(fmcPlan.activeLateralLeg, this.effectiveLegIndex) - 1;
            const effectiveSegmentIndex = fmcPlan.getSegmentIndex(effectiveFromLegIndex);
            const effectiveSegmentLegIndex = fmcPlan.getSegmentLegIndex(effectiveFromLegIndex);
            const dtoState = fmcPlan.directToData;
            // We add 2 to the dto segment leg index because the DTO is made of 3 legs, and we want to check the last one.
            return effectiveSegmentIndex === dtoState.segmentIndex && (effectiveSegmentLegIndex === dtoState.segmentLegIndex + 2);
        }
        else {
            return this.fms.getDirectToState(this.fms.getPlanIndexForFmcPage()) === DirectToState.TOEXISTING;
        }
    }
    /**
     * Handler called when a RSK is pressed on a SelectableDataField.
     * @param data The Leg Page Item or undefined.
     * @param scratchpadContents The Scratchpad Contents
     * @param isDelete Whether the input was a DELETE
     * @returns Whether this right press was successfully handled.
     */
    async rightPressed(data, scratchpadContents, isDelete) {
        var _a;
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        if (data && data.isFromLeg) {
            const legsArray = this.store.legs.getArray();
            const fromLegIndexInLegsArray = legsArray.findIndex(l => l === data);
            const toLeg = legsArray[fromLegIndexInLegsArray + 1];
            if (toLeg !== undefined && ((_a = toLeg.legDefinition) === null || _a === void 0 ? void 0 : _a.leg) && BoeingFmsUtils.isLegVectOrDisco(toLeg.legDefinition.leg)) {
                if (this.fms.createDirectToExistingNextValidLeg(toLeg.globalLegIndex)) {
                    return Promise.resolve(true);
                }
                else {
                    return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                }
            }
            this.eventBus.getPublisher().pub('suspend_sequencing', this.lnavSequencing, true);
            return Promise.resolve(true);
        }
        if ((data === null || data === void 0 ? void 0 : data.globalLegIndex) === undefined || !data.legDefinition) {
            return false;
        }
        if (!scratchpadContents && isDelete !== true && data.verticalDisplayData) {
            if (data.isFromLeg) {
                return Promise.reject('KEY NOT ACTIVE');
            }
            return Promise.resolve(BoeingVerticalIOUtils.renderDataForScratchpad(data.verticalDisplayData));
        }
        if (data.legDefinition.leg.type === LegType.Discontinuity) {
            return Promise.reject('KEY NOT ACTIVE');
        }
        if (isDelete) {
            this.fms.setUserConstraint(data.globalLegIndex, {
                altDesc: AltitudeRestrictionType.Unused,
                altitude1: 0,
                altitude2: 0,
                speed: 0,
                speedDesc: SpeedRestrictionType.Unused,
                speedUnit: SpeedUnit.IAS,
                displayAltitude1AsFlightLevel: false,
                displayAltitude2AsFlightLevel: false,
            });
            return true;
        }
        const canModifyConstraints = !BoeingFmsUtils.isAltitudeLeg(data.legDefinition.leg.type);
        if (!canModifyConstraints) {
            return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
        }
        const verticalDataClone = Object.assign({}, data.legDefinition.verticalData);
        const modification = B787FmcParsers.LegAirspeedAltConstraint(scratchpadContents, 'right', this.fms.activePerformancePlan.cruiseAltitude.get(), data.legDefinition.verticalData.phase);
        if (modification) {
            BoeingVerticalIOUtils.applyDisplayModificationToVerticalData(verticalDataClone, modification);
            this.fms.setUserConstraint(data.globalLegIndex, verticalDataClone);
            return true;
        }
        else {
            return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
        }
    }
    /**
     * Sets the Direct To INTC CRS.
     * @param modPlan The MOD Flight Plan.
     * @param course The scratchpad contents
     * @returns whether this was successfully completed.
     */
    setDirectToCourse(modPlan, course) {
        if (modPlan.directToData.segmentIndex > -1 && modPlan.directToData.segmentLegIndex > -1) {
            this.fms.createDirectTo(modPlan.directToData.segmentIndex, modPlan.directToData.segmentLegIndex, true, course === null || course === void 0 ? void 0 : course.value); // TODO true course
            return true;
        }
        return false;
    }
    /**
     * Gets a DTK and Distance string for the FMC Legs Page Display.
     *
     * @param leg The Leg Definition.
     * @param prevLeg The Leg Definition of the previous item, if applicable..
     * @param distance A manual distance to calculate with.
     * @param addHeader Whether to add a dash header.
     *
     * @returns A Display string.
     */
    getAnnotationRowString(leg, prevLeg, distance, addHeader) {
        if (!leg.calculated) {
            return ' ---°';
        }
        const legType = leg.leg.type;
        let dtkString = '';
        let dtk;
        if (BoeingFmsUtils.isArcLeg(legType)) {
            let radius;
            if (legType === LegType.RF) {
                const vectorRadius = leg.calculated.flightPath[0].radius;
                const vectorRadiusNormalised = leg.leg.turnDirection === LegTurnDirection.Left ? vectorRadius : Math.PI - vectorRadius;
                radius = UnitType.NMILE.convertFrom(vectorRadiusNormalised, UnitType.GA_RADIAN);
            }
            else {
                radius = UnitType.NMILE.convertFrom(leg.leg.rho, UnitType.METER);
            }
            radius = Math.round(radius).toString().padStart(2, ' ');
            const letter = leg.leg.turnDirection === LegTurnDirection.Left ? 'L' : leg.leg.turnDirection === LegTurnDirection.Right ? 'R' : ' ';
            dtkString = `${radius} ARC ${letter}`;
        }
        else if (BoeingFmsUtils.isHeadingToLeg(legType) || BoeingFmsUtils.isCourseToLeg(legType)) {
            dtk = leg.leg.course;
            if (dtk) {
                dtk = Math.round(dtk);
                if (dtk === 0) {
                    dtk = 360;
                }
                dtkString = ` ${dtk.toString().padStart(3, '0')}°`;
                if (leg.leg.trueDegrees) {
                    dtkString += 'T';
                }
                if (BoeingFmsUtils.isHeadingToLeg(legType)) {
                    dtkString += 'HDG';
                }
                else {
                    dtkString += 'TRK';
                }
            }
        }
        else if (BoeingFmsUtils.isHoldAtLeg(legType)) {
            if (legType === LegType.HF) {
                dtkString = 'PROC HOLD';
            }
            else {
                dtkString = 'HOLD AT';
            }
        }
        else if (legType === LegType.PI) {
            dtkString = 'PROC TURN';
        }
        else {
            dtk = leg.calculated.initialDtk;
            if (dtk) {
                dtk = Math.round(dtk);
                if (dtk === 0) {
                    dtk = 360;
                }
                dtkString = ` ${dtk.toString().padStart(3, '0')}°`;
            }
            else {
                dtkString = ' ---°';
            }
        }
        dtkString = dtkString.padEnd(8, ' ');
        let distanceActual;
        if (BoeingFmsUtils.isVectorsLeg(leg.leg.type) || (prevLeg && BoeingFmsUtils.isVectorsLeg(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type))) {
            distanceActual = NaN;
        }
        else if (distance !== undefined) {
            distanceActual = distance;
        }
        else {
            distanceActual = UnitType.METER.convertTo(leg.calculated.distance, UnitType.NMILE);
        }
        let distanceString;
        if (Number.isFinite(distanceActual)) {
            distanceString = `${DISTANCE_FORMATTER(distanceActual).padStart(this.page.getAnnotationRowLeftPadding(), ' ')}NM`;
        }
        else {
            distanceString = ' '.repeat(this.page.getAnnotationRowLeftPadding());
        }
        return dtkString + distanceString + (addHeader ? BoeingLegsPageController.directToOptionsHeaderstring : '');
    }
    /**
     * Generates a constraints string (including styles and input box) from vertical display data
     *
     * @param verticalDisplayData The vertical display data
     * @param suppressMagentaSpeed Whether to suppress a speed which would otherwise be colored magenta.
     * @param suppressMagentaAlt Whether to suppress an altitude which would otherwise be colored magenta.
     * @param shouldPadConstraintsString Whether to pad the constraints string.
     *
     * @returns a string
     */
    static getConstraintsString(verticalDisplayData, suppressMagentaSpeed, suppressMagentaAlt, shouldPadConstraintsString) {
        let speedConstraintString = '';
        let altitudeConstraintString = '';
        let allStyles = '';
        if (verticalDisplayData.speed !== undefined) {
            if (typeof verticalDisplayData.speed === 'string') {
                speedConstraintString = verticalDisplayData.speed;
            }
            else {
                if (verticalDisplayData.speedIsMach) {
                    speedConstraintString = verticalDisplayData.speed.toFixed(3).substring(1);
                }
                else {
                    speedConstraintString = verticalDisplayData.speed.toFixed(0);
                }
            }
            if (verticalDisplayData.speedIsCommanded && !suppressMagentaSpeed) {
                speedConstraintString += '[magenta]';
                allStyles += '[magenta]';
            }
            if (verticalDisplayData.speedIsPredicted && verticalDisplayData.altitudesArePredicted) {
                speedConstraintString += '[s-text]/[d-text]';
                allStyles += '[s-text]';
                allStyles += '[d-text]';
            }
            else if (verticalDisplayData.speedIsPredicted) {
                speedConstraintString += '/[s-text]';
                allStyles += '[s-text]';
            }
            else {
                speedConstraintString += '/[d-text]';
                allStyles += '[d-text]';
            }
        }
        else {
            speedConstraintString = '---/[d-text]';
            allStyles += '[d-text]';
        }
        if (verticalDisplayData.altitudes.length > 0) {
            for (let i = 0; i < verticalDisplayData.altitudes.length; i++) {
                const altitude = verticalDisplayData.altitudes[i];
                const isFlightLevel = verticalDisplayData.altitudesAreFlightLevels[i];
                const suffix = verticalDisplayData.altitudeSuffixes[i];
                let str = '';
                if (isFlightLevel) {
                    str += `FL${(altitude / 100).toFixed(0).padStart(3, '0')}`;
                }
                else {
                    str += altitude.toFixed(0).padStart(5, ' ');
                }
                str += suffix;
                altitudeConstraintString += str;
            }
            let altitudeStyleString = '';
            if (verticalDisplayData.altitudesArePredicted) {
                altitudeStyleString += '[s-text]';
            }
            else if (verticalDisplayData.altitudeIsCommanded && !suppressMagentaAlt) {
                altitudeStyleString += '[magenta]';
            }
            altitudeConstraintString += altitudeStyleString;
            allStyles += altitudeStyleString;
        }
        else {
            altitudeConstraintString = '------';
        }
        let constraintsString = `${speedConstraintString}${altitudeConstraintString}`;
        if (shouldPadConstraintsString) {
            const padAmount = 16 - (constraintsString.length - allStyles.length);
            constraintsString = ' '.repeat(Math.max(0, padAmount)) + constraintsString;
        }
        constraintsString = inputBox(constraintsString);
        return constraintsString;
    }
}
BoeingLegsPageController.geoPointCache = [new GeoPoint(0, 0)];
BoeingLegsPageController.discoIdentString = '□□□□□  ';
BoeingLegsPageController.discoCourseString = ' THEN';
BoeingLegsPageController.directToOptionsHeaderstring = '      ----------';

/** Store for RTE HOLD page */
class BoeingHoldPageStore {
    /** @inheritDoc */
    constructor(page, bus) {
        this.page = page;
        this.bus = bus;
        this.planHolds = ArraySubject.create();
        this.planHoldsLength = Subject.create(0);
        this.holdPageSubIndex = Subject.create(0);
        this.planHoldsLocked = false;
        /** Contains current ground speed */
        this.groundSpeedSubject = Subject.create(150);
        /** Contains current MSL altitude */
        this.mslAltitudeSubject = Subject.create(1000);
        /** Contains MSL altitude used for calculating hold speed. Only set when hold leg is selected. */
        this.frozenMslAltitudeSubject = Subject.create(1000);
        /** Contains whether LNAV is suspended */
        this.lnavSuspended = Subject.create(false);
        /** Contains global index of the hold leg in the plan */
        this.holdLegGlobalIndex = Subject.create(null);
        /** Contains whether the hold leg is PPOS */
        this.holdLegIsPpos = Subject.create(false);
        /** Contains hold leg definition */
        this.holdLegDefinition = Subject.create(null);
        /** Contains hold leg definition of the active flight plan, if it exists. */
        this.activeHoldLegDefinition = Subject.create(null);
        /** Whether the hold is being created for the first time, or already existed in the active plan. */
        this.holdIsNew = Subject.create(false);
        /** Contains selected speed mode data */
        this.holdSpeedRule = Subject.create(0);
        /** Contains data for display of hold speed */
        this.HoldSpeed = MappedSubject.create(([altitude, rule]) => HoldUtils.getHoldSpeed(altitude, rule), this.frozenMslAltitudeSubject, this.holdSpeedRule);
        /** Contains selected radial */
        this.radial = Subject.create(null);
        /** Contains selected inbound course */
        this.inboundCourse = Subject.create(0);
        /** Contains selected turn direction */
        this.turnDirection = Subject.create('R');
        /** Contains inbound course/turn direction tuple. */
        this.InboundCourseTurnDirection = MappedSubject.create((inputs) => [inputs[0], inputs[1]], this.inboundCourse, this.turnDirection);
        /** Active leg index. */
        this.activeLegIndex = ConsumerSubject.create(this.bus
            .getSubscriber().on('lnav_tracked_leg_index'), -1);
    }
}
/** Controller for a B787HoldPage. */
class BoeingHoldPageController {
    /** @inheritDoc */
    constructor(page, bus, fms, store) {
        this.page = page;
        this.bus = bus;
        this.fms = fms;
        this.store = store;
        this.syncPlanHoldsTimer = new DebounceTimer();
        const fpSub = this.bus.getSubscriber();
        fpSub.on('fplLegChange').handle(this.trySyncPlanHolds.bind(this));
        fpSub.on('fplLoaded').handle(this.trySyncPlanHolds.bind(this));
        this.fms.planInMod.sub(this.trySyncPlanHolds.bind(this));
        this.trySyncPlanHolds();
    }
    /**
     * Sets a debounced timer for syncing plan holds
     */
    trySyncPlanHolds() {
        this.syncPlanHoldsTimer.schedule(() => this.syncPlanHolds(), 500);
    }
    /**
     * Syncs the store with plan holds
     */
    syncPlanHolds() {
        if (this.store.planHoldsLocked) {
            return;
        }
        const flightPlan = this.fms.getPlanForFmcRender();
        const holdsList = BoeingFmsUtils.getPlanHolds(flightPlan);
        this.store.planHolds.set(holdsList.map(legDef => {
            const holdGlobalLegIndex = flightPlan.getLegIndexFromLeg(legDef);
            const parentGlobalLegIndex = holdGlobalLegIndex - 1;
            const parentLeg = flightPlan.tryGetLeg(parentGlobalLegIndex);
            if (!parentLeg) {
                throw new Error(`Hold leg at index ${holdGlobalLegIndex} does not have a parent leg.`);
            }
            return [parentGlobalLegIndex, parentLeg];
        }));
        const maxIndex = this.store.planHolds.length - 1;
        if (maxIndex < 0) {
            this.store.holdPageSubIndex.set(-1);
        }
        else if (this.store.holdPageSubIndex.get() > maxIndex) {
            this.store.holdPageSubIndex.set(maxIndex);
        }
        this.store.planHoldsLength.set(holdsList.length);
        const holdIndex = this.store.holdPageSubIndex.get();
        if (holdIndex >= 0) {
            const [parentLegIndexToShow] = this.store.planHolds.getArray()[holdIndex];
            this.initializeData(parentLegIndexToShow);
        }
    }
    /**
     * Initializes Hold page data.
     * @param parentGlobalLegIndex Hold parent leg index.
     * @throws If `parentGlobalLegIndex` is invalid or a new hold leg cannot be created.
     */
    initializeData(parentGlobalLegIndex) {
        this.store.frozenMslAltitudeSubject.set(this.store.mslAltitudeSubject.get());
        const holdGlobalLegIndex = parentGlobalLegIndex + 1;
        const targetLeg = this.fms.getPlanForFmcRender().tryGetLeg(holdGlobalLegIndex);
        const targetLegIsPpos = (targetLeg === null || targetLeg === void 0 ? void 0 : targetLeg.leg.fixIcao) === ICAO.emptyIcao;
        if (!targetLeg) {
            throw new Error('[FMC/HoldPage] HoldPage created with bad targetLeg');
        }
        this.store.holdLegGlobalIndex.set(holdGlobalLegIndex);
        this.store.holdLegIsPpos.set(targetLegIsPpos);
        this.store.holdLegDefinition.set(targetLeg);
        this.store.activeHoldLegDefinition.set(targetLeg);
        /* The radial is simply a function of the inbound course.  Even if it's set explicitly, it
        will modify the course to agree with it, so only course needs to be stored and loaded.
        Therefore, it should be cleared when loading a different hold. */
        this.store.radial.set(null);
        if (this.fms.planInMod.get()) {
            const activeHolds = BoeingFmsUtils.getPlanHolds(this.fms.getPrimaryFlightPlan());
            const holdAlreadyExists = activeHolds.some(leg => leg.leg.fixIcao === targetLeg.leg.fixIcao);
            this.store.holdIsNew.set(!holdAlreadyExists);
        }
        else {
            this.store.holdIsNew.set(false);
        }
    }
    /**
     * Applies a modification to the hold leg being edited.
     * @param flightPlanLeg Data to modify.
     */
    applyModification(flightPlanLeg) {
        var _a;
        const holdLegGlobalIndex = this.store.holdLegGlobalIndex.get();
        if (holdLegGlobalIndex) {
            const leg = FlightPlan.createLeg(Object.assign(Object.assign({}, (_a = this.store.holdLegDefinition.get()) === null || _a === void 0 ? void 0 : _a.leg), flightPlanLeg));
            const segmentIndex = this.fms.getPlanForFmcRender().getSegmentIndex(holdLegGlobalIndex);
            const segment = this.fms.getPlanForFmcRender().getSegment(segmentIndex);
            this.store.planHoldsLocked = true;
            if (ICAO.getIdent(leg.fixIcao) === 'PPOS') {
                this.fms.insertPposHold(leg);
            }
            else {
                this.fms.insertHold(segmentIndex, holdLegGlobalIndex - segment.offset - 1, leg);
            }
            this.store.planHoldsLocked = false;
            this.initializeData(holdLegGlobalIndex - 1);
            this.page.invalidate();
        }
    }
    /**
     * Applies a vertical constraint to the leg.
     * @param scratchpadContents The scratchpad contents.
     */
    applyVerticalModification(scratchpadContents) {
        const legDef = this.store.holdLegDefinition.get();
        if (legDef) {
            const verticalDataClone = Object.assign({}, legDef.verticalData);
            const modification = B787FmcParsers.LegAirspeedAltConstraint(scratchpadContents, 'right', this.fms.activePerformancePlan.cruiseAltitude.get(), legDef.verticalData.phase);
            const globalLegIndex = this.store.holdLegGlobalIndex.get();
            if (modification && globalLegIndex !== null) {
                BoeingVerticalIOUtils.applyDisplayModificationToVerticalData(verticalDataClone, modification);
                this.fms.setUserConstraint(globalLegIndex, verticalDataClone);
            }
        }
    }
}
/** Boeing HOLD page. */
class BoeingHoldPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingHoldPageStore(this, this.bus);
        this.controller = new BoeingHoldPageController(this, this.bus, this.fms, this.store);
        this.sub = this.bus.getSubscriber();
        this.commandedFmsAlt = ConsumerValue.create(this.sub.on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.commandedFmsSpeedIas = ConsumerValue.create(this.sub.on('fms_speed_computed_target_ias'), -1);
        this.commandedFmsSpeedMach = ConsumerValue.create(this.sub.on('fms_speed_computed_target_mach'), -1);
        this.commandedFmsSpeedIsMach = ConsumerValue.create(this.sub.on('fms_speed_computed_target_is_mach'), false);
        this.commandedFmsSpeedSource = ConsumerValue.create(this.sub.on('fms_speed_computed_target_source'), FmsSpeedTargetSource.None);
        this.emptyConstraintString = inputBox('---/------'.padStart(16, ' '));
        this.TitleField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (planInMod) => this.getTitleLineString(planInMod, 1),
            }
        }).bind(this.fms.planInMod);
        this.PagingIndicator = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([page, numberOfHolds]) => page < 1 || numberOfHolds < 1 ? '' : `${page}/${numberOfHolds}[s-text] `
            },
        }).bind(MappedSubject.create(this.store.holdPageSubIndex.map(index => index + 1), this.store.planHoldsLength));
        this.FixIdentField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([leg, isPpos, holdIndex, activeIndex, holdIsNew]) => {
                    const legIdent = isPpos ? 'PPOS' : (leg ? ICAO.getIdent(leg.leg.fixIcao) : '');
                    const styling = holdIndex + 1 === activeIndex ? '[magenta]' : holdIsNew ? '[r-white]' : '';
                    return `${legIdent}${styling}`;
                }
            },
        }).bind(MappedSubject.create(this.store.holdLegDefinition, this.store.holdLegIsPpos, this.store.holdLegGlobalIndex, this.store.activeLegIndex, this.store.holdIsNew));
        this.QuadRadialField = new TextInputField(this, {
            formatter: {
                parse: (v) => parseInt(v),
                nullValueString: `${inputBox('--/---')}°`,
                format: (radial) => {
                    const quad = HoldUtils.getDirectionString(NavMath.reciprocateHeading(radial), true).padEnd(2, ' ');
                    const radialStr = Math.trunc(radial).toString().padStart(3, '0');
                    const value = inputBox(`${quad}/${radialStr}`);
                    return `${value}°`;
                },
            },
            onModified: async (radial) => {
                radial !== null && this.controller.applyModification({
                    course: NavMath.reciprocateHeading(radial),
                });
                return false;
            },
        }).bind(this.store.radial);
        this.InbdCrsDirField = new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('---°/-'),
                format: (value) => {
                    const inputStr = `${Math.trunc(value[0]).toString().padStart(3, '0')}°/${value[1]}`;
                    return `${inputBox(inputStr)} TURN`;
                },
                parse: (input) => {
                    const match = /^(\d{1,3})?\/?([LR])?$/[Symbol.match](input);
                    if (!match) {
                        return null;
                    }
                    const [, course, direction] = match;
                    const courseInt = parseInt(course);
                    return [Number.isNaN(courseInt) ? null : courseInt, direction];
                },
            },
            onModified: async (newValue) => {
                if (newValue) {
                    const [course, turnDir] = newValue;
                    if (course && turnDir) {
                        this.controller.applyModification({
                            course,
                            turnDirection: turnDir === 'R' ? LegTurnDirection.Right : LegTurnDirection.Left,
                        });
                    }
                    else if (course) {
                        this.controller.applyModification({ course });
                    }
                    else {
                        this.controller.applyModification({
                            turnDirection: turnDir === 'R' ? LegTurnDirection.Right : LegTurnDirection.Left,
                        });
                    }
                    if (course) {
                        this.store.radial.set(NavMath.reciprocateHeading(course));
                    }
                }
                else {
                    this.controller.applyModification({
                        course: 100,
                        turnDirection: LegTurnDirection.Right,
                    });
                }
                return true;
            }
        }).bind(this.store.InboundCourseTurnDirection);
        this.LegTimeField = new TextInputField(this, {
            formatter: {
                nullValueString: B787FmcFormatters.Unit('MIN', { spaceBetween: false, precision: 1, type: 'input' }, '-.-')(null),
                format: (value) => {
                    const distanceInMinutes = value.leg.distanceMinutes;
                    if (!distanceInMinutes) {
                        return `${inputBox('-.-')}MIN`;
                    }
                    const displayedTime = value.leg.distance;
                    const valueStr = `${(displayedTime.toFixed(1))}[d-text]`;
                    return `${inputBox(valueStr)}MIN`;
                },
                parse: (input) => {
                    const float = parseFloat(input);
                    if (Number.isNaN(float) || float <= 0) {
                        return null;
                    }
                    return float;
                },
            },
            onModified: async (distance) => {
                this.controller.applyModification({
                    distanceMinutes: true,
                    distance,
                });
                return true;
            },
            style: '[s-text]',
        }).bind(this.store.holdLegDefinition);
        this.LegDistanceField = new TextInputField(this, {
            formatter: {
                nullValueString: B787FmcFormatters.Unit('NM', { spaceBetween: false, precision: 1, type: 'input' }, '--.-')(null),
                format: (value) => {
                    const distanceInNM = !value.leg.distanceMinutes;
                    if (!distanceInNM) {
                        return `${inputBox('-.-')}NM`;
                    }
                    const displayedDistance = UnitType.NMILE.convertFrom(value.leg.distance, UnitType.METER);
                    const valueStr = `${(displayedDistance.toFixed(1))}[d-text]`;
                    return `${inputBox(valueStr)}NM`;
                },
                parse: (input) => {
                    const float = parseFloat(input);
                    if (Number.isNaN(float) || float <= 0) {
                        return null;
                    }
                    return float;
                },
            },
            onModified: async (value) => {
                this.controller.applyModification({
                    distanceMinutes: false,
                    distance: UnitType.METER.convertFrom(value, UnitType.NMILE),
                });
                return true;
            },
            style: '[s-text]',
        }).bind(this.store.holdLegDefinition);
        this.SpeedTargetAltField = new DisplayField(this, {
            formatter: {
                nullValueString: this.emptyConstraintString,
                format: (holdLegGlobalIndex) => {
                    if (!holdLegGlobalIndex) {
                        return this.emptyConstraintString;
                    }
                    const lateralLeg = this.fms.getPlanForFmcRender().tryGetLeg(holdLegGlobalIndex);
                    if (!lateralLeg) {
                        return this.emptyConstraintString;
                    }
                    const predictions = this.fms.activeRoutePredictor.getPredictionsForLeg(holdLegGlobalIndex);
                    const verticalDisplayData = BoeingVerticalIOUtils.getDisplayDataForLeg(lateralLeg, predictions, this.fms.activePerformancePlan.transitionAltitude.get(), this.fms.activePerformancePlan.transitionLevel.get(), this.commandedFmsAlt.get(), this.commandedFmsSpeedIsMach.get() ? this.commandedFmsSpeedMach.get() : this.commandedFmsSpeedIas.get(), this.commandedFmsSpeedIsMach.get(), this.commandedFmsSpeedSource.get());
                    return BoeingLegsPageController.getConstraintsString(verticalDisplayData, false, false, true);
                },
            },
            onSelected: async (value) => {
                this.controller.applyVerticalModification(value);
                return true;
            },
            onDelete: async () => {
                const globalLegIndex = this.store.holdLegGlobalIndex.get();
                if (globalLegIndex) {
                    this.fms.setUserConstraint(globalLegIndex, {
                        altDesc: AltitudeRestrictionType.Unused,
                        altitude1: 0,
                        altitude2: 0,
                        speed: 0,
                        speedDesc: SpeedRestrictionType.Unused,
                        speedUnit: SpeedUnit.IAS,
                        displayAltitude1AsFlightLevel: false,
                        displayAltitude2AsFlightLevel: false,
                    });
                }
                return true;
            },
        }).bind(this.store.holdLegGlobalIndex);
        this.EraseField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<ERASE'),
            onSelected: async () => {
                const pageHold = this.store.holdLegDefinition.get();
                if (pageHold) {
                    const primaryFlightPlan = this.fms.getPrimaryFlightPlan();
                    const existingHoldIndex = BoeingFmsUtils.findHoldInPlan(primaryFlightPlan, pageHold.leg.fixIcao);
                    if (existingHoldIndex >= 0) {
                        const modPlan = this.fms.getPlanToModify();
                        const segmentIndex = modPlan.getSegmentIndex(existingHoldIndex);
                        const localLegIndex = modPlan.getSegmentLegIndex(existingHoldIndex);
                        modPlan.removeLeg(segmentIndex, localLegIndex);
                        this.screen.navigateTo('/legs');
                    }
                    else {
                        this.fms.cancelMod();
                        // this.screen.navigateTo('/legs', { isForHoldSelection: true });
                    }
                }
                return true;
            },
        });
        this.NextHoldField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<NEXT HOLD'),
            onSelected: async () => {
                this.screen.navigateTo('/legs', { isForHoldSelection: true });
                return true;
            },
        });
        this.ExitHoldField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<EXIT HOLD'),
            onSelected: async () => {
                this.bus.getPublisher().pub('suspend_sequencing', !this.store.lnavSuspended.get());
                return true;
            },
        });
    }
    /** @inheritDoc */
    onInit() {
        this.addBinding(this.bus.getSubscriber().on('ground_speed').handle((value) => {
            this.store.groundSpeedSubject.set(Math.max(150, value));
        }));
        this.addBinding(this.bus.getSubscriber().on('indicated_alt').handle((value) => {
            this.store.mslAltitudeSubject.set(value);
        }));
        this.addBinding(this.bus.getSubscriber().on('lnav_is_suspended').handle((state) => {
            if (state !== null) {
                this.store.lnavSuspended.set(state);
            }
        }));
        this.addBinding(this.fms.planInMod.sub(() => this.invalidate()));
        this.addBinding(this.store.activeLegIndex.sub(() => this.invalidate()));
        this.addBinding(this.store.holdPageSubIndex.sub((holdIndex) => {
            if (holdIndex >= 0) {
                const [globalLegIndex] = this.store.planHolds.getArray()[holdIndex];
                this.controller.initializeData(globalLegIndex);
            }
        }));
        // If planHolds length goes below 1 while the page is being viewed, go to the legs page.
        this.addBinding(this.store.planHoldsLength.sub((length) => {
            if (length < 1) {
                this.screen.navigateTo('/legs');
            }
        }));
        this.addBinding(this.store.planHolds.sub(() => {
            const parentLegIndex = this.params.get('atLeg');
            if (typeof parentLegIndex === 'number') {
                this.resyncSubpageIndex(parentLegIndex);
            }
        }));
        // Needed to update the SPD/TGT ALT field when vertical leg data has changed
        this.addBinding(this.bus.getSubscriber()
            .on('fplLegChange').handle(() => this.invalidate()));
    }
    /** @inheritDoc */
    onResume() {
        const parentLegIndex = this.params.get('atLeg');
        if (typeof parentLegIndex !== 'number') {
            throw new Error('[FMC/HoldPage] Cannot create HoldPage without number atLeg in router.params');
        }
        this.resyncSubpageIndex(parentLegIndex);
        this.controller.initializeData(parentLegIndex);
    }
    /**
     * Resync the subpage index.
     * @param parentLegIndex The parent leg index.
     */
    resyncSubpageIndex(parentLegIndex) {
        const subPageIndex = this.store.planHolds.getArray().findIndex(([globalIndex]) => globalIndex === parentLegIndex);
        this.store.holdPageSubIndex.set(subPageIndex);
    }
    /** @inheritDoc */
    render() {
        this.updateDataFromHoldLeg();
        const Field6L = this.fms.planInMod.get() ? this.EraseField : this.NextHoldField;
        const Field6R = this.fms.planInMod.get() &&
            (this.store.activeLegIndex.get() === this.store.holdLegGlobalIndex.get()) ? this.ExitHoldField : '';
        return [
            [
                [this.TitleField, this.PagingIndicator],
                [' FIX', 'SPD/TGT ALT'],
                [this.FixIdentField, this.SpeedTargetAltField],
                [' QUAD/RADIAL', 'FIX ETA[disabled]'],
                [this.QuadRadialField],
                [' INBD CRS/DIR', 'EFC TIME[disabled]'],
                [this.InbdCrsDirField],
                [' LEG TIME', 'HOLD AVAIL[disabled]'],
                [this.LegTimeField],
                [' LEG DIST', 'BEST SPEED[disabled]'],
                [this.LegDistanceField],
                ['', '', '--------------------------------------'],
                [Field6L, Field6R],
            ],
        ];
    }
    /**
     * Updates the data from the displayed hold leg
     */
    updateDataFromHoldLeg() {
        const leg = this.store.holdLegDefinition.get();
        if (leg) {
            this.store.inboundCourse.set(leg.leg.course);
            this.store.turnDirection.set(leg.leg.turnDirection === LegTurnDirection.Left ? 'L' : 'R');
        }
    }
    /** @inheritDoc */
    async onHandleScrolling(event) {
        const subIndex = this.store.holdPageSubIndex.get();
        const maxIndex = Math.max(0, this.store.planHoldsLength.get() - 1);
        switch (event) {
            case 'pageLeft':
                this.store.holdPageSubIndex.set(subIndex === 0 ? maxIndex : subIndex - 1);
                return true;
            case 'pageRight':
                this.store.holdPageSubIndex.set(subIndex === maxIndex ? 0 : subIndex + 1);
                return true;
        }
        return false;
    }
}

/** The Boeing IDENT page. */
class BoeingIdentPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.PosInitLink = PageLinkField.createLink(this, 'POS INIT>', '/pos-init');
        this.activeNavDbDateRange = Subject.create(SimVar.GetGameVarValue('FLIGHT_NAVDATA_DATE_RANGE', SimVarValueType.String));
        this.inactiveNavDbStartDate = ComputedSubject.create(this.getEndDateFromActiveNavDbDateString(this.activeNavDbDateRange.get()), (v) => {
            if (typeof v === 'string') {
                return v;
            }
            const cloneV = new Date(v.getTime());
            cloneV.setDate(cloneV.getDate() + 1);
            const end = new Date(cloneV);
            end.setDate(end.getDate() + 28);
            const monthDayFormatter = DateTimeFormatter.create('{MON}{dd}');
            const yearFormatter = DateTimeFormatter.create('{YY}');
            return `${monthDayFormatter(v.getTime())}${monthDayFormatter(end.getTime())}/${yearFormatter(v.getTime())}`;
        });
        this.isInactiveDateCopied = Subject.create(false);
        this.NavDbActiveDateField = new DisplayField(this, {
            formatter: RawFormatter,
            onSelected: (scratchPadContents) => {
                if (this.isInactiveDateCopied.get() || scratchPadContents === this.inactiveNavDbStartDate.get()) {
                    const clipboard = this.inactiveNavDbStartDate.get();
                    this.inactiveNavDbStartDate.set(this.activeNavDbDateRange.get());
                    this.activeNavDbDateRange.set(clipboard);
                    this.isInactiveDateCopied.set(false);
                    return Promise.resolve('');
                }
                return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
            }
        });
        this.NavDbInactivateDateField = new DisplayField(this, {
            formatter: RawFormatter,
            onSelected: () => {
                this.isInactiveDateCopied.set(true);
                return Promise.resolve(this.inactiveNavDbStartDate.get());
            }
        });
    }
    /**
     * Get date objects from nav data string
     * @param navDbString The nav data string.
     * @returns A Date() object for end date of the effective Nav Database date range.
     */
    getEndDateFromActiveNavDbDateString(navDbString) {
        const matches = navDbString.match(BoeingIdentPage.NAVDATA_DATE_RANGE_REGEX);
        const getMonth = (month) => {
            return (BoeingIdentPage.MONTH_NAMES.indexOf(month));
        };
        if (matches) {
            const [, , , toMonth, toDay, year] = matches;
            const yearStr = parseInt(`20${year}`);
            return new Date(yearStr, getMonth(toMonth), parseInt(toDay));
        }
        return new Date();
    }
    /** @inheritDoc */
    init() {
        this.NavDbActiveDateField.bind(this.activeNavDbDateRange);
        this.NavDbInactivateDateField.bind(this.inactiveNavDbStartDate);
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'IDENT  '],
                [' MODEL', this.getEngineDisplayTitle()],
                [this.getAircraftModel(), this.getEngineDisplayContent()],
                [' NAV DATA', this.getActiveDateDisplayTitle()],
                ['WT10407001', this.NavDbActiveDateField],
                [''],
                ['', this.NavDbInactivateDateField],
                [this.getOpProgramDisplayTitle()],
                [this.getOpProgramDisplayContent()],
                ['', 'DRAG/FF '],
                ['', '+1.1/-3.5', ''],
                ['--------------------------------------'],
                [this.IndexLink, this.PosInitLink],
            ],
        ];
    }
}
BoeingIdentPage.NAVDATA_DATE_RANGE_REGEX = /([A-Z]{3})(\d{2})([A-Z]{3})(\d{2})\/(\d{2})/;
BoeingIdentPage.MONTH_NAMES = ['JAN', 'FEB', 'MAR', 'APR', 'MAY', 'JUN', 'JUL', 'AUG', 'SEP', 'OCT', 'NOV', 'DEC'];

/**
 * LEGS Page Store
 */
class BoeingLegsPageStore {
    constructor() {
        this._legs = ArraySubject.create();
        this.legs = this._legs;
        this.holdAtFacilitySubject = Subject.create(null);
    }
    /**
     * Sets the legs array.
     * @param legs The array of RoutePageLegItems
     */
    setLegs(legs) {
        this._legs.set(legs);
    }
}

/** Boeing LEGS Page*/
class BoeingLegsPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingLegsPageStore();
        this.controller = new BoeingLegsPageController(this, this.bus, this.fms, this.store);
        this.PageHeaderDisplay = new DisplayField(this, {
            formatter: RawFormatter,
        });
        this.DirectToCourseField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({ parse: B787FmcParsers.Bearing(), format: B787FmcFormatters.Bearing('input') }),
            style: '>',
            onDelete: async () => this.controller.setDirectToCourse(this.fms.getPlanForFmcRender()),
            onModified: async (bearingData) => this.controller.setDirectToCourse(this.fms.getPlanForFmcRender(), bearingData),
        });
        this.FplnPaging = MappedSubject.create(([currentPage, pageCount]) => [currentPage, pageCount], this.controller.currentPage, this.controller.pageCount);
        this.FplnPagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        });
        /**
         * Handler called when LSK6 is pressed.
         * @returns Whether this button press was successfully handled.
         */
        this.lskL6Pressed = async () => {
            if (this.fms.planInMod.get()) {
                //cancel the mod
                this.fms.cancelMod();
                return Promise.resolve(true);
            }
            else {
                //do the runway update
                return Promise.resolve(true);
            }
        };
        // TODO RWY UPDATE Should only be visible when on ground and a departure runway in in the plan and not in MOD
        this.L6Text = this.fms.planInMod.map((is) => is ? '<ERASE' : '<RTE 2 LEGS[disabled]'); // TODO RTE 2
        this.L6Field = new DisplayField(this, {
            formatter: RawFormatter,
            onSelected: this.lskL6Pressed.bind(this),
            disabled: () => !this.fms.planInMod.get(),
        });
        this.L6HoldLegField = new TextInputField(this, {
            formatter: Object.assign(Object.assign({}, RawValidator), { nullValueString: inputBox('□□□□□'), 
                /** @inheritDoc */
                format(value) {
                    return inputBox(ICAO.getIdent(value.icao).padStart(7, ' '));
                } }),
            onDelete: async () => {
                this.store.holdAtFacilitySubject.set(null);
                return true;
            },
            onModified: async (ident) => {
                var _a, _b;
                const selectedLeg = this.store.selectedLeg;
                if (selectedLeg) {
                    const created = this.fms.createHold(selectedLeg.globalLegIndex);
                    if (created) {
                        if ((_a = selectedLeg.legDefinition) === null || _a === void 0 ? void 0 : _a.verticalData) {
                            this.fms.setUserConstraint(selectedLeg.globalLegIndex + 1, Object.assign({}, (_b = selectedLeg.legDefinition) === null || _b === void 0 ? void 0 : _b.verticalData));
                        }
                        this.controller.ensureNotInHoldSelection();
                        this.screen.navigateTo('/hold', { atLeg: selectedLeg.globalLegIndex });
                        return true;
                    }
                    return Promise.reject('HOLD NOT INSERTED'); // FIXME error handling
                }
                else {
                    const facility = await this.screen.selectWaypointByIdent(ident, this.fms.ppos);
                    if (facility) {
                        this.store.holdAtFacilitySubject.set(facility);
                        return `HOLD AT ${ICAO.getIdent(facility.icao)}`;
                    }
                    else {
                        return Promise.reject(BoeingFmcErrorKeys.NotInDataBase);
                    }
                }
            }
        }).bind(this.store.holdAtFacilitySubject);
        this.StepPrompt = new DisplayField(this, {
            formatter: new SimpleStringFormat('STEP>'),
            onSelected: async () => {
                this.controller.stepCtr();
                return true;
            }
        });
        this.RteDataLink = PageLinkField.createLink(this, 'RTE DATA>', '/rte-data');
        this.ActivatePrompt = new DisplayField(this, {
            formatter: new SimpleStringFormat('ACTIVATE>'),
            onSelected: async () => {
                this.fms.activate(1);
                return true;
            }
        });
        this.PposPrompt = new DisplayField(this, {
            formatter: new SimpleStringFormat('PPOS>'),
            onSelected: async () => {
                this.fms.insertPposHold();
                this.screen.navigateTo('/hold', { atLeg: 1 });
                return true;
            }
        });
    }
    /** @inheritDoc */
    onInit() {
        // Paging
        this.L6Field.bind(this.L6Text);
        this.FplnPagingIndicator.bind(this.FplnPaging);
        this.addBinding(MappedSubject.create(this.fms.routeActivated(1), this.fms.planInMod).sub(this.handleHeaderChange.bind(this)));
        this.PageHeaderDisplay.takeValue(this.getRouteHeaderString(this.fms.isRouteActivated(1), this.fms.planInMod.get(), 1));
        this.addBinding(this.planFormatActiveSub().sub((it) => this.handleFormatChanged(it), true));
    }
    /**
     * Handles when the map format changes.
     *
     * @param isFormatPlan Whether the map format is PLAN.
     */
    handleFormatChanged(isFormatPlan) {
        this.controller.isPlanMapStepEnabled.set(isFormatPlan);
        this.invalidate();
    }
    /** @inheritDoc */
    onPause() {
        this.controller.destroy();
    }
    /** @inheritDoc */
    onResume() {
        var _a;
        const isForHoldSelection = this.params.get('isForHoldSelection');
        this.controller.isForHoldSelection = (_a = isForHoldSelection) !== null && _a !== void 0 ? _a : false;
        this.controller.currentPage.set(1);
        this.controller.init(this.screen.scratchpad.contents.get());
    }
    /** @inheritDoc */
    render() {
        let L6;
        if (this.controller.isForHoldSelection) {
            if (this.fms.planInMod.get()) {
                L6 = new DisplayField(this, {
                    formatter: new SimpleStringFormat('<CANCEL'),
                    onSelected: () => {
                        this.fms.cancelMod();
                        return Promise.resolve(true);
                    },
                });
            }
            else {
                L6 = this.L6HoldLegField;
            }
        }
        else {
            const activeLeg = this.fms.getPlanForFmcRender().tryGetLeg(this.fms.getPlanForFmcRender().activeLateralLeg);
            // Show <EXIT HOLD is active leg is a hold
            if (activeLeg && BoeingFmsUtils.isHoldAtLeg(activeLeg.leg.type)) {
                L6 = new DisplayField(this, {
                    formatter: new SimpleStringFormat(this.controller.lnavSequencing ? '<CANCEL EXIT' : '<EXIT HOLD'),
                    onSelected: async () => {
                        // FIXME find out specifics about WT21 hold exits? for now just suspend/unsuspend
                        this.bus.getPublisher().pub('suspend_sequencing', this.controller.lnavSequencing);
                        return true;
                    },
                });
            }
            else {
                L6 = this.L6Field;
            }
        }
        let R6;
        if (this.planFormatActiveSub().get()) {
            R6 = this.StepPrompt;
        }
        else if (this.fms.isRouteActivated(1)) {
            R6 = this.RteDataLink;
        }
        else {
            R6 = this.ActivatePrompt;
        }
        let footerHeader = this.getBlankFooter();
        if (this.controller.isForHoldSelection) {
            R6 = this.PposPrompt;
            footerHeader = this.getHoldAtFooter();
        }
        else if (this.fms.planInMod.get() && this.controller.isFmcPageInDirectToExistingState()) {
            const modPlan = this.fms.getPlanForFmcRender();
            const activeDirectLeg = modPlan.tryGetLeg(modPlan.activeLateralLeg);
            if (activeDirectLeg) {
                const directCourse = BoeingFmsUtils.getDirectToCourse(activeDirectLeg);
                const isUserCourse = activeDirectLeg.leg.type === LegType.CF;
                this.DirectToCourseField.takeValue({ value: directCourse, isTrueRef: activeDirectLeg.leg.trueDegrees, pilotEdited: isUserCourse });
                R6 = this.DirectToCourseField;
            }
            else {
                R6 = '';
            }
            footerHeader = this.getIntcCrsFooter();
        }
        return [
            [
                ...this.controller.renderPageRows(),
                [footerHeader],
                [L6, R6]
            ]
        ];
    }
    /**
     * Handles when the FMS changes between MOD and ACT modes.
     * @param root0 data about the route activation
     * @param root0."0" whether the route is activated
     * @param root0."1" whether the route is in mod
     */
    handleHeaderChange([routeActivated, pageInMod]) {
        this.PageHeaderDisplay.takeValue(this.getRouteHeaderString(routeActivated, pageInMod, 1));
    }
    /** @inheritDoc */
    async onHandleScrolling(event) {
        const currentPage = this.controller.currentPage.get();
        const pageCount = this.controller.pageCount.get();
        switch (event) {
            case 'pageRight':
                if (currentPage === pageCount) {
                    this.controller.currentPage.set(1);
                }
                else {
                    this.controller.currentPage.set(Math.min(currentPage + 1, pageCount));
                }
                return true;
            case 'pageLeft':
                if (currentPage === 1) {
                    this.controller.currentPage.set(pageCount);
                }
                else {
                    this.controller.currentPage.set(Math.max(currentPage - 1, 1));
                }
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onPageButtonPressed() {
        this.controller.currentPage.set(1);
        this.controller.ensureNotInHoldSelection();
        this.invalidate();
    }
}

/**
 * {@link FmcFormat} for displaying a nav frequency
 *
 * Accepts any valid tuning string that complies with AdfFrequencyFormat and NavFrequencyFormat
 */
class NavRadioPreselectFormat {
    /**
     * Constructs an `NavRadioPreselectFormat`.
     *
     * @param index 1 for ADF Left, 2 for ADF Right.
     */
    constructor(index) {
        this.index = index;
        this.nullValueString = this.index === 1 ? inputBox(' --------') : inputBox('-------- ');
        this.NAV_RAD_ID_REGEX = /^[A-Z]{1,4}$/;
        this.NAV_FREQUENCY_NO_DECIMAL_REGEX = /^\d+$/;
        this.NAV_FREQUENCY_REGEX = /\d{1,3}\.\d{1,2}/;
        this.ADF_FREQUENCY_REGEX = /^(\d{3,4})(\.\d){1}$/;
        this.ADF_FREQUENCY_WITH_TUNING_MODE_REGEX = /^(\d{3,4})(\.\d){1}([A,B]?)$/;
    }
    /** @inheritDoc */
    format(value) {
        if (value) {
            const paddedString = this.index === 1 ? value.padEnd(9, ' ') : value.padStart(9, ' ');
            return inputBox(paddedString);
        }
        return this.nullValueString;
    }
    /** @inheritDoc */
    async parse(input) {
        if (this.NAV_RAD_ID_REGEX.test(input)
            || this.NAV_FREQUENCY_NO_DECIMAL_REGEX.test(input)
            || this.NAV_FREQUENCY_REGEX.test(input)
            || this.ADF_FREQUENCY_REGEX.test(input)
            || this.ADF_FREQUENCY_WITH_TUNING_MODE_REGEX.test(input)) {
            return input;
        }
        return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
    }
}
/**
 * The Boeing NAV RADIO page.
 */
class BoeingNavRadPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.navComSub = this.bus.getSubscriber();
        this.navProcSub = this.bus.getSubscriber();
        this.controlSub = this.bus.getSubscriber();
        this.vorLeftTuningMode = ConsumerSubject.create(this.controlSub.on('vor_tuning_mode_left'), VorTuningMode.None);
        this.vorLeftData = new DataInterface(MappedSubject.create(([freq, ident, tuningMode]) => ({ freq, ident, tuningMode }), ConsumerSubject.create(this.navComSub.on('nav_active_frequency_1').whenChanged(), 0), ConsumerSubject.create(this.navComSub.on('nav_ident_1').whenChanged(), ''), this.vorLeftTuningMode), (freq) => {
            this.bus.getPublisher().pub('set_manual_vor_freq_left', freq, true);
        });
        this.vorRightTuningMode = ConsumerSubject.create(this.controlSub.on('vor_tuning_mode_right'), VorTuningMode.None);
        this.vorRightData = new DataInterface(MappedSubject.create(([freq, ident, tuningMode]) => ({ freq, ident, tuningMode }), ConsumerSubject.create(this.navComSub.on('nav_active_frequency_2').whenChanged(), 0), ConsumerSubject.create(this.navComSub.on('nav_ident_2').whenChanged(), ''), this.vorRightTuningMode), (freq) => {
            this.bus.getPublisher().pub('set_manual_vor_freq_right', freq, true);
        });
        this.ilsFreq = ConsumerSubject.create(this.navComSub.on('nav_active_frequency_3').whenChanged(), 0);
        this.ilsCrs = ConsumerSubject.create(this.navProcSub.on('nav_obs_3').whenChanged(), 0);
        this.ilsTuningMode = ConsumerSubject.create(this.controlSub.on('approach_tuning_mode'), ApproachTuningMode.Park);
        this.ilsData = new DataInterface(MappedSubject.create(([freq, course, tuningMode]) => ({ freq, course, tuningMode }), this.ilsFreq, this.ilsCrs, this.ilsTuningMode), (freqCourse) => {
            if (freqCourse === null) {
                // DELETE passed from scratchpad... we will clear the manual tuning, triggering an auto-tune
                this.bus.getPublisher().pub('approach_frequency_manually_tuned', null, true);
            }
            else {
                if (freqCourse.freq !== null) {
                    this.bus.getPublisher().pub('approach_frequency_manually_tuned', freqCourse.freq, true);
                }
                SimVar.SetSimVarValue('K:VOR3_SET', SimVarValueType.Number, freqCourse.course);
            }
        });
        this.radialLeftData = ConsumerSubject.create(this.navProcSub.on('nav_radial_1').whenChanged(), 0);
        this.radialLeftValid = ConsumerSubject.create(this.navProcSub.on('nav_has_nav_1').whenChanged(), false);
        this.radialRightData = ConsumerSubject.create(this.navProcSub.on('nav_radial_2').whenChanged(), 0);
        this.radioRightValid = ConsumerSubject.create(this.navProcSub.on('nav_has_nav_2').whenChanged(), false);
        this.preselectLeftData = Subject.create('');
        this.preselectRightData = Subject.create('');
        this.radialsMapped = MappedSubject.create(([radialLeft, radioLeftValid, radialRight, radioRightValid]) => {
            const radioLeftStr = radioLeftValid ? NavMath.normalizeHeading(radialLeft).toFixed(0).padStart(3, '0') : '   ';
            const radioRightStr = radioRightValid ? NavMath.normalizeHeading(radialRight).toFixed(0).padStart(3, '0') : '   ';
            return `${radioLeftStr} ${radioRightStr}`;
        }, this.radialLeftData, this.radialLeftValid, this.radialRightData, this.radioRightValid);
        this.adfLeftData = new DataInterface(MappedSubject.create(([freq, ident]) => ({ freq, ident }), ConsumerSubject.create(this.navComSub.on('adf_active_frequency_1').whenChanged(), 0), 
        // TODO: Implement ADF Ident
        Subject.create('')), ({ freq, ident }) => {
            SimVar.SetSimVarValue('K:ADF_ACTIVE_SET', 'Frequency ADF BCD32', Avionics.Utils.make_adf_bcd32(freq * 1000));
            SimVar.SetSimVarValue('K:RADIO_ADF_IDENT_SET', SimVarValueType.Number, ident === 'ANT' ? 0 : 1);
        });
        this.adfRightData = new DataInterface(MappedSubject.create(([freq, ident]) => ({ freq, ident }), ConsumerSubject.create(this.navComSub.on('adf_active_frequency_2').whenChanged(), 0), 
        // TODO: Implement ADF Ident
        Subject.create('')), ({ freq, ident }) => {
            SimVar.SetSimVarValue('K:ADF2_ACTIVE_SET', 'Frequency ADF BCD32', Avionics.Utils.make_adf_bcd32(freq * 1000));
            SimVar.SetSimVarValue('K:RADIO_ADF_IDENT_SET', SimVarValueType.Number, ident === 'ANT' ? 0 : 1);
        });
        this.VorLeftInputField = new TextInputField(this, {
            formatter: new VorFrequencyFormat(this.screen, this.fms, 1),
            deleteAllowed: true,
            onDelete: async () => {
                if (this.vorLeftTuningMode.get() !== VorTuningMode.ManuallyTuned) {
                    console.error(BoeingFmcErrorKeys.InvalidDelete);
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
                else {
                    return false;
                }
            },
        }).bindSource(this.vorLeftData);
        this.VorRightInputField = new TextInputField(this, {
            formatter: new VorFrequencyFormat(this.screen, this.fms, 2),
            deleteAllowed: true,
            onDelete: async () => {
                if (this.vorRightTuningMode.get() !== VorTuningMode.ManuallyTuned) {
                    console.error(BoeingFmcErrorKeys.InvalidDelete);
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
                else {
                    return false;
                }
            },
        }).bindSource(this.vorRightData);
        this.RadialsDisplayField = new DisplayField(this, {
            formatter: RawFormatter,
        }).bind(this.radialsMapped);
        this.AdfLeftInputField = new TextInputField(this, {
            formatter: new AdfFrequencyFormat(1),
            deleteAllowed: false,
        }).bindSource(this.adfLeftData);
        this.AdfRightInputField = new TextInputField(this, {
            formatter: new AdfFrequencyFormat(2),
            deleteAllowed: false,
        }).bindSource(this.adfRightData);
        this.PreselectLeftInputField = new TextInputField(this, {
            formatter: new NavRadioPreselectFormat(1),
            deleteAllowed: false,
            onSelected: (scratchpadContents) => {
                if (scratchpadContents) {
                    this.preselectLeftData.set(scratchpadContents);
                    return Promise.resolve('');
                }
                return Promise.resolve(this.preselectLeftData.get());
            },
        }).bind(this.preselectLeftData);
        this.PreselectRightInputField = new TextInputField(this, {
            formatter: new NavRadioPreselectFormat(2),
            deleteAllowed: false,
            onSelected: (scratchpadContents) => {
                if (scratchpadContents) {
                    this.preselectRightData.set(scratchpadContents);
                    return Promise.resolve('');
                }
                return Promise.resolve(this.preselectRightData.get());
            },
        }).bind(this.preselectRightData);
        // Takes:
        // - XXX.XX/YYY (ils freq + front course)
        // - /YYY (front course if ils already entered)
        // - XXXXX [20000, 99999] (GLS channel)
        this.IlsInputField = new TextInputField(this, {
            formatter: new IlsGlsFrequencyFormat(this.getFormattedParkText()),
            deleteAllowed: true,
            onSelected: (scratchpadContents) => {
                // If the ILS is auto-tuned, pressing the LSK with empty scratchpad copies the freq/crs
                // to the scratchpad for manual/hard tuning
                if (scratchpadContents
                    || (this.ilsTuningMode.get() !== ApproachTuningMode.ParkTuned && this.ilsTuningMode.get() !== ApproachTuningMode.Autotuned)) {
                    return Promise.resolve(false);
                }
                const freq = SimVar.GetSimVarValue('NAV ACTIVE FREQUENCY:3', 'MHz');
                const course = SimVar.GetSimVarValue('NAV OBS:3', 'degree');
                return Promise.resolve(`${freq.toFixed(2).padStart(5, '0')}/${course.toFixed(0).padStart(3, '0')}`);
            },
            onModified: async () => {
                if (this.appTuningInhibited.get()) {
                    return Promise.reject(BoeingFmcErrorKeys.AppTuneInhibitedMcp);
                }
                return false;
            }
        }).bindSource(this.ilsData);
        this.appTuningInhibited = ConsumerValue.create(this.controlSub.on('approach_tuning_inhibited'), false);
        this.paramSubjects = [
            this.radialLeftData,
            this.radialRightData,
            this.radialsMapped,
            this.ilsFreq,
            this.ilsCrs,
            this.ilsTuningMode,
            this.vorLeftTuningMode,
            this.vorRightTuningMode,
            this.appTuningInhibited,
        ];
    }
    /** @inheritdoc */
    init() {
        super.init();
    }
    // TODO course info not displayed in autotune
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'NAV RADIO'],
                [' VOR L', 'VOR R'],
                [this.VorLeftInputField, this.VorRightInputField],
                [' CRS', 'CRS', 'RADIAL'],
                [this.getFormattedEmptyCrsField(), this.getFormattedEmptyCrsField(), this.RadialsDisplayField],
                [' ADF L', 'ADF R'],
                [this.AdfLeftInputField, this.AdfRightInputField],
                [this.getTitleIlsGls()],
                [this.IlsInputField],
                [''],
                [''],
                ['', '', 'PRESELECT'],
                [this.PreselectLeftInputField, this.PreselectRightInputField],
            ],
        ];
    }
    /** @inheritDoc */
    destroy() {
        this.paramSubjects.forEach((subject) => { subject.destroy(); });
        super.destroy();
    }
    /** @inheritdoc */
    onPause() {
        this.paramSubjects.forEach((subject) => subject.pause());
    }
    /** @inheritdoc */
    onResume() {
        this.paramSubjects.forEach((subject) => subject.resume());
    }
}
/**
 * {@link FmcFormat} for displaying a nav frequency
 * @todo Does not support GLS
 * Accepts a XXX.XX/YYY or /YYY string.
 */
class IlsGlsFrequencyFormat {
    /**
     * The constructor.
     * @param formattedParkText The formatted PARK text.
     */
    constructor(formattedParkText) {
        this.FREQUENCY_COURSE_REGEX = /^(\d{3}\.\d{1,2})\/(\d{1,3})$/;
        this.COURSE_REGEX = /^\/(\d{1,3})$/;
        this.formattedParkText = '';
        this.freqFormatter = NumberFormatter.create({ precision: 0.01 });
        this.courseFormatter = NumberFormatter.create({ pad: 3 });
        this.nullValueString = '';
        this.formattedParkText = formattedParkText;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    format({ freq, course, tuningMode }) {
        if (freq === null || freq < 1) {
            return this.formattedParkText;
        }
        switch (tuningMode) {
            case ApproachTuningMode.Park:
                return this.formattedParkText;
            case ApproachTuningMode.ParkTuned:
                return inputBox(`${this.freqFormatter(freq)}/${this.courseFormatter(course)}`) + 'PARK';
            case ApproachTuningMode.Autotuned:
                return inputBox(`${this.freqFormatter(freq)}[green s-text]A[white s-text]${this.courseFormatter(course)}[green s-text]`);
            case ApproachTuningMode.ManuallyTuned:
                return inputBox(`${this.freqFormatter(freq)}[green d-text]M[white s-text]${this.courseFormatter(course)}[green d-text]`);
        }
    }
    /** @inheritDoc */
    async parse(input) {
        let freq = null;
        let course = 0;
        const courseMatch = input.match(this.COURSE_REGEX);
        const freqMatch = input.match(this.FREQUENCY_COURSE_REGEX);
        if (freqMatch !== null) {
            const [, rawFreq, rawCourse] = freqMatch;
            freq = parseFloat(rawFreq);
            if (!RadioUtils.isLocalizerFrequency(freq)) {
                return null;
            }
            course = parseInt(rawCourse);
        }
        else if (courseMatch !== null) {
            const [, rawCourse] = courseMatch;
            course = parseInt(rawCourse);
        }
        else {
            return null;
        }
        if (course > 360) {
            return null;
        }
        return { freq, course };
    }
}
/**
 *
 */
class VorFrequencyFormat extends NavFrequencyFormat {
    // eslint-disable-next-line jsdoc/require-jsdoc
    format({ freq, ident, tuningMode }) {
        if (tuningMode === VorTuningMode.None) {
            return inputBox('           ');
        }
        let identString = '';
        if (ident && !RadioUtils.isLocalizerFrequency(freq)) {
            identString = ident;
        }
        const styledFreqString = this.index === 1
            ? `${this.formatter(freq)}[green]${this.tuningModeChar(tuningMode)}[s-text]${identString.padEnd(4)}[green]`
            : `${identString.padStart(4)}[green]${this.tuningModeChar(tuningMode)}[s-text]${this.formatter(freq)}[green]`;
        return inputBox(styledFreqString);
    }
    /**
     * Get the character to display for the current tuning mode
     * @param tuningMode Current tuning mode
     * @returns character for the current tuning mode
     */
    tuningModeChar(tuningMode) {
        switch (tuningMode) {
            case VorTuningMode.AutoTuned:
                return 'A';
            case VorTuningMode.ManuallyTuned:
                return 'M';
            case VorTuningMode.ProcedureTuned:
                return 'P';
            case VorTuningMode.RouteTuned:
                return 'R';
            default:
                return ' ';
        }
    }
}

/**
 * Boeing unit utility class.
 */
class BoeingUnitUtils {
    /**
     * Gets the weight unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The weight unit.
     */
    static getWeightUnits(isMetric) {
        return isMetric ? UnitType.KILOGRAM : UnitType.POUND;
    }
    /**
     * Gets the length unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The length unit.
     */
    static getLengthUnits(isMetric) {
        return isMetric ? UnitType.METER : UnitType.FOOT;
    }
    /**
     * Gets the pressure unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The pressure unit.
     */
    static getPressureUnits(isMetric) {
        return isMetric ? UnitType.HPA : UnitType.IN_HG;
    }
    /**
     * Gets the flow unit in metric or imperial
     * @param isMetric Whether the returned unit should be metric.
     * @returns The flow unit.
     */
    static getFlowUnits(isMetric) {
        return isMetric ? UnitType.KGH : UnitType.PPH;
    }
    /**
     * Gets the string (used for display) for a given unit in the WT21.
     * @param unit The unit to get the string for.
     * @returns The unit string for display.
     */
    static getUnitString(unit) {
        var _a;
        return (_a = BoeingUnitUtils.UNIT_STRINGS.get(unit)) !== null && _a !== void 0 ? _a : '';
    }
    /**
     * Returns a boolean indicating if the sim is in metric mode.
     * @returns true if sim is in metric mode, false otherwise.
     */
    static getIsMetric() {
        return SimVar.GetGameVarValue('GAME UNIT IS METRIC', 'number') === 1;
    }
}
BoeingUnitUtils.UNIT_STRINGS = new Map([
    [UnitType.KILOGRAM, 'KG'],
    [UnitType.POUND, 'LB'],
    [UnitType.METER, 'M'],
    [UnitType.FOOT, 'FT'],
    [UnitType.IN_HG, 'IN'],
    [UnitType.HPA, 'HPA'],
    [UnitType.PPH, 'PPH'],
    [UnitType.KGH, 'KGH'],
]);

const MIN_PREDICTIONS_IAS = 160;
const NULL_WIND_ENTRY = { speed: 0, direction: 0, trueDegrees: false };
/**
 * An implementation of {@link FlightPlanPredictionsProvider} that uses {@link BoeingPathCalculator}
 */
class BoeingFlightPlanPredictionsProvider {
    /**
     * Ctor
     * @param bus the bus
     * @param fmsPosIndex the index of the fms position to use
     * @param planIndex the index of the plan to predict data for
     * @param updateRate the update rate, in Hertz, at which to update plan predictions
     * @param flightPlanner the flight planner
     * @param windPlanner the wind planner
     * @param verticalPathCalculator the path calculator
     * @param performancePlanRepository the perf plan repo
     * @param perfProvider the perf provider
     * @param facLoader the fac loader
     */
    constructor(bus, fmsPosIndex, planIndex, updateRate, flightPlanner, windPlanner, verticalPathCalculator, performancePlanRepository, perfProvider, facLoader) {
        this.bus = bus;
        this.fmsPosIndex = fmsPosIndex;
        this.planIndex = planIndex;
        this.updateRate = updateRate;
        this.flightPlanner = flightPlanner;
        this.windPlanner = windPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.perfProvider = perfProvider;
        this.facLoader = facLoader;
        this.onPredictionsUpdated = new SubEvent();
        this.updateDebouncer = new DebounceTimer();
        this.realTimeValue = ConsumerValue.create(null, -1);
        this.simTimeValue = ConsumerValue.create(null, -1);
        this.activeLegDistanceAlongValue = ConsumerValue.create(null, -1);
        this.activeLegDtgValue = ConsumerValue.create(null, -1);
        this.pposValue = ConsumerValue.create(null, new LatLongAlt(NaN, NaN));
        this.casValue = ConsumerValue.create(null, 0);
        this.indicatedAltValue = ConsumerValue.create(null, 0);
        this.oatValue = ConsumerValue.create(null, 0);
        this.isaValue = ConsumerValue.create(null, 0);
        this.ambientWindMagnitudeValue = ConsumerValue.create(null, 0);
        this.ambientWindDirectionValue = ConsumerValue.create(null, 0);
        this.fobValue = ConsumerValue.create(null, -1);
        this.fuelWeightValue = ConsumerValue.create(null, -1);
        this.fuelFlowValue = ConsumerValue.create(null, -1);
        this.planPredictions = new Map();
        this.trackedFacilityEntries = new Map();
        this.trackedFacilityEntryPredictions = new Map();
        this.trackFacilityLastUpdates = new Map();
        this.resolvedFacilities = new Map();
        this.destinationPredictions = {
            ident: '',
            position: new GeoPoint(0, 0),
            valid: true,
            distance: NaN,
            estimatedTimeOfArrival: NaN,
            fob: NaN,
            altitude: NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0), new GeoCircle(new Float64Array(3), 0)];
        this.cachedSyncPacket = { planPredictions: {}, destinationPredictions: {}, trackedFacilityPredictions: {} };
        this.cachedSyncPositions = [];
        this.cachedSyncFacilityPositions = {};
        this.syncSub = this.bus.getSubscriber();
        this.syncPub = this.bus.getPublisher();
        this.initialized = false;
        this.useLocalCalculations = true;
    }
    /**
     * Fixes a Predictions object that was deserialized from JSON.
     * @param predictions The deserialized predictions object.
     * @returns The fixed predictions object.
     */
    static fixDeserializedPredictions(predictions) {
        var _a, _b, _c, _d, _e, _f;
        // We return a new object here to ensure that we don't forget to handle new fields.
        return {
            ident: predictions.ident,
            position: new GeoPoint((_a = predictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = predictions.position.lon) !== null && _b !== void 0 ? _b : NaN),
            valid: predictions.valid,
            distance: (_c = predictions.distance) !== null && _c !== void 0 ? _c : NaN,
            estimatedTimeOfArrival: (_d = predictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN,
            fob: (_e = predictions.fob) !== null && _e !== void 0 ? _e : NaN,
            altitude: (_f = predictions.altitude) !== null && _f !== void 0 ? _f : NaN,
            speed: NaN,
            isSpeedMach: false,
            duration: NaN,
        };
    }
    /**
     * Initializes the predictor
     *
     * @param useLocalCalculations whether to use local calculations or receive calculations from another calculator
     */
    init(useLocalCalculations) {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        this.useLocalCalculations = useLocalCalculations;
        const sub = this.bus.getSubscriber();
        if (useLocalCalculations) {
            this.setupLocalSyncEvents();
        }
        else {
            this.setupRemoteSyncEvents();
        }
        if (useLocalCalculations) {
            sub.on('realTime').whenChangedBy(this.updateRate).handle(() => {
                this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
            });
            this.realTimeValue.setConsumer(sub.on('realTime'));
            this.simTimeValue.setConsumer(sub.on('simTime'));
            this.activeLegDistanceAlongValue.setConsumer(sub.on('lnav_leg_distance_along'));
            this.activeLegDtgValue.setConsumer(sub.on('lnav_leg_distance_remaining'));
            this.pposValue.setConsumer(sub.on(`fms_pos_gps-position_${this.fmsPosIndex}`));
            this.casValue.setConsumer(sub.on('ias'));
            this.indicatedAltValue.setConsumer(sub.on('indicated_alt'));
            this.oatValue.setConsumer(sub.on('ambient_temp_c'));
            this.isaValue.setConsumer(sub.on('isa_temp_c'));
            this.ambientWindMagnitudeValue.setConsumer(sub.on('ambient_wind_velocity'));
            this.ambientWindDirectionValue.setConsumer(sub.on('ambient_wind_direction'));
            this.fobValue.setConsumer(sub.on('fuel_total_weight'));
            this.fuelWeightValue.setConsumer(sub.on('fuel_weight_per_gallon'));
            this.fuelFlowValue.setConsumer(sub.on('fuel_flow_total'));
            sub.on('fplLegChange').handle(({ legIndex, type }) => {
                const legPredictions = this.planPredictions.get(legIndex);
                switch (type) {
                    case LegEventType.Removed:
                        legPredictions && (legPredictions.valid = false);
                }
            });
        }
    }
    /**
     * Sets up sync events for receiving remote calculations
     */
    setupRemoteSyncEvents() {
        this.syncSub.on('boeing_predictions_sync').handle((predictions) => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;
            for (const [index, legPredictions] of Object.entries(predictions.planPredictions)) {
                const existing = this.planPredictions.get(parseInt(index));
                if (existing) {
                    existing.ident = legPredictions.ident;
                    existing.position.set((_a = legPredictions.position.lat) !== null && _a !== void 0 ? _a : NaN, (_b = legPredictions.position.lon) !== null && _b !== void 0 ? _b : NaN);
                    existing.valid = legPredictions.valid;
                    existing.distance = (_c = legPredictions.distance) !== null && _c !== void 0 ? _c : NaN;
                    existing.estimatedTimeOfArrival = (_d = legPredictions.estimatedTimeOfArrival) !== null && _d !== void 0 ? _d : NaN;
                    existing.fob = (_e = legPredictions.fob) !== null && _e !== void 0 ? _e : NaN;
                    existing.altitude = (_f = legPredictions.altitude) !== null && _f !== void 0 ? _f : NaN;
                    existing.speed = (_g = legPredictions.speed) !== null && _g !== void 0 ? _g : NaN;
                    existing.isSpeedMach = (_h = legPredictions.isSpeedMach) !== null && _h !== void 0 ? _h : false;
                    existing.duration = (_j = legPredictions.duration) !== null && _j !== void 0 ? _j : NaN;
                }
                else {
                    this.planPredictions.set(parseInt(index), BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(legPredictions));
                }
            }
            this.destinationPredictions.ident = predictions.destinationPredictions.ident;
            this.destinationPredictions.position.set((_k = predictions.destinationPredictions.position.lat) !== null && _k !== void 0 ? _k : NaN, (_l = predictions.destinationPredictions.position.lon) !== null && _l !== void 0 ? _l : NaN);
            this.destinationPredictions.valid = predictions.destinationPredictions.valid;
            this.destinationPredictions.distance = (_m = predictions.destinationPredictions.distance) !== null && _m !== void 0 ? _m : NaN;
            this.destinationPredictions.estimatedTimeOfArrival = (_o = predictions.destinationPredictions.estimatedTimeOfArrival) !== null && _o !== void 0 ? _o : NaN;
            this.destinationPredictions.fob = (_p = predictions.destinationPredictions.fob) !== null && _p !== void 0 ? _p : NaN;
            for (const [id, facilityPredictions] of Object.entries(predictions.trackedFacilityPredictions)) {
                const existing = this.trackedFacilityEntryPredictions.get(id);
                if (existing && facilityPredictions) {
                    existing.ident = facilityPredictions.ident;
                    existing.position.set((_q = facilityPredictions.position.lat) !== null && _q !== void 0 ? _q : NaN, (_r = facilityPredictions.position.lon) !== null && _r !== void 0 ? _r : NaN);
                    existing.valid = facilityPredictions.valid;
                    existing.distance = (_s = facilityPredictions.distance) !== null && _s !== void 0 ? _s : NaN;
                    existing.estimatedTimeOfArrival = (_t = facilityPredictions.estimatedTimeOfArrival) !== null && _t !== void 0 ? _t : NaN;
                    existing.fob = (_u = facilityPredictions.fob) !== null && _u !== void 0 ? _u : NaN;
                    existing.altitude = (_v = facilityPredictions.altitude) !== null && _v !== void 0 ? _v : NaN;
                    existing.speed = (_w = facilityPredictions.speed) !== null && _w !== void 0 ? _w : NaN;
                    existing.isSpeedMach = (_x = facilityPredictions.isSpeedMach) !== null && _x !== void 0 ? _x : false;
                    existing.duration = (_y = facilityPredictions.duration) !== null && _y !== void 0 ? _y : NaN;
                }
                else if (facilityPredictions) {
                    this.trackedFacilityEntryPredictions.set(id, BoeingFlightPlanPredictionsProvider.fixDeserializedPredictions(facilityPredictions));
                }
                else {
                    this.trackedFacilityEntryPredictions.set(id, undefined);
                }
            }
            this.onPredictionsUpdated.notify(this);
        });
    }
    /**
     * Sets up sync events for starting/stopping facility tracking from other predictors
     */
    setupLocalSyncEvents() {
        this.syncSub.on('boeing_predictions_start_tracking_facility').handle(({ id, entry }) => {
            this.startTrackingFacility(id, entry);
        });
        this.syncSub.on('boeing_predictions_stop_tracking_facility').handle((id) => {
            this.stopTrackingFacility(id);
        });
    }
    /**
     * Updates predictions for the flight plan, then notifies subscribers.
     */
    updatePredictions() {
        this.updatePredictionsInternal();
        this.onPredictionsUpdated.notify(this);
        this.syncPredictions();
    }
    /**
     * Updates predictions for the flight plan
     */
    updatePredictionsInternal() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return;
        }
        const cruiseAlt = this.performancePlanRepository.getActivePlan().cruiseAltitude.get();
        const zeroFuelWeight = this.performancePlanRepository.getActivePlan().manualZfw.get();
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        const verticalPath = this.verticalPathCalculator.getVerticalFlightPath(this.planIndex);
        const unixTimestamp = this.simTimeValue.get() / 1000;
        const canComputeAdvancedPredictions = cruiseAlt !== null && zeroFuelWeight !== null;
        const pposValue = this.pposValue.get();
        this.geoPointCache[2].set(pposValue.lat, pposValue.long);
        const _lastPosition = this.geoPointCache[2];
        const altitude = this.indicatedAltValue.get();
        const cas = this.casValue.get();
        const deltaIsa = this.oatValue.get() - this.isaValue.get();
        let _lastGroundSpeedMps = AeroMath.casToTasIsa(cas, altitude, deltaIsa);
        let accumulatedDistance = 0;
        let accumulatedTime = 0;
        for (let i = 0; i < plan.length; i++) {
            let legPredictions = this.planPredictions.get(i);
            const lateralLeg = plan.getLeg(i);
            const previousLateralLeg = plan.tryGetLeg(i - 1);
            const matchingVerticalLeg = verticalPath.legs[i];
            if (i < plan.activeLateralLeg || !matchingVerticalLeg) {
                if (legPredictions) {
                    legPredictions.valid = false;
                }
                this.invalidateTrackedFacilitiesForPosition(i);
                continue;
            }
            const legIsFollowingDiscontinuity = previousLateralLeg
                && ((BoeingFmsUtils.isDiscontinuityLeg(previousLateralLeg.leg.type) && !BitFlags.isAll(previousLateralLeg.flags, LegDefinitionFlags.DirectTo))
                    || BoeingFmsUtils.isVectorsLeg(previousLateralLeg === null || previousLateralLeg === void 0 ? void 0 : previousLateralLeg.leg.type));
            if (legPredictions === undefined) {
                legPredictions = {
                    ident: (_a = lateralLeg.name) !== null && _a !== void 0 ? _a : '',
                    position: new GeoPoint(0, 0),
                    valid: true,
                    distance: NaN,
                    estimatedTimeOfArrival: NaN,
                    fob: NaN,
                    altitude: NaN,
                    speed: NaN,
                    isSpeedMach: false,
                    duration: NaN,
                };
                this.planPredictions.set(i, legPredictions);
            }
            legPredictions.ident = (_b = lateralLeg.name) !== null && _b !== void 0 ? _b : '';
            let legDistance = NaN;
            let predictFromPpos = false;
            if (i === plan.activeLateralLeg) {
                // Active leg
                if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type) && matchingVerticalLeg.vectors.length > 0) {
                    // Active vectors leg
                    this.offsetPposAlongVectorsLeg(lateralLeg, 0.1, this.geoPointCache[1]);
                    this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1], legPredictions);
                    accumulatedDistance = legPredictions.distance;
                    // We skip the rest, and do not care about tracked facilities because who would put one on a VECTORS?
                    continue;
                }
                else {
                    accumulatedDistance += UnitType.METER.convertFrom(this.activeLegDtgValue.get(), UnitType.NMILE);
                    if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                        // Active non-vectors leg with a valid VNAV profile
                        accumulatedTime += (_c = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _c !== void 0 ? _c : matchingVerticalLeg.simDuration;
                    }
                    else {
                        // Active non-vectors leg without a valid VNAV profile
                        predictFromPpos = true;
                    }
                }
            }
            else if (BoeingFmsUtils.isVectorsLeg(lateralLeg.leg.type)) {
                // Upcoming vectors legs
                const previousPredictions = this.planPredictions.get(i - 1);
                if (previousPredictions) {
                    legPredictions.valid = previousPredictions.valid;
                    legPredictions.position.set(previousPredictions.position);
                    legPredictions.distance = previousPredictions.distance;
                    legPredictions.estimatedTimeOfArrival = previousPredictions.estimatedTimeOfArrival;
                    legPredictions.fob = previousPredictions.fob;
                    legPredictions.altitude = previousPredictions.altitude;
                    legPredictions.speed = previousPredictions.speed;
                    legPredictions.isSpeedMach = previousPredictions.isSpeedMach;
                    legPredictions.duration = previousPredictions.duration;
                }
                else {
                    legPredictions.valid = false;
                }
                accumulatedDistance += (_d = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _d !== void 0 ? _d : matchingVerticalLeg.simDistance;
                accumulatedTime += (_e = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _e !== void 0 ? _e : matchingVerticalLeg.simDuration;
                continue;
            }
            else if (legIsFollowingDiscontinuity) {
                if (((_f = lateralLeg.calculated) === null || _f === void 0 ? void 0 : _f.endLat) && lateralLeg.calculated.endLon) {
                    // Upcoming leg after discontinuity with valid termination point
                    const distance = GeoPoint.distance(_lastPosition.lat, _lastPosition.lon, lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                    const distanceMeters = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    accumulatedDistance += distanceMeters;
                    accumulatedTime += distanceMeters / _lastGroundSpeedMps;
                }
                else {
                    // Upcoming leg after discontinuity without a valid termination point
                    legPredictions.valid = false;
                    continue;
                }
            }
            else if (matchingVerticalLeg && matchingVerticalLeg.vectors.length > 0) {
                // Upcoming non-vectors leg with a valid VNAV profile
                accumulatedDistance += (_g = this.getVerticalLegTotalDistance(matchingVerticalLeg)) !== null && _g !== void 0 ? _g : matchingVerticalLeg.simDistance;
                accumulatedTime += (_h = this.getVerticalLegTotalDuration(matchingVerticalLeg)) !== null && _h !== void 0 ? _h : matchingVerticalLeg.simDuration;
            }
            else if (lateralLeg.calculated) {
                // Upcoming non-vectors leg without a valid VNAV profile
                accumulatedDistance += lateralLeg.calculated.distanceWithTransitions;
                accumulatedTime += lateralLeg.calculated.distanceWithTransitions / _lastGroundSpeedMps;
            }
            legDistance = accumulatedDistance;
            if (canComputeAdvancedPredictions && predictFromPpos && ((_j = lateralLeg.calculated) === null || _j === void 0 ? void 0 : _j.endLat) && lateralLeg.calculated.endLon) {
                this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(this.pposValue.get().lat, this.pposValue.get().long), this.geoPointCache[1].set((_k = lateralLeg.calculated) === null || _k === void 0 ? void 0 : _k.endLat, (_l = lateralLeg.calculated) === null || _l === void 0 ? void 0 : _l.endLon), legPredictions);
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (canComputeAdvancedPredictions && matchingVerticalLeg && matchingVerticalLeg.vectors.length !== 0) {
                const lastVector = this.getVerticalVectorForPredictions(matchingVerticalLeg);
                legPredictions.valid = true;
                legPredictions.position.set((_o = (_m = lateralLeg.calculated) === null || _m === void 0 ? void 0 : _m.endLat) !== null && _o !== void 0 ? _o : NaN, (_q = (_p = lateralLeg.calculated) === null || _p === void 0 ? void 0 : _p.endLon) !== null && _q !== void 0 ? _q : NaN);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = unixTimestamp + accumulatedTime;
                legPredictions.fob = lastVector.endWeight - zeroFuelWeight;
                legPredictions.altitude = lastVector.endAltitude;
                const predictedCas = lastVector.endCas;
                const predictedMach = lastVector.endMach;
                const targetCas = lastVector.targetCas;
                const targetMach = lastVector.targetMach;
                // TODO get pressure from vector
                const pressure = AeroMath.isaPressure(lastVector.endAltitude);
                const machCasEquivalent = AeroMath.machToCas(targetMach, pressure);
                const targetMachCasEquivalentKnots = UnitType.KNOT.convertFrom(machCasEquivalent, UnitType.MPS);
                if (targetMachCasEquivalentKnots < targetCas) {
                    legPredictions.speed = predictedMach;
                    legPredictions.isSpeedMach = true;
                }
                else {
                    legPredictions.speed = predictedCas;
                    legPredictions.isSpeedMach = false;
                }
                legPredictions.duration = matchingVerticalLeg.vectors.reduce((acc, vec) => acc + vec.duration, 0);
                const gs = this.getPredictedGroundSpeedAtEndOfLeg(matchingVerticalLeg);
                if (gs !== undefined && gs !== 0) {
                    _lastGroundSpeedMps = gs;
                }
                for (const [id, entry] of this.getTrackedFacilityEntriesForPosition(i)) {
                    this.updateTrackedFacilityPredictionsAfterLeg(id, entry, i);
                }
            }
            else if (lateralLeg.calculated && lateralLeg.calculated.endLat !== undefined && lateralLeg.calculated.endLon !== undefined) {
                legPredictions.valid = true;
                legPredictions.position.set(lateralLeg.calculated.endLat, lateralLeg.calculated.endLon);
                legPredictions.distance = legDistance;
                legPredictions.estimatedTimeOfArrival = NaN;
                legPredictions.fob = NaN;
                legPredictions.altitude = NaN;
                legPredictions.speed = NaN;
                legPredictions.isSpeedMach = false;
                legPredictions.duration = NaN;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            else {
                legPredictions.valid = false;
                this.invalidateTrackedFacilitiesForPosition(i);
            }
            if (legPredictions.valid) {
                Number.isFinite(legPredictions.position.lat) && _lastPosition.set(legPredictions.position);
            }
        }
        // Update tracked facilities with no leg index
        if (canComputeAdvancedPredictions) {
            for (const [id, entry] of this.getTrackedFacilityEntriesForPosition('direct')) {
                this.updateTrackedFacilityPredictionsFromPpos(id, entry);
            }
        }
        else {
            this.invalidateAllTrackedFacilities();
        }
        this.updateDestinationPredictions(canComputeAdvancedPredictions);
    }
    /**
     * Sync locally calculated predictions data to remote instruments
     */
    syncPredictions() {
        for (const [index, legPredictions] of this.planPredictions.entries()) {
            if (!this.cachedSyncPacket.planPredictions[index]) {
                this.cachedSyncPacket.planPredictions[index] = {};
            }
            Object.assign(this.cachedSyncPacket.planPredictions[index], legPredictions);
            if (!this.cachedSyncPositions[index]) {
                this.cachedSyncPositions[index] = { lat: 0, lon: 0 };
            }
            this.cachedSyncPositions[index].lat = legPredictions.position.lat;
            this.cachedSyncPositions[index].lon = legPredictions.position.lon;
            this.cachedSyncPacket.planPredictions[index].position = this.cachedSyncPositions[index];
        }
        Object.assign(this.cachedSyncPacket.destinationPredictions, this.destinationPredictions);
        if (!this.cachedSyncPositions[Number.MAX_SAFE_INTEGER]) {
            this.cachedSyncPositions[Number.MAX_SAFE_INTEGER] = { lat: 0, lon: 0 };
        }
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lat = this.destinationPredictions.position.lat;
        this.cachedSyncPositions[Number.MAX_SAFE_INTEGER].lon = this.destinationPredictions.position.lon;
        this.cachedSyncPacket.destinationPredictions.position = this.cachedSyncPositions[Number.MAX_SAFE_INTEGER];
        for (const [id] of this.trackedFacilityEntries) {
            const predictions = this.trackedFacilityEntryPredictions.get(id);
            if (predictions) {
                if (!this.cachedSyncPacket.trackedFacilityPredictions[id]) {
                    this.cachedSyncPacket.trackedFacilityPredictions[id] = {};
                }
                Object.assign(this.cachedSyncPacket.trackedFacilityPredictions[id], predictions);
                if (!this.cachedSyncFacilityPositions[id]) {
                    this.cachedSyncFacilityPositions[id] = { lat: 0, lon: 0 };
                }
                this.cachedSyncFacilityPositions[id].lat = predictions.position.lat;
                this.cachedSyncFacilityPositions[id].lon = predictions.position.lon;
                this.cachedSyncPacket.trackedFacilityPredictions[id].position = this.cachedSyncFacilityPositions[id];
            }
            else {
                this.cachedSyncPacket.trackedFacilityPredictions[id] = null;
            }
        }
        this.syncPub.pub('boeing_predictions_sync', this.cachedSyncPacket, true);
    }
    /**
     * Updates a tracked facility entry's predictions based on the predictions of a given leg index
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     * @param legIndex the leg index
     */
    updateTrackedFacilityPredictionsAfterLeg(id, entry, legIndex) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        const legPredictions = this.planPredictions.get(legIndex);
        if (!legPredictions || !legPredictions.valid) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        this.trackFacilityLastUpdates.set(entry, this.realTimeValue.get());
        const distance = legPredictions.position.distance(facilityPredictions.position);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(legPredictions.position, facilityPredictions.position, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions, legPredictions.estimatedTimeOfArrival, legPredictions.fob);
    }
    /**
     * Updates a tracked facility entry's predictions based on PPOS
     *
     * @param id the unique ID for the entry
     * @param entry the entry
     */
    updateTrackedFacilityPredictionsFromPpos(id, entry) {
        const facility = this.resolvedFacilities.get(entry.facIcao);
        const facilityPredictions = this.getTrackedFacilityPredictions(id, entry);
        if (!facility) {
            if (facilityPredictions) {
                facilityPredictions.valid = false;
            }
            return;
        }
        this.trackedFacilityEntryPredictions.set(id, facilityPredictions);
        const ppos = this.pposValue.get();
        const distance = GeoPoint.distance(facility.lat, facility.lon, ppos.lat, ppos.long);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        this.predictLinearly(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, distanceMetres, typeof entry.predictionSpeed === 'number' ? entry.predictionSpeed : 250, // TODO support speed schedules
        entry.predictionSpeedIsMach, entry.predictionsAltitude, entry.predictionsOatTemperature, entry.predictionsOatAltitude, entry.predictionsWind, facilityPredictions);
    }
    /**
     * Linearly predicts over a distance with fixed parameters
     *
     * @param startLla the position to predict at
     * @param endLla the position to predict at
     * @param distance the distance, in metres, over which to predict
     * @param speed the speed, in knots CAS or mach number, to predict at
     * @param speedIsMach whether {@link speed} is a mach number
     * @param altitude the altitude, in metres, to predict at
     * @param oatTemperature the outside air temperature, in Celsius, to predict at
     * @param oatAltitude the altitude of measure of {@link oatTemperature}
     * @param wind the wind vector to predict with
     * @param out the predictions object to hold the results
     * @param startingTime the starting time, or the current time if not provided
     * @param startingFob the starting fob, or the current fob if not provided
     */
    predictLinearly(startLla, endLla, distance, speed, speedIsMach, altitude, oatTemperature, oatAltitude, wind, out, startingTime, startingFob) {
        var _a;
        const unixTimestamp = startingTime !== null && startingTime !== void 0 ? startingTime : (this.simTimeValue.get() / 1000);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.METER);
        const distanceNm = UnitType.NMILE.convertFrom(distance, UnitType.METER);
        let predictionFuelFlow;
        const predictionOatIsaDev = oatTemperature - AeroMath.isaTemperature(oatAltitude);
        let predictionTrueAirspeed;
        if (speedIsMach) {
            predictionTrueAirspeed = AeroMath.machToTasIsa(speed, altitude, predictionOatIsaDev);
        }
        else {
            const predictionCasMps = UnitType.MPS.convertFrom(speed, UnitType.KNOT);
            predictionTrueAirspeed = AeroMath.casToTasIsa(predictionCasMps, altitude, predictionOatIsaDev);
        }
        const predictionTrueAirSpeedKnots = UnitType.KNOT.convertFrom(predictionTrueAirspeed, UnitType.MPS);
        const currentWeight = ((_a = this.performancePlanRepository.getActivePlan().manualZfw.get()) !== null && _a !== void 0 ? _a : 0) + this.fobValue.get();
        predictionFuelFlow = this.getInstantaneousFuelFlowIsa(altitude, predictionTrueAirspeed, predictionOatIsaDev, currentWeight, 0);
        // Cache great circle between positions
        this.geoCircleCache[0].setAsGreatCircle(startLla, endLla);
        let windKnots = FlightPathUtils.projectVelocityToCircle(wind.speed, startLla, wind.trueDegrees ? wind.direction : MagVar.magneticToTrue(wind.direction, startLla), this.geoCircleCache[0]);
        if (!Number.isFinite(windKnots)) {
            windKnots = 0;
        }
        const predictionGroundSpeed = predictionTrueAirSpeedKnots + windKnots;
        const durationSeconds = (distanceNm / predictionGroundSpeed) * 3600;
        if (predictionFuelFlow === undefined) {
            const fuelFlowPph = this.fuelFlowValue.get() * this.fuelWeightValue.get();
            predictionFuelFlow = fuelFlowPph / 3600;
        }
        const currentFob = startingFob !== null && startingFob !== void 0 ? startingFob : this.fobValue.get();
        out.valid = true;
        out.position.set(endLla);
        out.distance = distanceMetres;
        out.estimatedTimeOfArrival = unixTimestamp + durationSeconds;
        out.fob = currentFob - (durationSeconds * predictionFuelFlow);
        out.altitude = altitude;
        out.speed = speed;
        out.isSpeedMach = speedIsMach;
        out.duration = durationSeconds;
    }
    /**
     * Predicts performance linearly, with current conditions
     *
     * @param startLla the start point of the predictions
     * @param endLla the end point of the predictions
     * @param out the predictions object to hold the results
     */
    predictLinearlyWithCurrentConditions(startLla, endLla, out) {
        const distance = GeoPoint.distance(startLla, endLla);
        const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
        const speed = Math.max(MIN_PREDICTIONS_IAS, this.casValue.get());
        const altitude = this.indicatedAltValue.get();
        const altitudeMetres = UnitType.METER.convertFrom(altitude, UnitType.FOOT);
        const oat = this.oatValue.get();
        const wind = {
            speed: this.ambientWindMagnitudeValue.get(),
            direction: this.ambientWindDirectionValue.get(),
            trueDegrees: true,
        };
        this.predictLinearly(startLla, endLla, distanceMetres, speed, false, altitudeMetres, oat, altitudeMetres, wind, out);
    }
    /**
     * Offsets the present position along a vectors leg
     *
     * @param vectorsLeg the vectors leg
     * @param distanceToAdd the distance, in nautical miles, to offset by
     * @param out where the resulting position will be stored
     */
    offsetPposAlongVectorsLeg(vectorsLeg, distanceToAdd, out) {
        var _a;
        const distanceAlong = this.activeLegDistanceAlongValue.get();
        const distanceAlongGa = UnitType.GA_RADIAN.convertFrom(Math.max(0, distanceAlong) + distanceToAdd, UnitType.NMILE);
        if (((_a = vectorsLeg.calculated) === null || _a === void 0 ? void 0 : _a.startLat) === undefined || vectorsLeg.calculated.startLon === undefined || vectorsLeg.calculated.initialDtk === undefined) {
            return;
        }
        this.geoPointCache[1].set(vectorsLeg.calculated.startLat, vectorsLeg.calculated.startLon);
        this.geoCircleCache[1].setAsGreatCircle(this.geoPointCache[1], vectorsLeg.calculated.initialDtk + vectorsLeg.calculated.courseMagVar);
        this.geoCircleCache[1].offsetDistanceAlong(this.geoPointCache[1], distanceAlongGa, out);
    }
    /**
     * Gets the predicited ground speed at the end of a vertical leg.
     * @param verticalLeg The vertical leg to get the predicted ground speed for.
     * @returns The predicted grouns speed, or undefined if one could not be determined.
     */
    getPredictedGroundSpeedAtEndOfLeg(verticalLeg) {
        if (verticalLeg.vectors.length === 0) {
            return undefined;
        }
        const lastVector = this.getVerticalVectorForPredictions(verticalLeg);
        return lastVector.gs;
    }
    /**
     * Returns the total distance of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDistance(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
        }
        return distance;
    }
    /**
     * Returns the total duration of a vertical leg, starting at the last eligible vector
     *
     * @param verticalLeg the vertical leg
     *
     * @returns a number, or undefined if no eligible vector
     */
    getVerticalLegTotalDuration(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return undefined;
        }
        let distance = 0;
        for (let i = lastVectorIndex; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            distance += vector.duration;
        }
        return distance;
    }
    /**
     * Returns the vertical path vector of a vertical leg that should be used for predictions, or the last vector if none are eligible
     *
     * **Note:** this function assumes the leg contains at least one vector
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a {@link VerticalFlightPathVector}
     */
    getVerticalVectorForPredictions(verticalLeg) {
        const lastVectorIndex = this.getLastVerticalVectorIndexAlongLegPath(verticalLeg);
        if (lastVectorIndex === -1) {
            return verticalLeg.vectors[verticalLeg.vectors.length - 1];
        }
        return verticalLeg.vectors[lastVectorIndex];
    }
    /**
     * Returns the index of the last vertical path vector that is contained within the lateral path of a leg
     *
     * @param verticalLeg the vertical flight plan leg
     *
     * @returns a number, or -1 if no eligible vectors found
     */
    getLastVerticalVectorIndexAlongLegPath(verticalLeg) {
        for (let i = verticalLeg.vectors.length - 1; i >= 0; i--) {
            const vector = verticalLeg.vectors[i];
            if (vector.startDistanceToLegEnd >= 0) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Calculates the instantaneous fuel flow for given parameters at ISA conditions
     *
     * @param altitude the altitude, in metres
     * @param tas the true airspeed, in metres per second
     * @param isaDev the ISA temperature deviation, in degrees Celsius
     * @param weight the weight, in pounds
     * @param flapsIndex The flaps index to use, or zero for a clean configuration.
     *
     * @returns the fuel flow, in pounds per second
     */
    getInstantaneousFuelFlowIsa(altitude, tas, isaDev, weight, flapsIndex) {
        const weightForce = UnitType.NEWTON.convertFrom(weight, UnitType.POUND_FORCE);
        const density = AeroMath.isaDensity(altitude, isaDev);
        const cl = AeroMath.liftCoefficient(weightForce, this.perfProvider.getWingArea(), density, tas);
        const thrust = this.perfProvider.getLevelFlightRequiredThrust(weight, cl, flapsIndex);
        const mach = AeroMath.tasToMachIsa(tas, altitude, AeroMath.soundSpeedIsa(altitude, isaDev));
        const grossThrust = this.perfProvider.estimateGrossThrustFromNetThrust(thrust, mach, AeroMath.isaPressure(altitude), AeroMath.isaTemperature(altitude) + isaDev);
        return this.perfProvider.getEngineFuelFlow(grossThrust) / 3600;
    }
    /**
     * Returns the predictions object for a tracked facility entry, creating a new empty and invalid object if none is present
     *
     * @param id the unique id for the tracked facility entry
     * @param entry the tracked facility entry
     *
     * @returns a {@link Predictions} object
     */
    getTrackedFacilityPredictions(id, entry) {
        var _a;
        const predictions = this.trackedFacilityEntryPredictions.get(id);
        if (!predictions) {
            const emptyPredictions = {
                ident: (_a = ICAO.getIdent(entry.facIcao)) !== null && _a !== void 0 ? _a : '',
                position: new GeoPoint(NaN, NaN),
                valid: false,
                distance: NaN,
                estimatedTimeOfArrival: NaN,
                fob: NaN,
                altitude: NaN,
                groundSpeed: NaN,
                speed: NaN,
                isSpeedMach: false,
                duration: NaN,
            };
            this.trackedFacilityEntryPredictions.set(id, emptyPredictions);
            return emptyPredictions;
        }
        return predictions;
    }
    /**
     * Updates the destination prediction
     *
     * @param computeAdvancedPredictions whether to computer advanced predictions, or just distance
     */
    updateDestinationPredictions(computeAdvancedPredictions) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let mapIndex = -1;
        if (plan.length > 0) {
            for (let i = plan.length - 1; i > 0; i--) {
                const planLeg = plan.tryGetLeg(i);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    mapIndex = i;
                }
            }
        }
        // Use the MAP index if it is available
        if (mapIndex !== -1) {
            const mapLegPredictions = this.planPredictions.get(mapIndex);
            if (mapLegPredictions && mapLegPredictions.valid) {
                this.destinationPredictions.valid = true;
                Object.assign(this.destinationPredictions, mapLegPredictions);
                return;
            }
        }
        // Otherwise, predict using the prediction at the last non-missed-approach plan leg + great circle direct
        // distance to the destination airport reference point
        if (plan.length > 0 && plan.destinationAirport) {
            let lastNonMissedApproachLegIndex = -1;
            for (let i = plan.length - 1; i > 0; i--) {
                const leg = plan.getLeg(i);
                if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                    lastNonMissedApproachLegIndex = i;
                    break;
                }
            }
            if (lastNonMissedApproachLegIndex !== -1) {
                const backwardsIterator = this.iteratePredictionsReverse(lastNonMissedApproachLegIndex);
                let lastLegPredictions;
                let prevLastLegPredictions;
                for (const predictions of backwardsIterator) {
                    if (!prevLastLegPredictions && lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        prevLastLegPredictions = predictions;
                        break;
                    }
                    if (!lastLegPredictions && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                        lastLegPredictions = predictions;
                    }
                }
                if (prevLastLegPredictions && lastLegPredictions) {
                    this.destinationPredictions.valid = true;
                    Object.assign(this.destinationPredictions, lastLegPredictions);
                    const airportFacility = this.resolvedFacilities.get(plan.destinationAirport);
                    if (!airportFacility) {
                        this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                        this.destinationPredictions.valid = false;
                        return;
                    }
                    const distance = lastLegPredictions.position.distance(airportFacility);
                    const distanceMetres = UnitType.METER.convertFrom(distance, UnitType.GA_RADIAN);
                    if (Math.abs(prevLastLegPredictions.distance - lastLegPredictions.distance) > Number.EPSILON) {
                        BoeingFlightPlanPredictionsProvider.extrapolatePrediction(prevLastLegPredictions, lastLegPredictions, distanceMetres, this.destinationPredictions);
                    }
                    else {
                        this.predictLinearly(lastLegPredictions.position, this.geoPointCache[0].set(airportFacility.lat, airportFacility.lon), distanceMetres, UnitType.MPS.convertFrom(MIN_PREDICTIONS_IAS, UnitType.KNOT), false, lastLegPredictions.altitude, 15, 0, NULL_WIND_ENTRY, this.destinationPredictions);
                    }
                    return;
                }
            }
        }
        // In the worst case scenario, predict the great circle direct distance from PPOS to the destination airport reference point
        if (plan.destinationAirport) {
            const facility = this.resolvedFacilities.get(plan.destinationAirport);
            if (!facility) {
                this.loadFacilityAndScheduleUpdate(plan.destinationAirport);
                this.destinationPredictions.valid = false;
                return;
            }
            const ppos = this.pposValue.get();
            this.predictLinearlyWithCurrentConditions(this.geoPointCache[0].set(ppos.lat, ppos.long), facility, this.destinationPredictions);
            if (!computeAdvancedPredictions) {
                this.destinationPredictions.estimatedTimeOfArrival = NaN;
                this.destinationPredictions.fob = NaN;
                this.destinationPredictions.altitude = NaN;
                this.destinationPredictions.speed = NaN;
                this.destinationPredictions.isSpeedMach = false;
                this.destinationPredictions.duration = NaN;
            }
            return;
        }
        // Otherwise mark the destination predictions as invalid
        this.destinationPredictions.valid = false;
    }
    /**
     * Invalidates all tracked facility predictions
     */
    invalidateAllTrackedFacilities() {
        for (const [, predictions] of this.trackedFacilityEntryPredictions.entries()) {
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Invalidates all tracked facility predictions attached to a given position
     *
     * @param position the position
     */
    invalidateTrackedFacilitiesForPosition(position) {
        const entries = this.getTrackedFacilityEntriesForPosition(position);
        for (const [entry] of entries) {
            const predictions = this.trackedFacilityEntryPredictions.get(entry);
            if (predictions) {
                predictions.valid = false;
            }
        }
    }
    /**
     * Returns all facility tracking entries for a given position
     *
     * @param position the position
     *
     * @returns an array of {@link FacilityPredictionsTrackingEntry} objects
     */
    getTrackedFacilityEntriesForPosition(position) {
        const indices = [];
        for (const mapEntry of this.trackedFacilityEntries.entries()) {
            const [, entry] = mapEntry;
            if (entry.startAfterFlightPlanLeg === position) {
                indices.push(mapEntry);
            }
        }
        return indices;
    }
    /** @inheritDoc */
    *iteratePredictions(startGlobalLegIndex = 0) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = startGlobalLegIndex; i < plan.length; i++) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    *iteratePredictionsReverse(startGlobalLegIndex = this.flightPlanner.getFlightPlan(this.planIndex).length - 1) {
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = Math.min(plan.length - 1, startGlobalLegIndex); i > 0; i--) {
            yield this.getPredictionsForLeg(i);
        }
    }
    /** @inheritDoc */
    getPredictionsForLeg(globalLegIndex) {
        return this.planPredictions.get(globalLegIndex);
    }
    /** @inheritDoc */
    getDestinationPredictions() {
        return this.destinationPredictions;
    }
    /** @inheritDoc */
    getPredictionsForTrackedFacility(id) {
        var _a;
        return (_a = this.trackedFacilityEntryPredictions.get(id)) !== null && _a !== void 0 ? _a : undefined;
    }
    /** @inheritDoc */
    startTrackingFacility(id, entry) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_start_tracking_facility', { id, entry }, true);
            return;
        }
        this.trackedFacilityEntries.set(id, entry);
        this.facLoader.getFacility(ICAO.getFacilityType(entry.facIcao), entry.facIcao).then((facility) => {
            this.resolvedFacilities.set(entry.facIcao, facility);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /** @inheritDoc */
    stopTrackingFacility(id) {
        if (!this.useLocalCalculations && this.initialized) {
            this.syncPub.pub('boeing_predictions_stop_tracking_facility', id, true);
            return true;
        }
        return this.trackedFacilityEntries.delete(id) && this.trackedFacilityEntryPredictions.delete(id);
    }
    /** @inheritDoc */
    getPredictionsForTime(time) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('estimatedTimeOfArrival', time, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const ratio = (time - predictionsBefore.estimatedTimeOfArrival) / (predictionsAfter.estimatedTimeOfArrival - predictionsBefore.estimatedTimeOfArrival);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, ratio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForAltitude(altitude) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        let startAltitude;
        let crossingDirection = 1;
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (startAltitude === undefined && (predictions === null || predictions === void 0 ? void 0 : predictions.valid)) {
                startAltitude = predictions.altitude;
                crossingDirection = startAltitude > altitude ? -1 : 1;
            }
            if (!predictions) {
                continue;
            }
            if (crossingDirection > 0 && predictions.altitude > altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
            if (crossingDirection < 0 && predictions.altitude < altitude) {
                predictionsBefore = this.planPredictions.get(i - 1);
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return undefined;
        }
        const altitudeRatio = Math.abs(altitude - predictionsBefore.altitude) / Math.abs(predictionsAfter.altitude - predictionsBefore.altitude);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, altitudeRatio, out);
        return out;
    }
    /** @inheritDoc */
    getPredictionsForDistance(distance) {
        if (!this.flightPlanner.hasFlightPlan(this.planIndex)) {
            return undefined;
        }
        const boundary = this.getBoundingLegPredictions('distance', distance, 1);
        if (!boundary) {
            return undefined;
        }
        const [predictionsBefore, predictionsAfter] = boundary;
        const distanceRatio = (distance - predictionsBefore.distance) / (predictionsAfter.distance - predictionsBefore.distance);
        const out = {};
        BoeingFlightPlanPredictionsProvider.linearlyInterpolatePredictions(predictionsBefore, predictionsAfter, distanceRatio, out);
        return out;
    }
    /**
     * Gets the bounding (previous and next) leg predictions that surround a given value of a property
     *
     * @param discriminant the property to evaluate
     * @param value the value (the value the previous prediction must be below, and the next prediction above)
     * @param progression the progression direction: if -1, inverts the example conditions of the {@link value} param
     *
     * @returns a tuple of {@link Predictions} objects, or null if none found
     */
    getBoundingLegPredictions(discriminant, value, progression) {
        let predictionsBefore;
        let predictionsAfter;
        const plan = this.flightPlanner.getFlightPlan(this.planIndex);
        for (let i = 0; i < plan.length; i++) {
            const predictions = this.planPredictions.get(i);
            if (!predictions) {
                continue;
            }
            if (progression > 0 ? predictions[discriminant] < value : predictions[discriminant] > value) {
                predictionsBefore = predictions;
                continue;
            }
            if (progression > 0 ? predictions[discriminant] > value : predictions[discriminant] < value) {
                predictionsAfter = predictions;
                break;
            }
        }
        if (!predictionsBefore || !predictionsAfter) {
            return null;
        }
        return [predictionsBefore, predictionsAfter];
    }
    /**
     * Loads a facility and schedules a predictions update
     *
     * @param facilityIcao the facility ICAO
     */
    loadFacilityAndScheduleUpdate(facilityIcao) {
        this.facLoader.getFacility(ICAO.getFacilityType(facilityIcao), facilityIcao).then((loadedFac) => {
            this.resolvedFacilities.set(facilityIcao, loadedFac);
            this.updateDebouncer.schedule(() => this.updatePredictions(), 500);
        });
    }
    /**
     * Linearly interpolates two prediction objects
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param ratio the ratio to interpolate at
     * @param out the output value object
     */
    static linearlyInterpolatePredictions(predictionsA, predictionsB, ratio, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsA.distance + (ratio * (predictionsB.distance - predictionsA.distance));
            out.estimatedTimeOfArrival = predictionsA.estimatedTimeOfArrival + (ratio * (predictionsB.estimatedTimeOfArrival - predictionsA.estimatedTimeOfArrival));
            out.fob = predictionsA.fob + (ratio * (predictionsB.fob - predictionsA.fob));
            out.altitude = predictionsA.altitude + (ratio * (predictionsB.altitude - predictionsA.altitude));
            out.speed = predictionsA.speed + (ratio * (predictionsB.speed - predictionsA.speed));
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
    /**
     * Linearly extrapolates two prediction objects into another prediction given an additional distance flown
     *
     * @param predictionsA the first prediction
     * @param predictionsB the second prediction
     * @param additionalDistance the additional distance to extrapolate to
     * @param out the output value object
     */
    static extrapolatePrediction(predictionsA, predictionsB, additionalDistance, out) {
        out.ident = '';
        out.valid = predictionsA.valid && predictionsB.valid;
        if (out.valid) {
            out.distance = predictionsB.distance + additionalDistance;
            out.estimatedTimeOfArrival = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival);
            out.fob = MathUtils.lerp(out.estimatedTimeOfArrival, predictionsA.estimatedTimeOfArrival, predictionsB.estimatedTimeOfArrival, predictionsA.fob, predictionsB.fob);
            out.altitude = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.altitude, predictionsB.altitude);
            out.speed = MathUtils.lerp(predictionsB.distance + additionalDistance, predictionsA.distance, predictionsB.distance, predictionsA.speed, predictionsB.speed);
            out.isSpeedMach = predictionsB.isSpeedMach;
            out.duration = predictionsB.distance * out.distance / predictionsB.distance;
        }
        else {
            out.distance = NaN;
            out.estimatedTimeOfArrival = NaN;
            out.fob = NaN;
            out.altitude = NaN;
            out.speed = NaN;
            out.isSpeedMach = false;
            out.duration = NaN;
        }
    }
}

/** A Boeing PERF INIT page. */
class BoeingPerfInitPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, fuelTempLabel, requestHeader, requestPrompt, line6HeaderGen) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.fuelTempLabel = fuelTempLabel;
        this.requestHeader = requestHeader;
        this.requestPrompt = requestPrompt;
        this.line6HeaderGen = line6HeaderGen;
        this.numberUnitCache = [
            new NumberUnit(0, UnitType.POUND),
            new NumberUnit(0, UnitType.POUND),
        ];
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.ThrustLink = PageLinkField.createLink(this, 'THRUST LIM>', '/thrust-lim');
        this.line6Header = [''];
        this.perfPlan = this.fms.performancePlanProxy;
        this.perfProv = this.fms.perfProvider;
        this.fuelTemp = B787FmcFormatters.Unit('°C', { spaceBetween: false, fontSize: 'small' })(this.perfProv.fuelFreezeTemp);
        this.sub = this.bus.getSubscriber();
        this.gameUnit = ConsumerSubject.create(this.sub.on('game_units_metric'), false);
        this.gameUnitSub = this.gameUnit.map((metric) => metric ? UnitType.KILOGRAM : UnitType.POUND);
        this.displayZfw = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.displayFuelWeight = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.displayReserveFuel = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.sensedFuelWeight = ConsumerSubject.create(this.sub
            .on('fuel_total_weight').atFrequency(1), 0);
        this.isOnGround = ConsumerSubject.create(this.sub
            .on('on_ground').whenChanged(), true);
        this.indicatedAlt = ConsumerSubject.create(this.sub
            .on('indicated_alt').atFrequency(1), 0);
        this.todLeg = ConsumerSubject.create(this.sub
            .on('vnav_tod_global_leg_index'), -1);
        this.distanceFromTodInMeters = ConsumerSubject.create(this.sub
            .on('vnav_tod_distance').atFrequency(1), 0);
        this.flightPhase = ConsumerSubject.create(this.sub
            .on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.within10NmOfTod = MappedSubject.create(([todExists, distInMeters]) => todExists && distInMeters < 10 * 1852, // 10NM
        this.todLeg.map((leg) => leg !== -1), this.distanceFromTodInMeters);
        // In thousands of lbs (or thousands of kilograms)
        this.GwField = new DisplayField(this, {
            formatter: {
                format: B787FmcFormatters.Weight('display', this.gameUnitSub),
                nullValueString: '',
            },
        }).bind(MappedSubject.create(([zfw, fuelWeight]) => !Number.isNaN(zfw.number) ? fuelWeight.add(zfw, this.numberUnitCache[0]) : null, this.displayZfw, this.displayFuelWeight));
        // In thousands of lbs (or thousands of kilograms)
        this.FuelField = new DisplayField(this, {
            formatter: new NumberAndUnitFormat(this.gameUnitSub.map((unit) => `${unit === UnitType.POUND ? 'LB' : 'KG'} SENSED`), { precision: 1, spaceBetween: false }),
        }).bind(this.displayFuelWeight.asUnit(this.gameUnitSub).map((value) => value / 1000));
        // In thousands of lbs (or thousands of kilograms)
        this.ZfwField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.ZeroFuelWeight(this.gameUnitSub.map(unit => UnitType.POUND.convertTo(this.perfProv.maxGrossWeight, unit)), this.gameUnitSub.map(unit => UnitType.POUND.convertTo(this.perfProv.operatingEmptyWeight, unit)), this.gameUnitSub.map(unit => UnitType.POUND.convertTo(this.perfProv.maxZeroFuelWeight, unit))),
                format: B787FmcFormatters.Weight('input', this.gameUnitSub),
                nullValueString: inputBox('□□□.□'),
            },
            onSelected: async (scratchpadContents) => {
                if (this.perfPlan.manualZfw.get() === null && !scratchpadContents) {
                    const totalWeight = SimVar.GetSimVarValue('TOTAL WEIGHT', SimVarValueType.Pounds);
                    const fuelWeight = SimVar.GetSimVarValue('FUEL TOTAL QUANTITY WEIGHT', SimVarValueType.Pounds);
                    let zeroFuelWeight = totalWeight - fuelWeight;
                    if (BoeingUnitUtils.getIsMetric()) {
                        zeroFuelWeight = UnitType.POUND.convertTo(zeroFuelWeight, UnitType.KILOGRAM);
                    }
                    return (zeroFuelWeight / 1000).toFixed(1);
                }
                else {
                    return false;
                }
            },
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bindSource(BoeingFmcUtils.gameUnitsWeightDataInterface(this.gameUnitSub, this.displayZfw, this.perfPlan.manualZfw));
        this.ReservesField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.ReservesWeight(this.gameUnitSub.map(unit => UnitType.POUND.convertTo(this.perfProv.maxReserveFuel, unit))),
                format: B787FmcFormatters.Weight('input', this.gameUnitSub),
                nullValueString: inputBox('□□□.□'),
            },
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bindSource(BoeingFmcUtils.gameUnitsWeightDataInterface(this.gameUnitSub, this.displayReserveFuel, this.perfPlan.reserveFuel));
        this.CrzAltField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.CruiseAltitude(this.isOnGround, this.indicatedAlt, this.perfPlan.cruiseAltitude),
                format: B787FmcFormatters.Altitude('input', this.perfPlan.transitionAltitude),
                nullValueString: inputBox('□□□□□'),
            },
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bind(this.perfPlan.cruiseAltitude);
        this.CostIdxField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.DigitOnly(4),
                format: (val) => inputBox(val.toString().padStart(4, ' ')),
                nullValueString: inputBox('□□□□'),
            },
            onModified: async () => this.flightPhase.get() > FmsOperatingPhase.TAKEOFF &&
                (this.flightPhase.get() === FmsOperatingPhase.DESCENT || this.within10NmOfTod.get()) ?
                Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry) : false,
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bind(this.perfPlan.costIndex);
        this.CrzCgField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.FloatRangePositive(2, 1, 1, this.perfProv.maxCenterOfGravity, this.perfProv.minCenterOfGravity),
                nullValueString: B787FmcFormatters.Unit('%', {
                    precision: 1,
                    spaceBetween: false,
                    padStart: 4,
                    padString: ' ',
                    type: 'input',
                    fontSize: 'small',
                })(this.perfProv.minCenterOfGravity),
                format: B787FmcFormatters.Unit('%', {
                    precision: 1,
                    spaceBetween: false,
                    padStart: 4,
                    padString: ' ',
                    type: 'input'
                }),
            },
            onDelete: async () => this.perfPlan.cruiseCg.get() === null ?
                Promise.reject(BoeingFmcErrorKeys.InvalidDelete) : false,
        }).bind(this.perfPlan.cruiseCg);
        this.StepSizeField = new DisplayField(this, {
            formatter: {
                format: () => 'ICAO[disabled]',
                nullValueString: '',
            }
        }).bind(this.perfPlan.stepSize);
    }
    /** @inheritDoc */
    onInit() {
        this.sensedFuelWeight.pipe(this.displayFuelWeight);
        this.addBinding(this.perfPlan.manualZfw.sub((it) => this.displayZfw.set(it !== null && it !== void 0 ? it : NaN, UnitType.POUND), true));
        this.addBinding(this.perfPlan.reserveFuel.sub((it) => this.displayReserveFuel.set(it !== null && it !== void 0 ? it : NaN, UnitType.POUND), true));
        this.addBinding(this.gameUnit.sub(() => this.invalidate()));
        this.addBinding(MappedSubject.create(this.fms.preflightComplete, this.isOnGround, this.flightPhase.map(phase => phase > FmsOperatingPhase.TAKEOFF)).sub(([preflightComplete, isOnGround, isAfterTakeoff]) => {
            this.line6Header = this.line6HeaderGen(preflightComplete, isOnGround, isAfterTakeoff);
            this.invalidate();
        }, true));
    }
    /** @inheritDoc */
    onResume() {
        this.gameUnit.resume();
        this.sensedFuelWeight.resume();
        this.isOnGround.resume();
        this.indicatedAlt.resume();
        this.todLeg.resume();
        this.distanceFromTodInMeters.resume();
        this.flightPhase.resume();
    }
    /** @inheritDoc */
    onPause() {
        this.gameUnit.pause();
        this.sensedFuelWeight.pause();
        this.isOnGround.pause();
        this.indicatedAlt.pause();
        this.todLeg.pause();
        this.distanceFromTodInMeters.pause();
        this.flightPhase.pause();
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'PERF INIT'],
                [' GR WT', 'CRZ ALT'],
                [this.GwField, this.CrzAltField],
                [' FUEL', 'COST INDEX'],
                [this.FuelField, this.CostIdxField],
                [' ZFW', this.fuelTempLabel],
                [this.ZfwField, this.fuelTemp],
                [' RESERVES', 'CRZ CG'],
                [this.ReservesField, this.CrzCgField],
                [this.requestHeader, 'STEP SIZE[disabled]'],
                [this.requestPrompt, this.StepSizeField],
                this.line6Header,
                [this.IndexLink, this.ThrustLink],
            ],
        ];
    }
}

/// <reference types="@microsoft/msfs-types/JS/common" />
/** The Lat Long text format for REF AIRPORT position.*/
class RefAirportLatLongTextFormat extends LatLongTextFormat {
    /** @inheritDoc */
    constructor(options) {
        super();
        if (options === null || options === void 0 ? void 0 : options.placeholderAsBlank) {
            this.nullValueString = '';
        }
    }
}
/** The Boeing POS REF page. */
class BoeingPosRefPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, props) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.props = props;
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.RtePageLink = PageLinkField.createLink(this, 'ROUTE>', '/rte');
        this.sub = this.bus.getSubscriber();
        this.publisher = this.bus.getPublisher();
        this.latLongFormatter = new LatLongTextFormat();
        this.copiedPos = Subject.create(new LatLongAlt());
        this.lastPos = ConsumerSubject.create(this.sub.on('fms_pos_gps-position_1').whenChanged(), new LatLongAlt());
        this.gpsPos = ConsumerSubject.create(this.sub.on('fms_pos_gps-position_1').whenChanged(), new LatLongAlt());
        this.refAirportIdent = Subject.create('----');
        this.refAirportPos = Subject.create(new LatLongAlt());
        this.refInertPos = Subject.create(new LatLongAlt());
        this.gateNumber = Subject.create('');
        this.groundSpeed = ConsumerSubject.create(this.sub.on('ground_speed').whenChangedBy(3), 0);
        this.utcTime = ConsumerSubject.create(this.sub.on('zulu_time'), 0);
        this.gpsOneStatus = ConsumerSubject.create(this.sub.on('gps_rec_gps_system_state_changed_1'), GPSSystemState.Searching);
        this.gpsTwoStatus = ConsumerSubject.create(this.sub.on('gps_rec_gps_system_state_changed_2'), GPSSystemState.Searching);
        this.gpsIsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), this.gpsOneStatus, this.gpsTwoStatus);
        this.posIsInitialized = ConsumerSubject.create(this.sub.on('all_irs_systems_operating'), true);
        this.anIruIsAcceptingPos = ConsumerSubject.create(this.sub.on('an_irs_is_accepting_pos'), false);
        this.anIruIsRequestingPos = ConsumerSubject.create(this.sub.on('an_irs_is_requesting_pos'), false);
        this.anIruIsAccOrReqPos = ConsumerSubject.create(this.sub.on('an_irs_is_accepting_or_requesting_pos'), false);
        this.showInertPosField = MappedSubject.create(([needsPos, gs]) => needsPos && gs < 1, this.anIruIsAccOrReqPos, this.groundSpeed);
        // 2/4
        // TODO side
        this.iruAnpRawSub = ConsumerSubject.create(this.sub.on('fms_pos_iru_anp_1'), -1);
        this.iruAnpSub = this.iruAnpRawSub.map((anp) => anp >= 0 ? anp : null);
        this.gpsAnpRawSub = ConsumerSubject.create(this.sub.on('fms_pos_gps_anp_1'), -1);
        this.gpsAnpSub = this.gpsAnpRawSub.map((anp) => anp >= 0 ? anp : null);
        this.radioAnpRawSub = ConsumerSubject.create(this.sub.on('fms_pos_radio_anp_1'), -1);
        this.radioAnpSub = this.radioAnpRawSub.map((anp) => anp >= 0 ? anp : null);
        this.fmcRawAnp = ConsumerSubject.create(this.sub.on('fms_pos_anp_1'), -1);
        this.fmcAnp = this.fmcRawAnp.map((anp) => anp >= 0 ? anp : null);
        this.lateralRnp = ConsumerSubject.create(this.sub.on('lnavdata_rnp'), null);
        this.rnpData = new DataInterface(MappedSubject.create(([manualRnp, currentRnp, currentAnp]) => [currentRnp, manualRnp !== null, currentAnp], this.fms.activePerformancePlan.manualLateralRnp, this.lateralRnp, this.fmcAnp), (rnp) => {
            this.fms.activePerformancePlan.manualLateralRnp.set(rnp);
        });
        this.subscriptions = [
            this.sub.on('pos_ref_airport_ident').handle((ident) => this.refAirportIdent.set(ident)),
            this.sub.on('pos_ref_airport_pos').handle((pos) => this.refAirportPos.set(pos)),
            this.sub.on('pos_ref_inert_pos').handle((pos) => this.refInertPos.set(pos)),
        ];
        this.paramSubjects = [
            this.lastPos,
            this.gpsPos,
            this.groundSpeed,
            this.utcTime,
            this.gpsOneStatus,
            this.gpsTwoStatus,
            this.posIsInitialized,
            this.anIruIsAcceptingPos,
            this.anIruIsRequestingPos,
            this.anIruIsAccOrReqPos,
            this.iruAnpRawSub,
            this.gpsAnpRawSub,
            this.radioAnpRawSub,
            this.fmcRawAnp,
            this.lateralRnp,
        ];
        this.RefAirportIdentField = new TextInputField(this, {
            formatter: new StringInputFormat({
                maxLength: 4,
                nullValueString: inputBox('----'),
            }),
            onSelected: async (value) => {
                if (!value) {
                    return '';
                }
                const refAirportIcao = (await this.fms.facLoader.searchByIdent(FacilitySearchType.Airport, value, 1))[0];
                if (refAirportIcao) {
                    const refAirport = await this.fms.facLoader.getFacility(FacilityType.Airport, refAirportIcao);
                    if (refAirport) {
                        this.publisher.pub('pos_ref_airport_ident', ICAO.getIdent(refAirport.icao));
                        this.publisher.pub('pos_ref_airport_pos', new LatLongAlt(refAirport.lat, refAirport.lon));
                        return '';
                    }
                }
                return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
            }
        }).bind(this.refAirportIdent);
        this.GateField = new DisplayField(this, {
            formatter: RawFormatter,
        }).bind(this.gateNumber);
        this.LastPosField = new DisplayField(this, {
            formatter: this.latLongFormatter,
            onSelected: () => {
                try {
                    this.copiedPos.set(this.lastPos.get());
                    return Promise.resolve(this.latLongFormatter.format(this.copiedPos.get()));
                }
                catch (error) {
                    return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                }
            }
        }).bind(this.lastPos);
        this.RefAirportPosField = new DisplayField(this, {
            formatter: new RefAirportLatLongTextFormat({
                placeholderAsBlank: this.props.refAirportPosPlaceholderAsBlank,
            }),
            onSelected: () => {
                try {
                    if (this.refAirportPos.get().lat && this.refAirportPos.get().long) {
                        this.copiedPos.set(this.refAirportPos.get());
                        return Promise.resolve(this.latLongFormatter.format(this.refAirportPos.get()));
                    }
                    return Promise.resolve('');
                }
                catch (error) {
                    return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                }
            }
        }).bind(this.refAirportPos);
        this.GpsPosField = new DisplayField(this, {
            formatter: this.latLongFormatter,
            onSelected: () => {
                try {
                    this.copiedPos.set(this.gpsPos.get());
                    return Promise.resolve(this.latLongFormatter.format(this.copiedPos.get()));
                }
                catch (error) {
                    return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                }
            }
        }).bind(this.gpsPos);
        this.InertPosField = new TextInputField(this, {
            formatter: new LatLongTextFormat({
                placeholderAsSquare: false,
                inputBox: this.props.inertPosHasInputBox,
            }),
            // TODO Change the onSelected handler so that manual entries can be accepted
            onSelected: () => {
                if (this.copiedPos.get().lat !== undefined && this.copiedPos.get().long !== undefined) {
                    const origin = this.fms.facilityInfo.originFacility;
                    if (origin) {
                        const originAirportGeoPoint = new GeoPoint(origin.lat, origin.lon);
                        const distanceNm = UnitType.GA_RADIAN.convertTo(originAirportGeoPoint.distance(this.copiedPos.get().lat, this.copiedPos.get().long), UnitType.NMILE);
                        if (distanceNm > 6) {
                            return Promise.reject(BoeingFmcErrorKeys.InertialOriginDisagree);
                        }
                    }
                    this.publisher.pub('pos_ref_inert_pos', this.copiedPos.get());
                    for (let i = 1; i <= this.props.numberOfIRUs; i++) {
                        this.publisher.pub(`irs_set_position_${i}`, undefined, true, false);
                    }
                    this.copiedPos.set(new LatLongAlt());
                }
                return Promise.resolve('');
            }
        }).bind(this.refInertPos);
        this.UtcTimeField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.ZuluTime(this.props.zuluTimeSuffix),
            },
        }).bind(MappedSubject.create(this.utcTime, this.gpsIsAvailable));
        // 2/4
        this.anpFormatter = new NumberAndUnitFormat('NM', { precision: 2, prefix: 'ACTUAL ' });
        this.IruActualField = new DisplayField(this, {
            formatter: this.anpFormatter,
        }).bind(this.iruAnpSub);
        this.GpsActualField = new DisplayField(this, {
            formatter: this.anpFormatter,
        }).bind(this.gpsAnpSub);
        this.RadioActualField = new DisplayField(this, {
            formatter: this.anpFormatter,
        }).bind(this.radioAnpSub);
        this.RnpField = new TextInputField(this, {
            formatter: new RnpAnpFormat(),
            deleteAllowed: true,
        }).bindSource(this.rnpData);
    }
    /**
     * Set the InertPosField's placeholder character.
     * @param placeholder Boxes if true, dashes if false.
     * */
    setSetInertPosFieldPlaceholderChar(placeholder) {
        this.InertPosField.getOptions().formatter = new LatLongTextFormat({
            placeholderAsSquare: placeholder === 'box',
            inputBox: this.props.inertPosHasInputBox
        });
    }
    /** @inheritDoc */
    onInit() {
        // Modify the input box to display either box or dash prompts
        this.addBinding(MappedSubject.create(this.anIruIsRequestingPos, this.anIruIsAcceptingPos).sub(([isReq, isAcc]) => {
            if (isReq) {
                this.setSetInertPosFieldPlaceholderChar('box');
            }
            else if (isAcc) {
                this.setSetInertPosFieldPlaceholderChar('dash');
            }
        }, true));
        // Hide or display the SET INERT/IRS POS field and reset the bound value
        this.addBinding(this.showInertPosField.sub(() => {
            this.publisher.pub('pos_ref_inert_pos', new LatLongAlt());
            this.invalidate();
        }, true));
    }
    /** @inheritDoc */
    onResume() {
        this.paramSubjects.forEach(sub => sub.resume());
        this.subscriptions.forEach(sub => sub.resume());
    }
    /** @inheritDoc */
    onPause() {
        this.paramSubjects.forEach(sub => sub.pause());
        this.subscriptions.forEach(sub => sub.pause());
    }
    /** @inheritDoc */
    render() {
        const inertPosHeader = this.showInertPosField.get() ? this.props.inertPosHeaderText : '';
        const inertPosField = this.showInertPosField.get() ? this.InertPosField : '';
        return [
            [
                ['', this.PagingIndicator, 'POS INIT   '],
                ['', 'LAST POS'],
                ['', this.LastPosField],
                [' REF AIRPORT'],
                [this.RefAirportIdentField, this.RefAirportPosField],
                [' GATE[disabled]'],
                [this.GateField],
                [this.props.utcFieldTitle, 'GPS POS'],
                [this.UtcTimeField, this.GpsPosField],
                ['', inertPosHeader],
                ['', inertPosField],
                ['--------------------------------------'],
                [this.IndexLink, this.RtePageLink],
            ],
            [
                ['', this.PagingIndicator, 'POS REF'],
                [this.props.fmcPosFieldTitle, this.props.updateArmFieldTitle],
                [this.GpsPosField, 'ARM>'],
                [this.props.irsFieldTitle, this.IruActualField],
                [this.props.irsFieldContent, ''],
                [this.props.gpsFieldTitle, this.GpsActualField],
                [this.props.gpsFieldContent, ''],
                [this.props.radioFieldTitle, this.RadioActualField],
                [this.props.radioFieldContent, ''],
                [' RNP/ACTUAL', 'DME DME'],
                [this.RnpField, ''],
                ['--------------------------------------'],
                this.getPosRef24L6R6Row(),
            ],
            // Removing pages 3 and 4 until they're implemented
            /*
            [
              ['', this.PagingIndicator, 'POS REF'],
              ...this.getPosRef34Page(),
            ],
            [
              ['', this.PagingIndicator, 'POS REF'],
              ...this.getPosRef44Page(),
            ],
            */
        ];
    }
    /** @inheritDoc */
    destroy() {
        this.paramSubjects.forEach((sub) => sub.destroy());
        this.subscriptions.forEach((sub) => sub.destroy());
        super.destroy();
    }
}

/**
 * Mode for fix entry
 */
var FixEntryMode;
(function (FixEntryMode) {
    FixEntryMode[FixEntryMode["Dest"] = 0] = "Dest";
    FixEntryMode[FixEntryMode["Altn"] = 1] = "Altn";
    FixEntryMode[FixEntryMode["Enroute"] = 2] = "Enroute";
    FixEntryMode[FixEntryMode["Fix"] = 3] = "Fix";
})(FixEntryMode || (FixEntryMode = {}));
/**
 * Store for {@link BoeingProgPage}
 */
class BoeingProgPageStore {
    /**
     * Ctor
     * @param bus the event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.flightPhase = ConsumerSubject.create(this.bus.getSubscriber().on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.activeLegIndex = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_nominal_leg_index'), -1);
        this.activeLegPrediction = Subject.create(null);
        this.nextLegPrediction = Subject.create(null);
        this.fixEntryMode = Subject.create(FixEntryMode.Dest);
        this.fixEntryFacility = Subject.create(null);
        this.fixEntryFacilityTrackingEntry = Subject.create(null);
        this.fixEntryPrediction = Subject.create(null);
    }
}

/**
 * Formatter for leg predictions
 */
class PredictionFormatter {
    /**
     * Ctor
     * @param bus the event bus
     * @param uiProvider the UI provider
     * @param weightUnit the unit to use for displaying fuel weight
     * @param doShowIdent whether to show the ident
     * @param isForToLeg whether to apply TO leg styling
     */
    constructor(bus, uiProvider, weightUnit, doShowIdent, isForToLeg) {
        this.bus = bus;
        this.uiProvider = uiProvider;
        this.weightUnit = weightUnit;
        this.doShowIdent = doShowIdent;
        this.isForToLeg = isForToLeg;
        this.timeFormatter = DateTimeFormatter.create('{HH}{mm}z');
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), -1);
        this.nullValueString = this.uiProvider.getPredictionsNullValueString(this.doShowIdent);
    }
    /** @inheritDoc */
    format(value) {
        const identStr = `${value.ident.padEnd(7, ' ')}${this.isForToLeg ? '[magenta]' : ''}`;
        const distStr = value.valid && Number.isFinite(value.distance) ? UnitType.NMILE.convertFrom(value.distance, UnitType.METER).toFixed(0).padStart(4, ' ') : '     ';
        const fuelStr = value.valid && Number.isFinite(value.fob) ? (this.weightUnit.get().convertFrom(value.fob, UnitType.POUND) / 1000).toFixed(1).padStart(5, ' ') : '      ';
        const simTime = this.simTime.get();
        let timeStr = '    ';
        if (simTime !== -1 && value.valid && Number.isFinite(value.estimatedTimeOfArrival)) {
            timeStr = this.timeFormatter(value.estimatedTimeOfArrival * 1000);
        }
        return this.uiProvider.getPredictionsFormattedString(this.doShowIdent, identStr, distStr, timeStr, fuelStr);
    }
}
/**
 * VNP/ANP format
 */
class VnpAnpFormat {
    constructor() {
        this.nullValueString = '';
    }
    /** @inheritdoc */
    parse(input) {
        if (input.match(/^\d{2,3}\/?$/) === null) {
            return null;
        }
        const tmp = parseInt(input.replace('/', ''));
        if (tmp > 999 || tmp < 10) {
            return null;
        }
        return tmp;
    }
    /**
     * Format FT value with 0 dp
     * @param value value in FT
     * @returns formatted value
     */
    formatValue(value) {
        if (value === null) {
            return '---';
        }
        return value.toString().padStart(3, ' ');
    }
    /** @inheritDoc */
    format(value) {
        const [rnp, isManual, anp] = value;
        // TODO only pilot value is large
        return `${this.formatValue(rnp)}[${isManual ? 'd' : 's'}-text]/${this.formatValue(anp)}[d-text]FT[s-text]`;
    }
}
/** The Boeing PROG page. */
class BoeingProgPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingProgPageStore(this.bus);
        this.sub = this.bus.getSubscriber();
        this.gameUnit = ConsumerSubject.create(this.sub.on('game_units_metric'), false);
        this.gameUnitSub = this.gameUnit.map((metric) => metric ? UnitType.KILOGRAM : UnitType.POUND);
        // private readonly PosReportLink = PageLinkField.createLink(this, '<POS REPORT', '/pos-report');
        this.PosRefLink = PageLinkField.createLink(this, 'POS REF>', '/pos-init#2');
        this.TitleDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: 'PROGRESS',
                format: (flightNumber) => `${flightNumber} PROGRESS`.trim(),
            },
        }).bind(CockpitUserSettings.getManager(this.bus).getSetting('fltNumber'));
        // 1/4
        this.FixEntryHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    switch (value) {
                        case FixEntryMode.Dest:
                            return ' DEST';
                        case FixEntryMode.Altn:
                            return ' DIR TO ALTERNATE';
                        case FixEntryMode.Enroute:
                            return ' EN ROUTE WPT';
                        case FixEntryMode.Fix:
                            return ' DIR TO FIX';
                        default:
                            return '';
                    }
                }
            }
        }).bind(this.store.fixEntryMode);
        this.ActiveLegPredictions = new DisplayField(this, {
            formatter: new PredictionFormatter(this.bus, this, this.gameUnitSub, true, true),
        }).bind(this.store.activeLegPrediction);
        this.NextLegPredictions = new DisplayField(this, {
            formatter: new PredictionFormatter(this.bus, this, this.gameUnitSub, true, false),
        }).bind(this.store.nextLegPrediction);
        this.FixEntryIdent = new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('□□□□   '),
                /** @inheritDoc */
                format(value) {
                    return inputBox(ICAO.getIdent(value.icao).padEnd(7, ' '));
                },
                /** @inheritDoc */
                parse: async (input) => this.screen.selectWaypointByIdent(input, this.fms.ppos),
            },
            onDelete: async () => {
                this.setDestinationFacilityAsFixEntry();
                return true;
            }
        }).bind(this.store.fixEntryFacility);
        this.FixEntryPredictions = new DisplayField(this, {
            formatter: new PredictionFormatter(this.bus, this, this.gameUnitSub, false, false),
        }).bind(this.store.fixEntryPrediction);
        // TODO step alts
        // TODO LEVEL AT
        this.AtHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format([flightPhase, tocDistance, todDistance, eodDistance, destDistance]) {
                    switch (flightPhase) {
                        case FmsOperatingPhase.CLIMB: {
                            if (tocDistance > 0) {
                                return 'TO T/C';
                            }
                            break;
                        }
                        case FmsOperatingPhase.CRUISE: {
                            if (todDistance > 0 && destDistance > 0) {
                                const todDistanceNM = UnitType.NMILE.convertFrom(todDistance, UnitType.METER);
                                const destDistanceNm = UnitType.NMILE.convertFrom(destDistance, UnitType.METER);
                                if (todDistanceNM < 200 || destDistanceNm < 500) {
                                    return 'TO T/D';
                                }
                            }
                            break;
                        }
                        case FmsOperatingPhase.DESCENT: {
                            if (eodDistance > 0) {
                                return 'TO E/D';
                            }
                            break;
                        }
                    }
                    return '';
                }
            }
        }).bind(MappedSubject.create(this.store.flightPhase, this.fms.vnavData.distanceToc, this.fms.vnavData.distanceTod, this.fms.vnavData.distanceBod, this.fms.vnavData.distanceDest));
        this.AtDataField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format([flightPhase, tocDistance, tocEta, todDistance, todEta, eodDistance, eodEta, destDistance]) {
                    switch (flightPhase) {
                        case FmsOperatingPhase.CLIMB: {
                            if (tocDistance > 0 && tocEta !== null) {
                                const tocDistanceNm = UnitType.NMILE.convertFrom(tocDistance, UnitType.METER);
                                const etaStr = BoeingProgPage.ETA_FORMATTER(tocEta);
                                const distanceStr = tocDistanceNm.toFixed(0).padStart(4, ' ');
                                return `${etaStr}/[d-text]${distanceStr}[d-text]NM[s-text]`;
                            }
                            break;
                        }
                        case FmsOperatingPhase.CRUISE: {
                            if (todDistance > 0 && destDistance > 0 && todEta !== null) {
                                const todDistanceNM = UnitType.NMILE.convertFrom(todDistance, UnitType.METER);
                                const destDistanceNm = UnitType.NMILE.convertFrom(destDistance, UnitType.METER);
                                if (todDistanceNM < 200 || destDistanceNm < 500) {
                                    const todDistanceNm = UnitType.NMILE.convertFrom(todDistance, UnitType.METER);
                                    const etaStr = BoeingProgPage.ETA_FORMATTER(todEta);
                                    const distanceStr = todDistanceNm.toFixed(0).padStart(4, ' ');
                                    return `${etaStr}/[d-text]${distanceStr}[d-text]NM[s-text]`;
                                }
                            }
                            break;
                        }
                        case FmsOperatingPhase.DESCENT: {
                            if (eodDistance > 0 && eodEta !== null) {
                                const eodDistanceNm = UnitType.NMILE.convertFrom(eodDistance, UnitType.METER);
                                const etaStr = BoeingProgPage.ETA_FORMATTER(eodEta);
                                const distanceStr = eodDistanceNm.toFixed(0).padStart(4, ' ');
                                return `${etaStr}/[d-text]${distanceStr}[d-text]NM[s-text]`;
                            }
                            break;
                        }
                    }
                    return '';
                }
            }
        }).bind(MappedSubject.create(this.store.flightPhase, this.fms.vnavData.distanceToc, this.fms.vnavData.tocEta, this.fms.vnavData.distanceTod, this.fms.vnavData.todEta, this.fms.vnavData.distanceBod, this.fms.vnavData.eodEta, this.fms.vnavData.distanceDest));
        // 3/4
        this.Xtk = Subject.create(null);
        this.Vtk = Subject.create(null);
        this.XtkField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    const valueString = Math.abs(value).toFixed(2);
                    const signString = value > 0 ? 'R' : 'L';
                    return `${signString} ${valueString}[d-text]NM[s-text]`;
                },
            },
        });
        this.VtkField = new DisplayField(this, {
            formatter: new NumberAndUnitFormat('FT', { minValue: -999, maxValue: 999, precision: 0, spaceBetween: false, forceSign: true }),
        });
        // 4/4
        this.lateralAnp = ConsumerSubject.create(this.sub.on('fms_pos_anp_1'), -1);
        this.lateralRnp = ConsumerSubject.create(this.sub.on('lnavdata_rnp'), null);
        this.rnpData = new DataInterface(MappedSubject.create(([manualRnp, currentRnp, currentAnp]) => [currentRnp, manualRnp !== null, currentAnp], this.fms.activePerformancePlan.manualLateralRnp, this.lateralRnp, this.lateralAnp), (rnp) => {
            this.fms.activePerformancePlan.manualLateralRnp.set(rnp);
        });
        this.verticalAnp = ConsumerSubject.create(this.sub.on('fms_pos_vertical_anp_1'), -1);
        this.verticalRnp = ConsumerSubject.create(this.sub.on('boeingvnav_rnp'), null);
        this.vnpData = new DataInterface(MappedSubject.create(([manualRnp, defaultRnp, actualNP]) => [manualRnp !== null && manualRnp !== void 0 ? manualRnp : defaultRnp, manualRnp !== null, actualNP], this.fms.activePerformancePlan.manualVerticalRnp, this.verticalRnp, this.verticalAnp), (rnp) => {
            this.fms.activePerformancePlan.manualVerticalRnp.set(rnp);
        });
        this.RnpField = new TextInputField(this, {
            formatter: new RnpAnpFormat(),
            deleteAllowed: true,
        }).bindSource(this.rnpData);
        this.VnpField = new TextInputField(this, {
            formatter: new VnpAnpFormat(),
            deleteAllowed: true,
        }).bindSource(this.vnpData);
    }
    /** @inheritDoc */
    onInit() {
        super.onInit();
        const subs = this.bus.getSubscriber();
        // 1/4
        this.addBinding(this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => this.updatePredictions()));
        this.addBinding(subs.on('fplOriginDestChanged').handle((event) => this.handlePlanOriginDestChanged(event)));
        this.addBinding(subs.on('fplCopied').handle((event) => this.handlePlanCopied(event)));
        this.addBinding(this.store.fixEntryFacility.sub((facility) => {
            var _a;
            const existingEntry = this.store.fixEntryFacilityTrackingEntry.get();
            if (facility) {
                if ((existingEntry === null || existingEntry === void 0 ? void 0 : existingEntry.facIcao) !== facility.icao) {
                    if (existingEntry) {
                        this.fms.activeRoutePredictor.stopTrackingFacility(this.fixEntryTrackingID());
                    }
                    const cruiseAltitudeFeet = (_a = this.fms.activePerformancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : 37000;
                    const entry = {
                        facIcao: facility.icao,
                        predictionsAltitude: UnitType.METER.convertFrom(cruiseAltitudeFeet, UnitType.FOOT),
                        predictionSpeed: 250,
                        predictionSpeedIsMach: false,
                        predictionsOatAltitude: 0,
                        predictionsOatTemperature: 15,
                        predictionsWind: { direction: 0, speed: 0, trueDegrees: false },
                        startAfterFlightPlanLeg: 'direct',
                    };
                    this.store.fixEntryFacilityTrackingEntry.set(entry);
                    this.fms.activeRoutePredictor.startTrackingFacility(this.fixEntryTrackingID(), entry);
                    this.updateFixEntryType();
                }
            }
            else {
                this.store.fixEntryFacilityTrackingEntry.set(null);
            }
            this.updatePredictions();
        }, true));
        // 2/4
        this.addBinding(subs.on('lnav_xtk').atFrequency(3).handle((value) => {
            this.Xtk.set(MathUtils.clamp(value, -99.99, 99.99));
        }));
        this.addBinding(subs.on('vnav_vertical_deviation').atFrequency(3).handle((value) => {
            this.Vtk.set(MathUtils.clamp(value, -999, 999));
        }));
        this.XtkField.bind(this.Xtk);
        this.VtkField.bind(this.Vtk);
    }
    /** @inheritDoc */
    onResume() {
        super.onResume();
        if (!this.store.fixEntryFacility.get()) {
            this.setDestinationFacilityAsFixEntry();
        }
        this.updatePredictions();
    }
    /**
     * Handles a copied flight plan event
     *
     * @param event the event
     */
    handlePlanCopied(event) {
        if (event.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            if (!this.store.fixEntryFacility.get()) {
                this.setDestinationFacilityAsFixEntry();
                this.updatePredictions();
            }
            else {
                this.updateFixEntryType();
            }
        }
    }
    /**
     * Handles an origin/dest changed flight plan event
     *
     * @param event the event
     */
    handlePlanOriginDestChanged(event) {
        if (event.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            if (!this.store.fixEntryFacility.get()) {
                this.setDestinationFacilityAsFixEntry();
                this.updatePredictions();
            }
            else {
                this.updateFixEntryType();
            }
        }
    }
    /**
     * Updates predictions to show
     */
    updatePredictions() {
        const primaryFlightPlan = this.fms.getPrimaryFlightPlan();
        const activeLegIndex = this.store.activeLegIndex.get();
        if (activeLegIndex !== -1) {
            const predictions = this.fms.activeRoutePredictor.iteratePredictions(activeLegIndex);
            const activeLegPredictions = predictions.next();
            if (activeLegPredictions.value) {
                this.store.activeLegPrediction.set(activeLegPredictions.value);
                this.store.activeLegPrediction.notify();
            }
            else {
                this.store.activeLegPrediction.set(null);
            }
            let nextLegPredictions = predictions.next();
            let nextLegIndex = activeLegIndex + 1;
            let nextLeg = primaryFlightPlan.tryGetLeg(nextLegIndex);
            // Skip legs until we don't have a discontinuity
            while (nextLeg && BoeingFmsUtils.isDiscontinuityLeg(nextLeg.leg.type) && nextLegIndex < primaryFlightPlan.length) {
                nextLegIndex++;
                nextLeg = primaryFlightPlan.getLeg(nextLegIndex);
                nextLegPredictions = predictions.next();
            }
            if (nextLegPredictions.value) {
                this.store.nextLegPrediction.set(nextLegPredictions.value);
                this.store.nextLegPrediction.notify();
            }
            else {
                this.store.nextLegPrediction.set(null);
            }
        }
        else {
            this.store.activeLegPrediction.set(null);
            this.store.nextLegPrediction.set(null);
        }
        const fixEntryFacility = this.store.fixEntryFacility.get();
        const fixEntryFacilityTrackingEntry = this.store.fixEntryFacilityTrackingEntry.get();
        const fixEntryMode = this.store.fixEntryMode.get();
        let predictions;
        if (fixEntryMode === FixEntryMode.Dest) {
            predictions = this.fms.activeRoutePredictor.getDestinationPredictions();
        }
        else if (fixEntryMode === FixEntryMode.Enroute) {
            const plan = primaryFlightPlan;
            for (let i = plan.activeLateralLeg; i < plan.length; i++) {
                const leg = plan.getLeg(i);
                if (leg.leg.fixIcao === (fixEntryFacility === null || fixEntryFacility === void 0 ? void 0 : fixEntryFacility.icao)) {
                    predictions = this.fms.activeRoutePredictor.getPredictionsForLeg(i);
                    break;
                }
            }
        }
        else if (fixEntryFacility && fixEntryFacilityTrackingEntry) {
            predictions = this.fms.activeRoutePredictor.getPredictionsForTrackedFacility(this.fixEntryTrackingID());
        }
        if (predictions) {
            this.store.fixEntryPrediction.set(predictions);
            this.store.fixEntryPrediction.notify();
        }
        else {
            this.store.fixEntryPrediction.set(null);
        }
    }
    /**
     * Updates the fix entry facility type based on that facility
     */
    updateFixEntryType() {
        const facility = this.store.fixEntryFacility.get();
        if (facility) {
            const actLateralPlan = this.fms.getPrimaryFlightPlan();
            if (facility.icao === actLateralPlan.destinationAirport) {
                this.store.fixEntryMode.set(FixEntryMode.Dest);
            }
            else if (this.fms.alternates.getAlternateIndexByIcao(facility.icao) !== -1) {
                this.store.fixEntryMode.set(FixEntryMode.Altn);
            }
            else if (Array.from(actLateralPlan.legs()).some((it) => it.leg.fixIcao === facility.icao)) {
                this.store.fixEntryMode.set(FixEntryMode.Enroute);
            }
            else {
                this.store.fixEntryMode.set(FixEntryMode.Fix);
            }
        }
    }
    /**
     * Sets the destination facility as the fix entry
     */
    setDestinationFacilityAsFixEntry() {
        if (this.fms.hasPrimaryFlightPlan()) {
            const destIcao = this.fms.getPrimaryFlightPlan().destinationAirport;
            if (destIcao && destIcao !== ICAO.emptyIcao) {
                this.fms.facLoader.getFacility(FacilityType.Airport, destIcao).then((destFacility) => {
                    this.store.fixEntryMode.set(FixEntryMode.Dest);
                    this.store.fixEntryFacility.set(destFacility);
                });
            }
        }
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '1/4[s-text] ', this.TitleDisplay],
                [this.getPredictionsHeaderString()],
                [this.ActiveLegPredictions],
                [' NEXT'],
                [this.NextLegPredictions],
                [this.FixEntryHeader],
                [this.FixEntryIdent, this.FixEntryPredictions],
                [' SEL SPD[disabled]', this.AtHeader],
                ['---[disabled]', this.AtDataField],
                [''],
                [''],
                ['--------------------------------------'],
                ['<POS REPORT[disabled]', this.PosRefLink],
            ],
            [
                ['', this.PagingIndicator, this.TitleDisplay],
                [' H/WIND[disabled]', 'X/WIND[disabled]', 'WIND[disabled]'],
                ['-[disabled d-text]KT[disabled s-text]', '- --[disabled d-text]KT[disabled s-text]'],
                [' XTK ERROR', 'VTK ERROR'],
                [this.XtkField, this.VtkField],
                [' TAS[disabled]', 'SAT[disabled]'],
                ['---[disabled d-text]KT[disabled s-text]', '+--[disabled d-text]°C[disabled s-text]'],
                [' LEFT     RIGHT[disabled]', 'APU     FUEL USED[disabled]'],
                ['--.-       --.-[disabled]', '-.-     [disabled d-text]TOT[disabled s-text]  --.-[disabled d-text]'],
                [''],
                ['<USE[disabled]', '', 'FUEL QTY[disabled]'],
                ['TOTALIZER[disabled]', 'CALCULATED[disabled]'],
                [' --.-[disabled]', '<SEL>     --.-[disabled]'],
            ],
            [
                ['', this.PagingIndicator, 'ACT RTA PROGRESS'],
                [' FIX     ALT[disabled]', 'RTA[disabled]'],
                ['', ' ----.--[disabled d-text]z[disabled]'],
                [' RTA SPD[disabled]', 'DTG/   ALT [disabled]'],
                ['.---/---[disabled s-text]', '--/----.--z[disabled]'],
                ['', 'T/O[disabled]'],
                ['', '------[disabled]'],
                ['', 'TIME ERROR[disabled]'],
                ['', 'ON TIME[disabled]'],
                ['EARLIEST[disabled]', 'LATEST[disabled]', ' ---- ETA WINDOW --------[disabled]'],
                ['----.--z[disabled]', '----.--z[disabled]'],
                ['--------------------------------------[disabled]'],
                ['', 'RTA LIMITS>[disabled]'],
            ],
            [
                ['', this.PagingIndicator, 'RNP PROGRESS'],
                [' ---°[disabled]', 'GP-.-°[disabled]', '-.-NM[disabled]'],
                ['-----[disabled]', '---/ ----[disabled]'],
                [' RNP ACTUAL', 'VERT RNP/ANP'],
                [this.RnpField, this.VnpField],
                [' XTK ERROR', 'VTK ERROR'],
                [this.XtkField, this.VtkField],
                [''],
                [''],
                [''],
                [''],
                [`${this.getRnpFooterString()}[disabled]`],
                ['-.--[disabled d-text]NM[disabled s-text]', '---[disabled d-text]FT[disabled s-text]'],
            ],
        ];
    }
    /**
     * Returns a tracking ID for the fix entry predictions
     *
     * @returns a string
     */
    fixEntryTrackingID() {
        return `prog-user-entry-cdu${this.screen.getSideIndex()}`;
    }
}
BoeingProgPage.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z');

/** The Boeing REF NAV DATA page. */
class BoeingRefNavDataPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.headerMagVarOrLength = Subject.create(' MAG VAR');
        this.headerFreqOrChannel = Subject.create('FREQ');
        this.facilityIdent = Subject.create('-----');
        this.facilityLatLong = Subject.create({ lat: 0, long: 0 });
        this.facilityFreq = Subject.create('---.--');
        this.facilityElevation = Subject.create('');
        this.facilityMagVarOrLengthData = Subject.create({
            identType: 'other',
            value: -1
        });
        this.IdentField = new TextInputField(this, {
            formatter: new StringInputFormat({
                maxLength: 5,
                nullValueString: '-----',
            }),
            deleteAllowed: false,
            onSelected: async (value) => {
                if (!value) {
                    return '';
                }
                // Check if value is a destination runway designator
                if (this.destinationAirport) {
                    const runway = RunwayUtils.matchOneWayRunwayFromIdent(this.destinationAirport, value);
                    if (runway) {
                        const formattedRunwayIdent = `${value.slice(0, 2)}${value.slice(2).length === 1 ? `0${value.slice(2)}` : value.slice(2)}`;
                        this.headerMagVarOrLength.set(' LENGTH');
                        this.facilityFreq.set('');
                        this.facilityIdent.set(formattedRunwayIdent);
                        this.facilityLatLong.set({ lat: runway.latitude, long: runway.longitude });
                        this.facilityElevation.set(runway.elevation.toFixed(0));
                        this.facilityMagVarOrLengthData.set({ identType: 'runway', value: runway.length });
                        return '';
                    }
                }
                this.headerMagVarOrLength.set(' MAG VAR');
                const facilityIcao = (await this.fms.facLoader.searchByIdent(FacilitySearchType.All, value, 1))[0];
                if (facilityIcao) {
                    const facilityType = ICAO.getFacilityType(facilityIcao);
                    const facility = await this.fms.facLoader.getFacility(facilityType, facilityIcao);
                    if (facility) {
                        this.facilityFreq.set('');
                        this.facilityIdent.set(value.padEnd(5, ' '));
                        this.facilityLatLong.set({ lat: facility.lat, long: facility.lon });
                        this.facilityElevation.set('---');
                        this.facilityMagVarOrLengthData.set(Object.assign(Object.assign({}, this.facilityMagVarOrLengthData.get()), { value: facility.magvar }));
                        if (FacilityUtils.isFacilityType(facility, FacilityType.VOR) || FacilityUtils.isFacilityType(facility, FacilityType.NDB)) {
                            if (FacilityUtils.isFacilityType(facility, FacilityType.VOR)) {
                                this.facilityMagVarOrLengthData.set(Object.assign(Object.assign({}, this.facilityMagVarOrLengthData.get()), { value: facility.magneticVariation }));
                                if (facility.type === VorType.ILS) {
                                    this.headerFreqOrChannel.set('CHANNEL');
                                }
                            }
                            this.facilityFreq.set(Math.round((facility.freqMHz * 100) / 100).toFixed(2));
                            this.facilityMagVarOrLengthData.set(Object.assign(Object.assign({}, this.facilityMagVarOrLengthData.get()), { identType: 'navaid' }));
                        }
                        else if (FacilityUtils.isFacilityType(facility, FacilityType.Airport)) {
                            const referenceRunway = facility.runways[0];
                            this.facilityElevation.set(referenceRunway.elevation.toFixed(0));
                        }
                        else if (FacilityUtils.isFacilityType(facility, FacilityType.Intersection)) {
                            // TODO: support all types of waypoints, not just Intersections
                            this.facilityElevation.set('');
                        }
                        return '';
                    }
                }
                return Promise.reject(BoeingFmcErrorKeys.NotInDataBase);
            }
        });
        this.FreqOrChannelHeaderField = new DisplayField(this, {
            formatter: RawFormatter
        });
        this.FreqField = new DisplayField(this, {
            formatter: RawFormatter
        });
        this.ElevationField = new DisplayField(this, {
            formatter: new RefNavDataElevationTextFormat()
        });
        this.MagVarOrLengthHeaderField = new DisplayField(this, {
            formatter: RawFormatter
        });
        this.MagVarOrLengthField = new DisplayField(this, {
            formatter: new RefNavDataMagVarTextFormat()
        });
        this.LatField = new DisplayField(this, {
            formatter: new LatLongTextFormat({ onlyFormatLat: true })
        });
        this.LongField = new DisplayField(this, {
            formatter: new LatLongTextFormat({ onlyFormatLong: true })
        });
    }
    /** @inheritDoc */
    async onInit() {
        this.IdentField.bind(this.facilityIdent);
        this.FreqOrChannelHeaderField.bind(this.headerFreqOrChannel);
        this.FreqField.bind(this.facilityFreq);
        this.ElevationField.bind(this.facilityElevation);
        this.MagVarOrLengthHeaderField.bind(this.headerMagVarOrLength);
        this.MagVarOrLengthField.bind(this.facilityMagVarOrLengthData);
        this.LatField.bind(this.facilityLatLong);
        this.LongField.bind(this.facilityLatLong);
        if (this.fms.hasPrimaryFlightPlan()) {
            const plan = this.fms.getPrimaryFlightPlan();
            if (plan.destinationAirport) {
                this.destinationAirport = await this.fms.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
            }
        }
    }
    /** @inheritDoc */
    render() {
        const navIdInhibitBlock = this.getIsShowNavIdInhibit()
            ? [['', '', 'NAVAID INHIBIT'], ['----', '----']]
            : [['', '', ''], ['', '']];
        const vorOnlyInhibitBlock = this.getIsShowVorOnlyInhibit()
            ? [['', '', 'VOR ONLY INHIBIT'], ['----', '----']]
            : [['', '', ''], ['', '']];
        const isR6Button = this.getR6Button();
        const lastRow = isR6Button ? [this.IndexLink, isR6Button] : [this.IndexLink];
        return [
            [
                ['', '', 'REF NAV DATA'],
                [' IDENT', this.FreqOrChannelHeaderField],
                [this.IdentField, this.FreqField],
                [' LATITUDE', 'LONGITUDE'],
                [this.LatField, this.LongField],
                [this.MagVarOrLengthHeaderField, 'ELEVATION'],
                [this.MagVarOrLengthField, this.ElevationField],
                ...navIdInhibitBlock,
                ...vorOnlyInhibitBlock,
                ['--------------------------------------'],
                lastRow,
            ],
        ];
    }
}

/** RTE DATA PAGE Controller. */
class BoeingRteDataPageController {
    /**
     * Creates the Controller.
     * @param eventBus The event bus
     * @param fms The Fms
     * @param isDiscontinuityLegsHidden Whether discontinuity legs should be hidden from rows.
     * @param discontinuityLineString The Discontinuity line string.
     * @param wptPadEnd The number to use with pad end for the waypoint text.
     * @param wptPadLeft Number of spaces to pad left on the wpt string.
     * @param page The FMC Page
     */
    constructor(eventBus, fms, isDiscontinuityLegsHidden, discontinuityLineString, wptPadEnd, wptPadLeft, page) {
        this.eventBus = eventBus;
        this.fms = fms;
        this.isDiscontinuityLegsHidden = isDiscontinuityLegsHidden;
        this.discontinuityLineString = discontinuityLineString;
        this.wptPadEnd = wptPadEnd;
        this.wptPadLeft = wptPadLeft;
        this.page = page;
        this.isForHoldSelection = false;
        this.currentPage = Subject.create(1);
        this.pageCount = ComputedSubject.create(0, (v) => {
            return Math.max(1, Math.ceil(v / 5));
        });
        this.legChangeConsumer = this.eventBus.getSubscriber().on('fplLegChange');
        this.planCopiedConsumer = this.eventBus.getSubscriber().on('fplCopied');
        this.planCalculatedConsumer = this.eventBus.getSubscriber().on('fplCalculated');
        this.activeLegChangeConsumer = this.eventBus.getSubscriber().on('fplActiveLegChange');
        this.lnavDataConsumer = this.eventBus.getSubscriber().on('lnavdata_waypoint_distance');
        this.effectiveLegIndexConsumer = this.eventBus.getSubscriber().on('lnavdata_nominal_leg_index');
        this.gameUnitsSub = ConsumerSubject.create(this.eventBus.getSubscriber().on('game_units_metric'), false);
        this.predictions = ArraySubject.create();
        this.subscriptions = [];
        this.effectiveLegIndex = -1;
        this.firstGlobalLegIndex = -1;
        /**
         * Renders a row.
         * @param page The FmcPage
         * @param indexInDisplay the index in the rendered list
         * @param prevData The prev Data as RoutePageLegItem or undefined
         * @param data The LegPredictions or undefined
         * @returns an array of FmcRenderTemplateRows
         */
        this.renderRow = (page, indexInDisplay, prevData, data) => {
            var _a, _b;
            const returnRows = [];
            if (data) {
                if (data.isDiscontinuityLeg) {
                    returnRows.push([this.discontinuityLineString]);
                }
                else {
                    const etaStr = Number.isFinite(data.estimatedTimeOfArrival)
                        ? BoeingRteDataPageController.ETA_FORMATTER(data.estimatedTimeOfArrival * 1000)
                        : '----z';
                    const globalLegIndex = this.firstGlobalLegIndex + (this.currentPage.get() - 1) * 5 + indexInDisplay;
                    const plan = this.fms.getPlanForFmcRender();
                    const canHaveWindData = BoeingFmsUtils.legTypeCanHaveWind((_b = (_a = plan.tryGetLeg(globalLegIndex)) === null || _a === void 0 ? void 0 : _a.leg.type) !== null && _b !== void 0 ? _b : LegType.Unknown);
                    const hasWindData = canHaveWindData && this.fms.windPlanner.legHasNonPropagatedWind(plan.planIndex, globalLegIndex);
                    const windField = canHaveWindData ? PageLinkField.createLink(page, `${hasWindData ? 'W' : ''}>`, '/wind', false, { globalLegIndex }) : '';
                    const gameUnit = this.gameUnitsSub.get() ? UnitType.KILOGRAM : UnitType.POUND;
                    const fobStr = data.fob ? (UnitType.POUND.convertTo(data.fob, gameUnit) / 1000).toFixed(1) : ' --.-';
                    returnRows.push([etaStr, windField, `${''.padStart(this.wptPadLeft, ' ')}${data.ident.padEnd(this.wptPadEnd, ' ')}${data.isActiveLeg ? '[magenta]' : ''}${fobStr}`]);
                }
            }
            else {
                returnRows.push(['']);
            }
            // return no empty row if last row
            if (indexInDisplay < 4) {
                returnRows.push(['']);
            }
            return [...returnRows];
        };
        this.rows = new FmcListUtility(this.page, this.predictions, this.renderRow, 5);
    }
    /** Initializes the Controller */
    init() {
        this.subscriptions = [
            this.legChangeConsumer.handle(() => this.updateData()),
            this.activeLegChangeConsumer.handle(() => this.updateData()),
            this.planCalculatedConsumer.handle(() => this.updateData()),
            this.lnavDataConsumer.atFrequency(0.5).handle(() => this.updateData()),
            this.planCopiedConsumer.handle(() => this.updateData()),
            this.effectiveLegIndexConsumer.whenChanged().handle(() => this.updateData()),
            this.currentPage.sub(() => this.invalidate(), true),
            this.gameUnitsSub.sub(() => this.invalidate()),
            this.fms.activeRoutePredictor.onPredictionsUpdated.on(() => this.invalidate()),
        ];
        this.updateData();
    }
    /** Destroys the Controller.*/
    destroy() {
        this.subscriptions.map((sub) => sub.destroy());
        this.predictions.clear();
    }
    /** Local invalidate method */
    invalidate() {
        this.page.invalidate();
    }
    /**
     * Renders the Page
     * @returns The FmcRenderTemplate
     */
    renderPageRows() {
        const template = [];
        this.rows.renderList(this.currentPage.get()).forEach(row => template.push(row));
        return template;
    }
    /** Update the data used to render the Rte Data page. */
    updateData() {
        var _a;
        this.predictions.clear();
        // Needs to stay here so this page can get the most up-to-date flight plan
        // when leg sequences are changed at the LEGS page level.
        const lateralPlan = this.fms.getFlightPlan();
        if (this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const activeLegIndex = lateralPlan.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX
                ? Math.max(lateralPlan.activeLateralLeg, this.effectiveLegIndex)
                : lateralPlan.activeLateralLeg;
            const fromLegIndex = Math.max(0, activeLegIndex);
            this.firstGlobalLegIndex = fromLegIndex;
            const startSegmentIndex = Math.max(0, lateralPlan.getSegmentIndex(fromLegIndex));
            for (let s = startSegmentIndex; s < lateralPlan.segmentCount; s++) {
                const segment = lateralPlan.getSegment(s);
                let startLegIndex = 0;
                if (s === startSegmentIndex) {
                    startLegIndex = fromLegIndex - segment.offset;
                }
                for (let l = startLegIndex; l < segment.legs.length; l++) {
                    const leg = segment.legs[l];
                    if (FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) && this.isDiscontinuityLegsHidden) {
                        continue;
                    }
                    const globalLegIndex = segment.offset + l;
                    const legPrediction = this.fms.activeRoutePredictor.getPredictionsForLeg(globalLegIndex);
                    const copiedPrediction = legPrediction
                        ? Object.assign(Object.assign({}, legPrediction), { isActiveLeg: globalLegIndex === activeLegIndex, isDiscontinuityLeg: FlightPlanUtils.isDiscontinuityLeg(leg.leg.type) }) : {
                        speed: NaN,
                        duration: NaN,
                        isSpeedMach: false,
                        ident: (_a = leg.name) !== null && _a !== void 0 ? _a : '',
                        valid: false,
                        fob: NaN,
                        estimatedTimeOfArrival: NaN,
                        altitude: NaN,
                        distance: NaN,
                        position: new GeoPoint(0, 0),
                        isActiveLeg: false,
                        isDiscontinuityLeg: FlightPlanUtils.isDiscontinuityLeg(leg.leg.type),
                    };
                    this.predictions.insert(copiedPrediction);
                }
            }
            this.pageCount.set(this.predictions.length);
            const pageDiff = this.pageCount.get() - this.currentPage.get();
            if (pageDiff < 0) {
                this.currentPage.set(this.currentPage.get() + pageDiff);
            }
        }
    }
}
BoeingRteDataPageController.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z');

/** The RTE DATA page. Displays ETA, FUEL level at the ETA, and links to WIND data of each waypoint. */
class BoeingRteDataPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.controller = new BoeingRteDataPageController(this.bus, this.fms, this.getIsDiscontinuityLegsHidden(), this.getDiscontinuityLineString(), this.getWptPadEnd(), this.getWptPadLeft(), this);
        this.pageCountDisplay = new DisplayField(this, {
            formatter: PageNumberDisplay,
        });
        this.pageHeaderDisplay = new DisplayField(this, {
            formatter: RawFormatter,
        });
        this.FplnPagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        }).bind(MappedSubject.create(([currentPage, pageCount]) => [currentPage, pageCount], this.controller.currentPage, this.controller.pageCount));
    }
    /** @inheritDoc */
    onInit() {
        this.headerChangeSub = MappedSubject.create(this.fms.routeActivated(1), this.fms.planInMod).sub(this.handleHeaderChange.bind(this), true);
        this.mapFormatChangeSub = this.getMapSettings().whenSettingChanged('mapFormat').handle(() => this.handleFormatChanged());
        this.addBinding(this.headerChangeSub);
        this.addBinding(this.mapFormatChangeSub);
    }
    /**
     * Handles when the map format changes.
     */
    handleFormatChanged() {
        this.invalidate();
    }
    /**
     * Handles when the FMS changes between MOD and ACT modes.
     * @param root0 data about the route activation
     * @param root0."0" whether the route is activated
     * @param root0."1" whether the route is in mod
     */
    handleHeaderChange([routeActivated, pageInMod]) {
        if (pageInMod) {
            this.pageHeaderDisplay.takeValue(this.modHeaderString);
        }
        else {
            this.pageHeaderDisplay.takeValue(routeActivated ? this.activeHeaderString : this.inactiveHeaderString);
        }
    }
    /** @inheritDoc */
    onPause() {
        this.controller.destroy();
    }
    /** @inheritDoc */
    onResume() {
        this.controller.currentPage.set(1);
        this.controller.init();
    }
    /** @inheritDoc */
    render() {
        const L6 = PageLinkField.createLink(this, '<LEGS', '/legs');
        const R6 = new DisplayField(this, {
            formatter: new SimpleStringFormat(this.getR6ButtonNameString()),
            onSelected: async () => {
                return false;
            }
        });
        return [
            [
                [this.renderTitleOnLeftSide ? this.pageHeaderDisplay : '', this.FplnPagingIndicator, this.renderTitleOnLeftSide ? '' : this.pageHeaderDisplay],
                [' ETA', 'WIND', this.getFuelWindHeaderString()],
                ...this.controller.renderPageRows(),
                [this.getBottomSeparatorLineString()],
                [L6, R6]
            ]
        ];
    }
    /** @inheritDoc */
    async onHandleScrolling(event) {
        const currentPage = this.controller.currentPage.get();
        const pageCount = this.controller.pageCount.get();
        switch (event) {
            case 'pageRight':
                if (currentPage === pageCount) {
                    this.controller.currentPage.set(1);
                }
                else {
                    this.controller.currentPage.set(currentPage + 1);
                }
                return true;
            case 'pageLeft':
                if (currentPage === 1) {
                    this.controller.currentPage.set(pageCount);
                }
                else {
                    this.controller.currentPage.set(currentPage - 1);
                }
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onPageButtonPressed() {
        this.controller.currentPage.set(1);
        this.invalidate();
    }
    /** @inheritdoc*/
    destroy() {
        var _a, _b;
        (_a = this.headerChangeSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.mapFormatChangeSub) === null || _b === void 0 ? void 0 : _b.destroy();
        this.controller.destroy();
        super.destroy();
    }
}

/** Route Page Leg Items */
class RoutePageLegItem {
    /**
     * A Route Page Item
     * @param globalIndex Leg Global Leg Index
     * @param segmentIndex Segment Index
     * @param segmentLegIndex Leg Index in Segment
     * @param lastRowWasDiscontinuity Whether the last row was a discontinuity
     * @param isPlanEnd Whether this is the plan end line
     * @param isFirstRow Whether this is the first row of the list on the page
     * @param isActive Where this is or contains the active leg
     * @param segmentType is the Segment Type for the segment containing this leg
     * @param legDefinition Leg Definition
     * @param title The title for this route page item (DIRECT, AirwayName, Proc Name)
     * @param automaticTermination Whether the line was automatically terminated
     */
    constructor(globalIndex, segmentIndex, segmentLegIndex, lastRowWasDiscontinuity, isPlanEnd, isFirstRow, isActive, segmentType, legDefinition, title, automaticTermination) {
        this.globalIndex = globalIndex;
        this.segmentIndex = segmentIndex;
        this.segmentLegIndex = segmentLegIndex;
        this.lastRowWasDiscontinuity = lastRowWasDiscontinuity;
        this.isPlanEnd = isPlanEnd;
        this.isFirstRow = isFirstRow;
        this.isActive = isActive;
        this.segmentType = segmentType;
        this.legDefinition = legDefinition;
        this.title = title;
        this.automaticTermination = automaticTermination;
    }
}
/**
 * RTE Page Store
 */
class BoeingRtePageStore {
    constructor() {
        this._legs = ArraySubject.create();
        this.legs = this._legs;
        this.origin = Subject.create(null);
        this.originRunway = Subject.create(null);
        this.destination = Subject.create(null);
        this.altn = Subject.create(null);
        this.distance = Subject.create(0);
    }
    /**
     * Sets the legs array.
     * @param legs The array of RoutePageLegItems
     */
    setLegs(legs) {
        this._legs.clear();
        this._legs.set(legs);
    }
    /**
     * Sets the legs array.
     * @param index The index to insert the leg at.
     * @param leg The RoutePageLegItem to insert
     */
    insertLegAt(index, leg) {
        this._legs.insert(leg, index);
    }
    /**
     * Removes an item from the leg array.
     * @param leg the RoutePageLegItem to remove
     * @returns whether anything was removed
     */
    removeLeg(leg) {
        return this._legs.removeItem(leg);
    }
}

/**
 * RTE Page Controller
 */
class BoeingRtePageController {
    /**
     * Creates the Controller.
     * @param discontinuityHeader The discontinuity line string.
     * @param eventBus The event bus.
     * @param fms The FMS.
     * @param store The store.
     * @param page The FMC Page.
     */
    constructor(discontinuityHeader, eventBus, fms, store, page) {
        this.discontinuityHeader = discontinuityHeader;
        this.eventBus = eventBus;
        this.fms = fms;
        this.store = store;
        this.page = page;
        this.currentPage = Subject.create(1);
        this.pageCount = ComputedSubject.create(0, (v) => {
            return Math.max(2, 1 + (Math.ceil(v / 5)));
        });
        this.legChangeConsumerFpln = this.eventBus.getSubscriber().on('fplLegChange');
        this.activeLegChangeConsumerFpln = this.eventBus.getSubscriber().on('fplActiveLegChange');
        this.originDestinationChangeConsumerFpln = this.eventBus.getSubscriber().on('fplOriginDestChanged');
        this.planCopiedConsumerFpln = this.eventBus.getSubscriber().on('fplCopied');
        this.planCalculatedConsumerFpln = this.eventBus.getSubscriber().on('fplCalculated');
        this.planUserDataSetConsumerFpln = this.eventBus.getSubscriber().on('fplUserDataSet');
        this.listConsumer = this.store.legs;
        this.planChanged = false;
        this.ppos = ConsumerSubject.create(this.eventBus.getSubscriber().on('gps-position'), new LatLongAlt());
        /**
         * Renders a row.
         * @param page The FmcPage
         * @param indexInDisplay The index in display
         * @param prevData The previous data item as RoutePageLegItem or undefined
         * @param data The Data as RoutePageLegItem or undefined
         * @returns an array of FmcRenderTemplateRows
         */
        this.renderRow = (page, indexInDisplay, prevData, data) => {
            var _a, _b, _c, _d, _e;
            if (data !== undefined) {
                const title = new DisplayField(this.page, {
                    formatter: {
                        nullValueString: '',
                        /** @inheritDoc */
                        format(value) {
                            return inputBox(value.padEnd(13, ' '));
                        }
                    },
                    onSelected: (scratchpadContents) => this.onAirwayInput(data, scratchpadContents, false),
                    onDelete: () => this.onAirwayInput(data, '', true),
                });
                const name = new DisplayField(this.page, {
                    formatter: {
                        nullValueString: '',
                        /** @inheritDoc */
                        format(value) {
                            return inputBox(value);
                        }
                    },
                    onSelected: (scratchpadContents) => this.onWaypointInput(data, scratchpadContents, false),
                    onDelete: () => this.onWaypointInput(data, '', true),
                });
                const header = new DisplayField(this.page, {
                    formatter: RawFormatter,
                });
                if (data.legDefinition) {
                    if (data.legDefinition.leg.type === LegType.Discontinuity) {
                        title.takeValue(BoeingRtePageController.emptyAirwayString);
                        name.takeValue(BoeingRtePageController.discoIdentString);
                    }
                    else {
                        title.takeValue((_a = data.title) !== null && _a !== void 0 ? _a : '');
                        name.takeValue(((_c = (_b = data.legDefinition.name) === null || _b === void 0 ? void 0 : _b.padStart(8, ' ')) !== null && _c !== void 0 ? _c : '') + (data.automaticTermination ? '[s-text]' : ''));
                    }
                }
                else if (data.isPlanEnd) {
                    title.takeValue(BoeingRtePageController.emptyAirwayString);
                    if (!prevData || !(prevData.globalIndex !== -1 && prevData.segmentIndex === -1)) {
                        name.takeValue(BoeingRtePageController.emptyIdentString);
                    }
                }
                else {
                    title.takeValue((_d = data.title) !== null && _d !== void 0 ? _d : '');
                    name.takeValue(((_e = data.title) === null || _e === void 0 ? void 0 : _e.padStart(8, ' ')) ? BoeingRtePageController.discoIdentString : '');
                }
                // title.getOptions().style = data.isActive ? '[magenta]' : '';
                // name.getOptions().style = data.isActive ? '[magenta]' : '';
                header.takeValue(data.lastRowWasDiscontinuity ? this.discontinuityHeader : '');
                if (data.globalIndex !== -1 && data.segmentIndex === -1) {
                    return [['                   THEN[s-text]', '', header], [title, name]];
                }
                else if (data.isFirstRow) {
                    return [[' VIA[s-text]', 'TO[s-text]', header], [title, name]];
                }
                else {
                    return [[header], [title, name]];
                }
            }
            return [[''], ['']];
        };
        this.rteLegList = new FmcListUtility(this.page, this.store.legs, this.renderRow, 5, 0);
        this.airwayInEditRow = -1;
        /**
         * Handles when the OriginDestination Event is received over the bus
         * @param event is the FlightPlanOriginDestEvent
         */
        this.handleFlightPlanChangeEvent = (event) => {
            if (event.planIndex === this.fms.getPlanIndexForFmcPage()) {
                this.planChanged = true;
            }
        };
        this.handleFlightPlanCopiedEvent = (event) => {
            if (event.targetPlanIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX && this.airwayInEdit && this.airwayEntryLeg) {
                return;
            }
            this.planChanged = true;
        };
        this.handleFlightPlanCalculated = (event) => {
            if (event.planIndex === this.fms.getPlanIndexForFmcPage() && this.planChanged) {
                this.getData();
            }
        };
        this.handleFlightPlanUserDataSet = async (event) => {
            if (event.planIndex === this.fms.getPlanIndexForFmcPage() && event.key === BoeingFms.USER_DATA_KEY_ALTN) {
                if (event.data && ICAO.isFacility(event.data)) {
                    const facility = await this.fms.facLoader.getFacility(FacilityType.Airport, event.data);
                    this.store.altn.set(facility);
                }
                else {
                    this.store.altn.set(null);
                }
            }
        };
        this.handleCurrentPageChange = () => {
            this.invalidate();
        };
        this.handleOnListUpdate = () => {
            this.invalidate();
        };
        this.onAirwayInput = (data, scratchpadContents, isDelete) => {
            if (data !== undefined && isDelete) {
                return this.deleteAirway(data);
            }
            else if (data !== undefined && scratchpadContents) {
                return this.takeAirwayEntry(data, scratchpadContents);
            }
            return Promise.reject(BoeingFmcErrorKeys.InvalidEntryRouteAirway);
        };
        this.page.addBinding(this.legChangeConsumerFpln.handle(this.handleFlightPlanChangeEvent));
        this.page.addBinding(this.activeLegChangeConsumerFpln.handle(this.handleFlightPlanChangeEvent));
        this.page.addBinding(this.originDestinationChangeConsumerFpln.handle(this.handleFlightPlanChangeEvent));
        this.page.addBinding(this.planCopiedConsumerFpln.handle(this.handleFlightPlanCopiedEvent));
        this.page.addBinding(this.planCalculatedConsumerFpln.handle(this.handleFlightPlanCalculated));
        this.page.addBinding(this.planUserDataSetConsumerFpln.handle(this.handleFlightPlanUserDataSet));
        this.page.addBinding(this.currentPage.sub(this.handleCurrentPageChange));
        this.page.addBinding(this.listConsumer.sub(this.handleOnListUpdate));
    }
    /**
     * Initializes the Controller
     */
    init() {
        this.getData();
    }
    /**
     * Destroys the Controller.
     */
    destroy() {
        // noop
    }
    /**
     * Local invalidate method
     */
    invalidate() {
        this.page.invalidate();
    }
    /**
     * Method to get the flight plan data on initial open.
     */
    async getData() {
        var _a;
        if (this.fms.hasFlightPlan(this.fms.getPlanIndexForFmcPage())) {
            const plan = this.fms.getPlanForFmcRender();
            const originAirport = plan.originAirport
                ? await this.fms.facLoader.getFacility(FacilityType.Airport, plan.originAirport)
                : null;
            this.store.origin.set(originAirport);
            this.store.originRunway.set((_a = plan.procedureDetails.originRunway) !== null && _a !== void 0 ? _a : null);
            const destinationAirport = plan.destinationAirport
                ? await this.fms.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport)
                : null;
            this.store.destination.set(destinationAirport);
            const alternateAirport = plan.getUserData(BoeingFms.USER_DATA_KEY_ALTN)
                ? await this.fms.facLoader.getFacility(FacilityType.Airport, plan.getUserData(BoeingFms.USER_DATA_KEY_ALTN))
                : null;
            this.store.altn.set(alternateAirport);
            if (plan.originAirport && plan.destinationAirport) {
                const originFac = this.fms.facilityInfo.originFacility;
                const destFac = this.fms.facilityInfo.destinationFacility;
                if (originFac && destFac) {
                    this.calculateDistance(originFac, destFac);
                }
            }
            else {
                this.store.distance.set(0);
            }
        }
        this.airwayInEdit = undefined;
        this.airwayInEditRow = -1;
        this.airwayEntryLeg = undefined;
        this.planChanged = false;
        this.loadLegs();
    }
    /**
     * Calculates the distance between Origin and Destination and sets the distance in the store.
     * @param originFac The origin facility.
     * @param destFac The destination facility.
     */
    calculateDistance(originFac, destFac) {
        BoeingRtePageController.geoPointCache[1].set(originFac.lat, originFac.lon);
        const distance = UnitType.GA_RADIAN.convertTo(BoeingRtePageController.geoPointCache[1].distance(destFac.lat, destFac.lon), UnitType.NMILE);
        this.store.distance.set(distance);
    }
    /**
     * Method to populate the legs array with the flight plan legs.
     */
    loadLegs() {
        const plan = this.fms.getPlanForFmcRender();
        const legs = [];
        let lastLegWasDiscontinuity = false;
        const isFirstRow = () => {
            return legs.length === 0 || legs.length % 5 === 0;
        };
        const isDiscontinuity = () => {
            return lastLegWasDiscontinuity;
        };
        const activeLegIndex = plan.activeLateralLeg;
        const activeLeg = plan.tryGetLeg(activeLegIndex);
        if (activeLeg === null) {
            return;
        }
        const activeSegmentIndex = plan.getSegmentIndex(activeLegIndex);
        const activeSegment = plan.getSegment(activeSegmentIndex);
        for (let s = activeSegmentIndex; s < plan.segmentCount; s++) {
            const segment = plan.getSegment(s);
            const segmentType = segment.segmentType;
            let procedureAdded = false;
            const segmentIsAirway = segmentType === FlightPlanSegmentType.Enroute && segment.airway !== undefined;
            const startSegmentLegIndex = segmentIsAirway && segment.legs.length > 0 ? segment.legs.length - 1
                : s === activeSegmentIndex ? activeLegIndex - activeSegment.offset
                    : 0;
            for (let l = startSegmentLegIndex; l < segment.legs.length; l++) {
                const leg = segment.legs[l];
                if (segmentIsAirway) {
                    legs.push(new RoutePageLegItem(segment.offset + l, segment.segmentIndex, l, false, false, isFirstRow(), (activeLegIndex >= segment.offset && activeLegIndex < segment.offset + segment.legs.length), segmentType, leg, segment.airway));
                    lastLegWasDiscontinuity = false;
                    break;
                }
                if (!procedureAdded && BitFlags.isAny(leg.flags, BoeingExtraLegDefinitionFlags.ProcedureLeg)) {
                    let procedureEndIndex = -1;
                    for (let p = l + 1; p < segment.legs.length; p++) {
                        if (!segment.legs[p].flags || !BitFlags.isAny(segment.legs[p].flags, BoeingExtraLegDefinitionFlags.ProcedureLeg)) {
                            procedureEndIndex = p - 1;
                            break;
                        }
                        if (segmentType === FlightPlanSegmentType.Approach && BitFlags.isAny(segment.legs[p].leg.fixTypeFlags, FixTypeFlags.MAP)) {
                            procedureEndIndex = p;
                            break;
                        }
                    }
                    if (procedureEndIndex < 0) {
                        procedureEndIndex = segment.legs.length - 1;
                    }
                    while (segment.legs[procedureEndIndex].leg.type === LegType.Discontinuity) {
                        procedureEndIndex--;
                    }
                    const procedureIndexes = BoeingFmsUtils.getProcedureIndexAndTransitionIndexFromSegmentType(segmentType, plan);
                    if (!isDiscontinuity() && segmentType !== FlightPlanSegmentType.Departure) {
                        legs.push(new RoutePageLegItem(segment.offset + l, segment.segmentIndex, l, false, false, isFirstRow(), (segment.offset + l === activeLegIndex), segmentType, leg, 'DIRECT'));
                        lastLegWasDiscontinuity = false;
                    }
                    legs.push(new RoutePageLegItem(segment.offset + procedureEndIndex, segment.segmentIndex, procedureEndIndex, isDiscontinuity(), false, isFirstRow(), (activeLegIndex >= segment.offset + l && activeLegIndex <= segment.offset + procedureEndIndex), segmentType, segment.legs[procedureEndIndex], BoeingFmsUtils.getProcedureNameAsString(segmentType, segmentType === FlightPlanSegmentType.Departure ? this.fms.facilityInfo.originFacility : this.fms.facilityInfo.destinationFacility, procedureIndexes[0], procedureIndexes[1])));
                    procedureAdded = true;
                    lastLegWasDiscontinuity = false;
                    if (segmentType === FlightPlanSegmentType.Approach && procedureAdded) {
                        for (let m = procedureEndIndex + 1; m < segment.legs.length; m++) {
                            if (BitFlags.isAll(segment.legs[m].leg.fixTypeFlags, FixTypeFlags.MAHP)) {
                                procedureEndIndex = m;
                                const nextLeg = segment.legs[procedureEndIndex + 1];
                                if (nextLeg !== undefined && nextLeg.leg.fixIcao === segment.legs[m].leg.fixIcao) {
                                    procedureEndIndex++;
                                }
                                legs.push(new RoutePageLegItem(segment.offset + procedureEndIndex, segment.segmentIndex, procedureEndIndex, isDiscontinuity(), false, isFirstRow(), (activeLegIndex >= segment.offset + l && activeLegIndex <= segment.offset + procedureEndIndex), segmentType, segment.legs[procedureEndIndex], 'MISSED APPR'));
                                lastLegWasDiscontinuity = false;
                                break;
                            }
                        }
                    }
                    if (procedureEndIndex >= segment.legs.length - 1) {
                        break;
                    }
                    else {
                        l = procedureEndIndex;
                        continue;
                    }
                }
                else {
                    // filter out origin or rwy
                    if (segmentType === FlightPlanSegmentType.Departure && l === 0) {
                        continue;
                    }
                    legs.push(new RoutePageLegItem(segment.offset + l, segment.segmentIndex, l, isDiscontinuity(), false, isFirstRow(), (segment.offset + l === activeLegIndex), segmentType, leg, 'DIRECT'));
                    lastLegWasDiscontinuity = leg.leg.type === LegType.Discontinuity;
                }
            }
        }
        if (legs.length > 0) {
            legs[legs.length - 1].isPlanEnd = true;
        }
        legs.push(new RoutePageLegItem(-1, -1, -1, false, true, legs.length % 5 === 0, false));
        this.pageCount.set(legs.length);
        this.store.setLegs(legs);
        this.invalidate();
    }
    /**
     * Takes a waypoint.
     * @param data The RoutePageLegItem.
     * @param scratchpadContents The Scratchpad Contents.
     * @param isDelete Whether this is a delete.
     * @returns Whether this entry was successfully completed.
     */
    onWaypointInput(data, scratchpadContents, isDelete) {
        if (data !== undefined && isDelete) {
            return this.deleteLeg(data);
        }
        else if (data !== undefined && scratchpadContents) {
            return this.takeLegEntry(data, scratchpadContents);
        }
        else if (data === undefined && scratchpadContents) {
            const emptyItem = new RoutePageLegItem(-1, -1, -1, false, false, false, false, undefined, undefined, undefined);
            return this.takeLegEntry(emptyItem, scratchpadContents);
        }
        return Promise.reject(BoeingFmcErrorKeys.InvalidEntryRouteTermination);
    }
    /**
     * Takes an airway.
     * @param displayItem The Selected Display Item
     * @param scratchpadContents The Scratchpad Contents
     * @returns Whether this leg entry was successful
     */
    async takeAirwayEntry(displayItem, scratchpadContents) {
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        let legsArray = this.store.legs.getArray();
        const displayItemIndex = legsArray.indexOf(displayItem);
        let prevEntry = this.store.legs.tryGet(displayItemIndex - 1);
        let insertIndex = displayItemIndex;
        if (prevEntry) {
            const plan = this.fms.getPlanForFmcRender();
            if (prevEntry.segmentIndex === -1) {
                const prevPrevEntry = this.store.legs.tryGet(displayItemIndex - 2);
                if (prevPrevEntry && prevEntry.title) {
                    const prevPrevEntryLeg = plan.getLeg(prevPrevEntry.globalIndex);
                    const airwayA = await BoeingFmsUtils.isAirwayAtLeg(this.fms.facLoader, prevPrevEntryLeg.leg.fixIcao, prevEntry.title);
                    if (airwayA) {
                        const result = await BoeingFmsUtils.findAirwayCrossingAirway(this.fms.facLoader, airwayA, scratchpadContents);
                        if (result) {
                            const [, crossingIcao] = result;
                            await this.takeLegEntry(prevEntry, ICAO.getIdent(crossingIcao));
                            // Reset variables to reflect new data after entering exit leg
                            // We re-use displayItemIndex here, since we are editing the same item
                            legsArray = this.store.legs.getArray();
                            prevEntry = this.store.legs.tryGet(displayItemIndex - 1);
                            insertIndex = displayItemIndex;
                            if (!prevEntry) {
                                throw new Error('Cannot find previous entry after automatic leg entry');
                            }
                            prevEntry.automaticTermination = true;
                        }
                    }
                }
            }
            const segment = plan.getSegment(prevEntry.segmentIndex);
            if (segment.segmentType === FlightPlanSegmentType.Enroute || segment.segmentType === FlightPlanSegmentType.Departure) {
                const prevEntryLeg = plan.getLeg(prevEntry.globalIndex);
                const airwayInEdit = await BoeingFmsUtils.isAirwayAtLeg(this.fms.facLoader, prevEntryLeg.leg.fixIcao, scratchpadContents);
                if (airwayInEdit) {
                    this.airwayInEdit = airwayInEdit;
                    this.airwayInEditRow = insertIndex;
                    this.airwayEntryLeg = prevEntryLeg;
                    this.store.insertLegAt(this.airwayInEditRow, new RoutePageLegItem(prevEntry.globalIndex + 1, -1, -1, false, false, false, false, undefined, undefined, scratchpadContents));
                    for (let l = 0; l < legsArray.length; l++) {
                        legsArray[l].isFirstRow = l === 0 || l % 5 === 0;
                    }
                    if (!this.fms.planInMod.get()) {
                        this.fms.getPlanToModify();
                    }
                    this.pageCount.set(this.store.legs.length);
                    this.invalidate();
                    return Promise.resolve(true);
                }
                else {
                    return Promise.reject('AIRWAY NOT FOUND');
                }
            }
        }
        return Promise.reject('INVALID AIRWAY LOCATION');
    }
    /**
     * Takes a leg entry.
     * @param displayItem The Selected Display Item
     * @param scratchpadContents The Scratchpad Contents
     * @returns Whether this leg entry was successful
     */
    async takeLegEntry(displayItem, scratchpadContents) {
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        const legsArray = this.store.legs.getArray();
        if (this.airwayInEdit && this.airwayEntryLeg) {
            // case where we're entering an airway exit
            if (this.airwayInEditRow === legsArray.indexOf(displayItem)) {
                const exitFacility = BoeingFmsUtils.matchIdentToAirway(this.airwayInEdit, scratchpadContents);
                if (exitFacility) {
                    const entryFacility = await this.fms.facLoader.getFacility(FacilityType.Intersection, this.airwayEntryLeg.leg.fixIcao);
                    const airwayEntryLeg = this.store.legs.tryGet(legsArray.indexOf(displayItem) - 1);
                    if (airwayEntryLeg && entryFacility) {
                        this.fms.insertAirwaySegment(this.airwayInEdit, entryFacility, exitFacility, airwayEntryLeg.segmentIndex, airwayEntryLeg.segmentLegIndex);
                        this.airwayInEdit = undefined;
                        this.airwayInEditRow = -1;
                        this.airwayEntryLeg = undefined;
                        await this.getData();
                        return Promise.resolve(true);
                    }
                }
                return Promise.reject('INVALID AIRWAY EXIT');
            }
            else {
                return Promise.reject('INVALID LINE SELECTED');
            }
        }
        else {
            // DCT case
            let pos;
            let plan = this.fms.getPlanForFmcRender();
            const prevLegIndex = (displayItem.globalIndex >= 0 ? displayItem.globalIndex : plan.length) - 1;
            if (prevLegIndex >= 0 && prevLegIndex < plan.length) {
                const prevLeg = plan.getLeg(prevLegIndex);
                pos = prevLeg.calculated ? FlightPathUtils.getLegFinalPosition(prevLeg.calculated, BoeingRtePageController.geoPointCache[0]) : undefined;
                if (!pos) {
                    switch (prevLeg.leg.type) {
                        case LegType.IF:
                        case LegType.TF:
                        case LegType.DF:
                        case LegType.CF:
                        case LegType.AF:
                        case LegType.RF:
                        case LegType.HF:
                        case LegType.HM:
                        case LegType.HA: {
                            const facility = await this.fms.facLoader.getFacility(ICAO.getFacilityType(prevLeg.leg.fixIcao), prevLeg.leg.fixIcao);
                            pos = BoeingRtePageController.geoPointCache[0].set(facility);
                        }
                    }
                }
            }
            if (!pos) {
                const ppos = this.ppos.get();
                pos = BoeingRtePageController.geoPointCache[0].set(ppos.lat, ppos.long);
            }
            let selectedFacility = await this.page.screen.selectWaypointByIdent(scratchpadContents, pos);
            // TODO: Pilot-defined waypoints
            if (!selectedFacility) {
                const result = await BoeingPilotWaypointUtils.createFromScratchpadEntry(this.fms, (ident, refPos) => this.page.screen.selectWaypointByIdent(ident, refPos), scratchpadContents);
                if (result) {
                    const [userFacility] = result;
                    this.fms.addUserFacility(userFacility);
                    selectedFacility = userFacility;
                }
            }
            if (selectedFacility !== null && displayItem) {
                this.fms.getPlanToModify();
                plan = this.fms.getPlanForFmcRender();
                let segmentIndex = displayItem.segmentIndex > -1 ? displayItem.segmentIndex : undefined;
                let segmentLegIndex = displayItem.segmentLegIndex > -1 ? displayItem.segmentLegIndex : undefined;
                if (segmentIndex !== undefined) {
                    const segment = plan.getSegment(segmentIndex);
                    if (segment.segmentType === FlightPlanSegmentType.Departure) {
                        // If we have a departure segment, we have to insert our waypoint into a non-airway enroute segment immediately
                        // after the departure
                        let enrouteSegment = Array.from(plan.segmentsOfType(FlightPlanSegmentType.Enroute))[0];
                        if (!enrouteSegment || enrouteSegment.airway) {
                            enrouteSegment = plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                        }
                        segmentIndex = enrouteSegment === null || enrouteSegment === void 0 ? void 0 : enrouteSegment.segmentIndex;
                        segmentLegIndex = 0;
                    }
                }
                this.fms.insertWaypoint(selectedFacility, segmentIndex, segmentLegIndex);
                return Promise.resolve(true);
            }
            return Promise.reject('FACILITY NOT FOUND');
        }
    }
    /**
     * Deletes a selected airway segment.
     * @param displayItem The Selected Display Item
     * @returns Whether this airway removal was successful
     */
    async deleteAirway(displayItem) {
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        if (displayItem) {
            if (displayItem.segmentIndex >= 0) {
                const segment = this.fms.getPlanForFmcRender().getSegment(displayItem.segmentIndex);
                if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway) {
                    this.fms.removeAirway(displayItem.segmentIndex);
                    return Promise.resolve(true);
                }
                else {
                    return await this.deleteLeg(displayItem);
                }
            }
            else if (displayItem.globalIndex >= 0) {
                // If no valid segment index but a valid leg index, this is a pending airway entry - delete only from store
                return this.store.removeLeg(displayItem);
            }
        }
        return Promise.reject('INVALID DELETE');
    }
    /**
     * Deletes a selected leg.
     * @param displayItem The Selected Display Item
     * @returns Whether this leg removal was successful
     */
    async deleteLeg(displayItem) {
        var _a;
        if (!this.fms.canEditPlan()) {
            return Promise.reject('XSIDE EDIT IN PROGRESS');
        }
        if (displayItem) {
            const segment = this.fms.getPlanForFmcRender().getSegment(displayItem.segmentIndex);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.airway) {
                this.fms.removeAirway(displayItem.segmentIndex);
                return Promise.resolve(true);
            }
            else if (segment.segmentType === FlightPlanSegmentType.Enroute || ((_a = displayItem.legDefinition) === null || _a === void 0 ? void 0 : _a.leg.type) === LegType.Discontinuity) {
                if (this.fms.removeWaypoint(segment.segmentIndex, displayItem.segmentLegIndex)) {
                    return Promise.resolve(true);
                }
            }
        }
        return Promise.reject('INVALID DELETE');
    }
    /**
     * Handles when ERASE is pressed
     */
    handleCancelMod() {
        this.fms.cancelMod();
        this.getData();
        this.invalidate();
    }
}
BoeingRtePageController.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0)];
//public static readonly discontinuityHeader = '------------ DISCONTINUITY -----------';
BoeingRtePageController.discoIdentString = '   □□□□□';
BoeingRtePageController.emptyAirwayString = '-----';
BoeingRtePageController.emptyIdentString = '   -----';
BoeingRtePageController.activeHeaderString = ' ACT FPLN[blue]';
BoeingRtePageController.modHeaderString = ' MOD[white] FPLN[blue]';

/** Format for entering airport facilities */
class AirportFormat {
    /**
     * Ctor
     * @param page the FMC page
     * @param side the side of the page the screen is on
     */
    constructor(page, side) {
        this.page = page;
        this.side = side;
        this.nullValueString = inputBox('□□□□');
    }
    /** @inheritDoc */
    format(value) {
        const ident = ICAO.getIdent(value.icao);
        return inputBox(this.side === 'left' ? ident.padEnd(4, ' ') : ident.padStart(4, ' '));
    }
    /** @inheritDoc */
    async parse(input) {
        const facility = await this.page.screen.selectWaypointByIdent(input, this.page.fms.ppos, FacilitySearchType.Airport);
        if (!facility) {
            return Promise.reject(BoeingFmcErrorKeys.NotInDataBase);
        }
        return facility;
    }
}
/** Format for entering origin runway. */
class RunwayFormat {
    /**
     * Ctor
     * @param fms The BoeingFms.
     */
    constructor(fms) {
        this.fms = fms;
        this.nullValueString = inputBox('-----');
    }
    /** @inheritDoc */
    format(value) {
        return inputBox(`RW${value.designation}`);
    }
    /** @inheritDoc */
    async parse(input) {
        return B787FmcParsers.Runway(this.fms.getPlanForFmcRender(), this.fms.facLoader, true)(input);
    }
}
/** The Boeing RTE page. */
class BoeingRtePage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.lNavDataSub = this.bus.getSubscriber();
        this.store = new BoeingRtePageStore();
        this.controller = new BoeingRtePageController(this.getDiscontinuityLineString(), this.bus, this.fms, this.store, this);
        this.isRunwayDisabled = Subject.create(false);
        this.CoRouteSub = Subject.create(null);
        this.AltnLink = PageLinkField.createLink(this, 'ALTN>', '/altn');
        this.ActivateField = new DisplayField(this, {
            formatter: new SimpleStringFormat('ACTIVATE>'),
            onSelected: async () => {
                this.fms.activate(1);
                return true;
            },
        });
        this.PerfInitLink = PageLinkField.createLink(this, 'PERF INIT>', '/perf-init');
        this.TakeoffRefLink = PageLinkField.createLink(this, 'TAKEOFF>', '/takeoff-ref');
        this.FplnPaging = MappedSubject.create(([routerSubpageIndex, currentPage, pageCount]) => {
            if (routerSubpageIndex === 1) {
                return [1, pageCount];
            }
            else {
                return [currentPage, pageCount];
            }
        }, this.screen.currentSubpageIndex, this.controller.currentPage, this.controller.pageCount);
        this.RtePagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        });
        this.EraseDisplay = new DisplayField(this, {
            formatter: new SimpleStringFormat('<ERASE'),
            onSelected: async () => {
                this.controller.handleCancelMod();
                return true;
            },
        });
        this.Rte2Display = new DisplayField(this, {
            formatter: new SimpleStringFormat('<RTE 2[disabled]'),
        });
        this.TitleDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format: ([routeActivated, planInMod]) => {
                    if (planInMod) {
                        return this.getPlanInModPageTitle();
                    }
                    else {
                        return routeActivated ? this.getRteActivatedPageTitle() : this.getRteInactivatedPageTitle();
                    }
                },
            },
        }).bind(MappedSubject.create(this.fms.routeActivated(1), this.fms.planInMod));
        this.OriginInput = new TextInputField(this, {
            formatter: new AirportFormat(this, 'left'),
            onModified: async (newValue) => {
                this.fms.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                if (this.fms.isRouteActivated(1)) {
                    this.fms.planInMod.set(true);
                    const modPlan = this.fms.getPlanToModify();
                    modPlan.setUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN, true);
                }
                this.fms.setOrigin(newValue);
                return false;
            },
            onDelete: async () => {
                this.fms.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                if (!this.fms.isRouteActivated(1)) {
                    this.fms.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX);
                }
                else {
                    this.fms.planInMod.set(true);
                    const modPlan = this.fms.getPlanToModify();
                    modPlan.setUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN, true);
                }
                this.store.origin.set(null);
                this.store.destination.set(null);
                return true;
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.length > 0) {
                    return false;
                }
                const origin = this.store.origin.get();
                if (!origin) {
                    return false;
                }
                return ICAO.getIdent(origin.icao);
            }
        }).bind(this.store.origin);
        this.DestInput = new TextInputField(this, {
            formatter: new AirportFormat(this, 'right'),
            onModified: async (newValue) => {
                this.fms.setDestination(newValue);
                return false;
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.length > 0) {
                    return false;
                }
                const destination = this.store.destination.get();
                if (!destination) {
                    return false;
                }
                return ICAO.getIdent(destination.icao);
            }
        }).bind(this.store.destination);
        this.RunwayInput = new TextInputField(this, {
            formatter: new RunwayFormat(this.fms),
            onModified: async (newValue) => {
                this.fms.getPlanToModify(1).setOriginRunway(newValue);
                return false;
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents.length > 0) {
                    return false;
                }
                const originRunway = this.store.originRunway.get();
                if (!originRunway) {
                    return false;
                }
                return `RW${originRunway.designation}`;
            }
        }).bind(this.store.originRunway);
        this.FltNoInput = BoeingFmcComponentFactory.createFlightNumberTextInputField(this, this.getFlightNumberMinLength(), this.getFlightNumberMaxLength(), CockpitUserSettings.getManager(this.bus).getSetting('fltNumber'), this.useInputBox()).bind(CockpitUserSettings.getManager(this.bus).getSetting('fltNumber'));
        this.CoRouteInput = new TextInputField(this, {
            formatter: {
                nullValueString: this.getCorouteFieldPlaceholderContent(),
                /** @inheritDoc */
                format(value) {
                    return value;
                },
                /** @inheritDoc */
                parse(input) {
                    return input;
                }
            },
            disabled: this.getIsCorouteFieldDisabled(),
        }).bind(this.CoRouteSub);
    }
    /** @inheritDoc */
    init() {
        super.init();
        this.addBinding(this.isRunwayDisabled.sub(() => this.invalidate()));
        this.addBinding(this.store.origin.sub(() => this.invalidate()));
        this.addBinding(this.fms.routeActivated(1).sub(() => this.invalidate()));
        this.addBinding(this.fms.planInMod.sub(() => this.invalidate()));
        this.addBinding(this.fms.perfIsInitialized.sub(() => this.invalidate()));
        this.lNavDataSub.on('lnavdata_nominal_leg_index').whenChanged().handle((v) => {
            if (v > 1) {
                this.isRunwayDisabled.set(true);
            }
        });
        // Paging
        this.RtePagingIndicator.bind(this.FplnPaging);
    }
    /** @inheritDoc */
    onPause() {
        this.controller.destroy();
    }
    /** @inheritDoc */
    onResume() {
        this.controller.init();
    }
    /**
     * Renders the Main Page
     * @returns the Render Template
     */
    renderMainPage() {
        const showRunwayField = !this.isRunwayDisabled.get() && Boolean(this.store.origin.get());
        const L6 = this.fms.planInMod.get() ? this.EraseDisplay : this.Rte2Display;
        let R6;
        if (!this.fms.isRouteActivated(1) && !this.fms.planInMod.get()) {
            R6 = this.ActivateField;
        }
        else {
            R6 = this.fms.perfIsInitialized.get() ? this.TakeoffRefLink : this.PerfInitLink;
        }
        const titleRow = this.getRenderPageTitleRowWith2Columns()
            ? [this.TitleDisplay, this.RtePagingIndicator]
            : ['', this.RtePagingIndicator, this.TitleDisplay];
        return [
            titleRow,
            [' ORIGIN', 'DEST'],
            [this.OriginInput, this.DestInput],
            [' RUNWAY', 'FLT NO'],
            [showRunwayField ? this.RunwayInput : '', this.FltNoInput],
            [' ROUTE[disabled]', this.getCorouteFieldTitle()],
            ['<REQUEST[disabled]', this.CoRouteInput],
            [''],
            [''],
            [this.getSeparatorLineString()],
            ['', this.AltnLink],
            [''],
            [L6, R6],
        ];
    }
    /**
     * Renders the Route Pages
     * @returns the Render Template
     */
    renderRoutePage() {
        const template = [
            ['', this.RtePagingIndicator, this.TitleDisplay]
        ];
        this.controller.rteLegList.renderList(this.controller.currentPage.get()).forEach(row => template.push(row));
        let L6;
        if (this.fms.planInMod.get()) {
            L6 = this.EraseDisplay;
        }
        else {
            L6 = this.Rte2Display;
        }
        let R6;
        if (!this.fms.isRouteActivated(1)) {
            R6 = this.ActivateField;
        }
        else {
            R6 = this.fms.perfIsInitialized.get() ? '' : this.PerfInitLink;
        }
        template.push([this.getSeparatorLineString()]);
        template.push([L6, R6]);
        return template;
    }
    /** @inheritDoc */
    render() {
        return [
            this.renderMainPage(),
            this.renderRoutePage(),
        ];
    }
    // Special handling for RTE page
    /** @inheritDoc */
    handleScrolling(event) {
        // The currentSubpageIndex is 1 when on the main page, and 2 when on any of the other "fixes" pages
        const routerPageIndex = this.screen.currentSubpageIndex.get();
        if (routerPageIndex === 1) {
            if (this.controller.pageCount.get() > 1) {
                if (event === 'pageRight') {
                    this.screen.currentSubpageIndex.set(2);
                    this.controller.currentPage.set(2);
                }
                else {
                    this.screen.currentSubpageIndex.set(2);
                    this.controller.currentPage.set(this.controller.pageCount.get());
                }
            }
        }
        else {
            if (event === 'pageRight') {
                if (this.controller.currentPage.get() === this.controller.pageCount.get()) {
                    this.screen.currentSubpageIndex.set(1);
                    this.controller.currentPage.set(1);
                }
                else {
                    this.controller.currentPage.set(this.controller.currentPage.get() + 1);
                }
            }
            else {
                if (this.controller.currentPage.get() === 2) {
                    this.screen.currentSubpageIndex.set(1);
                    this.controller.currentPage.set(1);
                }
                else {
                    this.controller.currentPage.set(this.controller.currentPage.get() - 1);
                }
            }
        }
        return Promise.resolve(true);
    }
}

// It's not perfect, but good enough, if people know what a valid selcal code is then they can jsut put it in.
const selcalRegex = /^[A-Z]{2}-?[A-Z]{2}$/;
/** SETTINGS page */
class BoeingSettingsPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.boeingUserSettings = BoeingMsfsUserSettings.getManager(this.bus);
        this.NdUpModeSwitchField = new SwitchLabel(this, {
            optionStrings: ['HDG', 'TRK'],
            caret: 'left',
            separator: 'arrows',
        }).bind(this.boeingUserSettings.getSetting('boeingMsfsNdHdgTrkUpMode'));
        this.irsAlignTimeField = new SwitchLabel(this, {
            optionStrings: ['INSTANT', 'ACCEL', 'REAL'],
            caret: 'left',
            separator: 'slash',
        }).bind(this.boeingUserSettings.getSetting('boeingMsfsIrsAlignTime'));
        this.selcalInput = new TextInputField(this, {
            formatter: {
                format: value => inputBox(value),
                parse: input => {
                    if (!selcalRegex.test(input)) {
                        return null;
                    }
                    if (input.length === 4) {
                        return input[0] + input[1] + '-' + input[2] + input[3];
                    }
                    return input;
                },
                nullValueString: '-----',
            },
        }).bind(this.boeingUserSettings.getSetting('boeingMsfsSelcal'));
    }
    /**
     * Whether to use the selcal field.
     * @returns Whether to use the selcal field.
     */
    useSelCalField() {
        return false;
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'SETTINGS'],
                ['ND UP MODE', ''],
                [this.NdUpModeSwitchField, '', ''],
                ['IRS ALIGN TIME', ''],
                [this.irsAlignTimeField, '', ''],
                [this.useSelCalField() ? 'SELCAL' : '', ''],
                [this.useSelCalField() ? this.selcalInput : '', ''],
                ['', ''],
                ['', ''],
                ['', ''],
                ['', ''],
                ['', ''],
                ['', ''],
            ]
        ];
    }
}

var RefSpeedsStatus;
(function (RefSpeedsStatus) {
    RefSpeedsStatus[RefSpeedsStatus["OFF"] = 0] = "OFF";
    RefSpeedsStatus[RefSpeedsStatus["ON"] = 1] = "ON";
})(RefSpeedsStatus || (RefSpeedsStatus = {}));
/** A Boeing TAKEOFF REF page. */
class BoeingTakeoffRefPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, props) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.props = props;
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.line6PageLink = PageLinkField.createLink(this, 'THRUST LIM>', '/thrust-lim');
        this.line6Header = [''];
        this.blankVSpeedFields = Subject.create(false);
        this.perfPlan = this.fms.performancePlanProxy;
        this.perfProv = this.fms.perfProvider;
        this.blankVSpeedsTimer = new DebounceTimer();
        this.vSpeedSettings = VSpeedUserSettings.getManager(this.bus);
        this.v1UserSetting = this.vSpeedSettings.getSettings(VSpeedType.V1).value;
        this.vRUserSetting = this.vSpeedSettings.getSettings(VSpeedType.Vr).value;
        this.v2UserSetting = this.vSpeedSettings.getSettings(VSpeedType.V2).value;
        this.sub = this.bus.getSubscriber();
        this.gameUnit = ConsumerSubject.create(this.sub.on('game_units_metric'), false);
        this.gameUnitSub = this.gameUnit.map((metric) => metric ? UnitType.KILOGRAM : UnitType.POUND);
        this.isOnGround = ConsumerSubject.create(this.bus.getSubscriber()
            .on('on_ground').whenChanged(), true);
        this.flightPhase = ConsumerSubject.create(this.sub.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.oat = ConsumerSubject.create(this.sub.on('ambient_temp_c').whenChangedBy(1), 0);
        this.posIsInitialized = ConsumerSubject.create(this.sub.on('all_irs_systems_operating'), true);
        this.stabTrim = ConsumerSubject.create(this.sub.on('calculated_stab_trim'), null);
        this.ReadonlyTakeoffFlapsDisplay = MappedSubject.create(([planTakeoffFlaps, pendingTakeoffDataUplink]) => {
            if (pendingTakeoffDataUplink) {
                return pendingTakeoffDataUplink.flapSetting;
            }
            else {
                return planTakeoffFlaps;
            }
        }, this.perfPlan.takeoffFlaps, this.fms.pendingTakeoffDataUplink);
        this.ReadonlyThrustDisplay = MappedSubject.create(([planTakeoffAssumedTemp, planTakeoffThrustMode, pendingTakeoffDataUplink]) => {
            if (pendingTakeoffDataUplink) {
                return [pendingTakeoffDataUplink.assumedTemperature, pendingTakeoffDataUplink.thrustRating];
            }
            else {
                return [planTakeoffAssumedTemp, planTakeoffThrustMode];
            }
        }, this.perfPlan.takeoffAssumedTemp, this.perfPlan.takeoffThrustMode, this.fms.pendingTakeoffDataUplink);
        this.ReadonlyV1Display = MappedSubject.create(([settingV1, pendingUplinkData]) => {
            var _a;
            return (_a = pendingUplinkData === null || pendingUplinkData === void 0 ? void 0 : pendingUplinkData.v1) !== null && _a !== void 0 ? _a : settingV1;
        }, this.vSpeedSettings.getSettings(VSpeedType.V1).value, this.fms.pendingTakeoffDataUplink);
        this.ReadonlyVRDisplay = MappedSubject.create(([settingV1, pendingUplinkData]) => {
            var _a;
            return (_a = pendingUplinkData === null || pendingUplinkData === void 0 ? void 0 : pendingUplinkData.vr) !== null && _a !== void 0 ? _a : settingV1;
        }, this.vSpeedSettings.getSettings(VSpeedType.Vr).value, this.fms.pendingTakeoffDataUplink);
        this.ReadonlyV2Display = MappedSubject.create(([settingV1, pendingUplinkData]) => {
            var _a;
            return (_a = pendingUplinkData === null || pendingUplinkData === void 0 ? void 0 : pendingUplinkData.v2) !== null && _a !== void 0 ? _a : settingV1;
        }, this.vSpeedSettings.getSettings(VSpeedType.V2).value, this.fms.pendingTakeoffDataUplink);
        this.refV1Speed = Subject.create(0);
        this.refVRSpeed = Subject.create(0);
        this.refV2Speed = Subject.create(0);
        this.refSpeedsFieldSwitchState = Subject.create(RefSpeedsStatus.ON);
        this.grossWeightLbs = MappedSubject.create(([zfw, fuelWeight]) => zfw !== null ? (zfw + fuelWeight) : null, this.perfPlan.manualZfw, ConsumerSubject.create(this.bus.getSubscriber()
            .on('fuel_total_weight').atFrequency(0.5), 0));
        this.displayGrossWeight = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.displayTakeoffGw = NumberUnitSubject.create(new NumberUnit(0, UnitType.POUND));
        this.takeoffRunwayProxy = MappedSubject.create(([originRwy, takeoffRwy]) => takeoffRwy !== null && takeoffRwy !== void 0 ? takeoffRwy : originRwy, this.perfPlan.originRunway, this.perfPlan.takeoffRunway);
        this.takeoffWeightProxy = MappedSubject.create(([gw, takeoffGw]) => takeoffGw !== null && takeoffGw !== void 0 ? takeoffGw : gw, this.grossWeightLbs, this.perfPlan.takeoffGw);
        this.vSpeedsCanBeComputed = MappedSubject.create(([weight, rwy, flaps]) => weight !== null && rwy !== null && flaps !== null, this.takeoffWeightProxy, this.takeoffRunwayProxy, this.perfPlan.takeoffFlaps);
        this.invalidateVSpeedsWhenChanges = MappedSubject.create(this.perfPlan.manualZfw, this.perfPlan.takeoffAssumedTemp, this.perfPlan.takeoffThrustMode, this.perfPlan.takeoffFlaps, this.perfPlan.originRunway, this.perfPlan.takeoffRunway, this.perfPlan.takeoffRunwayPositionShift, this.perfPlan.takeoffGw, this.perfPlan.takeoffWind, // 787 only?
        this.perfPlan.takeoffRunwayWind, // 787 only?
        this.perfPlan.takeoffRunwaySlope, this.perfPlan.takeoffRunwayCondition, this.perfPlan.takeoffTemp);
        this.TitleField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (value) => {
                    return `TAKEOFF REF${value ? ' UPLINK' : ''}${this.props.titleRightPadding ? '  ' : ''}`;
                }
            }
        }).bind(this.fms.pendingTakeoffDataUplink.map((it) => !!it));
        /** Page 1 */
        this.TakeoffFlapsField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.LimitedChoice(this.props.takeoffFlapSettings),
                nullValueString: inputBox('□□'),
                format: (value) => inputBox(value.toString().padStart(2, ' ')),
            }),
        }).bind(this.perfPlan.takeoffFlaps);
        this.ReadonlyTakeoffFlapsField = new DisplayField(this, {
            formatter: {
                nullValueString: '□□[s-text]',
                format: (value) => value.toString().padStart(2, ' ') + '[s-text]',
            },
        }).bind(this.ReadonlyTakeoffFlapsDisplay);
        this.ThrustField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AssumedTemp,
                format: this.props.thrustFieldFormatter(false),
            }),
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.takeoffAssumedTemp, this.perfPlan.takeoffThrustMode), (value) => this.perfPlan.takeoffAssumedTemp.set(value)));
        this.ReadonlyThrustField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: this.props.thrustFieldFormatter(true),
            },
            style: '[s-text]',
        }).bind(this.ReadonlyThrustDisplay);
        this.CgField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.IntegerRangePositive(2, 1, this.perfProv.maxCenterOfGravity, this.perfProv.minCenterOfGravity),
                nullValueString: '',
                format: this.props.cgFieldFormatter(false),
            },
            onDelete: async () => {
                this.perfPlan.takeoffCg.set(null);
                return true;
            },
            onSelected: async (scratchpadContents) => (this.perfPlan.takeoffCg.get() === null && !scratchpadContents) ?
                // If no takeoff CG is set and the scratchpad is blank, populate the scratchpad from the simvar...
                Math.floor(SimVar.GetSimVarValue('CG PERCENT', SimVarValueType.Percent)).toFixed(0)
                // ...otherwise pass the scratchpad value through to the parser
                : false,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.takeoffCg, this.stabTrim), (value) => this.perfPlan.takeoffCg.set(value)));
        this.ReadonlyCgField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: this.props.cgFieldFormatter(true),
            },
            style: '[s-text]',
        }).bind(MappedSubject.create(this.perfPlan.takeoffCg, this.stabTrim));
        this.RunwayPosField = new TextInputField(this, {
            formatter: {
                // Don't use a function reference below or else the parser won't be passed the current plan
                parse: (input) => B787FmcParsers.RunwayPositionShift('left', this.fms.getPlanForFmcRender(), this.fms.facLoader)(input),
                nullValueString: '---/----',
                format: B787FmcFormatters.RunwayPositionShift('input', 'large'),
            },
            onModified: async ([rwy, pos]) => {
                if (rwy) {
                    this.perfPlan.takeoffRunway.set(rwy);
                }
                if (pos !== null) {
                    if (this.takeoffRunwayProxy.get()) {
                        this.perfPlan.takeoffRunwayPositionShift.set(pos);
                    }
                    else {
                        // A position alone can't be accepted if there's no runway yet
                        return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                    }
                }
                return true;
            },
            onDelete: async () => {
                if (this.perfPlan.takeoffRunway.get() !== null || this.perfPlan.takeoffRunwayPositionShift.get() !== null) {
                    this.perfPlan.takeoffRunway.set(null);
                    this.perfPlan.takeoffRunwayPositionShift.set(null);
                    return true;
                }
                else {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
            }
        }).bind(MappedSubject.create(this.perfPlan.originRunway, this.perfPlan.takeoffRunway, this.perfPlan.takeoffRunwayPositionShift));
        this.ReadonlyRunwayPosField = new DisplayField(this, {
            formatter: {
                nullValueString: '---/----[s-text]',
                format: B787FmcFormatters.RunwayPositionShift('display', 'small'),
            },
            style: '[s-text]',
        }).bind(MappedSubject.create(this.perfPlan.originRunway, this.perfPlan.takeoffRunway, this.perfPlan.takeoffRunwayPositionShift));
        this.V1Field = this.props.showRefSpeeds ?
            this.refAndVSpeedFieldFactory(this.v1UserSetting, this.refV1Speed) :
            this.vSpeedFieldFactory(VSpeedType.V1);
        this.ReadonlyV1Field = this.readonlyVSpeedFieldFactory(this.ReadonlyV1Display);
        this.VrField = this.props.showRefSpeeds ?
            this.refAndVSpeedFieldFactory(this.vRUserSetting, this.refVRSpeed) :
            this.vSpeedFieldFactory(VSpeedType.Vr);
        this.ReadonlyVrField = this.readonlyVSpeedFieldFactory(this.ReadonlyVRDisplay);
        this.V2Field = this.props.showRefSpeeds ?
            this.refAndVSpeedFieldFactory(this.v2UserSetting, this.refV2Speed) :
            this.vSpeedFieldFactory(VSpeedType.V2);
        this.ReadonlyV2Field = this.readonlyVSpeedFieldFactory(this.ReadonlyV2Display);
        this.TakeoffGrossWeightField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.Weight,
                format: B787FmcFormatters.TakeoffGrossWeightInput(this.gameUnitSub, this.props.grossWeightSpacing, 'input', 'large'),
            }),
        }).bindSource(new DataInterface(MappedSubject.create(this.displayGrossWeight, this.displayTakeoffGw)
            .map(([gw, tow]) => [Number.isNaN(gw.number) ? null : gw, Number.isNaN(tow.number) ? null : tow]), (value) => value === null ?
            this.perfPlan.takeoffGw.set(null) :
            this.perfPlan.takeoffGw.set(this.gameUnitSub.get().convertTo(value, UnitType.POUND))));
        this.ReadonlyTakeoffGrossWeightField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.TakeoffGrossWeightInput(this.gameUnitSub, this.props.grossWeightSpacing, 'display', 'small'),
            },
        }).bind(MappedSubject.create(this.displayGrossWeight, this.displayTakeoffGw)
            .map(([gw, tow]) => [Number.isNaN(gw.number) ? null : gw, Number.isNaN(tow.number) ? null : tow]));
        this.TakeoffDataAcceptField = new DisplayField(this, {
            formatter: new SimpleStringFormat('ACCEPT>'),
            onSelected: async () => {
                this.fms.acceptPendingTakeoffUplink();
                return true;
            },
        });
        this.TakeoffDataRejectField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<REJECT'),
            onSelected: async () => {
                this.fms.rejectPendingTakeoffUplink();
                return true;
            },
        });
        this.RefSpeedsSwitchField = new SwitchLabel(this, {
            optionStrings: ['OFF', 'ON'],
            caret: 'right',
            separator: 'arrows',
        }).bind(this.refSpeedsFieldSwitchState);
        /** Page 2 */
        this.WindField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.WindVector('left', this.perfPlan.takeoffWind),
                nullValueString: B787FmcFormatters.Unit('KT', { type: 'input', spaceBetween: false }, '---°/---')(null),
                format: B787FmcFormatters.WindVector,
            },
            onModified: async (val) => {
                this.perfPlan.takeoffRunwayWind.set(val);
                return false;
            },
            onDelete: async () => {
                this.perfPlan.takeoffWind.set(null);
                this.perfPlan.takeoffRunwayWind.set(null);
                return true;
            },
        }).bind(this.perfPlan.takeoffWind);
        this.ReadonlyWindField = new DisplayField(this, {
            formatter: {
                nullValueString: B787FmcFormatters.Unit('KT', { type: 'display', spaceBetween: false }, '---°/---')(null),
                format: B787FmcFormatters.WindVector,
            },
            style: '[s-text]',
        }).bind(this.perfPlan.takeoffWind);
        this.RwyWindField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.WindRunway(this.perfPlan.originRunway),
                nullValueString: B787FmcFormatters.Unit('KT', { spaceBetween: false, type: 'input' }, this.props.rwyWindNullValueString)(null),
                format: B787FmcFormatters.WindComponentsRunway(this.perfPlan.originRunway),
            },
            onModified: async () => {
                this.perfPlan.takeoffWind.set(null);
                return false;
            }
        }).bind(this.perfPlan.takeoffRunwayWind);
        this.ReadonlyRwyWindField = new DisplayField(this, {
            formatter: {
                nullValueString: B787FmcFormatters.Unit('KT', { spaceBetween: false, type: 'display', fontSize: 'small' }, this.props.rwyWindNullValueString)(null),
                format: B787FmcFormatters.WindComponentsRunway(this.perfPlan.originRunway),
            },
        }).bind(this.perfPlan.takeoffRunwayWind);
        this.SlopeCondField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.RunwaySlopeAndCondition('left', this.perfPlan.takeoffRunwaySlope, this.perfPlan.takeoffRunwayCondition),
                nullValueString: '',
                format: B787FmcFormatters.RunwaySlopeAndCondition,
            },
            onDelete: async () => {
                this.perfPlan.takeoffRunwaySlope.set(0);
                this.perfPlan.takeoffRunwayCondition.set(RunwayCondition.DRY);
                return true;
            }
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.takeoffRunwaySlope, this.perfPlan.takeoffRunwayCondition), ([slope, cond]) => {
            this.perfPlan.takeoffRunwaySlope.set(slope);
            this.perfPlan.takeoffRunwayCondition.set(cond);
        }));
        this.ReadonlySlopeCondField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.RunwaySlopeAndCondition,
            },
            style: '[s-text]',
        }).bind(MappedSubject.create(this.perfPlan.takeoffRunwaySlope, this.perfPlan.takeoffRunwayCondition));
        this.EoAccelHtField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.IntegerRangePositive(4, 3, 9999, 400),
                nullValueString: '□□□□',
                format: B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type: 'input' }),
            },
        }).bind(this.perfPlan.takeoffEoAccelerationHeight);
        this.ReadonlyEoAccelHtField = new DisplayField(this, {
            formatter: {
                nullValueString: '□□□□',
                format: B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type: 'display', fontSize: 'small' }),
            },
        }).bind(this.perfPlan.takeoffEoAccelerationHeight);
        this.AccelHtField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.IntegerRangePositive(4, 3, 9999, 400),
                nullValueString: '□□□□',
                format: B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type: 'input' }),
            },
        }).bind(this.perfPlan.takeoffAccelerationHeight);
        this.ReadonlyAccelHtField = new DisplayField(this, {
            formatter: {
                nullValueString: '□□□□',
                format: B787FmcFormatters.Unit('FT', { padStart: 4, padString: ' ', spaceBetween: false, type: 'display', fontSize: 'small' }),
            },
        }).bind(this.perfPlan.takeoffAccelerationHeight);
        this.ThrReductionField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.ThrustReduction,
                nullValueString: '',
                format: B787FmcFormatters.ThrustReduction('input', 'large'),
            },
            onModified: async (value) => {
                // Should only ever be true for the 78 as there is no overlap between valid takeoff flaps and thrust reduction flaps for the 74
                if (this.perfPlan.takeoffFlaps.get() === value) {
                    this.perfPlan.takeoffFlaps.set(null);
                    this.props.messenger.sendMessage(BoeingFmcErrorKeys.TakeoffFlapsDeleted);
                }
                return false;
            },
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.climbThrustMode, this.perfPlan.takeoffThrustReductionPoint), (value) => this.perfPlan.takeoffThrustReductionPoint.set(value)));
        this.ReadonlyThrReductionField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.ThrustReduction('display', 'small'),
            },
            style: '[s-text]',
        }).bind(MappedSubject.create(this.perfPlan.climbThrustMode, this.perfPlan.takeoffThrustReductionPoint));
        this.RefOatField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.IntegerRange(99, -54),
                nullValueString: B787FmcFormatters.Unit('°C', { spaceBetween: false, type: 'inputWithUnit', padString: ' ', padStart: this.props.refOatPad }, '--')(null),
                format: B787FmcFormatters.Unit('°C', { spaceBetween: false, padString: ' ', padStart: this.props.refOatPad, type: 'inputWithUnit' })
            }
        }).bind(this.perfPlan.takeoffTemp);
        this.ReadonlyRefOatField = new DisplayField(this, {
            formatter: {
                nullValueString: B787FmcFormatters.Unit('°C', { spaceBetween: false, type: 'display', fontSize: 'small', padString: ' ', padStart: this.props.refOatPad }, '--')(null),
                format: B787FmcFormatters.Unit('°C', { spaceBetween: false, padString: ' ', padStart: this.props.refOatPad, type: 'display', fontSize: 'small' }),
            }
        }).bind(this.perfPlan.takeoffTemp);
    }
    /** @inheritDoc */
    onInit() {
        this.addBinding(this.grossWeightLbs.sub((it) => this.displayGrossWeight.set(it === null ? NaN : it, UnitType.POUND), true));
        this.addBinding(this.perfPlan.takeoffGw.sub((it) => this.displayTakeoffGw.set(it === null ? NaN : it, UnitType.POUND), true));
        this.addBinding(MappedSubject.create(this.fms.preflightComplete, this.isOnGround, this.flightPhase.map(phase => phase > FmsOperatingPhase.TAKEOFF)).sub(([preflightComplete, isOnGround, isAfterTakeoff]) => {
            this.line6Header = this.props.line6HeaderGen(preflightComplete, isOnGround, isAfterTakeoff);
            this.invalidate();
        }, true));
        this.addBinding(MappedSubject.create(this.posIsInitialized, this.fms.route1Activated, this.fms.perfInitPageCompleted).sub(([posIsInit, routeIsAct, perfInitDone]) => {
            if (!posIsInit) {
                this.line6PageLink = PageLinkField.createLink(this, 'POS INIT>', '/pos-init');
            }
            else if (!routeIsAct) {
                this.line6PageLink = PageLinkField.createLink(this, 'ROUTE>', '/rte');
            }
            else if (!perfInitDone) {
                this.line6PageLink = PageLinkField.createLink(this, 'PERF INIT>', '/perf-init');
            }
            else {
                this.line6PageLink = PageLinkField.createLink(this, 'THRUST LIM>', '/thrust-lim');
            }
            this.invalidate();
        }, true));
        // Recalculate CG field header
        this.addBinding(this.perfPlan.takeoffCg.sub(() => this.invalidate()));
        this.addBinding(this.gameUnitSub.sub(() => this.invalidate()));
        this.addBinding(this.refSpeedsFieldSwitchState.sub(() => this.invalidate()));
        this.addBinding(this.vSpeedsCanBeComputed.sub((canBeComputed) => {
            this.tryUpdateRefSpeeds(canBeComputed);
            this.invalidate();
        }, true));
        // Should not be paused when leaving the page, or else value changes on other pages won't be observed.
        // None of the inputs to this sub should change after takeoff anyway.
        this.invalidateVSpeedsWhenChanges.sub(() => {
            this.invalidateVSpeeds();
            this.tryUpdateRefSpeeds(this.vSpeedsCanBeComputed.get());
        });
        // Invalidate V speeds if V1 <= VR <= V2 is not true
        this.addBinding(MappedSubject.create(this.v1UserSetting, this.vRUserSetting, this.v2UserSetting).sub(([v1, vR, v2]) => {
            const v1isGreaterThanVr = Boolean(v1 && vR && v1 > vR);
            const v1isGreaterThanV2 = Boolean(v1 && v2 && v1 > v2);
            const vRisGreaterThanV2 = Boolean(vR && v2 && vR > v2);
            if (v1isGreaterThanVr || v1isGreaterThanV2 || vRisGreaterThanV2) {
                this.invalidateVSpeeds();
            }
        }));
        // Blank V speed fields immediately if spawning in the air
        this.blankVSpeedFields.set(!this.isOnGround.get());
        this.addBinding(this.isOnGround.sub((onGround) => {
            if (onGround) {
                // Show the V speed fields again upon landing
                this.blankVSpeedsTimer.clear();
                this.blankVSpeedFields.set(false);
            }
            else {
                // Hide and reset the V speed fields two minutes after becoming airborne
                this.blankVSpeedsTimer.schedule(() => {
                    this.blankVSpeedFields.set(true);
                    this.v1UserSetting.resetToDefault();
                    this.vRUserSetting.resetToDefault();
                    this.v2UserSetting.resetToDefault();
                }, 2 * 60 * 1000);
            }
        }));
        this.addBinding(this.fms.pendingTakeoffDataUplink.sub(() => this.invalidate()));
    }
    /**
     * Attempt to update REF speeds if required information exists.
     * @param canBeComputed Whether the information exists to compute V speeds.
     */
    tryUpdateRefSpeeds(canBeComputed) {
        const weight = this.takeoffWeightProxy.get();
        const toRwy = this.takeoffRunwayProxy.get();
        const flaps = this.perfPlan.takeoffFlaps.get();
        if (canBeComputed && weight !== null && toRwy !== null && flaps !== null) {
            const vSpeeds = this.computeVSpeeds(weight, toRwy, flaps);
            this.refV1Speed.set(vSpeeds[VSpeedType.V1]);
            this.refVRSpeed.set(vSpeeds[VSpeedType.Vr]);
            this.refV2Speed.set(vSpeeds[VSpeedType.V2]);
        }
    }
    /** @inheritDoc */
    onResume() {
        this.gameUnit.resume();
        this.isOnGround.resume();
        this.flightPhase.resume();
        this.oat.resume();
        this.posIsInitialized.resume();
        this.stabTrim.resume();
    }
    /** @inheritDoc */
    onPause() {
        this.gameUnit.pause();
        this.isOnGround.pause();
        this.flightPhase.pause();
        this.oat.pause();
        this.posIsInitialized.pause();
        this.stabTrim.pause();
    }
    /** Handle the invalidation of V speeds by displaying an alert and resetting their values. */
    invalidateVSpeeds() {
        // Only display alert if there are V speeds to be deleted
        if (this.v1UserSetting.get() || this.vRUserSetting.get() || this.v2UserSetting.get()) {
            this.props.messenger.sendMessage(BoeingFmcErrorKeys.TakeoffSpeedsDeleted);
        }
        this.v1UserSetting.resetToDefault();
        this.vRUserSetting.resetToDefault();
        this.v2UserSetting.resetToDefault();
    }
    /**
     * Computes the V speeds for a given configuration.
     * @param weight The gross weight.
     * @param toRwy The takeoff runway.
     * @param flapsSetting The takeoff flap setting.
     * @returns An object with integer values for V1, VR, and V2.
     * */
    computeVSpeeds(weight, toRwy, flapsSetting) {
        var _a, _b;
        const temp = (_a = this.perfPlan.takeoffTemp.get()) !== null && _a !== void 0 ? _a : this.oat.get();
        const slope = this.perfPlan.takeoffRunwaySlope.get();
        // Get rwy wind
        const windVector = (_b = this.perfPlan.takeoffRunwayWind.get()) !== null && _b !== void 0 ? _b : { speed: 0, direction: 0 };
        const magVar = Facilities.getMagVar(toRwy.latitude, toRwy.longitude);
        const [headwind] = BoeingAeroMath.calcRelativeWindComponents(toRwy.course - magVar, windVector.speed, windVector.direction);
        const isRwyWet = this.perfPlan.takeoffRunwayCondition.get() !== RunwayCondition.DRY;
        return this.props.vSpeedData.getVSpeed(weight, toRwy.elevation, temp, flapsSetting, slope, headwind, this.perfPlan.takeoffThrustMode.get(), isRwyWet);
    }
    /**
     * A factor that returns Ref speed and V speed fields.
     * @param vSpeedUserSetting The V speed user setting.
     * @param refSpeedSub The ref speed subscribable.
     * @returns A Ref and V speed field.
     * */
    refAndVSpeedFieldFactory(vSpeedUserSetting, refSpeedSub) {
        return new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.IntegerRangePositive(3, 2, 300, 80),
                nullValueString: '---[s-text]',
                format: this.props.refAndVSpeedFieldFormat,
            },
            onSelected: async (scratchpad) => {
                if (!scratchpad && // Scratchpad is empty
                    this.refSpeedsFieldSwitchState.get() && // Show ref speeds is switched on
                    this.vSpeedsCanBeComputed.get() && // Ref speeds have been computed
                    !vSpeedUserSetting.get() // A V speed has not already been assigned
                ) {
                    vSpeedUserSetting.set(refSpeedSub.get());
                    return true;
                }
                return false; // Try to parse the scratchpad contents and set the result in onModified
            },
            onModified: async (val) => {
                vSpeedUserSetting.set(val);
                return true;
            },
            onDelete: async () => {
                // Reject a deletion when displaying small text speeds
                if (!vSpeedUserSetting.get() && this.refSpeedsFieldSwitchState.get() && this.vSpeedsCanBeComputed.get()) {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
                else {
                    vSpeedUserSetting.resetToDefault();
                    return true;
                }
            },
        }).bind(MappedSubject.create(vSpeedUserSetting, refSpeedSub, this.refSpeedsFieldSwitchState.map((val) => Boolean(val)), this.vSpeedsCanBeComputed));
    }
    /**
     * A factor that returns V Speed fields.
     * @param vSpeed The type of V Speed.
     * @returns A V Speed field.
     * */
    vSpeedFieldFactory(vSpeed) {
        return new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.DigitOnly(3),
                format: (value) => inputBox(value <= 0 ? '---' : value.toString().padStart(3, ' ')),
                nullValueString: inputBox('---'),
            },
            onSelected: async (scratchpadContents) => {
                if (scratchpadContents === '') {
                    const weight = this.takeoffWeightProxy.get();
                    const toRwy = this.takeoffRunwayProxy.get();
                    const flaps = this.perfPlan.takeoffFlaps.get();
                    if (this.vSpeedsCanBeComputed.get() && weight !== null && toRwy !== null && flaps !== null) {
                        // Put the V speed in the scratchpad if it can be calculated
                        return this.computeVSpeeds(weight, toRwy, flaps)[vSpeed].toString();
                    }
                    else {
                        // Don't trigger an INVALID ENTRY error with an empty scratchpad, just do nothing
                        return true;
                    }
                }
                else {
                    // Pass value on to the parser
                    return false;
                }
            },
        }).bind(this.vSpeedSettings.getSettings(vSpeed).value);
    }
    /**
     * A factor that returns readonly V Speed fields.
     * @param vSpeedSubject The V Speed subject.
     * @returns A V Speed field.
     * */
    readonlyVSpeedFieldFactory(vSpeedSubject) {
        return new DisplayField(this, {
            formatter: {
                nullValueString: '---[s-text]',
                format: (value) => `${value <= 0 ? '---' : value.toString().padStart(3, ' ')}[s-text]`,
            },
        }).bind(vSpeedSubject);
    }
    /** @inheritDoc */
    render() {
        const cgHeader = this.perfPlan.takeoffCg.get() === null ? ' CG' : ' CG  TRIM';
        const takeoffDataUplinkPending = this.fms.pendingTakeoffDataUplink.get();
        const TakeoffFlapsField = takeoffDataUplinkPending ? this.ReadonlyTakeoffFlapsField : this.TakeoffFlapsField;
        const ThrustField = takeoffDataUplinkPending ? this.ReadonlyThrustField : this.ThrustField;
        const CgField = takeoffDataUplinkPending ? this.ReadonlyCgField : this.CgField;
        const showPropsV1Header = !this.blankVSpeedFields.get() &&
            this.props.showRefSpeeds && this.refSpeedsFieldSwitchState.get() && this.vSpeedsCanBeComputed.get();
        const v1Header = showPropsV1Header ? this.props.v1Header : 'V1';
        const v1Field = takeoffDataUplinkPending ? this.ReadonlyV1Field : (this.blankVSpeedFields.get() ? '' : this.V1Field);
        const vRField = takeoffDataUplinkPending ? this.ReadonlyVrField : (this.blankVSpeedFields.get() ? '' : this.VrField);
        const v2Field = takeoffDataUplinkPending ? this.ReadonlyV2Field : (this.blankVSpeedFields.get() ? '' : this.V2Field);
        const RunwayPosField = takeoffDataUplinkPending ? this.ReadonlyRunwayPosField : this.RunwayPosField;
        const TakeoffGrossWeightField = takeoffDataUplinkPending ? this.ReadonlyTakeoffGrossWeightField : this.TakeoffGrossWeightField;
        const L5Header = takeoffDataUplinkPending ? this.props.PendingUplinkHeader : this.props.RequestHeader;
        const L5 = takeoffDataUplinkPending ? this.TakeoffDataRejectField : this.props.RequestPrompt;
        const R5Header = (!takeoffDataUplinkPending && this.props.showRefSpeeds) ? 'REF SPDS' : '';
        const R5 = takeoffDataUplinkPending ? this.TakeoffDataAcceptField : ((!takeoffDataUplinkPending && this.props.showRefSpeeds) ? this.RefSpeedsSwitchField : '');
        return [
            [
                ['', this.PagingIndicator, this.TitleField],
                [' FLAPS', v1Header],
                [TakeoffFlapsField, v1Field],
                [' THRUST', 'VR'],
                [ThrustField, vRField],
                [cgHeader, 'V2'],
                [CgField, v2Field],
                [this.props.RunwayHeader, `GR WT${' '.repeat(this.props.grossWeightSpacing + 1)}TOGW`],
                [RunwayPosField, TakeoffGrossWeightField],
                [L5Header, R5Header],
                [L5, R5],
                this.line6Header,
                [this.IndexLink, this.line6PageLink],
            ],
            this.pageTwoRenderTemplate(),
        ];
    }
}

/** A Boeing THRUST LIM page. */
class BoeingThrustLimPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, TemperatureFieldHeader, TemperatureFieldFormatter, thrustModePadding, thrustRefMetric, QuietClimbHeader, QuietClimbField, line6HeaderGen) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.TemperatureFieldHeader = TemperatureFieldHeader;
        this.TemperatureFieldFormatter = TemperatureFieldFormatter;
        this.thrustModePadding = thrustModePadding;
        this.thrustRefMetric = thrustRefMetric;
        this.QuietClimbHeader = QuietClimbHeader;
        this.QuietClimbField = QuietClimbField;
        this.line6HeaderGen = line6HeaderGen;
        this.IndexLink = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.TakeoffLink = PageLinkField.createLink(this, 'TAKEOFF>', '/takeoff-ref');
        this.ApproachLink = PageLinkField.createLink(this, 'APPROACH>', '/approach-ref');
        this.line6Header = [''];
        this.perfPlan = this.fms.performancePlanProxy;
        this.subs = this.bus.getSubscriber();
        this.isOnGround = ConsumerSubject.create(this.subs.on('on_ground').whenChanged(), true);
        this.pressureAlt = ConsumerSubject.create(this.subs.on('pressure_alt').whenChangedBy(100), 0);
        this.oat = ConsumerSubject.create(this.subs.on('ambient_temp_c').whenChangedBy(1), 0);
        this.flightPhase = ConsumerSubject.create(this.subs.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.fadecThrustMode = ConsumerSubject.create(this.subs.on('fadec_thrust_mode'), TakeoffThrustMode.TO);
        this.fadecDeratePerc = ConsumerSubject.create(this.subs.on('fadec_takeoff_derate_percentage'), 0);
        this.refTpr = ConsumerSubject.create(this.subs.on('fadec_ref_tpr_1'), 0);
        this.refN1 = ConsumerSubject.create(this.subs.on('fadec_ref_n1_1'), 0);
        this.isPostTakeoff = this.flightPhase.map((phase) => phase > FmsOperatingPhase.TAKEOFF);
        this.tempSubject = MappedSubject.create(this.perfPlan.takeoffAssumedTemp, this.oat);
        // We are assuming the ADS will always be able to provide OAT, therefore
        // entry of OAT in addition to assumed temp is not currently supported.
        this.TemperatureField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.AssumedTemp,
                nullValueString: '',
                format: this.TemperatureFieldFormatter,
            },
        }).bindSource(new DataInterface(this.tempSubject, (assumedTemp) => {
            this.perfPlan.takeoffAssumedTemp.set(assumedTemp);
            const assumedTempExceedsOAT = assumedTemp > this.oat.get();
            const takeoffThrustMode = this.perfPlan.takeoffThrustMode.get();
            if ((assumedTempExceedsOAT && !BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode)) ||
                (!assumedTempExceedsOAT && BoeingFmsUtils.thrustModeIsAssumedTemp(takeoffThrustMode))) {
                this.perfPlan.takeoffThrustMode.set(BoeingFmsUtils.toggleAssumedTempDerate(takeoffThrustMode));
            }
        }));
        this.TakeoffField = this.takeoffFieldFactory(TakeoffThrustMode.TO, TakeoffThrustMode.DTO, `<TO${' '.repeat(this.thrustModePadding)}<SEL>`, '<TO');
        this.TakeoffOneField = this.takeoffFieldFactory(TakeoffThrustMode.TO1, TakeoffThrustMode.DTO1, `<-10%${' '.repeat(this.thrustModePadding - 2)}<SEL>`, '<-10%');
        this.TakeoffTwoField = this.takeoffFieldFactory(TakeoffThrustMode.TO2, TakeoffThrustMode.DTO2, `<-20%${' '.repeat(this.thrustModePadding - 2)}<SEL>`, '<-20%');
        this.GoAroundField = this.airborneFieldFactory(AirborneThrustMode.GA, `<GA${' '.repeat(this.thrustModePadding)}<SEL>`, '<GA');
        this.ContinuousField = this.airborneFieldFactory(AirborneThrustMode.CON, `<CON${' '.repeat(this.thrustModePadding - 1)}<SEL>`, '<CON');
        this.CruiseField = this.airborneFieldFactory(AirborneThrustMode.CRZ, `<CRZ${' '.repeat(this.thrustModePadding - 1)}<SEL>`, '<CRZ');
        this.ThrustMode = new DisplayField(this, {
            formatter: {
                nullValueString: this.thrustRefMetric,
                format: (thrustMode) => `${thrustMode} ${this.thrustRefMetric}`,
            }
        }).bind(this.fadecThrustMode);
        this.ThrustValue = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (tpr) => `${tpr.toFixed(1)}${this.thrustRefMetric === 'N1' ? '%' : ''}`,
            }
        }).bind(this.thrustRefMetric === 'TPR' ? this.refTpr : this.refN1);
        this.ClimbField = this.climbFieldFactory(ClimbThrustMode.CLB, ' '.repeat(this.thrustModePadding), 'CLB>');
        this.ClimbOneField = this.climbFieldFactory(ClimbThrustMode.CLB1, ' '.repeat(this.thrustModePadding - 2), 'CLB 1>');
        this.ClimbTwoField = this.climbFieldFactory(ClimbThrustMode.CLB2, ' '.repeat(this.thrustModePadding - 2), 'CLB 2>');
    }
    /** @inheritDoc */
    onInit() {
        this.addBinding(this.isOnGround.sub(() => this.invalidate()));
        this.addBinding(this.flightPhase.sub(() => this.invalidate()));
        this.addBinding(this.fadecDeratePerc.sub((deratePerc) => {
            if (deratePerc < 5) {
                this.perfPlan.climbThrustMode.set(ClimbThrustMode.CLB);
            }
            else if (deratePerc < 15) {
                this.perfPlan.climbThrustMode.set(ClimbThrustMode.CLB1);
            }
            else {
                this.perfPlan.climbThrustMode.set(ClimbThrustMode.CLB2);
            }
        }, true));
        this.addBinding(MappedSubject.create(this.fms.preflightComplete, this.isOnGround, this.flightPhase.map(phase => phase > FmsOperatingPhase.TAKEOFF)).sub(([preflightComplete, isOnGround, isAfterTakeoff]) => {
            this.line6Header = this.line6HeaderGen(preflightComplete, isOnGround, isAfterTakeoff);
            this.invalidate();
        }, true));
    }
    /** @inheritDoc */
    onResume() {
        this.isOnGround.resume();
        this.pressureAlt.resume();
        this.oat.resume();
        this.flightPhase.resume();
        this.fadecThrustMode.resume();
        this.fadecDeratePerc.resume();
        this.refTpr.resume();
        this.refN1.resume();
    }
    /** @inheritDoc */
    onPause() {
        this.isOnGround.pause();
        this.pressureAlt.pause();
        this.oat.pause();
        this.flightPhase.pause();
        this.fadecThrustMode.pause();
        this.fadecDeratePerc.pause();
        this.refTpr.pause();
        this.refN1.pause();
    }
    /**
     * Produces {@link DisplayField}s for selecting takeoff thrust modes.
     * @param fixedDerate The thrust mode to select if assumed temperature is disabled.
     * @param tempDerate The thrust mode to select if assumed temperature is enabled.
     * @param activeText The text to display when one of the preceding thrust modes is active.
     * @param inactiveText The text to display when neither of the preceding thrust modes is active.
     * @returns A {@link DisplayField} for rendering and setting takeoff thrust modes.
     */
    takeoffFieldFactory(fixedDerate, tempDerate, activeText, inactiveText) {
        return new DisplayField(this, {
            formatter: {
                format: (isActive) => isActive ? activeText : inactiveText,
                nullValueString: ''
            },
            onSelected: async () => {
                const assumedTemp = this.perfPlan.takeoffAssumedTemp.get();
                const assumedTempExceedsOAT = assumedTemp === null ? false : assumedTemp > this.oat.get();
                this.perfPlan.takeoffThrustMode.set(assumedTempExceedsOAT ? tempDerate : fixedDerate);
                return true;
            },
        }).bind(this.perfPlan.takeoffThrustMode
            .map((val) => val === fixedDerate || val === tempDerate));
    }
    /**
     * Produces {@link DisplayField}s for selecting airborne thrust modes.
     * @param thrustMode The thrust mode to select.
     * @param activeText The text to display when the thrust mode is active.
     * @param inactiveText The text to display when the thrust modes is active.
     * @returns A {@link DisplayField} for rendering and setting airborne thrust modes.
     */
    airborneFieldFactory(thrustMode, activeText, inactiveText) {
        return new DisplayField(this, {
            formatter: {
                format: (isActive) => isActive ? activeText : inactiveText,
                nullValueString: ''
            },
            onSelected: async () => {
                this.bus.getPublisher().pub('thrust_control_activate_mode', thrustMode, true);
                return true;
            }
        }).bind(this.fadecThrustMode.map((mode) => mode === thrustMode));
    }
    /**
     * Produces {@link DisplayField}s for selecting climb thrust modes.
     * @param thrustMode The thrust mode to select.
     * @param padding The spaces to pad between the selector and the text.
     * @param text The text to display.
     * @returns A {@link DisplayField} for rendering and setting climb thrust modes.
     */
    climbFieldFactory(thrustMode, padding, text) {
        return new DisplayField(this, {
            formatter: {
                format: ([isActiveClimbMode, isActiveThrustsMode, isAirborne]) => {
                    return isAirborne ?
                        (isActiveThrustsMode ? `<SEL>${padding}${text}` : text) :
                        (isActiveClimbMode ? `${isAirborne ? '<SEL>' : '<ARM>'}${padding}${text}` : text);
                },
                nullValueString: '',
            },
            onSelected: async () => {
                this.perfPlan.climbThrustMode.set(thrustMode);
                if (this.isPostTakeoff.get()) {
                    this.bus.getPublisher().pub('thrust_control_activate_mode', thrustMode, true);
                }
                return true;
            },
        }).bind(MappedSubject.create(this.perfPlan.climbThrustMode.map((mode) => mode === thrustMode), this.fadecThrustMode.map((mode) => mode === thrustMode), this.isPostTakeoff));
    }
    /** @inheritDoc */
    render() {
        const afterTakeoff = this.flightPhase.get() > FmsOperatingPhase.TAKEOFF;
        return [
            [
                ['', '', 'THRUST LIM'],
                [(afterTakeoff ? '' : this.TemperatureFieldHeader), this.ThrustMode],
                [(afterTakeoff ? '' : this.TemperatureField), this.ThrustValue],
                [''],
                [(afterTakeoff ? this.GoAroundField : this.TakeoffField), this.ClimbField],
                [(afterTakeoff ? '' : ' TO 1')],
                [(afterTakeoff ? this.ContinuousField : this.TakeoffOneField), this.ClimbOneField],
                [(afterTakeoff ? '' : ' TO 2')],
                [(afterTakeoff ? this.CruiseField : this.TakeoffTwoField), this.ClimbTwoField],
                ['', this.QuietClimbHeader],
                ['', this.QuietClimbField],
                this.line6Header,
                [this.IndexLink, this.isOnGround.get() ? this.TakeoffLink : this.ApproachLink],
            ],
        ];
    }
}

/**
 * The 787 VNAV Debug page.
 */
class BoeingVnavDebugPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.vnavConsumer = this.bus.getSubscriber();
        this.todDistance = ConsumerSubject.create(this.vnavConsumer.on('vnav_tod_distance'), 0);
        this.deviation = ConsumerSubject.create(this.vnavConsumer.on('vnav_vertical_deviation'), 0);
        this.targetAltitude = ConsumerSubject.create(this.vnavConsumer.on('vnav_target_altitude'), 0);
        this.state = ConsumerSubject.create(this.vnavConsumer.on('vnav_state'), VNavState.Disabled);
        this.pathmode = ConsumerSubject.create(this.vnavConsumer.on('vnav_path_mode'), VNavPathMode.None);
        this.apInSelectedSpeed = ConsumerSubject.create(this.bus.getSubscriber().on('ap_selected_speed_is_manual'), true);
        this.atSpeedIas = ConsumerSubject.create(this.bus.getSubscriber().on('boeing_at_target_ias'), 0);
        this.atSpeedMach = ConsumerSubject.create(this.bus.getSubscriber().on('boeing_at_target_mach'), 0);
        this.fmsSpeedIas = ConsumerSubject.create(this.bus.getSubscriber().on('fms_speed_active_target_ias'), 0);
        this.fmsSpeedMach = ConsumerSubject.create(this.bus.getSubscriber().on('fms_speed_active_target_mach'), 0);
        this.apSpeedIas = ConsumerSubject.create(this.bus.getSubscriber().on('fms_speed_autopilot_target_ias'), 0);
        this.apSpeedMach = ConsumerSubject.create(this.bus.getSubscriber().on('fms_speed_autopilot_target_mach'), 0);
        this.profileDebugLegIndex = Subject.create(1);
        this.profileDebugRightColumnMode = Subject.create(0);
        this.todDistanceDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    if (value) {
                        return `${UnitType.METER.convertTo(value, UnitType.NMILE).toFixed(1)}NM`;
                    }
                    else {
                        return '';
                    }
                },
            },
        }).bind(this.todDistance);
        this.deviationDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    if (value) {
                        return `${value.toFixed(0)}FT`;
                    }
                    else {
                        return '';
                    }
                },
            },
        }).bind(this.deviation);
        this.targetAltitudeDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    if (value) {
                        return `${value.toFixed(0)}FT`;
                    }
                    else {
                        return '';
                    }
                },
            },
        }).bind(this.targetAltitude);
        this.stateDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    switch (value) {
                        case VNavState.Disabled:
                            return 'Disabled';
                        case VNavState.Enabled_Active:
                            return 'Enabled Active';
                        case VNavState.Enabled_Inactive:
                            return 'Enabled Inactive';
                        default:
                            return 'UNKNOWN';
                    }
                },
            },
        }).bind(this.state);
        this.pathModeDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    switch (value) {
                        case VNavPathMode.PathInvalid:
                            return 'Path Invalid';
                        case VNavPathMode.PathArmed:
                            return 'Path Armed';
                        case VNavPathMode.PathActive:
                            return 'Path Active';
                        default:
                            return 'NONE';
                    }
                },
            },
        }).bind(this.pathmode);
        this.atInSelectedDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    if (value) {
                        return 'SEL';
                    }
                    else {
                        return 'FMS';
                    }
                },
            },
        }).bind(this.apInSelectedSpeed);
        this.atIasValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(0);
                },
            },
        }).bind(this.atSpeedIas);
        this.atMachValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(2);
                },
            },
        }).bind(this.atSpeedMach);
        this.fmsIasValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(0);
                },
            },
        }).bind(this.fmsSpeedIas);
        this.fmsMachValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(2);
                },
            },
        }).bind(this.fmsSpeedMach);
        this.apIasValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(0);
                },
            },
        }).bind(this.apSpeedIas);
        this.apMachValueDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    return value.toFixed(2);
                },
            },
        }).bind(this.apSpeedMach);
        this.devPlanDisplay = new DisplayField(this, {
            formatter: {
                nullValueString: 'LOAD DEV FLIGHT PLAN >',
                /** @inheritDoc */
                format() {
                    return 'LOAD DEV FLIGHT PLAN >';
                },
            },
            onSelected: () => {
                BoeingDevFlightPlan.insertDevPlan(this.fms);
                return Promise.resolve(true);
            },
        });
        this.ProfileDebugRightColumnModeSwitch = new SwitchLabel(this, {
            caret: 'right',
            separator: 'slash',
            optionStrings: ['T+DIST', 'TYPE'],
        }).bind(this.profileDebugRightColumnMode);
        this.ProfileDebugPrevLegField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<PREV'),
            onSelected: async () => {
                const index = this.profileDebugLegIndex.get();
                if (index > 0) {
                    this.profileDebugLegIndex.set(this.profileDebugLegIndex.get() - 1);
                }
                return true;
            }
        });
        this.ProfileDebugNextLegField = new DisplayField(this, {
            formatter: new SimpleStringFormat('NEXT>'),
            onSelected: async () => {
                const index = this.profileDebugLegIndex.get();
                if (index < this.fms.getPrimaryFlightPlan().length - 1) {
                    this.profileDebugLegIndex.set(this.profileDebugLegIndex.get() + 1);
                }
                return true;
            }
        });
    }
    /** @inheritDoc */
    onInit() {
        this.addBinding(this.profileDebugLegIndex.sub(() => this.invalidate()));
        this.addBinding(this.profileDebugRightColumnMode.sub(() => this.invalidate()));
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '1/2', 'VNAV DEBUG'],
                [' STATE', 'PATH MODE '],
                [this.stateDisplay, this.pathModeDisplay],
                [' Target Alt', 'Deviation '],
                [this.targetAltitudeDisplay, this.deviationDisplay],
                [' TOD Distance', ' AT MODE'],
                [this.todDistanceDisplay, this.atInSelectedDisplay],
                [' IAS', 'MACH '],
                [this.atIasValueDisplay, this.atMachValueDisplay, 'AT'],
                [this.fmsIasValueDisplay, this.fmsMachValueDisplay, 'FMS'],
                [this.apIasValueDisplay, this.apMachValueDisplay, 'AP'],
                ['', ''],
                ['', this.devPlanDisplay],
            ],
            this.renderProfileDebug(),
        ];
    }
    /**
     * Renders PROFILE debug page
     *
     * @returns an FMC template
     **/
    renderProfileDebug() {
        let vectorRows = [];
        const verticalFlightPath = this.fms.verticalPathCalculator.getVerticalFlightPath(BoeingFms.ACT_RTE_PLAN_INDEX);
        const flightPlan = this.fms.getPrimaryFlightPlan();
        const legIndex = this.profileDebugLegIndex.get();
        if (verticalFlightPath && verticalFlightPath.legs[legIndex]) {
            const leg = verticalFlightPath.legs[legIndex];
            const legTimeMin = Math.floor(leg.simDuration / 60);
            const legTimeSec = leg.simDuration % 60;
            const legTimeStr = `${legTimeMin.toFixed(0).padStart(3, ' ')}[white]${legTimeSec.toFixed(0).padStart(2, '0')}`;
            const legDistanceNm = UnitType.NMILE.convertFrom(leg.simDistance, UnitType.METER);
            const legDistanceStr = legDistanceNm.toFixed(1).padStart(5, ' ') + 'n';
            const lateralLeg = flightPlan.getLeg(legIndex);
            vectorRows.push([`#${legIndex}[white] ${lateralLeg.name}[${legIndex === flightPlan.activeLateralLeg ? 'magenta' : 'green'}] PROFILE[white]`, `${legTimeStr} ${legDistanceStr}[cyan]`]);
            for (const vector of leg.vectors) {
                const startAltitude = vector.startAltitude;
                const startAltitudeFt = UnitType.FOOT.convertFrom(startAltitude, UnitType.METER);
                const startAltitudeStr = startAltitudeFt.toFixed(0).padStart(5, ' ');
                const endAltitude = vector.endAltitude;
                const endAltitudeFt = UnitType.FOOT.convertFrom(endAltitude, UnitType.METER);
                const endAltitudeSStr = endAltitudeFt.toFixed(0).padStart(5, ' ');
                const startSpeed = vector.startCas;
                const startSpeedStr = startSpeed.toFixed(0).padStart(3, ' ');
                const endSpeed = vector.endCas;
                const endSpeedStr = endSpeed.toFixed(0).padStart(3, ' ');
                const timeMin = Math.floor(vector.duration / 60);
                const timeSec = vector.duration % 60;
                const timeStr = `${timeMin.toFixed(0).padStart(3, ' ')}[s-text white]${timeSec.toFixed(0).padStart(2, '0')}[s-text cyan]`;
                const distanceNm = UnitType.NMILE.convertFrom(vector.startDistanceToLegEnd - vector.endDistanceToLegEnd, UnitType.METER);
                const distanceStr = distanceNm.toFixed(1).padStart(5, ' ') + 'n';
                const rightColText = this.profileDebugRightColumnMode.get() === 1 ? VerticalFlightPathVectorType[vector.type].substring(0, 8) : `${timeStr}/${distanceStr}`;
                vectorRows.push([`${startAltitudeStr}/${endAltitudeSStr}ft ${startSpeedStr}/${endSpeedStr}k [white s-text]`, `${rightColText}[s-text cyan]`]);
            }
        }
        vectorRows = vectorRows.slice(0, 6);
        while (vectorRows.length < 7) {
            vectorRows.push(['']);
        }
        const prediction = this.fms.activeRoutePredictor.getPredictionsForLeg(legIndex);
        vectorRows.push(['PREDS   ETA   GW    FOB', 'SHOW']);
        const predsStartStr = (prediction === null || prediction === void 0 ? void 0 : prediction.valid) ? 'VALID[green]' : 'NONE [amber]';
        const etaStr = prediction && Number.isFinite(prediction.estimatedTimeOfArrival) ? BoeingVnavDebugPage.ETA_FORMATTER(prediction.estimatedTimeOfArrival * 1000) : '----z';
        const gwStr = prediction && Number.isFinite(prediction.fob) ? (UnitType.POUND.convertFrom(prediction.fob, UnitType.KILOGRAM) / 1000).toFixed(1).padStart(5, ' ') : '---.-';
        vectorRows.push([`${predsStartStr}  ${etaStr} ${gwStr} 129.1`, this.ProfileDebugRightColumnModeSwitch]);
        vectorRows.push([' VECTORS --------------------- VECTORS']);
        vectorRows.push(['<PREV', 'NEXT>']);
        vectorRows.push([' LEG                               LEG']);
        vectorRows.push([this.ProfileDebugPrevLegField, this.ProfileDebugNextLegField]);
        return vectorRows;
    }
}
BoeingVnavDebugPage.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z');
// import {
//   ConsumerSubject, DisplayField, FmcRenderTemplate, EngineEvents, UnitType, AdcEvents, ClockEvents,
//   SimVarValueType, Subject, WeightBalanceEvents
// } from '@microsoft/msfs-sdk';
// import { BoeingPerformanceMath } from '../../Shared/Performance/BoeingPerformanceMath';
// import { B787FmcPage } from '../B787FmcPage';
// /**
//  * The 787 VNAV Debug page.
//  */
// export class B787VnavDebugPage extends B787FmcPage {
//   private readonly engineEventsConsumer = this.bus.getSubscriber<EngineEvents>();
//   private readonly adcEventsConsumer = this.bus.getSubscriber<AdcEvents>();
//   private readonly clockEventsConsumer = this.bus.getSubscriber<ClockEvents>();
//   private readonly weightEventsConsumer = this.bus.getSubscriber<WeightBalanceEvents>();
//   private readonly n1 = ConsumerSubject.create(this.engineEventsConsumer.on('n1_1'), 0);
//   private readonly fuelFlow = ConsumerSubject.create(this.engineEventsConsumer.on('fuel_flow_1'), 0);
//   private readonly mach = ConsumerSubject.create(this.adcEventsConsumer.on('mach_number').whenChangedBy(.1), 0);
//   private readonly tas = ConsumerSubject.create(this.adcEventsConsumer.on('tas').whenChangedBy(1), 0);
//   private readonly ambientPressure = ConsumerSubject.create(this.adcEventsConsumer.on('ambient_pressure_inhg').whenChangedBy(.01), 0);
//   private readonly ambientTemperature = ConsumerSubject.create(this.adcEventsConsumer.on('ambient_temp_c').whenChangedBy(1), 0);
//   private readonly indicatedAltitude = ConsumerSubject.create(this.adcEventsConsumer.on('indicated_alt').whenChangedBy(1), 0);
//   private readonly time = ConsumerSubject.create(this.clockEventsConsumer.on('realTime').whenChangedBy(2000), 0);
//   private readonly aircraftWeightInPounds = ConsumerSubject.create(this.weightEventsConsumer.on('total_weight').whenChangedBy(1), 0);
//   private inletTemp = 0;
//   private readonly predictedThrust = Subject.create(0);
//   private readonly actualThrust = Subject.create(0);
//   private readonly predictedVerticalSpeed = Subject.create(0);
//   private readonly predictedFuelFlow = Subject.create(0);
//   private readonly predictedIdleThrust = Subject.create(0);
//   private readonly predictedRamDrag = Subject.create(0);
//   private readonly endranceSpeed = Subject.create(0);
//   private readonly optimumAltAtCurrentMach = Subject.create(0);
//   private readonly optimumMachAtCurrentAlt = Subject.create(0);
//   private readonly optimumAlt = Subject.create(0);
//   private readonly optimumMach = Subject.create(0);
//   private readonly N1Display = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(1)}%`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.n1);
//   private readonly FuelFlowDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${UnitType.GPH_FUEL.convertTo(value, UnitType.PPH).toFixed(0)} PPH`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.fuelFlow);
//   private readonly ThrustPredictionDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} LBS`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.predictedThrust);
//   private readonly ThrustActualDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} LBS`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.actualThrust);
//   private readonly VerticalSpeedPredictedDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} FPM`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.predictedVerticalSpeed);
//   private readonly FuelFlowPredictedDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} PPH`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.predictedFuelFlow);
//   private readonly PredictedIdleThrustDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} LBS`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.predictedIdleThrust);
//   // private readonly PredictedRamDragDisplay = new DisplayField(this, {
//   //   formatter: {
//   //     nullValueString: '',
//   //     /** @inheritDoc */
//   //     format(value: number): string {
//   //       if (value) {
//   //         return `${value.toFixed(0)} LBS`;
//   //       } else {
//   //         return '';
//   //       }
//   //     },
//   //   },
//   // }).bind(this.predictedRamDrag);
//   private readonly BestEnduranceSpeedDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `M ${value.toFixed(2)}`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.endranceSpeed);
//   private readonly OptAltAtMachDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} FT`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.optimumAltAtCurrentMach);
//   private readonly OptMachAtAltDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `M ${value.toFixed(2)}`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.optimumMachAtCurrentAlt);
//   private readonly OptMachDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `M ${value.toFixed(2)}`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.optimumMach);
//   private readonly OptAltDisplay = new DisplayField(this, {
//     formatter: {
//       nullValueString: '',
//       /** @inheritDoc */
//       format(value: number): string {
//         if (value) {
//           return `${value.toFixed(0)} FT`;
//         } else {
//           return '';
//         }
//       },
//     },
//   }).bind(this.optimumAlt);
//   /** @inheritDoc */
//   protected onInit(): void {
//     this.time.sub(() => {
//       const aircraftWeight = this.aircraftWeightInPounds.get();
//       this.actualThrust.set(SimVar.GetSimVarValue('TURB ENG JET THRUST:1', SimVarValueType.Pounds));
//       this.inletTemp = SimVar.GetSimVarValue('TURB ENG INLET TEMPERATURE:1', 'Rankine');
//       const mach = this.mach.get();
//       // const ambientPressure = this.ambientPressure.get();
//       const ambientTemperature = this.ambientTemperature.get();
//       const isa = BoeingPerformanceMath.calcIsaFromAltitude(this.indicatedAltitude.get());
//       // const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
//       const isaPresinHg = UnitType.HPA.convertTo(isa[1], UnitType.IN_HG);
//       const cl = BoeingPerformanceMath.calculateCL(aircraftWeight, isaPresinHg, mach);
//       // const totalInletTempMachRise = 1.0 + 0.2 * Math.pow(mach, 2);
//       // const totalInletPressureMachRise = Math.pow(totalInletTempMachRise, 3.5);
//       // const deltaPressureRatio = ambientPressure / 29.92;
//       // const deltaTotalPressureRatio = deltaPressureRatio * totalInletPressureMachRise;
//       this.predictedThrust.set(BoeingPerformanceMath.calculateThrustRequired(aircraftWeight, cl) / 2);
//       this.predictedVerticalSpeed.set(BoeingPerformanceMath.calculateConstantSpeedVerticalSpeedFromThrust(
//         2 * this.actualThrust.get(), this.tas.get(), aircraftWeight, cl));
//       const predictedGrossThrust = BoeingPerformanceMath.findGrossThrustFromNetThrust(
//         this.predictedThrust.get(),
//         mach,
//         this.indicatedAltitude.get());
//       // this.predictedRamDrag.set(predictedGrossThrust - this.predictedThrust.get());
//       this.predictedFuelFlow.set(BoeingPerformanceMath.calculateFuelFlowFromThrust(predictedGrossThrust));
//       this.predictedIdleThrust.set(BoeingPerformanceMath.calculateIdleThrust(ambientTemperature, mach));
//       this.endranceSpeed.set(BoeingPerformanceMath.calculateBestEconSpeed(aircraftWeight, this.indicatedAltitude.get()));
//       this.optimumAltAtCurrentMach.set(BoeingPerformanceMath.calcOptimumAltitudeFromCruiseMach(.9, aircraftWeight));
//       this.optimumMachAtCurrentAlt.set(BoeingPerformanceMath.calcOptimumCruiseMachFromAltitude(41000, aircraftWeight));
//       const optAltMach = BoeingPerformanceMath.calcOptimumCruiseMachAndAltitude(aircraftWeight);
//       this.optimumAlt.set(optAltMach[0]);
//       this.optimumMach.set(optAltMach[1]);
//     }, true);
//   }
//   /** @inheritDoc */
//   protected onPause(): void {
//     this.time.pause();
//   }
//   /** @inheritDoc */
//   protected onResume(): void {
//     this.time.resume();
//   }
//   /** @inheritDoc */
//   render(): FmcRenderTemplate[] {
//     return [
//       [
//         ['', '1/1', 'VNAV DEBUG'],
//         [' ACTUAL N1', 'L/Dmax SPEED '],
//         [this.N1Display, this.BestEnduranceSpeedDisplay],
//         [' ACTUAL FUEL FLOW', 'PREDICTED FUEL FLOW '],
//         [this.FuelFlowDisplay, this.FuelFlowPredictedDisplay],
//         [' ACTUAL THRUST', 'PREDICTED THRUST '],
//         [this.ThrustActualDisplay, this.ThrustPredictionDisplay],
//         [' ECON M AT ALT', 'PREDICTED VS '],
//         [this.OptMachAtAltDisplay, this.VerticalSpeedPredictedDisplay],
//         [' ECON ALT AT M', 'PREDICTED IDLE THRUST'],
//         [this.OptAltAtMachDisplay, this.PredictedIdleThrustDisplay],
//         // ['--------------------------------------'],
//         ['', '', 'ECON ALT AND MACH'],
//         [this.OptAltDisplay, this.OptMachDisplay],
//       ]
//     ];
//   }
// }

/** Boeing VNAV pages. */
class BoeingVnavPage extends BoeingFmcPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback, engineData, engineMetric, spacing, showClbForecastPageLink) {
        super(bus, screen, fms, renderCallback);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.engineData = engineData;
        this.engineMetric = engineMetric;
        this.spacing = spacing;
        this.showClbForecastPageLink = showClbForecastPageLink;
        this.ClbForecastLink = this.showClbForecastPageLink ?
            PageLinkField.createLink(this, '<CLB FORECAST', '/clb-forecast') : '';
        this.DesForecastLink = PageLinkField.createLink(this, 'FORECAST>', '/des-forecast');
        this.perfPlan = this.fms.performancePlanProxy;
        this.gameUnit = ConsumerSubject.create(this.bus.getSubscriber().on('game_units_metric'), false);
        this.gameUnitSub = this.gameUnit.map((metric) => metric ? UnitType.KILOGRAM : UnitType.POUND);
        this.indicatedAlt = ConsumerSubject.create(this.bus.getSubscriber()
            .on('indicated_alt').atFrequency(1), 0);
        this.flightPhase = ConsumerSubject.create(this.bus.getSubscriber()
            .on('fms_operating_phase').whenChanged(), FmsOperatingPhase.PREFLIGHT);
        this.speedSub = this.bus.getSubscriber();
        this.fmsTargetCasNumber = ConsumerSubject.create(this.speedSub
            .on('fms_speed_active_target_ias'), 0);
        this.fmsTargetMachNumber = ConsumerSubject.create(this.speedSub
            .on('fms_speed_active_target_mach'), 0);
        this.fmsTargetIsMach = ConsumerSubject.create(this.speedSub
            .on('fms_speed_active_target_is_mach'), false);
        this.fmsTargetCas = MappedSubject.create(([cas, isMach]) => isMach ? null : cas, this.fmsTargetCasNumber, this.fmsTargetIsMach);
        this.fmsTargetMach = MappedSubject.create(([mach, isMach]) => isMach ? mach : null, this.fmsTargetMachNumber, this.fmsTargetIsMach);
        this.fmsTargetAlt = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vnav_next_constraint_altitude').whenChanged(), 0);
        this.cruiseSelSpeedUnit = Subject.create('cas');
        this.climbSpeed = MappedSubject.create(([mode, econCas, selectCas]) => mode === SpeedMode.ECON ? econCas : selectCas, this.perfPlan.speedClimbMode, this.perfPlan.speedClimbEconCas, this.perfPlan.speedClimbSelectCas);
        this.descentSpeed = MappedSubject.create(([mode, econCas, selectCas]) => mode === SpeedMode.ECON ? econCas : selectCas, this.perfPlan.speedDescentMode, this.perfPlan.speedDescentEconCas, this.perfPlan.speedDescentSelectCas);
        // TODO Replace map function below with the commented-out one once `cruiseRequiredTpr` in the perf plan is being updated
        this.showTpr = MappedSubject.create(() => false, 
        // ([inMod, phase]: readonly [boolean, FmsOperatingPhase]): boolean => !inMod && phase === FmsOperatingPhase.CRUISE,
        this.fms.planInMod, this.flightPhase);
        this.sensedFuelWeight = ConsumerSubject.create(this.bus.getSubscriber()
            .on('fuel_total_weight').atFrequency(1), 0);
        this.optimumAltitude = MappedSubject.create(([zfw, fuelWeight]) => zfw === null ? null : this.engineData.getOptimumAltitude(zfw + fuelWeight), this.perfPlan.manualZfw, this.sensedFuelWeight);
        this.maximumPerfAltitude = MappedSubject.create(([zfw, fuelWeight]) => zfw === null ? null : this.engineData.getMaximumAltitude(zfw + fuelWeight), this.perfPlan.manualZfw, this.sensedFuelWeight);
        this.currentLegIndex = ConsumerSubject.create(this.bus.getSubscriber()
            .on('lnavdata_nominal_leg_index').whenChanged(), -1);
        this.endOfDescentLegIndex = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vnav_bod_global_leg_index').whenChanged(), -1);
        this.endOfDescentLegIsActive = MappedSubject.create(([currentLeg, eodLeg]) => currentLeg === eodLeg, this.currentLegIndex, this.endOfDescentLegIndex);
        this.endOfDescentVertDispData = MappedSubject.create(([globalLegIndex]) => this.fms.vnavData.getVerticalDisplayData(globalLegIndex), this.endOfDescentLegIndex, this.fmsTargetAlt);
        this.endOfDescentLegDef = this.endOfDescentLegIndex.map(globalLegIndex => this.fms.getPlanForFmcRender().tryGetLeg(globalLegIndex));
        this.descentWaypointAlt = MappedSubject.create(([legDef, indicatedAlt]) => {
            if (legDef) {
                const alt1Ft = UnitType.METER.convertTo(legDef.verticalData.altitude1, UnitType.FOOT);
                if (legDef.verticalData.altDesc === AltitudeRestrictionType.At ||
                    legDef.verticalData.altDesc === AltitudeRestrictionType.AtOrAbove ||
                    legDef.verticalData.altDesc === AltitudeRestrictionType.AtOrBelow) {
                    return alt1Ft;
                }
                else if (legDef.verticalData.altDesc === AltitudeRestrictionType.Between) {
                    const alt2Ft = UnitType.METER.convertTo(legDef.verticalData.altitude2, UnitType.FOOT);
                    const max = Math.max(alt1Ft, alt2Ft);
                    const min = Math.min(alt1Ft, alt2Ft);
                    return indicatedAlt > max ? max : min;
                }
                else {
                    return null;
                }
            }
            else {
                return null;
            }
        }, this.fms.vnavData.currentDescentConstraintLegDef, this.indicatedAlt);
        this.refVertBearingWpt = Subject.create(null);
        this.refVertBearingWptAlt = Subject.create(null);
        this.refVertBearingWptManual = Subject.create(null);
        this.refVertBearingWptAltManual = Subject.create(null);
        this.distToWaypointRad = Subject.create(null);
        this.groundSpeed = ConsumerSubject.create(this.bus.getSubscriber()
            .on('ground_speed').atFrequency(1), 0);
        this.verticalSpeed = ConsumerSubject.create(this.bus.getSubscriber()
            .on('vertical_speed').atFrequency(1), 0);
        this.desDirAvailable = ConsumerSubject.create(this.bus.getSubscriber().on('vnav_boeing_des_dir_available'), false);
        this.desNowAvailable = ConsumerSubject.create(this.bus.getSubscriber().on('vnav_boeing_des_now_available'), false);
        this.constraintHeaderFactory = (vnavConstraintLegDefSub) => new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.ConstraintHeader,
            },
        }).bind(vnavConstraintLegDefSub);
        this.constraintFieldFactory = (page, vnavConstraintSub, vnavConstraintDisplayDataSub) => new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: this.constraintFormatter(page),
            },
            onDelete: async () => {
                const vnavConstraint = vnavConstraintSub.get();
                if (vnavConstraint) {
                    this.fms.setUserConstraint(vnavConstraint.index, {
                        altDesc: AltitudeRestrictionType.Unused,
                        altitude1: 0,
                        altitude2: 0,
                        speed: 0,
                        speedDesc: SpeedRestrictionType.Unused,
                        speedUnit: SpeedUnit.IAS,
                        displayAltitude1AsFlightLevel: false,
                        displayAltitude2AsFlightLevel: false,
                    });
                }
                return true;
            }
        }).bind(vnavConstraintDisplayDataSub);
        this.TitleField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([subPageIndex, planInMod, cruiseAlt, flightPhase, fmsTargetSpeedCas, fmsTargetSpeedMach, currentFmsClimbSpeedMode, currentFmsCruiseSpeedMode, currentFmsDescentSpeedMode]) => {
                    let prefixStr = '';
                    let speedStr = '';
                    let phaseStr = '';
                    let currentSpeedMode;
                    switch (flightPhase) {
                        case FmsOperatingPhase.TAKEOFF:
                        case FmsOperatingPhase.CLIMB:
                            currentSpeedMode = currentFmsClimbSpeedMode;
                            break;
                        case FmsOperatingPhase.CRUISE:
                            currentSpeedMode = currentFmsCruiseSpeedMode;
                            break;
                        case FmsOperatingPhase.DESCENT:
                        case FmsOperatingPhase.APPROACH:
                            currentSpeedMode = currentFmsDescentSpeedMode;
                            break;
                    }
                    let calculatedSpeedStr = '';
                    switch (currentSpeedMode) {
                        case CurrentFmsSpeedMode.ECON:
                        case CurrentFmsSpeedMode.EO:
                        case CurrentFmsSpeedMode.MCP_SPD:
                        case CurrentFmsSpeedMode.LIM_SPD:
                            // TODO Handle XXX CRZ CLB and XXX CRZ DES (See Cruise page CRZ ALT field 1L)
                            calculatedSpeedStr = currentSpeedMode;
                            break;
                        case CurrentFmsSpeedMode.CAS:
                            calculatedSpeedStr = `${fmsTargetSpeedCas}KT`;
                            break;
                        case CurrentFmsSpeedMode.MACH:
                            calculatedSpeedStr = `M.${(fmsTargetSpeedMach * 1000).toFixed(0)}`;
                            break;
                    }
                    switch (subPageIndex) {
                        case 1: {
                            phaseStr = 'CLB';
                            if (flightPhase === FmsOperatingPhase.TAKEOFF || flightPhase === FmsOperatingPhase.CLIMB) {
                                prefixStr = 'ACT';
                            }
                            switch (flightPhase) {
                                case FmsOperatingPhase.TAKEOFF:
                                    // Don't show CAS if it's still the default value of -1
                                    speedStr = fmsTargetSpeedCas > 0 ? `${fmsTargetSpeedCas}KT` : calculatedSpeedStr;
                                    break;
                                case FmsOperatingPhase.CLIMB:
                                    if (cruiseAlt !== null) {
                                        speedStr = calculatedSpeedStr;
                                    }
                                    break;
                            }
                            break;
                        }
                        case 2: {
                            phaseStr = 'CRZ';
                            if (flightPhase === FmsOperatingPhase.CRUISE) {
                                prefixStr = 'ACT';
                                speedStr = calculatedSpeedStr;
                            }
                            break;
                        }
                        case 3: {
                            phaseStr = 'DES';
                            if (flightPhase === FmsOperatingPhase.DESCENT || flightPhase === FmsOperatingPhase.APPROACH) {
                                prefixStr = 'ACT';
                                speedStr = calculatedSpeedStr;
                            }
                            break;
                        }
                    }
                    // MOD should supersede ACT as a prefix
                    if (planInMod) {
                        prefixStr = 'MOD[r-white]';
                    }
                    return `${prefixStr} ${speedStr} ${phaseStr}`.trim();
                },
            }
        }).bind(MappedSubject.create(this.screen.currentSubpageIndex, this.fms.planInMod, this.perfPlan.cruiseAltitude, this.flightPhase, this.fmsTargetCasNumber, this.fmsTargetMachNumber, this.fms.vnavData.currentFmsClimbSpeedMode, this.fms.vnavData.currentFmsCruiseSpeedMode, this.fms.vnavData.currentFmsDescentSpeedMode));
        /** Climb */
        this.ClimbCrzAltField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.Altitude,
                format: B787FmcFormatters.Altitude('input', this.perfPlan.transitionAltitude, this.fmsTargetAlt),
                nullValueString: inputBox('□□□□□'),
            },
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bind(this.perfPlan.cruiseAltitude);
        this.ClimbSpeedHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (speedMode) => {
                    return speedMode === SpeedMode.ECON ? ' ECON SPD' : ' SEL SPD';
                }
            },
        }).bind(this.perfPlan.speedClimbMode);
        this.ClimbEconSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasMachPair('left', 'cas_mach'),
                format: B787FmcFormatters.AirspeedCasAndOrMach('input', 'cas_mach', this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedClimbEconCas, this.perfPlan.speedClimbEconMach), ([cas, mach]) => {
            cas !== null && this.perfPlan.speedClimbSelectCas.set(cas);
            mach !== null && this.perfPlan.speedClimbSelectMach.set(mach);
            this.perfPlan.speedClimbMode.set(SpeedMode.SEL);
            this.invalidate();
        }));
        this.ClimbSelectSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasMachPair('left', 'cas_mach'),
                format: B787FmcFormatters.AirspeedCasAndOrMach('input', 'cas_mach', this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedClimbSelectCas, this.perfPlan.speedClimbSelectMach), ([cas, mach]) => {
            cas !== null && this.perfPlan.speedClimbSelectCas.set(cas);
            mach !== null && this.perfPlan.speedClimbSelectMach.set(mach);
        }));
        this.ClimbSpeedTransitionField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([casLimit, altLimit, indicatedAlt]) => {
                    const formatter = B787FmcFormatters.AirspeedCasAltitudePair('display', this.perfPlan.transitionAltitude, this.fmsTargetCas);
                    return formatter(altLimit && altLimit < indicatedAlt ? [null, null] : [casLimit, altLimit]);
                },
            },
            onDelete: async () => {
                this.perfPlan.climbSpeedLimitCas.set(null);
                this.perfPlan.climbSpeedLimitAltitude.set(null);
                return true;
            },
        }).bind(MappedSubject.create(this.perfPlan.climbSpeedLimitCas, this.perfPlan.climbSpeedLimitAltitude, this.indicatedAlt));
        this.ClimbSpeedRestrictionField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                // TODO need to consider if only Mach climb speed set here
                parse: B787FmcParsers.SpeedRestrictionClimb('left', this.climbSpeed, this.indicatedAlt, this.perfPlan.cruiseAltitude),
                format: ([restrCas, restrAlt]) => {
                    const formatter = B787FmcFormatters.AirspeedCasAltitudePair('input', this.perfPlan.transitionAltitude, this.fmsTargetCas);
                    return formatter([restrCas, restrAlt]);
                },
            }),
            onDelete: async () => {
                this.perfPlan.climbSpeedRestrCas.set(null);
                this.perfPlan.climbSpeedRestrAltitude.set(null);
                return true;
            },
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.climbSpeedRestrCas, this.perfPlan.climbSpeedRestrAltitude), ([cas, alt]) => {
            this.perfPlan.climbSpeedRestrCas.set(cas);
            this.perfPlan.climbSpeedRestrAltitude.set(alt);
        }));
        this.ClimbEconModeField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: () => '<ECON',
            },
            onSelected: async () => {
                this.perfPlan.speedClimbSelectCas.set(null);
                this.perfPlan.speedClimbSelectMach.set(null);
                this.perfPlan.speedClimbMode.set(SpeedMode.ECON);
                const restrictionCas = this.perfPlan.climbSpeedRestrCas.get();
                const climbEconCas = this.perfPlan.speedClimbEconCas.get();
                if (restrictionCas && climbEconCas && climbEconCas < restrictionCas) {
                    this.perfPlan.climbSpeedRestrCas.set(null);
                    this.perfPlan.climbSpeedRestrAltitude.set(null);
                }
                return true;
            },
        }).bind(this.perfPlan.speedClimbMode);
        this.ClimbConstraintHeader = this.constraintHeaderFactory(this.fms.vnavData.currentClimbConstraintLegDef);
        this.ClimbConstraintField = this.constraintFieldFactory('CLB', this.fms.vnavData.currentClimbConstraint, this.fms.vnavData.currentClimbConstraintDisplayData);
        // TODO ERROR at Waypoint
        // 'ERROR'
        // '350[d-text]LO[s-text] 2[d-text]LONG[s-text]'
        this.TransitionAltitudeField = new TextInputField(this, {
            formatter: new AltitudeFeetInputFormat('input'),
            deleteAllowed: false,
        }).bind(this.perfPlan.transitionAltitude);
        // TODO Uncomment if or when max climb speed angle is implemented
        /*
        private readonly MaxAngleClimbSpeedField = new DisplayField(this, {
          formatter: {
            nullValueString: '---',
            format: B787FmcFormatters.AirspeedCas('display'),
          },
          onSelected: async (): Promise<string> =>
            B787FmcFormatters.AirspeedCas('display')(this.perfPlan.climbSpeedMaxAngle.get()),
        }).bind(this.perfPlan.climbSpeedMaxAngle);
        */
        // TODO RTA/ECON
        /** Cruise */
        this.CruiseCrzAltField = new TextInputField(this, {
            formatter: {
                parse: B787FmcParsers.Altitude,
                format: (cruiseAlt) => {
                    if (this.flightPhase.get() === FmsOperatingPhase.CRUISE) {
                        return B787FmcFormatters.Altitude('input', this.perfPlan.transitionAltitude, this.perfPlan.cruiseAltitude)(cruiseAlt);
                    }
                    else {
                        return B787FmcFormatters.Altitude('input', this.perfPlan.transitionAltitude)(cruiseAlt);
                    }
                },
                nullValueString: inputBox('□□□□□'),
            },
            onModified: async (cruiseAlt) => {
                // TODO A new entry changes the page title to CRZ CLB or CRZ DES
                const maxPerfAlt = this.maximumPerfAltitude.get();
                if (cruiseAlt && maxPerfAlt && cruiseAlt > maxPerfAlt) {
                    const maxAltStr = B787FmcFormatters.Altitude('display', this.perfPlan.transitionAltitude)(maxPerfAlt);
                    this.publishMaxAltMessage(maxAltStr);
                }
                // The entry should still be accepted even if it's above the max performance altitude.
                return false;
            },
            onDelete: async () => Promise.reject(BoeingFmcErrorKeys.InvalidDelete),
        }).bind(this.perfPlan.cruiseAltitude);
        this.CruiseSpeedHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([crzAlt, speedMode]) => crzAlt !== null ? (speedMode === SpeedMode.ECON ? ' ECON SPD' : ' SEL SPD') : '',
            }
        }).bind(MappedSubject.create(this.perfPlan.cruiseAltitude, this.perfPlan.speedCruiseMode));
        this.CruiseEconSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasOrMach,
                format: B787FmcFormatters.AirspeedCasOrMach(this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedCruiseEconCas, this.perfPlan.speedCruiseEconMach, this.perfPlan.speedCruiseEconUnit), ([cas, mach]) => {
            // Setting the speed manually sets either the SELECT CAS or
            // Mach value and changes the speed mode from ECON to SELECT
            this.onCruiseSpeedModified(cas, mach);
            this.perfPlan.speedCruiseMode.set(SpeedMode.SEL);
            this.invalidate();
        }));
        this.CruiseSelectSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasOrMach,
                format: B787FmcFormatters.AirspeedCasOrMach(this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedCruiseSelectCas, this.perfPlan.speedCruiseSelectMach, this.cruiseSelSpeedUnit), ([cas, mach]) => this.onCruiseSpeedModified(cas, mach)));
        // TODO step alts
        this.AtHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format([todDistance, destDistance]) {
                    if (todDistance >= 0 && destDistance >= 0) {
                        const todDistanceNM = UnitType.NMILE.convertFrom(todDistance, UnitType.METER);
                        const destDistanceNm = UnitType.NMILE.convertFrom(destDistance, UnitType.METER);
                        if (todDistanceNM < 200 || destDistanceNm < 500) {
                            return 'TO T/D';
                        }
                    }
                    return '';
                }
            }
        }).bind(MappedSubject.create(this.fms.vnavData.distanceTod, this.fms.vnavData.distanceDest));
        this.AtDataField = new DisplayField(this, {
            formatter: {
                nullValueString: '----z',
                /** @inheritDoc */
                format(value) {
                    const todDistance = value[0];
                    const todDistanceNm = todDistance !== -1 ? UnitType.NMILE.convertFrom(todDistance, UnitType.METER) : null;
                    const destDistance = value[1];
                    const destDistanceNm = destDistance !== -1 ? UnitType.NMILE.convertFrom(destDistance, UnitType.METER) : null;
                    const todEta = value[2];
                    const withinDistance = todDistanceNm && destDistanceNm && (todDistanceNm < 200 || destDistanceNm < 500);
                    if (withinDistance && todEta !== null && Number.isFinite(todEta)) {
                        const etaStr = BoeingVnavPage.ETA_FORMATTER(todEta);
                        const distanceStr = todDistanceNm.toFixed(0).padStart(4, ' ');
                        return `${etaStr}/[d-text]${distanceStr}[d-text]NM[s-text]`;
                    }
                    else {
                        return '----[d-text]z/----[d-text]NM[s-text]';
                    }
                },
            }
        }).bind(MappedSubject.create(this.fms.vnavData.distanceTod, this.fms.vnavData.distanceDest, this.fms.vnavData.todEta));
        this.TPRField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: NumberFormatter.create({ precision: .1 }),
            }
        }).bind(this.perfPlan.cruiseRequiredTpr);
        this.StepSizeField = new DisplayField(this, {
            formatter: {
                format: () => 'ICAO[disabled]',
                nullValueString: '',
            }
        }).bind(this.perfPlan.stepSize);
        this.CruiseEconModeField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: () => '<ECON',
            },
            onSelected: async () => {
                this.perfPlan.speedCruiseSelectCas.set(null);
                this.perfPlan.speedCruiseSelectMach.set(null);
                this.perfPlan.speedCruiseMode.set(SpeedMode.ECON);
                return true;
            },
        }).bind(this.perfPlan.speedCruiseMode);
        // TODO STEP TO
        // TODO AT, AVAIL AT, TO T/D, TO FLXXX
        this.DestPredictionsHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format(value) {
                    const identStr = ICAO.getIdent(value);
                    return `${identStr} ETA/FUEL`;
                }
            }
        }).bind(this.fms.vnavData.destAirportFacility);
        this.DestPredictionsField = new DisplayField(this, {
            formatter: {
                nullValueString: '----z/ --.-',
                /** @inheritDoc */
                format([predictions, unit]) {
                    const etaStr = (predictions === null || predictions === void 0 ? void 0 : predictions.valid) && Number.isFinite(predictions.estimatedTimeOfArrival) ?
                        DateTimeFormatter.create('{HH}{mm}z')(predictions.estimatedTimeOfArrival * 1000) : '----z';
                    let fobStr;
                    if ((predictions === null || predictions === void 0 ? void 0 : predictions.valid) && Number.isFinite(predictions.fob)) {
                        const weightInUserUnits = unit.convertFrom(predictions.fob, UnitType.POUND);
                        fobStr = (weightInUserUnits / 1000).toFixed(1).padStart(5, ' ');
                    }
                    else {
                        fobStr = ' --.-';
                    }
                    return `${etaStr}/${fobStr}`;
                }
            }
        }).bind(MappedSubject.create(this.fms.vnavData.destinationPredictions, this.gameUnitSub));
        this.OptMaxRecmdAltField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([optAlt, maxAlt]) => {
                    const altFormatter = B787FmcFormatters.Altitude('display', this.perfPlan.transitionAltitude);
                    const optAltStr = optAlt === null ? '     ' : altFormatter(optAlt);
                    const maxAltStr = maxAlt === null ? '     ' : altFormatter(maxAlt);
                    const recmdAltStr = '     '; // TODO Recommended Altitude
                    const spacing = `${' '.repeat(this.spacing - 1)}`;
                    return `${optAltStr}${spacing}${maxAltStr}${spacing}${recmdAltStr}`;
                }
            }
        }).bind(MappedSubject.create(this.optimumAltitude, this.maximumPerfAltitude));
        /** Descent */
        this.EndOfDescentAtField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([dispData, legDefinition, eodLegIsActive]) => {
                    if (dispData && (legDefinition === null || legDefinition === void 0 ? void 0 : legDefinition.name)) {
                        const formatter = B787FmcFormatters.Altitude('display', this.perfPlan.transitionLevel);
                        const altNumeral = formatter(ArrayUtils.last(dispData.altitudes));
                        const altSuffix = ArrayUtils.last(dispData.altitudeSuffixes);
                        const altStr = `${altNumeral}${altSuffix}[${dispData.altitudeIsCommanded ? 'magenta' : 'd-text'}]`;
                        const identStr = `${legDefinition.name}[${eodLegIsActive ? 'magenta' : 'd-text'}]`;
                        return `${altStr} ${identStr}`;
                    }
                    else {
                        return '';
                    }
                }
            }
        }).bind(MappedSubject.create(this.endOfDescentVertDispData, this.endOfDescentLegDef, this.endOfDescentLegIsActive));
        this.DescSpeedHeader = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (speedMode) => speedMode === SpeedMode.ECON ? ' ECON SPD' : ' SEL SPD',
            }
        }).bind(this.perfPlan.speedDescentMode);
        this.DescEconSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasMachPair('left', 'mach_cas'),
                format: B787FmcFormatters.AirspeedCasAndOrMach('input', 'mach_cas', this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedDescentEconCas, this.perfPlan.speedDescentEconMach), ([cas, mach]) => {
            this.perfPlan.speedDescentSelectCas.set(cas);
            this.perfPlan.speedDescentSelectMach.set(mach);
            this.perfPlan.speedDescentMode.set(SpeedMode.SEL);
            this.invalidate();
        }));
        this.DescSelectSpeedField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                parse: B787FmcParsers.AirspeedCasMachPair('left', 'mach_cas'),
                format: B787FmcFormatters.AirspeedCasAndOrMach('input', 'mach_cas', this.fmsTargetCas, this.fmsTargetMach),
            }),
            onDelete: async () => true,
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.speedDescentSelectCas, this.perfPlan.speedDescentSelectMach), ([cas, mach]) => {
            cas !== null && this.perfPlan.speedDescentSelectCas.set(cas);
            mach !== null && this.perfPlan.speedDescentSelectMach.set(mach);
        }));
        this.DescSpeedTransitionField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([casLimit, altLimit, indicatedAlt]) => {
                    const formatFunc = B787FmcFormatters.AirspeedCasAltitudePair('display', this.perfPlan.transitionLevel, this.fmsTargetCas);
                    const formattedVal = formatFunc([casLimit, altLimit]);
                    const descentSpeed = this.descentSpeed.get();
                    const restrictionAlt = this.perfPlan.descentSpeedRestrAltitude.get();
                    const belowTransitionAlt = altLimit !== null && indicatedAlt < altLimit;
                    const restrictionBelowTransitionAlt = restrictionAlt !== null && altLimit !== null && restrictionAlt < altLimit;
                    const speedLimitWasDeleted = this.perfPlan.descentSpeedLimitCas.get() === null;
                    const targetedSpeedIsSlowerThanLimit = descentSpeed !== null && casLimit !== null && descentSpeed <= casLimit;
                    const blankValue = belowTransitionAlt || restrictionBelowTransitionAlt || speedLimitWasDeleted || targetedSpeedIsSlowerThanLimit;
                    return blankValue ? '' : formattedVal;
                },
            },
            onDelete: async () => {
                this.perfPlan.descentSpeedLimitCas.set(null);
                this.perfPlan.descentSpeedLimitAltitude.set(null);
                return true;
            },
        }).bind(MappedSubject.create(this.perfPlan.descentSpeedLimitCas, this.perfPlan.descentSpeedLimitAltitude, this.indicatedAlt));
        this.DescSpeedRestrictionField = new TextInputField(this, {
            formatter: new ConfigurableFormatter({
                // TODO need to consider if only Mach descent speed set here
                parse: B787FmcParsers.SpeedRestrictionDescent('left', this.descentSpeed, this.indicatedAlt, this.perfPlan.cruiseAltitude, this.endOfDescentVertDispData, this.perfPlan.climbSegmentExists),
                format: ([restrCas, restrAlt, currentAlt]) => {
                    const formatFunc = B787FmcFormatters.AirspeedCasAltitudePair('input', this.perfPlan.transitionLevel, this.fmsTargetCas);
                    const formattedVal = formatFunc(restrAlt !== null && restrAlt <= currentAlt ? [restrCas, restrAlt] : [null, null]);
                    const descentSpeed = this.descentSpeed.get();
                    return (descentSpeed !== null && restrCas !== null && descentSpeed <= restrCas) ? '' : formattedVal;
                },
            }),
            onDelete: async () => {
                this.perfPlan.descentSpeedRestrCas.set(null);
                this.perfPlan.descentSpeedRestrAltitude.set(null);
                return true;
            },
        }).bindSource(new DataInterface(MappedSubject.create(this.perfPlan.descentSpeedRestrCas, this.perfPlan.descentSpeedRestrAltitude, this.indicatedAlt), ([cas, alt]) => {
            this.perfPlan.descentSpeedRestrCas.set(cas);
            this.perfPlan.descentSpeedRestrAltitude.set(alt);
        }));
        this.DescEconModeField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: () => '<ECON',
            },
            onSelected: async () => {
                this.perfPlan.speedDescentSelectCas.set(null);
                this.perfPlan.speedDescentSelectMach.set(null);
                this.perfPlan.speedDescentMode.set(SpeedMode.ECON);
                const restrictionCas = this.perfPlan.descentSpeedRestrCas.get();
                const descEconCas = this.perfPlan.speedDescentEconCas.get();
                if (restrictionCas && descEconCas && descEconCas < restrictionCas) {
                    this.perfPlan.descentSpeedRestrCas.set(null);
                    this.perfPlan.descentSpeedRestrAltitude.set(null);
                }
                return true;
            }
        }).bind(this.perfPlan.speedDescentMode);
        this.DescentConstraintHeader = this.constraintHeaderFactory(this.fms.vnavData.currentDescentConstraintLegDef);
        this.DescentConstraintField = this.constraintFieldFactory('DES', this.fms.vnavData.currentDescentConstraint, this.fms.vnavData.currentDescentConstraintDisplayData);
        this.WaypointAltitudeField = new TextInputField(this, {
            formatter: {
                parse: async (input) => {
                    var _a, _b, _c;
                    const [dataPairFacStr, dataPairAltStr] = (_a = B787FmcParsers.DataPair('right', input)) !== null && _a !== void 0 ? _a : [null, null];
                    // If the input was a valid data pair, attempt to parse the first half into a facility
                    const parsedInputFacility = dataPairFacStr !== null ?
                        await this.screen.selectWaypointByIdent(dataPairFacStr, this.fms.ppos) : null;
                    // If the data pair produced a valid facility, use it; otherwise attempt to parse the whole input string as a facility
                    const parsedFacility = parsedInputFacility !== null && parsedInputFacility !== void 0 ? parsedInputFacility : await this.screen.selectWaypointByIdent(input, this.fms.ppos);
                    // TODO Attempt to parse a pilot waypoint
                    /*
                    if (!parsedFacility) {
                      const result = await BoeingPilotWaypointUtils.createFromScratchpadEntry(
                        this.fms,
                        (ident: string, refPos: GeoPoint) => this.screen.selectWaypointByIdent(ident, refPos),
                        facilityStr,
                      );
            
                      if (result) {
                        const [userFacility] = result;
                        this.fms.addUserFacility(userFacility);
                        parsedFacility = userFacility;
                      }
                    }
                    */
                    // If the input was a valid data pair, attempt to parse the second half into an altitude
                    const parsedInputAlt = dataPairAltStr !== null ? B787FmcParsers.Altitude(dataPairAltStr) : null;
                    // If the data pair produced a valid altitude, use it; otherwise attempt to parse the whole input string as an altitude
                    const parsedAlt = parsedInputAlt !== null && parsedInputAlt !== void 0 ? parsedInputAlt : B787FmcParsers.Altitude(input);
                    // Invalid entry if neither value can be parsed
                    if (parsedFacility === null && parsedAlt === null) {
                        return null;
                    }
                    // Try to use the input value first, an existing manual entry next, falling back to the constraint value last
                    const facility = (_b = parsedFacility !== null && parsedFacility !== void 0 ? parsedFacility : this.refVertBearingWptManual.get()) !== null && _b !== void 0 ? _b : this.refVertBearingWpt.get();
                    const alt = (_c = parsedAlt !== null && parsedAlt !== void 0 ? parsedAlt : this.refVertBearingWptAltManual.get()) !== null && _c !== void 0 ? _c : this.refVertBearingWptAlt.get();
                    // Accept a single-part entry only if the other part already exists
                    if (facility !== null && alt !== null) {
                        return [parsedFacility, parsedAlt];
                    }
                    return null;
                },
                nullValueString: '',
                format: ([constraintFac, constraintAlt, manualFac, manualAlt]) => {
                    const formatter = B787FmcFormatters.Altitude('display', this.perfPlan.transitionLevel);
                    const fac = manualFac !== null && manualFac !== void 0 ? manualFac : constraintFac;
                    const alt = manualAlt !== null && manualAlt !== void 0 ? manualAlt : constraintAlt;
                    const wptStr = fac === null ? '-----' : ICAO.getIdent(fac.icao);
                    const altStr = alt === null ? '-----' : formatter(alt);
                    return inputBox(`${wptStr}/${altStr}`.padStart(13, ' '));
                }
            },
            onModified: async ([facility, alt]) => {
                facility !== null && this.refVertBearingWptManual.set(facility);
                alt !== null && this.refVertBearingWptAltManual.set(alt);
                return true;
            },
            onDelete: async () => {
                this.refVertBearingWptManual.set(null);
                this.refVertBearingWptAltManual.set(null);
                return true;
            },
        }).bind(MappedSubject.create(this.refVertBearingWpt, this.refVertBearingWptAlt, this.refVertBearingWptManual, this.refVertBearingWptAltManual));
        this.FpaVbVsField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: B787FmcFormatters.FpaVbVs(this.spacing),
            }
        }).bind(MappedSubject.create(this.distToWaypointRad, MappedSubject.create(([constraint, manual]) => manual !== null && manual !== void 0 ? manual : constraint, this.refVertBearingWptAlt, this.refVertBearingWptAltManual), this.indicatedAlt, this.groundSpeed, this.verticalSpeed));
        // DES NOW / DES DIR (pg3 LSK R6)
        this.DesDirNowField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: ([desDirAvailable, desNowAvailable]) => desNowAvailable ? 'DES NOW>' : desDirAvailable ? 'DES DIR>' : '',
            },
            onSelected: async () => {
                if (this.desNowAvailable.get()) {
                    const plan = this.fms.getPlanToModify();
                    this.fms.setVnavDesPending(plan.planIndex, BoeingVnavDescentPendingType.DesNow);
                    return true;
                }
                else if (this.desDirAvailable.get()) {
                    const plan = this.fms.getPlanToModify();
                    this.fms.setVnavDesPending(plan.planIndex, BoeingVnavDescentPendingType.DesDir);
                    return true;
                }
                return false;
            },
            disabled: () => !this.desDirAvailable.get() && !this.desNowAvailable.get(),
        }).bind(MappedSubject.create(this.desDirAvailable, this.desNowAvailable));
        this.EraseField = new DisplayField(this, {
            formatter: new SimpleStringFormat('<ERASE'),
            onSelected: async () => {
                this.fms.cancelMod();
                return true;
            },
        });
    }
    /** @inheritDoc */
    onInit() {
        // TODO Move to performance planner
        this.addBinding(MappedSubject.create(this.indicatedAlt, this.perfPlan.descentSpeedRestrAltitude)
            .sub(([currentAlt, restrictionAlt]) => {
            if (restrictionAlt !== null && currentAlt < restrictionAlt) {
                this.perfPlan.speedClimbSelectCas.set(this.perfPlan.descentSpeedRestrCas.get());
                this.perfPlan.speedClimbMode.set(SpeedMode.SEL);
            }
        }, true));
        this.addBinding(MappedSubject.create(this.perfPlan.speedClimbMode, this.perfPlan.speedCruiseMode, this.perfPlan.speedDescentMode).sub(() => this.invalidate()));
        this.addBinding(this.perfPlan.cruiseAltitude.sub(() => this.invalidate()));
        this.addBinding(this.showTpr.sub(() => this.invalidate()));
        this.addBinding(this.endOfDescentLegIndex.sub(() => this.invalidate()));
        this.addBinding(this.fms.perfIsInitialized.sub(() => this.invalidate()));
        this.addBinding(this.fms.planInMod.sub(() => this.invalidate()));
        // Auto-advance page to next phase of flight
        this.addBinding(this.flightPhase.sub((phase) => {
            const pageIndex = this.screen.currentSubpageIndex.get();
            if (phase === FmsOperatingPhase.CLIMB && pageIndex !== 1) {
                this.screen.navigateTo('/vnav#1');
            }
            else if (phase === FmsOperatingPhase.CRUISE && pageIndex !== 2) {
                this.screen.navigateTo('/vnav#2');
            }
            else if (phase === FmsOperatingPhase.DESCENT && pageIndex !== 3) {
                this.screen.navigateTo('/vnav#3');
            }
            this.invalidate();
        }));
        this.addBinding(this.fms.vnavData.currentDescentConstraintLegDef.sub((legDef) => {
            if (legDef) {
                this.fms.facLoader.getFacility(ICAO.getFacilityType(legDef.leg.fixIcao), legDef.leg.fixIcao)
                    .then((fac) => this.refVertBearingWpt.set(fac));
            }
        }));
        this.addBinding(this.descentWaypointAlt.pipe(this.refVertBearingWptAlt));
        this.addBinding(this.bus.getSubscriber().on('realTime').atFrequency(1 / 3).handle(() => {
            var _a;
            const waypoint = (_a = this.refVertBearingWptManual.get()) !== null && _a !== void 0 ? _a : this.refVertBearingWpt.get();
            this.distToWaypointRad.set(waypoint ? this.fms.ppos.distance(waypoint) : null);
        }));
    }
    /** @inheritDoc */
    onResume() {
        this.indicatedAlt.resume();
        this.flightPhase.resume();
        this.fmsTargetAlt.resume();
        this.fmsTargetCasNumber.resume();
        this.fmsTargetMachNumber.resume();
        this.fmsTargetIsMach.resume();
        this.sensedFuelWeight.resume();
        this.currentLegIndex.resume();
        this.endOfDescentLegIndex.resume();
        this.groundSpeed.resume();
        this.verticalSpeed.resume();
        this.desDirAvailable.resume();
        this.desNowAvailable.resume();
    }
    /** @inheritDoc */
    onPause() {
        this.indicatedAlt.pause();
        this.flightPhase.pause();
        this.fmsTargetAlt.pause();
        this.fmsTargetCasNumber.pause();
        this.fmsTargetMachNumber.pause();
        this.fmsTargetIsMach.pause();
        this.sensedFuelWeight.pause();
        this.currentLegIndex.pause();
        this.endOfDescentLegIndex.pause();
        this.groundSpeed.pause();
        this.verticalSpeed.pause();
        this.desDirAvailable.pause();
        this.desNowAvailable.pause();
    }
    /**
     * Logic run when the cruise speed is modified
     * @param cas The new CAS value
     * @param mach The new Mach value
     */
    onCruiseSpeedModified(cas, mach) {
        this.perfPlan.speedCruiseSelectCas.set(cas);
        this.perfPlan.speedCruiseSelectMach.set(mach);
        cas !== null && this.cruiseSelSpeedUnit.set('cas');
        mach !== null && this.cruiseSelSpeedUnit.set('mach');
    }
    /** @inheritDoc */
    render() {
        const climbSpeedModeIsEcon = this.perfPlan.speedClimbMode.get() === SpeedMode.ECON;
        const cruiseSpeedModeIsEcon = this.perfPlan.speedCruiseMode.get() === SpeedMode.ECON;
        const descentSpeedModeIsEcon = this.perfPlan.speedDescentMode.get() === SpeedMode.ECON;
        const cruiseAltExists = this.perfPlan.cruiseAltitude.get() !== null;
        const perfIsInit = this.fms.perfIsInitialized.get();
        const climbSpeedField = climbSpeedModeIsEcon ? this.ClimbEconSpeedField : this.ClimbSelectSpeedField;
        const cruiseSpeedField = cruiseSpeedModeIsEcon ? this.CruiseEconSpeedField : this.CruiseSelectSpeedField;
        const descSpeedHeader = cruiseAltExists ? this.DescSpeedHeader : '';
        const descSpeedField = cruiseAltExists ?
            (descentSpeedModeIsEcon ? this.DescEconSpeedField : this.DescSelectSpeedField) : '';
        const climbEconModeField = climbSpeedModeIsEcon ? '' : this.ClimbEconModeField;
        const cruiseEconModeField = cruiseSpeedModeIsEcon ? '' : this.CruiseEconModeField;
        const descEconModeField = descentSpeedModeIsEcon ? '' : this.DescEconModeField;
        const showClimbPage = this.flightPhase.get() <= FmsOperatingPhase.CLIMB;
        const showDescentPage = this.endOfDescentLegIndex.get() > 0;
        const showClimbSpeedRestr = this.perfPlan.cruiseAltitude.get() !== null && perfIsInit;
        const climbSpeedRestrHeader = showClimbSpeedRestr ? ' SPD RESTR' : '';
        const climbSpeedRestrField = showClimbSpeedRestr ? this.ClimbSpeedRestrictionField : '';
        // TODO Uncomment if or when max climb speed angle is implemented
        // const maxAngleClimbSpeedHeader = perfIsInit ? 'MAX ANGLE' : '';
        // const maxAngleClimbSpeedField = perfIsInit ? this.MaxAngleClimbSpeedField : '';
        const desSpeedRestrHeader = perfIsInit ? ' SPD RESTR' : '';
        const fpaVbVsHeader = `FPA${' '.repeat(this.spacing - 1)}V/B${' '.repeat(this.spacing)}V/S`;
        const optMaxRecmdAltHeader = `OPT${' '.repeat(this.spacing + 1)}MAX[s-text]${' '.repeat(this.spacing)}RECMD[s-text disabled]`;
        const tprField = this.showTpr.get() ? this.TPRField : '';
        const climbL6 = this.fms.planInMod.get() ? this.EraseField : this.ClbForecastLink;
        const cruiseL6 = this.fms.planInMod.get() ? this.EraseField : '<RTA PROGRESS[disabled]';
        const descentL6 = this.fms.planInMod.get() ? this.EraseField : '<OFFPATH DES[disabled]';
        return [
            // Climb
            showClimbPage ? [
                ['', this.PagingIndicator, this.TitleField],
                [' CRZ ALT', this.ClimbConstraintHeader],
                [this.ClimbCrzAltField, this.ClimbConstraintField],
                [this.ClimbSpeedHeader, ''],
                [climbSpeedField, ''],
                [' SPD TRANS', 'TRANS ALT'],
                [this.ClimbSpeedTransitionField, this.TransitionAltitudeField],
                [climbSpeedRestrHeader, ''],
                [climbSpeedRestrField, ''],
                ['--------------------------------------'],
                [climbEconModeField, 'ENG OUT>[disabled]'],
                [''],
                [climbL6, 'CLB DIR>[disabled]'],
            ] : [
                ['', this.PagingIndicator, this.TitleField],
                [' CRZ ALT',],
                [this.ClimbCrzAltField, ''],
                ['', ''],
                ['', ''],
                ['', 'TRANS ALT'],
                ['', this.TransitionAltitudeField],
                ['', ''],
                ['', ''],
                ['--------------------------------------'],
                ['', 'ENG OUT>[disabled]'],
                [''],
                [climbL6, ''],
            ],
            // Cruise
            [
                ['', this.PagingIndicator, this.TitleField],
                [' CRZ ALT', 'STEP TO[disabled]'],
                [this.CruiseCrzAltField, ''],
                [this.CruiseSpeedHeader, this.AtHeader],
                [cruiseSpeedField, this.AtDataField],
                [this.engineMetric, this.DestPredictionsHeader],
                [tprField, this.DestPredictionsField],
                [' STEP[disabled]', optMaxRecmdAltHeader],
                [this.StepSizeField, this.OptMaxRecmdAltField],
                ['--------------------------------------'],
                [cruiseEconModeField, 'ENG OUT>[disabled]'],
                [''],
                [cruiseL6, 'LRC>[disabled]'],
            ],
            // Descent
            showDescentPage ? [
                ['', this.PagingIndicator, this.TitleField],
                [' E/D AT', this.DescentConstraintHeader],
                [this.EndOfDescentAtField, this.DescentConstraintField],
                [descSpeedHeader, ''],
                [descSpeedField],
                [' SPD TRANS', 'WPT/ALT'],
                [this.DescSpeedTransitionField, this.WaypointAltitudeField],
                [desSpeedRestrHeader, fpaVbVsHeader],
                [this.DescSpeedRestrictionField, this.FpaVbVsField],
                ['--------------------------------------'],
                [descEconModeField, this.DesForecastLink],
                [''],
                [descentL6, this.DesDirNowField],
            ] : [
                ['', this.PagingIndicator, this.TitleField]
            ],
        ];
    }
}
BoeingVnavPage.ETA_FORMATTER = DateTimeFormatter.create('{HH}{mm}z');

/** Data store for the fix info page */
class BoeingFixInfoPageStore {
    constructor() {
        // all the data to render the current page
        this.currentFixIdent = Subject.create(null);
        this.currentFixIsDatabaseItem = Subject.create(false);
        /** [bearing, bearingPilotEntry, distance, distancePilotEntry] */
        this.currentFixBrgDist = Subject.create([null, false, null, false], BoeingFixInfoPageStore.ARRAY_EQUALITY);
        /** [bearing, bearingPilotEntry, distance, distancePilotEntry] */
        this.currentBrgDist = Array.from({ length: BoeingFixInfoPageStore.NUM_FIXES + 1 }, () => Subject.create([null, false, null, false], BoeingFixInfoPageStore.ARRAY_EQUALITY));
        this.currentEtaDtgAlt = Array.from({ length: BoeingFixInfoPageStore.NUM_FIXES + 1 }, () => Subject.create([null, null, null], BoeingFixInfoPageStore.ARRAY_EQUALITY));
        this.currentAbeamBearingDist = Subject.create([null, false, null, false], BoeingFixInfoPageStore.ARRAY_EQUALITY);
        this.currentAbeamPointCalculated = false;
        this.currentAbeamEtaDtgAlt = Subject.create([null, null, null], BoeingFixInfoPageStore.ARRAY_EQUALITY);
        /** predicted distance, eta (or null if altitude), altitude (or null if eta). eta and altitude are mutually exclusive */
        this.currentPredEtaAlt = Subject.create([null, null, null], BoeingFixInfoPageStore.ARRAY_EQUALITY);
        this.activeRouteExists = Subject.create(false);
    }
    /**
     * Erase the page data
     */
    erasePageData() {
        this.currentFixIdent.set(null);
        this.currentFixBrgDist.set([null, false, null, false]);
        this.currentBrgDist.forEach((v) => v.set([null, false, null, false]));
        this.currentEtaDtgAlt.forEach((v) => v.set([null, null, null]));
        this.currentPredEtaAlt.set([null, null, null]);
    }
}
BoeingFixInfoPageStore.NUM_FIXES = 4;
BoeingFixInfoPageStore.NUM_BRG_DIST = 3;
BoeingFixInfoPageStore.ARRAY_EQUALITY = (a, b) => (a.length === b.length && a.every((v, i) => v === b[i]));

/** Fix Info page controller */
class BoeingFixInfoPageController {
    /**
     * Instantiates a new instance of the controller
     * @param bus Event Bus
     * @param fms Boeing FMS
     * @param store Fix Info page store
     * @param page Fix Info page
     */
    constructor(bus, fms, store, page) {
        this.bus = bus;
        this.fms = fms;
        this.store = store;
        this.page = page;
        /** current page number, 1-based */
        this.currentPage = Subject.create(1);
        /** current page index, 0-based */
        this.currentPageIndex = this.currentPage.map((p) => p - 1);
        /** total number of pages */
        this.pageCount = Subject.create(BoeingFixInfoPageStore.NUM_FIXES);
        /** sim time as a unix timestamp in milliseconds */
        this.simTime = ConsumerSubject.create(null, 0);
        this.fmsOperatingPhase = ConsumerSubject.create(null, 0);
        this.transitionAltitudeOrLevel = MappedSubject.create(([fmsPhase, transAlt, transLevel]) => fmsPhase < FmsOperatingPhase.CRUISE ? transAlt : transLevel, this.fmsOperatingPhase, this.fms.activePerformancePlan.transitionAltitude, this.fms.activePerformancePlan.transitionLevel);
        this.subs = [];
    }
    /** Initialise this instance of the controller */
    init() {
        this.simTime.setConsumer(this.bus.getSubscriber().on('simTime'));
        this.fmsOperatingPhase.setConsumer(this.bus.getSubscriber().on('fms_operating_phase'));
        this.subs.push(this.bus.getSubscriber().on('fix_info_calculated').handle(this.onFixInfoCalculated.bind(this)));
        this.subs.push(this.fms.routeActivated(1).sub((v) => this.store.activeRouteExists.set(v), true));
        this.subs.push(this.transitionAltitudeOrLevel.sub(() => this.page.invalidate()));
    }
    /**
     * Handle FMS fix info calculate events
     * @param fixIndex Index of the fix info updated (0-based)
     */
    onFixInfoCalculated(fixIndex) {
        if (fixIndex === this.currentPageIndex.get()) {
            this.readDataFromFms();
        }
    }
    /** Read data for the page from the FMS*/
    readDataFromFms() {
        const calculated = this.fms.fixInfo.getCalculatedData(this.currentPageIndex.get());
        const entered = this.fms.fixInfo.getEnteredData(this.currentPageIndex.get());
        if (!calculated || !entered) {
            this.store.erasePageData();
            return;
        }
        this.store.currentFixIdent.set(calculated.fixIdent);
        this.store.currentFixIsDatabaseItem.set(entered.fix !== null && ICAO.getFacilityType(entered.fix.icao) !== FacilityType.USR);
        this.store.currentFixBrgDist.set([
            calculated.fixBearing, true,
            calculated.fixDistance !== null ? UnitType.NMILE.convertFrom(calculated.fixDistance, UnitType.METER) : null, true,
        ]);
        calculated.bearingDistancePredictions.forEach((prediction, i) => {
            const [pilotBearing, pilotDistance] = entered.bearingDistances[i];
            this.store.currentBrgDist[i].set([
                prediction.bearing, pilotBearing !== null,
                prediction.distance !== null ? UnitType.NMILE.convertFrom(prediction.distance, UnitType.METER) : null, pilotDistance !== null,
            ]);
            this.store.currentEtaDtgAlt[i].set([
                prediction.eta,
                prediction.dtg !== null ? UnitType.NMILE.convertFrom(prediction.dtg, UnitType.METER) : null,
                prediction.altitude !== null ? UnitType.FOOT.convertFrom(prediction.altitude, UnitType.METER) : null,
            ]);
        });
        this.store.currentAbeamPointCalculated = calculated.abeamCalculated;
        this.store.currentAbeamBearingDist.set([
            calculated.abeamPredictions.bearing, true,
            calculated.abeamPredictions.distance !== null ? UnitType.NMILE.convertFrom(calculated.abeamPredictions.distance, UnitType.METER) : null, true,
        ]);
        this.store.currentAbeamEtaDtgAlt.set([
            calculated.abeamPredictions.eta,
            calculated.abeamPredictions.dtg !== null ? UnitType.NMILE.convertFrom(calculated.abeamPredictions.dtg, UnitType.METER) : null,
            calculated.abeamPredictions.altitude !== null ? UnitType.FOOT.convertFrom(calculated.abeamPredictions.altitude, UnitType.METER) : null,
        ]);
        this.store.currentPredEtaAlt.set([
            calculated.etaAltitudePrediction !== null ? UnitType.NMILE.convertFrom(calculated.etaAltitudePrediction, UnitType.METER) : null,
            entered.predictedTime,
            entered.predictedAltitude !== null ? UnitType.FOOT.convertFrom(entered.predictedAltitude, UnitType.METER) : null,
        ]);
        this.page.invalidate();
    }
    /** Pause the controller and it's subscriptions */
    pause() {
        this.subs.forEach((sub) => sub.pause());
        this.simTime.pause();
        this.fmsOperatingPhase.pause();
    }
    /** Resume the controller and it's subscriptions */
    resume() {
        this.fmsOperatingPhase.resume();
        this.simTime.resume();
        this.subs.forEach((sub) => sub.resume(true));
        this.readDataFromFms();
    }
    /** Advance to the next page */
    next() {
        if (this.currentPage.get() < this.pageCount.get()) {
            this.setCurrentPage(this.currentPage.get() + 1);
        }
        else {
            this.setCurrentPage(1);
        }
    }
    /** Go back to the previous page */
    previous() {
        if (this.currentPage.get() > 1) {
            this.setCurrentPage(this.currentPage.get() - 1);
        }
        else {
            this.setCurrentPage(this.pageCount.get());
        }
    }
    /**
     * Set the current page
     * @param page page number, 1-based
     */
    setCurrentPage(page) {
        this.currentPage.set(MathUtils.clamp(page, 1, this.pageCount.get()));
        this.readDataFromFms();
    }
    /**
     * Get a fix from a scratchpad entry
     * @param input any valid fix format
     */
    async getFix(input) {
        const selectedFacility = await this.page.screen.selectWaypointByIdent(input, this.fms.ppos);
        if (selectedFacility !== null) {
            return selectedFacility;
        }
        const result = await BoeingPilotWaypointUtils.createFromScratchpadEntry(this.fms, (ident, refPos) => this.page.screen.selectWaypointByIdent(ident, refPos), input);
        if (result) {
            const [userFacility] = result;
            this.fms.addUserFacility(userFacility);
            return userFacility;
        }
        return Promise.reject(BoeingFmcErrorKeys.NotInDataBase);
    }
    /**
     * Set the current page fix
     * @param fix Facility
     */
    setCurrentFix(fix) {
        this.fms.fixInfo.setFix(this.currentPageIndex.get(), fix);
    }
    /**
     * Delete the current page fix
     * @throws Help window message if needed
     * @returns true
     */
    deleteCurrentFix() {
        if (this.store.currentFixIdent.get() === null) {
            throw BoeingFmcErrorKeys.InvalidDelete;
        }
        this.fms.fixInfo.clearFix(this.currentPageIndex.get());
        return true;
    }
    /**
     * Set the bearing/distance for a row; either bearing or dist is mandatory.
     * Null entries will be computed.
     * @param brgDistIndex index of the row, 0-based
     * @param bearing bearing in degrees magnetic or true depending on current ref
     * @param dist distance in nautical miles
     */
    setBearingDist(brgDistIndex, bearing, dist) {
        this.fms.fixInfo.setBearingDistance(this.currentPageIndex.get(), brgDistIndex, bearing, dist !== null ? UnitType.METER.convertFrom(dist, UnitType.NMILE) : null);
    }
    /**
     * Delete the bearing/distance for a row
     * Null entries will be computed.
     * @param brgDistIndex index of the row, 0-based
     */
    deleteBearingDist(brgDistIndex) {
        this.fms.fixInfo.clearBearingDistance(this.currentPageIndex.get(), brgDistIndex);
    }
    /**
     * Set an ETA or Altitude to predict distance to
     * @param eta unix timestamp in milliseconds or null if altitude entry
     * @param altitude altitude in feet or null if eta entry
     * @returns true on success
     */
    setEtaAltitude(eta, altitude) {
        if (eta !== null) {
            return this.fms.fixInfo.setTimePrediction(this.currentPageIndex.get(), eta);
        }
        else if (altitude !== null) {
            return this.fms.fixInfo.setAltitudePrediction(this.currentPageIndex.get(), UnitType.METER.convertFrom(altitude, UnitType.FOOT));
        }
        return this.fms.fixInfo.clearPrediction(this.currentPageIndex.get());
    }
    /**
     * Creates the abeam point
     * @returns true on success
     */
    createAbeamPoint() {
        return this.fms.fixInfo.createAbeamPoint(this.currentPageIndex.get());
    }
    /**
     * Deletes the abeam point
     * @returns true on success
     */
    deleteAbeamPoint() {
        return this.fms.fixInfo.deleteAbeamPoint(this.currentPageIndex.get());
    }
}

/**
 * The Boeing FIX INFO page.
 */
class BaseBoeingFixInfoPage extends BoeingFmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingFixInfoPageStore();
        this.controller = new BoeingFixInfoPageController(this.bus, this.fms, this.store, this);
        this.altitudeInputFormatter = B787FmcFormatters.Altitude('input', this.controller.transitionAltitudeOrLevel);
        this.altitudeInputParser = B787FmcParsers.Altitude;
        this.timeInputFormatter = B787FmcFormatters.UtcTime('input');
        this.timeInputParser = B787FmcParsers.UtcTime(this.controller.simTime);
        this.fixInfoPaging = MappedSubject.create(([currentPage, pageCount]) => [currentPage, pageCount], this.controller.currentPage, this.controller.pageCount);
        this.FixInfoPagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        }).bind(this.fixInfoPaging);
        // 1L
        this.FixField = new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('□□□□□  '),
                /** @inheritDoc */
                format(value) {
                    return inputBox(value.padEnd(7));
                },
                /** @inheritDoc */
                parse: async (input) => this.controller.getFix(input),
            },
            onModified: async (fac) => {
                this.controller.setCurrentFix(fac);
                return true;
            },
            onDelete: async () => {
                if (this.store.currentFixIdent === null) {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
                }
                return this.controller.deleteCurrentFix();
            },
        }).bind(this.store.currentFixIdent);
        // 1R
        this.FixBrgDistField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format: (args) => {
                    const [bearing, , distance] = args;
                    return bearing === null || distance === null ? '' : this.formatBearingDist('', args, this.getFixBearingDistSuffix());
                },
            },
        }).bind(this.store.currentFixBrgDist);
        // 2L - 4L
        this.BrgDistFields = Array.from({ length: BoeingFixInfoPageStore.NUM_BRG_DIST }, (_, i) => new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('---/----'),
                /** @inheritDoc */
                format: this.formatBearingDist.bind(this, inputBox('---/----')),
                /** @inheritdoc */
                parse: (input) => {
                    const match = input.match(/^([0-3][0-9]{2})?(\/([0-9]{1,4}))?$/);
                    if (match === null) {
                        throw BoeingFmcErrorKeys.InvalidEntryBearingDistance;
                    }
                    const bearing = match[1] !== undefined ? parseInt(match[1]) : null;
                    const dist = match[3] !== undefined ? parseInt(match[3]) : null;
                    if (((bearing !== null && bearing !== void 0 ? bearing : 0) > 360) || ((dist !== null && dist !== void 0 ? dist : 0) > 5400) || (bearing === null && dist === null)) {
                        throw BoeingFmcErrorKeys.InvalidEntryBearingDistance;
                    }
                    return [bearing === 0 ? 360 : bearing, bearing !== null, dist, dist !== null];
                },
            },
            /** @inheritdoc */
            onSelected: async () => {
                if (this.screen.scratchpad.contents.get().length > 0) {
                    return false;
                }
                const fixIdent = this.store.currentFixIdent.get();
                const [bearing, bearingPilotEntry, distance, distancePilotEntry] = this.store.currentBrgDist[i].get();
                // needs to be a flightplan intercept to be eligible for downselect, which means both values are valid and one is not a pilot entry
                if (fixIdent === null || bearing === null || distance === null || (bearingPilotEntry && distancePilotEntry)) {
                    return false;
                }
                return this.formatPbdForScratchpad(fixIdent, bearing, distance);
            },
            /** @inheritdoc */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onModified: async ([bearing, bearingPilotEntry, distance, distancePilotEntry]) => {
                this.controller.setBearingDist(i, bearing, distance);
                return true;
            },
            onDelete: async () => {
                const [bearing, distance] = this.store.currentBrgDist[i].get();
                if (bearing === null && distance === null) {
                    throw BoeingFmcErrorKeys.InvalidDelete;
                }
                this.controller.deleteBearingDist(i);
                return true;
            },
        }).bind(this.store.currentBrgDist[i]));
        // 2R - 4R
        this.EtaDtgAltFields = Array.from({ length: BoeingFixInfoPageStore.NUM_BRG_DIST }, (_, i) => new DisplayField(this, {
            formatter: this.getEtaDtgAltitudeFormatter(),
        }).bind(this.store.currentEtaDtgAlt[i]));
        // 5R
        this.AbeamEtaDtgAltField = new DisplayField(this, {
            formatter: this.getEtaDtgAltitudeFormatter(),
        }).bind(this.store.currentAbeamEtaDtgAlt);
        // 5L
        this.AbeamField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format: (args) => {
                    return this.formatBearingDist(this.store.currentAbeamPointCalculated ? '' : '<ABEAM', args);
                },
            },
            /** @inheritdoc */
            onSelected: async () => {
                if (!this.store.currentAbeamPointCalculated) {
                    return this.controller.createAbeamPoint();
                }
                const fixIdent = this.store.currentFixIdent.get();
                const bearing = this.store.currentAbeamBearingDist.get()[0];
                const dist = this.store.currentAbeamBearingDist.get()[2];
                if (fixIdent !== null && bearing !== null && dist !== null && this.screen.scratchpad.contents.get().length === 0) {
                    return this.formatPbdForScratchpad(fixIdent, bearing, dist);
                }
                return false;
            },
            onDelete: async () => {
                if (this.store.currentAbeamPointCalculated) {
                    return this.controller.deleteAbeamPoint();
                }
                return false;
            }
        }).bind(this.store.currentAbeamBearingDist);
        // 6L
        this.EraseFixField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                /** @inheritDoc */
                format() {
                    return '<ERASE FIX';
                },
            },
            onSelected: this.store.currentFixIdent !== null ? async () => {
                this.controller.deleteCurrentFix();
                return true;
            } : undefined,
        }).bind(this.store.currentFixIdent);
        // 6M/6R
        this.PredictedDtgEtaAltField = new TextInputField(this, {
            formatter: {
                nullValueString: inputBox('-----'),
                format: ([predictedDistance, etaInput, altInput]) => {
                    let rightSide;
                    if (etaInput !== null) {
                        rightSide = this.timeInputFormatter(etaInput);
                    }
                    if (altInput !== null) {
                        rightSide = this.altitudeInputFormatter(altInput);
                    }
                    if (rightSide !== undefined) {
                        return `${predictedDistance !== null ? Math.min(9999, predictedDistance).toFixed(0).padStart(4) : ''}${this.getDtgEtaAltSeparator()}[d-text]${rightSide}`;
                    }
                    return inputBox('-----');
                },
                /** @inheritdoc */
                parse: async (input) => {
                    const time = await this.timeInputParser(input);
                    if (time !== null) {
                        return [time, null];
                    }
                    const altitude = this.altitudeInputParser(input);
                    if (altitude !== null) {
                        return [null, altitude];
                    }
                    throw BoeingFmcErrorKeys.InvalidEntryAltitudeOrTime;
                }
            },
            onModified: async ([eta, alt]) => {
                this.controller.setEtaAltitude(eta, alt);
                return true;
            },
            onDelete: async () => {
                const [eta, alt] = this.store.currentPredEtaAlt.get();
                if (eta === null && alt === null) {
                    throw BoeingFmcErrorKeys.InvalidDelete;
                }
                this.controller.setEtaAltitude(null, null);
                return true;
            },
        }).bind(this.store.currentPredEtaAlt);
    }
    /** @inheritDoc */
    async onHandleScrolling(event) {
        switch (event) {
            case 'pageRight':
                this.controller.next();
                return true;
            case 'pageLeft':
                this.controller.previous();
                return true;
        }
        return false;
    }
    /** @inheritdoc */
    onPageButtonPressed() {
        this.controller.setCurrentPage(1);
    }
    /**
     * Format the bearing/dist fields in 2L-5L
     * @param nullValueString The string to display when the data is null
     * @param root0 Data
     * @param root0."0" bearing in degrees or null
     * @param root0."1" true if the bearing was entered by the pilot
     * @param root0."2" distance in nautical miles or null
     * @param root0."3" true if the distance was entered by the pilot
     * @param suffix A string to append at the end
     * @returns Formatted value
     */
    formatBearingDist(nullValueString, [bearing, bearingPilotEntry, distance, distancePilotEntry], suffix = '') {
        var _a, _b, _c;
        if (bearing === null && distance === null) {
            return nullValueString;
        }
        return `${(_b = (_a = (bearing === 0 ? 360 : bearing)) === null || _a === void 0 ? void 0 : _a.toFixed(0).padStart(3, '0')) !== null && _b !== void 0 ? _b : '---'}[${bearingPilotEntry ? 'd' : 's'}-text]/[d-text]${(_c = distance === null || distance === void 0 ? void 0 : distance.toFixed(0).padEnd(4)) !== null && _c !== void 0 ? _c : '----'}[${distancePilotEntry ? 'd' : 's'}-text]${suffix}`;
    }
    /**
     * Format a PB/D for the scratchpad
     * @param fixIdent Identifier of the fix from which the PBD originates
     * @param bearing Bearing from the fix in degrees
     * @param distance Distance from the fix in nautical miles
     * @returns formatted string for the scratchpad
     */
    formatPbdForScratchpad(fixIdent, bearing, distance) {
        return `${fixIdent}${bearing.toFixed(1).padStart(5, '0')}/${distance.toFixed(1)}`;
    }
    /** @inheritdoc */
    onInit() {
        this.controller.init();
        this.controller.currentPage.sub(() => this.invalidate());
    }
    /** @inheritdoc */
    onPause() {
        this.controller.pause();
    }
    /** @inheritdoc */
    onResume() {
        this.controller.resume();
    }
}

/** Controller for the leg wind pages */
class BoeingWindPageController {
    /**
     * Instantiates the wind page controller
     * @param bus Event bus
     * @param fms FMS
     * @param store Data store for this page
     * @param page The leg wind page
     * @param windAltitudeTemperatureNullValueString The altitude/temperature null value string.
     */
    constructor(bus, fms, store, page, windAltitudeTemperatureNullValueString) {
        this.bus = bus;
        this.fms = fms;
        this.store = store;
        this.page = page;
        this.windAltitudeTemperatureNullValueString = windAltitudeTemperatureNullValueString;
        this.perfPlan = this.fms.performancePlanProxy;
        this.globalLegIndex = Subject.create(0);
        this.activeLegIndex = Subject.create(0);
        this.pageCount = Subject.create(0);
        this.currentPage = Subject.create(0);
        this.pageHeaderRenderOptions = ObjectSubject.create({
            headerString: '',
            paddingLeft: 0,
            hasPrefixes: true,
        });
        this.pageHeader = Subject.create(this.pageHeaderRenderOptions.get().headerString);
        this.isaDeviation = this.store.temperatureData.map((data) => (isFinite(data.altitude) && data.temperature !== null) ? data.temperature - AeroMath.isaTemperature(UnitType.METER.convertFrom(data.altitude, UnitType.FOOT)) : NaN);
        this.altFormatter = new AltitudeInputFormat('display', this.perfPlan.transitionLevel);
        this.AltEntryField = new TextInputField(this.page, {
            formatter: new AltitudeInputFormat('input', this.perfPlan.transitionLevel, '-----'),
            deleteAllowed: false,
            onModified: async (alt) => {
                if (this.insertAltitude(alt)) {
                    return true;
                }
                // FIXME proper error
                throw BoeingFmcErrorKeys.GenericInvalidEntry;
            }
        });
        this.altitudeOatRowFormatter = {
            nullValueString: '-----',
            format: (record) => {
                if (!isFinite(record.altitude)) {
                    return '';
                }
                const temperature = AeroMath.isaTemperature(UnitType.METER.convertFrom(record.altitude, UnitType.FOOT)) + this.isaDeviation.get();
                const propagated = isFinite(temperature) && this.store.temperatureData.get().temperaturePropagated;
                const formattedTemperature = isFinite(temperature) ? temperature.toFixed(0).padStart(3) : '';
                return `${this.altFormatter.format(record.altitude).padEnd(8)}${formattedTemperature}[${propagated ? 's' : 'd'}-text]`;
            },
        };
        this.AltOatRowFields = Array.from({ length: this.store.maximumNumberOfAltitudes }, (_, i) => new DisplayField(this.page, {
            formatter: this.altitudeOatRowFormatter,
            onDelete: async () => {
                const alt = this.store.windData[i].get().altitude;
                if (isFinite(alt)) {
                    this.fms.windPlanner.deleteLegAltitude(this.fms.getPlanIndexForFmcPage(), alt);
                    return true;
                }
                return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
            }
        }).bind(this.store.windData[i]));
        this.windDirectionSpeedFormatter = new WindDirSpdFormat();
        this.WindDirectionSpeedFields = Array.from({ length: this.store.maximumNumberOfAltitudes }, (_, i) => new TextInputField(this.page, {
            formatter: this.windDirectionSpeedFormatter,
            onDelete: async () => {
                const alt = this.store.windData[i].get().altitude;
                if (isFinite(alt)) {
                    this.fms.windPlanner.deleteLegWind(this.fms.getPlanIndexForFmcPage(), this.globalLegIndex.get(), alt);
                    return true;
                }
                return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
            },
            onModified: async ([direction, speed]) => {
                const oldData = this.store.windData[i].get();
                if ((oldData.speed === null || oldData.direction === null) && (direction === null || speed === null)) {
                    return Promise.reject(BoeingFmcErrorKeys.InvalidEntryWindDirSpdInitial);
                }
                else {
                    this.fms.windPlanner.setLegWind(this.fms.getPlanIndexForFmcPage(), this.globalLegIndex.get(), oldData.altitude, speed !== null ? speed : oldData.speed, direction !== null ? direction : oldData.direction);
                    return true;
                }
            },
        }).bind(this.store.windData[i]));
        this.temperatureFormatter = new WindAltitudeTemperatureFormat(this.perfPlan.transitionLevel, false, this.windAltitudeTemperatureNullValueString);
        this.TemperatureField = new TextInputField(this.page, {
            formatter: {
                nullValueString: this.temperatureFormatter.nullValueString,
                format: (record) => isFinite(record.altitude) ? this.temperatureFormatter.format(record) : this.temperatureFormatter.nullValueString,
                parse: this.temperatureFormatter.parse.bind(this.temperatureFormatter),
            },
            onDelete: async () => {
                const alt = this.store.temperatureData.get().altitude;
                if (isFinite(alt)) {
                    this.fms.windPlanner.deleteLegTemperature(this.fms.getPlanIndexForFmcPage(), this.globalLegIndex.get());
                    return true;
                }
                return Promise.reject(BoeingFmcErrorKeys.InvalidDelete);
            },
            onModified: async ([altitude, oat]) => {
                if (oat === null) {
                    // FIXME proper message
                    return Promise.reject(BoeingFmcErrorKeys.GenericInvalidEntry);
                }
                else {
                    this.fms.windPlanner.setLegTemperature(this.fms.getPlanIndexForFmcPage(), this.globalLegIndex.get(), altitude, oat);
                    return true;
                }
            },
        }).bind(this.store.temperatureData);
        this.PageHeaderField = new DisplayField(this.page, {
            formatter: new SimpleStringFormat(this.pageHeaderRenderOptions.get().headerString),
        }).bind(this.pageHeader);
    }
    /** Update the current leg from the navigation params */
    updateLegIndexFromParams() {
        var _a;
        const globalLegIndex = parseInt((_a = this.page.params.get('globalLegIndex')) !== null && _a !== void 0 ? _a : 0);
        this.globalLegIndex.set(globalLegIndex);
        this.page.params.set('globalLegIndex', globalLegIndex);
    }
    /**
     * @inheritdoc
     * @param options The options determining how the page header string should be constructed.
     */
    onInit(options) {
        this.pageHeaderRenderOptions.set(options);
        this.updateLegIndexFromParams();
        this.page.addBinding(this.bus.getSubscriber().on('leg_wind_data_changed').handle(this.updateData.bind(this)));
        this.page.addBinding(this.fms.planInMod.sub(this.updateData.bind(this)));
        this.page.addBinding(this.globalLegIndex.sub(this.updateData.bind(this)));
        this.page.addBinding(this.fms.routeActivated(1).sub(this.handleHeaderChange.bind(this)));
        this.page.addBinding(this.fms.planInMod.sub(this.handleHeaderChange.bind(this)));
        this.page.addBinding(this.store.legIdent.sub(this.handleHeaderChange.bind(this)));
        this.handleHeaderChange();
        this.updateData();
    }
    /** @inheritDoc */
    onResume() {
        this.updateLegIndexFromParams();
        this.updateData();
    }
    /** Update the leg data in the store when something changes */
    updateData() {
        var _a, _b, _c, _d, _e;
        const flightPlan = this.fms.getPlanForFmcRender();
        this.activeLegIndex.set(flightPlan.activeLateralLeg);
        let eligibleLegCount = 0;
        for (let i = this.activeLegIndex.get(); i < flightPlan.length; i++) {
            if (BoeingFmsUtils.legTypeCanHaveWind((_b = (_a = flightPlan.tryGetLeg(i)) === null || _a === void 0 ? void 0 : _a.leg.type) !== null && _b !== void 0 ? _b : LegType.Unknown)) {
                eligibleLegCount++;
                if (this.globalLegIndex.get() === i) {
                    this.currentPage.set(eligibleLegCount);
                }
            }
        }
        this.pageCount.set(eligibleLegCount);
        if (this.globalLegIndex.get() < this.activeLegIndex.get() || !BoeingFmsUtils.legTypeCanHaveWind((_d = (_c = flightPlan.tryGetLeg(this.globalLegIndex.get())) === null || _c === void 0 ? void 0 : _c.leg.type) !== null && _d !== void 0 ? _d : LegType.Unknown)) {
            // this leg is no longer eligible, move on
            this.nextLeg();
            return;
        }
        const flightPlanLeg = flightPlan.getLeg(this.globalLegIndex.get());
        this.store.legIdent.set((_e = flightPlanLeg.name) !== null && _e !== void 0 ? _e : '------');
        const planIndex = flightPlan.planIndex;
        this.store.setWindData(this.fms.windPlanner.getLegWinds(planIndex, this.globalLegIndex.get()));
        this.store.setTemperatureData(this.fms.windPlanner.getLegTemperature(planIndex, this.globalLegIndex.get()));
        this.page.invalidate();
    }
    /** Handles when the FMS changes between MOD and ACT modes, or the ident changes */
    handleHeaderChange() {
        const ident = this.store.legIdent.get();
        const headerFullString = `${this.getHeaderPrefix()}${ident.padEnd(6, ' ')} ${this.pageHeaderRenderOptions.get().headerString}${this.getHeaderSuffix()}`;
        this.pageHeader.set(`${this.getHeaderEmptySpaceOffset()}${headerFullString}`);
    }
    /**
     * Determines how the prefix of the header should be, if any.
     * @returns the prefix string.
     */
    getHeaderPrefix() {
        if (this.pageHeaderRenderOptions.get().hasPrefixes) {
            if (this.fms.planInMod.get()) {
                return '[white]MOD[r-white] ';
            }
            else if (this.fms.routeActivated(1).get()) {
                return 'ACT ';
            }
            else {
                return '';
            }
        }
        return '';
    }
    /**
     * Calculates a string of empty spaces for the left padding of the page header.
     * @returns A string of empty spaces.
     */
    getHeaderEmptySpaceOffset() {
        const paddingLeft = this.pageHeaderRenderOptions.get().paddingLeft;
        if (this.pageHeaderRenderOptions.get().hasPrefixes) {
            return ' '.repeat(paddingLeft < 4 ? 0 : paddingLeft - 4);
        }
        else {
            return ' '.repeat(paddingLeft);
        }
    }
    /**
     * Determines if there should be a suffix to the header string.
     * @returns the suffix string.
     */
    getHeaderSuffix() {
        return this.fms.isRouteActivated(1) ? '' : '[cyan]';
    }
    /** Swift page to the next leg */
    nextLeg() {
        var _a, _b, _c, _d;
        if (this.pageCount.get() < 1) {
            this.page.screen.navigateTo('/rte-data');
            return;
        }
        if (this.pageCount.get() === 1) {
            return;
        }
        const flightPlan = this.fms.getPlanForFmcRender();
        // try search forward for a leg
        for (let i = this.globalLegIndex.get() + 1; i < flightPlan.length; i++) {
            if (BoeingFmsUtils.legTypeCanHaveWind((_b = (_a = flightPlan.tryGetLeg(i)) === null || _a === void 0 ? void 0 : _a.leg.type) !== null && _b !== void 0 ? _b : LegType.Unknown)) {
                this.globalLegIndex.set(i);
                return;
            }
        }
        // try search forward from the start of the plan
        for (let i = this.activeLegIndex.get(); i < this.globalLegIndex.get(); i++) {
            if (BoeingFmsUtils.legTypeCanHaveWind((_d = (_c = flightPlan.tryGetLeg(i)) === null || _c === void 0 ? void 0 : _c.leg.type) !== null && _d !== void 0 ? _d : LegType.Unknown)) {
                this.globalLegIndex.set(i);
                return;
            }
        }
    }
    /** Swift page to the previous leg */
    prevLeg() {
        var _a, _b, _c, _d;
        if (this.pageCount.get() < 1) {
            this.page.screen.navigateTo('/rte-data');
            return;
        }
        if (this.pageCount.get() === 1) {
            return;
        }
        const flightPlan = this.fms.getPlanForFmcRender();
        // try search backward for a leg
        for (let i = this.globalLegIndex.get() - 1; i >= this.activeLegIndex.get(); i--) {
            if (BoeingFmsUtils.legTypeCanHaveWind((_b = (_a = flightPlan.tryGetLeg(i)) === null || _a === void 0 ? void 0 : _a.leg.type) !== null && _b !== void 0 ? _b : LegType.Unknown)) {
                this.globalLegIndex.set(i);
                return;
            }
        }
        // try search backward from the end of the plan
        for (let i = flightPlan.length - 1; i > this.globalLegIndex.get(); i--) {
            if (BoeingFmsUtils.legTypeCanHaveWind((_d = (_c = flightPlan.tryGetLeg(i)) === null || _c === void 0 ? void 0 : _c.leg.type) !== null && _d !== void 0 ? _d : LegType.Unknown)) {
                this.globalLegIndex.set(i);
                return;
            }
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllAltitudesUsed() {
        return this.fms.windPlanner.areAllLegAltitudesUsed(this.fms.getPlanIndexForFmcPage());
    }
    /**
     * Insert a new leg wind altitude
     * @param alt Altitude in feet MSL
     * @returns true on success, otherwise false
     */
    insertAltitude(alt) {
        return this.fms.windPlanner.setLegWind(this.fms.getPlanIndexForFmcPage(), this.globalLegIndex.get(), alt, null, null);
    }
    /**
     * Render the altitude entry field for adding a new altitude
     * @returns an entry field
     */
    renderAltEntryField() {
        return this.AltEntryField;
    }
    /**
     * Render a filled altitude/OAT row
     * @param row Index of the row to render, 0-based
     * @returns the contents for the row
     */
    renderAltOatRow(row) {
        var _a, _b;
        const alt = (_b = (_a = this.store.windData[row]) === null || _a === void 0 ? void 0 : _a.get().altitude) !== null && _b !== void 0 ? _b : NaN;
        if (!isNaN(alt)) {
            return this.AltOatRowFields[row];
        }
        return '';
    }
    /**
     * Render wind/dir spd or blank if none
     * @param row Index of the row to render, 0-based
     * @returns the contents for the row
     */
    renderWindDirSpdRow(row) {
        var _a;
        const windData = (_a = this.store.windData[row]) === null || _a === void 0 ? void 0 : _a.get();
        if (windData !== undefined && isFinite(windData.altitude)) {
            return this.WindDirectionSpeedFields[row];
        }
        return '';
    }
    /**
     * Render the leg temperature entry field
     * @returns the field
     */
    renderTemperatureField() {
        return this.TemperatureField;
    }
    /**
     * Render the header/title of the wind page.
     * @returns the title component
     */
    renderPageHeader() {
        return this.PageHeaderField;
    }
}

/** Data store for the leg wind pages */
class BoeingWindPageStore {
    /**
     * Instantiate the page data store
     * @param maximumNumberOfAltitudes Maximum number of wind altitudes permitted
     */
    constructor(maximumNumberOfAltitudes) {
        this.maximumNumberOfAltitudes = maximumNumberOfAltitudes;
        this.windData = Array.from({ length: this.maximumNumberOfAltitudes }, () => ObjectSubject.create({
            altitude: NaN,
            direction: null,
            speed: null,
            windPropagated: false,
        }));
        this.temperatureData = ObjectSubject.create({
            altitude: NaN,
            temperature: null,
            temperaturePropagated: true,
        });
        this.legIdent = Subject.create('------');
        this.windDataCache = Array.from({ length: this.maximumNumberOfAltitudes }, () => null);
    }
    /**
     * Set the wind data for the page
     * @param data wind data records for the current leg
     */
    setWindData(data) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        for (let i = 0; i < this.maximumNumberOfAltitudes; i++) {
            if (data !== undefined && data[i]) {
                this.windDataCache[i] = data[i];
            }
            else {
                this.windDataCache[i] = null;
            }
        }
        // sort in ascending order, with blank rows first
        this.windDataCache.sort((a, b) => {
            const altA = a === null || a === void 0 ? void 0 : a.altitude;
            const altB = b === null || b === void 0 ? void 0 : b.altitude;
            if (altA === undefined) {
                if (altB === undefined) {
                    return 0;
                }
                return -1;
            }
            if (altB === undefined) {
                return 1;
            }
            return altA - altB;
        });
        // now put it into the subjects, and clear any unused ones
        for (let i = 0; i < this.maximumNumberOfAltitudes; i++) {
            this.windData[i].set('altitude', (_b = (_a = this.windDataCache[i]) === null || _a === void 0 ? void 0 : _a.altitude) !== null && _b !== void 0 ? _b : NaN);
            this.windData[i].set('direction', (_d = (_c = this.windDataCache[i]) === null || _c === void 0 ? void 0 : _c.direction) !== null && _d !== void 0 ? _d : null);
            this.windData[i].set('speed', (_f = (_e = this.windDataCache[i]) === null || _e === void 0 ? void 0 : _e.speed) !== null && _f !== void 0 ? _f : null);
            this.windData[i].set('windPropagated', (_h = (_g = this.windDataCache[i]) === null || _g === void 0 ? void 0 : _g.windPropagated) !== null && _h !== void 0 ? _h : true);
        }
    }
    /**
     * Set the temperature data for the page
     * @param data temperature data record for the current leg
     */
    setTemperatureData(data) {
        if (data !== undefined) {
            this.temperatureData.set('altitude', data.altitude);
            this.temperatureData.set('temperature', data.temperature);
            this.temperatureData.set('temperaturePropagated', data.temperaturePropagated);
        }
        else {
            this.temperatureData.set('altitude', NaN);
            this.temperatureData.set('temperature', null);
            this.temperatureData.set('temperaturePropagated', true);
        }
    }
}

/** The Boeing WIND (at a waypoint) page. */
class BoeingWindPage extends BoeingFmcPage {
    constructor() {
        var _a;
        super(...arguments);
        this.store = new BoeingWindPageStore((_a = this.fms.windPlanner.getNumberOfLegAltitudes()) !== null && _a !== void 0 ? _a : 4);
        this.controller = new BoeingWindPageController(this.bus, this.fms, this.store, this, this.getWindAltitudeTemperatureNullValueString());
        this.WindPagingIndicator = new DisplayField(this, {
            formatter: this.PagingFormat,
        }).bind(MappedSubject.create(([currentPage, pageCount]) => [currentPage, pageCount], this.controller.currentPage, this.controller.pageCount));
        this.rteDataLink = PageLinkField.createLink(this, 'RTE DATA>', '/rte-data');
    }
    /** @inheritDoc */
    onInit() {
        const pageHeaderRenderOptions = {
            headerString: this.getPageHeaderString(),
            paddingLeft: this.getBasePaddingLeft(),
            hasPrefixes: this.getIsPagePrefixEnabled(),
        };
        this.controller.onInit(pageHeaderRenderOptions);
    }
    /** @inheritdoc */
    onResume() {
        this.controller.onResume();
    }
    /** @inheritdoc */
    async onHandleScrolling(event) {
        switch (event) {
            case 'pageRight':
                this.controller.nextLeg();
                return true;
            case 'pageLeft':
                this.controller.prevLeg();
                return true;
        }
        return false;
    }
    /** @inheritDoc */
    render() {
        return [
            [
                [this.controller.renderPageHeader(), this.WindPagingIndicator],
                [this.getAltOatHeaderNames(), this.getDirSpdFieldName()],
                [this.controller.areAllAltitudesUsed() ? this.controller.renderAltOatRow(0) : this.controller.renderAltEntryField(), this.controller.areAllAltitudesUsed() ? this.controller.renderWindDirSpdRow(0) : ''],
                ['', ''],
                [this.controller.renderAltOatRow(1), this.controller.renderWindDirSpdRow(1)],
                ['', ''],
                [this.controller.renderAltOatRow(2), this.controller.renderWindDirSpdRow(2)],
                ['', ''],
                [this.controller.renderAltOatRow(3), this.controller.renderWindDirSpdRow(3)],
                ['', this.getAltOatFieldName()],
                ['', this.controller.renderTemperatureField()],
                ['--------------------------------------'],
                ['', this.rteDataLink],
            ],
        ];
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * 787 FMC screen
 */
class BoeingFmcScreen extends FmcScreen {
    /**
     * Ctor
     * @param bus the event bus
     * @param pageFactory the page factory to be used for creating FMC pages for this screen
     * @param options the screen options
     * @param renderer the renderer to use for this screen
     * @param scratchpad the scratchpad to use for this screen
     * @param fms the fms
     */
    constructor(bus, pageFactory, options, renderer, scratchpad, fms) {
        super(bus, pageFactory, options, renderer, scratchpad);
        this.fms = fms;
        this.facilitySelectionResolveFn = undefined;
    }
    /**
     * Returns a facility (if applicable) given an ident. This presents a de-duplication screen to the user if needed.
     * @param ident the ident to use
     * @param referencePos The reference position to use to sort multiple matching facilities. Facilities are sorted
     * in order of increasing distance from the reference position.
     * @param filter the filter to apply to the facility search.
     * @param pickClosest whether to automatically return the closest facility in case multiple search results are found. otherwise,
     * the SELECT DESIRED XXX page is used.
     * @returns the facility or `null`
     */
    async selectWaypointByIdent(ident, referencePos, filter, pickClosest) {
        return null;
    }
}

/**
 * FMS altitude speed limit state.
 */
var FmsAltitudeLimitState;
(function (FmsAltitudeLimitState) {
    /** The altitude speed limit is already in effect. */
    FmsAltitudeLimitState["InEffect"] = "InEffect";
    /** The altitude speed limit is not in effect, and anticipation is required. */
    FmsAltitudeLimitState["AnticipationNeeded"] = "AnticipationNeeded";
    /** The altitude speed limit is not in effect, and anticipation is not required. */
    FmsAltitudeLimitState["AnticipationNotNeeded"] = "AnticipationNotNeeded";
})(FmsAltitudeLimitState || (FmsAltitudeLimitState = {}));
/**
 * A manager which computes FMS speed targets and syncs those targets with the autopilot when in FMS-managed speed
 * mode.
 */
class FmsSpeedManager {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param flightPlanner The flight planner.
     * @param pathCalculator Vertical path calculator
     * @param perfPlanRepo The performance plan repository
     * @param speedData Speed data provider for the airframe
     * @param perfProvider Provides vertical path performance calculations
     * @param messageService The CDU message service
     * @param engineData For ECON speed calculation.
     * @param windPlanner For ECON speed calculation.
     * @param adcIndex The index of the ADC used by this manager.
     * @param fmsPosIndex The index of the FMS positioning system used by this manager.
     */
    constructor(bus, flightPlanner, pathCalculator, perfPlanRepo, speedData, perfProvider, messageService, engineData, windPlanner, adcIndex, fmsPosIndex) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.pathCalculator = pathCalculator;
        this.perfPlanRepo = perfPlanRepo;
        this.speedData = speedData;
        this.perfProvider = perfProvider;
        this.messageService = messageService;
        this.engineData = engineData;
        this.windPlanner = windPlanner;
        this.vec2Cache = [Vec2Math.create()];
        this.bool2Cache = [false, false];
        /** Landing gear placard speed */
        this.gearExtendedSpeed = -1;
        this.publisher = this.bus.getPublisher();
        // eslint-disable-next-line jsdoc/require-jsdoc
        this.keyEventManagerReadyPromises = [];
        this._currentStateIndex = SpeedStateMachineState.Takeoff;
        this.states = new Map([
            [SpeedStateMachineState.Takeoff, new SpeedStateMachineTakeoff(this.bus, this)],
            [SpeedStateMachineState.Climb, new SpeedStateMachineClimb(this.bus, this)],
            [SpeedStateMachineState.Cruise, new SpeedStateMachineCruise(this.bus, this)],
            [SpeedStateMachineState.Descent, new SpeedStateMachineDescent(this.bus, this)],
            [SpeedStateMachineState.Approach, new SpeedStateMachineApproach(this.bus, this)],
            [SpeedStateMachineState.GoAround, new SpeedStateMachineGoAround(this.bus, this)],
        ]);
        this.performancePlan = this.perfPlanRepo.getActivePlan();
        this.mcpTargetIas = ConsumerSubject.create(null, -1);
        this.mcpTargetMach = ConsumerSubject.create(null, -1);
        this.mcpTargetIsMach = ConsumerSubject.create(null, false);
        this.mcpTargetIsActive = ConsumerSubject.create(null, true);
        this.climbCas = -1;
        this.climbMach = -1;
        this.climbSpeedLimitCeiling = this.performancePlan.climbSpeedLimitAltitude;
        this.climbSpeedLimitSpeed = this.performancePlan.climbSpeedLimitCas;
        this.climbSpeedRestrictionCeiling = this.performancePlan.climbSpeedRestrAltitude;
        this.climbSpeedRestrictionSpeed = this.performancePlan.climbSpeedRestrCas;
        this.cruiseCas = -1;
        this.cruiseMach = -1;
        this.descentCas = -1;
        this.descentMach = -1;
        this.descentSpeedLimitCeiling = this.performancePlan.descentSpeedLimitAltitude;
        this.descentSpeedLimitSpeed = this.performancePlan.descentSpeedLimitCas;
        this.descentSpeedRestrictionCeiling = this.performancePlan.descentSpeedRestrAltitude;
        this.descentSpeedRestrictionSpeed = this.performancePlan.descentSpeedRestrCas;
        this.apSelectedAltitude = ConsumerSubject.create(null, 0);
        /** altitude captured by the AP in feet, valid in ALT/LEVEL modes and CAP mode. */
        this.apCapturedAltitude = ConsumerValue.create(null, 0);
        this.apFmaData = ConsumerSubject.create(null, null);
        this.apLateralMode = Subject.create(APLateralModes.NONE);
        this.apVerticalMode = Subject.create(APVerticalModes.NONE);
        this.apEngaged = ConsumerSubject.create(null, false);
        this.fd1Engaged = ConsumerSubject.create(null, false);
        this.fd2Engaged = ConsumerSubject.create(null, false);
        this.apOrFdEngaged = MappedSubject.create(([ap, fd1, fd2]) => ap || fd1 || fd2, this.apEngaged, this.fd1Engaged, this.fd2Engaged);
        this.apSelectedIas = ConsumerSubject.create(null, 0);
        this.apSelectedMach = ConsumerSubject.create(null, 0);
        this.apSelectedSpeedIsMach = ConsumerSubject.create(null, false);
        this.apSelectedSpeedIsManual = ConsumerSubject.create(null, true);
        this.isOnGround = ConsumerSubject.create(null, false);
        this.ppos = new GeoPoint(0, 0);
        this.indicatedAltitude = ConsumerSubject.create(null, 0);
        this.indicatedAirspeed = ConsumerValue.create(null, 0);
        this.machNumber = ConsumerValue.create(null, 0);
        /** true airspeed in knots */
        this.trueAirspeed = ConsumerValue.create(null, 0);
        this.pressureAltitude = ConsumerSubject.create(null, 0);
        /** current vertical speed in feet/minute */
        this.verticalSpeed = ConsumerSubject.create(null, 0);
        /** current vertical speed in metres/sec */
        this.verticalSpeedMps = this.verticalSpeed.map((v) => UnitType.MPS.convertFrom(v, UnitType.FPM));
        /** ambient air density in slugs per cubic foot */
        this.ambientDensity = ConsumerValue.create(null, 0);
        /** ambient pressure in in.Hg */
        this.ambientPressure = ConsumerValue.create(null, 0);
        /** ambient temperature in °C */
        this.ambientTemperature = ConsumerValue.create(null, 0);
        this.availableEngines = ConsumerValue.create(null, 0);
        this.engineOut = ConsumerValue.create(null, false);
        /** gross weight in pounds */
        this.grossWeight = ConsumerValue.create(null, 0);
        this.trueHeading = ConsumerValue.create(null, 0);
        this.lnavIsTracking = ConsumerSubject.create(null, false);
        this.lnavLegIndex = ConsumerSubject.create(null, 0);
        this.lnavLegDistanceRemaining = ConsumerSubject.create(null, 0);
        this.lnavDistanceAlongLeg = ConsumerSubject.create(null, 0);
        this.lnavAlongTrackSpeed = ConsumerSubject.create(null, 0);
        this.machToKiasSmoother = new ExpSmoother(FmsSpeedManager.MACH_TO_KIAS_SMOOTHING_TAU);
        this.lastMachToKiasTime = 0;
        this.machToKias = 1;
        this.rotationPerformed = false;
        /** The indicated altitude in feet MSL the last time we were on the ground */
        this.groundAltitude = 0;
        this.cruiseAltitude = ConsumerSubject.create(null, 0);
        this.vnavState = ConsumerSubject.create(null, VNavState.Disabled);
        this.vnavFlightPhase = ConsumerSubject.create(null, VerticalFlightPhase.Climb);
        this.vnavTargetAltitude = ConsumerSubject.create(null, 0);
        this.flapSpeedLimit = ConsumerValue.create(null, Infinity);
        this.flapManeuverSpeed = ConsumerValue.create(null, 0);
        this.flapLimitPosition = ConsumerValue.create(null, 0);
        // speed limits
        this.minimumManeuveringSpeed = ConsumerValue.create(null, 0);
        this.gearNosePosition = ConsumerSubject.create(null, 0);
        this.gearLeftPosition = ConsumerSubject.create(null, 0);
        this.gearRightPosition = ConsumerSubject.create(null, 0);
        this.pitchAttitude = ConsumerSubject.create(null, 0);
        this.onGround = ConsumerSubject.create(null, true);
        this.fmsPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT);
        this.computedSpeedInfo = {
            maxIas: -1,
            maxIasSource: FmsSpeedTargetSource.None,
            maxMach: -1,
            maxMachSource: FmsSpeedTargetSource.None,
            maxIsMach: false,
            targetIas: -1,
            targetIasSource: FmsSpeedTargetSource.None,
            targetMach: -1,
            targetMachSource: FmsSpeedTargetSource.None,
            targetIsMach: false
        };
        this.computedSpeedInfoWithSpeedLimit = {
            maxIas: -1,
            maxIasSource: FmsSpeedTargetSource.None,
            maxMach: -1,
            maxMachSource: FmsSpeedTargetSource.None,
            maxIsMach: false,
            targetIas: -1,
            targetIasSource: FmsSpeedTargetSource.None,
            targetMach: -1,
            targetMachSource: FmsSpeedTargetSource.None,
            targetIsMach: false
        };
        this.computedSpeedInfoWithSpeedRestriction = {
            maxIas: -1,
            maxIasSource: FmsSpeedTargetSource.None,
            maxMach: -1,
            maxMachSource: FmsSpeedTargetSource.None,
            maxIsMach: false,
            targetIas: -1,
            targetIasSource: FmsSpeedTargetSource.None,
            targetMach: -1,
            targetMachSource: FmsSpeedTargetSource.None,
            targetIsMach: false
        };
        this.computedSpeedInfoWithNextConstraint = {
            maxIas: -1,
            maxIasSource: FmsSpeedTargetSource.None,
            maxMach: -1,
            maxMachSource: FmsSpeedTargetSource.None,
            maxIsMach: false,
            targetIas: -1,
            targetIasSource: FmsSpeedTargetSource.None,
            targetMach: -1,
            targetMachSource: FmsSpeedTargetSource.None,
            targetIsMach: false
        };
        this.armedAnticipatedConstraint = undefined;
        this.anticipatedConstraint = undefined;
        this.isAnticipatedSpeedLimitActive = false;
        this.isAnticipatedSpeedRestrictionActive = false;
        this.isAnticipatedSpeedLimitDragRequiredActive = false;
        this.isAnticipatedSpeedRestrictionDragRequiredActive = false;
        this.isAnticipatedSpeedConstraintDragRequiredActive = false;
        this.speedLimitState = FmsAltitudeLimitState.AnticipationNotNeeded;
        this.speedRestrictionState = FmsAltitudeLimitState.AnticipationNotNeeded;
        this.maxIas = 0;
        this.maxIasSource = FmsSpeedTargetSource.None;
        this.maxMach = 0;
        this.maxMachSource = FmsSpeedTargetSource.None;
        this.maxIsMach = false;
        this.targetIas = -1;
        this.targetIasSource = FmsSpeedTargetSource.None;
        this.targetMach = -1;
        this.targetMachSource = FmsSpeedTargetSource.None;
        this.targetIsMach = false;
        this.activeIas = -1;
        this.activeMach = -1;
        this.activeIsMach = false;
        this.apTargetIas = -1;
        this.apTargetMach = -1;
        this.apTargetIsMach = false;
        this.apTargetTogaIas = -1;
        this.dragRequired = Subject.create(false);
        this.isAlive = true;
        this.isInit = false;
        this.fplSubs = [];
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.fmsPosIndex = SubscribableUtils.toSubscribable(fmsPosIndex, true);
        KeyEventManager.getManager(this.bus).then(manager => {
            this.keyEventManager = manager;
            while (this.isAlive && this.keyEventManagerReadyPromises.length > 0) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                this.keyEventManagerReadyPromises.shift().resolve();
            }
        });
    }
    /**
     * Waits for this manager's key event manager to be ready.
     * @returns A Promise which will be fulfilled when this manager's key event manager is ready, or rejected if this
     * manager is destroyed before then.
     */
    awaitKeyEventManagerReady() {
        if (this.keyEventManager !== undefined) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => { this.keyEventManagerReadyPromises.push({ resolve, reject }); });
    }
    /**
     * Initializes this manager.
     * @returns A Promise which will be fulfilled when this manager is fully initialized, or rejected if this manager is
     * destroyed before then.
     */
    async init() {
        var _a, _b, _c;
        if (!this.isAlive) {
            throw new Error('FmsSpeedManager: cannot initialize a dead manager');
        }
        await this.awaitKeyEventManagerReady();
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        for (const state of this.states.values()) {
            (_a = state.init) === null || _a === void 0 ? void 0 : _a.call(state);
        }
        (_c = (_b = this.currentState).onEnter) === null || _c === void 0 ? void 0 : _c.call(_b);
        this.gearExtendedSpeed = SimVar.GetGameVarValue('AIRCRAFT_MAX_GEAR_EXTENDED', 'knots');
        // Set up AP selected speed key intercepts
        const keyEventManager = this.keyEventManager;
        FmsSpeedManager.KEY_INTERCEPTS.forEach(key => { keyEventManager.interceptKey(key, false); });
        const sub = this.bus.getSubscriber();
        // Pass through key events when not in FMS speed mode
        this.keySub = sub.on('key_intercept').handle(data => {
            if (!FmsSpeedManager.KEY_INTERCEPTS.includes(data.key)) {
                return;
            }
            if (this.apSelectedSpeedIsManual.get()) {
                keyEventManager.triggerKey(data.key, true, data.value0, data.value1, data.value2);
            }
        });
        this.apSelectedIas.setConsumer(sub.on('ap_boeing_selected_ias'));
        this.apSelectedMach.setConsumer(sub.on('ap_boeing_selected_mach'));
        this.apSelectedSpeedIsMach.setConsumer(sub.on('ap_selected_speed_is_mach'));
        this.apSelectedSpeedIsManual.setConsumer(sub.on('ap_selected_speed_is_manual'));
        this.mcpTargetIas.setConsumer(sub.on('ap_ias_selected'));
        this.mcpTargetMach.setConsumer(sub.on('ap_mach_selected'));
        this.mcpTargetIsMach.setConsumer(sub.on('ap_selected_speed_is_mach'));
        this.mcpTargetIsActive.setConsumer(sub.on('ap_selected_speed_is_manual'));
        this.apSelectedAltitude.setConsumer(sub.on('ap_altitude_selected_3'));
        this.apCapturedAltitude.setConsumer(sub.on('ap_boeing_captured_altitude'));
        this.apFmaData.setConsumer(sub.on('fma_data'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.lnavIsTracking.setConsumer(sub.on('lnav_is_tracking'));
        this.lnavLegIndex.setConsumer(sub.on('lnav_tracked_leg_index'));
        this.lnavLegDistanceRemaining.setConsumer(sub.on('lnav_leg_distance_remaining'));
        this.lnavDistanceAlongLeg.setConsumer(sub.on('lnav_leg_distance_along'));
        this.lnavAlongTrackSpeed.setConsumer(sub.on('lnav_along_track_speed'));
        this.adcIndexSub = this.adcIndex.sub(index => {
            var _a;
            this.indicatedAltitude.setConsumer(sub.on(`adc_indicated_alt_${index}`));
            this.indicatedAirspeed.setConsumer(sub.on(`adc_ias_${index}`));
            this.machNumber.setConsumer(sub.on(`adc_mach_number_${index}`));
            this.trueAirspeed.setConsumer(sub.on(`adc_tas_${index}`));
            this.pressureAltitude.setConsumer(sub.on(`adc_pressure_alt_${index}`));
            this.verticalSpeed.setConsumer(sub.on(`adc_vertical_speed_${index}`));
            this.ambientDensity.setConsumer(sub.on(`adc_ambient_density_${index}`));
            this.ambientPressure.setConsumer(sub.on(`adc_ambient_pressure_inhg_${index}`));
            this.ambientTemperature.setConsumer(sub.on(`adc_ambient_temp_c_${index}`));
            (_a = this.machToKiasSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.machToKiasSub = sub.on(`adc_mach_to_kias_factor_${index}`).handle(machToKias => {
                const time = Date.now();
                this.machToKias = this.machToKiasSmoother.next(machToKias, time - this.lastMachToKiasTime);
                this.lastMachToKiasTime = time;
            });
        }, true);
        this.fmsPosIndexSub = this.fmsPosIndex.sub(index => {
            var _a;
            (_a = this.pposSub) === null || _a === void 0 ? void 0 : _a.destroy();
            this.pposSub = sub.on(`fms_pos_gps-position_${index}`).handle(lla => { this.ppos.set(lla.lat, lla.long); });
        }, true);
        this.flapSpeedLimit.setConsumer(sub.on('flap_computer_limit_speed'));
        this.flapManeuverSpeed.setConsumer(sub.on('flap_computer_maneuver_speed'));
        this.flapLimitPosition.setConsumer(sub.on('flap_computer_limit_position'));
        this.minimumManeuveringSpeed.setConsumer(sub.on('speedlimit_min_maneuver_ias'));
        this.gearNosePosition.setConsumer(sub.on('gear_position_0'));
        this.gearLeftPosition.setConsumer(sub.on('gear_position_1'));
        this.gearRightPosition.setConsumer(sub.on('gear_position_2'));
        this.availableEngines.setConsumer(sub.on('fadec_available_engines'));
        this.engineOut.setConsumer(sub.on('fadec_engine_out'));
        this.grossWeight.setConsumer(sub.on('total_weight'));
        this.trueHeading.setConsumer(sub.on('actual_hdg_deg_true'));
        this.pitchAttitudeSub = this.pitchAttitude.sub(this.checkRotation.bind(this));
        this.onGroundSub = this.onGround.sub(this.checkRotation.bind(this));
        this.fmsPhaseSub = this.fmsPhase.sub(() => {
            this.onEvent(SpeedStateMachineEvents.FlightPhaseChanged);
        });
        this.iasMachWindowSub = this.mcpTargetIas.sub(() => this.onEvent(SpeedStateMachineEvents.IasMachWindSpeedChanged));
        this.apFmaDataSub = this.apFmaData.sub((fma) => {
            var _a, _b;
            this.apLateralMode.set((_a = fma === null || fma === void 0 ? void 0 : fma.lateralActive) !== null && _a !== void 0 ? _a : APLateralModes.NONE);
            this.apVerticalMode.set((_b = fma === null || fma === void 0 ? void 0 : fma.verticalActive) !== null && _b !== void 0 ? _b : APVerticalModes.NONE);
            this.onEvent(SpeedStateMachineEvents.ApStatusChanged);
            if ((fma === null || fma === void 0 ? void 0 : fma.verticalActive) === APVerticalModes.CAP) {
                this.onEvent(SpeedStateMachineEvents.AltitudeCapture);
            }
        });
        this.apOrFdSub = this.apOrFdEngaged.sub(() => this.onEvent(SpeedStateMachineEvents.ApStatusChanged));
        // TODO
        // TogaPressed
        this.pitchAttitude.setConsumer(sub.on('pitch_deg'));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.fmsPhase.setConsumer(sub.on('fms_operating_phase'));
        this.apEngaged.setConsumer(sub.on('ap_master_status'));
        this.fd1Engaged.setConsumer(sub.on('ap_boeing_flight_director_is_active_1'));
        this.fd2Engaged.setConsumer(sub.on('ap_boeing_flight_director_is_active_2'));
        //this.cruiseAltitude.setConsumer(sub.on('vnav_cruise_altitude'));
        this.vnavState.setConsumer(sub.on('vnav_state'));
        //this.vnavFlightPhase.setConsumer(sub.on('vnav_flight_phase'));
        this.vnavTargetAltitude.setConsumer(sub.on('vnav_target_altitude'));
        this.clockSub = sub.on('realTime').handle(this.update.bind(this));
        this.monitorMessages();
    }
    /** Setup listeners for CDU messages */
    monitorMessages() {
        this.dragRequiredSub = this.dragRequired.sub((v) => {
            if (v) {
                this.messageService.sendMessage(BoeingFmcErrorKeys.DragRequired);
            }
            else {
                this.messageService.clearMessage(BoeingFmcErrorKeys.DragRequired);
            }
        });
    }
    /** Update out internal data from external sources */
    updateData() {
        // FIXME there are a few things assuming ISA conditions in here
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const cruiseAltitude = ((_a = this.performancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : 35000);
        // For the cas/mach crossover altitude we set 4/5 of cruise altitude but not less than FL237.
        // We then use ECON mach and the crossover altitude to calculate ECON cas.
        let crossOverAltitude = Math.max(23700, cruiseAltitude * 4 / 5);
        if (Math.abs(crossOverAltitude - cruiseAltitude) < 1000.0) {
            // If the crossover altitude and planned cruise altitude are close to each other (because cruise alt is ~ FL240),
            // move crossOverAltitude up, so the aircraft will fly firmly below cross over alt (in cas regime) in order to
            // not potentially trigger crossovers all the time:
            crossOverAltitude += 1000;
        }
        const crossOverPressure = AeroMath.isaPressure(UnitType.METER.convertFrom(crossOverAltitude, UnitType.FOOT));
        // First we need to determine the limits of any FMC commanded speed:
        //
        // During descend the FMS does not command an ECON speed higher than MMO/VMO - 16 knots, or a selected
        // speed higher than MMO/VMO - 11 knots
        // calculate CAS limits, up to max of crossover alt
        const ambientPressure = UnitType.HPA.convertFrom(this.ambientPressure.get(), UnitType.IN_HG);
        const casConversionPressure = Math.max(ambientPressure, crossOverPressure);
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(this.speedData.getMmo(), casConversionPressure), UnitType.MPS);
        const maxEconClbCrzCas = Math.min(this.speedData.getVmo(), mmoCas) - 5;
        const maxEconDesCas = Math.min(this.speedData.getVmo(), mmoCas) - 16;
        const maxSelectedClbCrzCas = maxEconClbCrzCas;
        const maxSelectedDesCas = Math.min(this.speedData.getVmo(), mmoCas) - 11;
        // calculate Mach limits, at minmum of crossover alt
        const machConversionPressure = Math.min(ambientPressure, crossOverPressure);
        const machMmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(this.speedData.getMmo(), machConversionPressure), UnitType.MPS);
        const machVmoCas = this.speedData.getVmo(Math.max(crossOverAltitude, this.indicatedAltitude.get()));
        const maxEconClbCrzMach = AeroMath.casToMach(UnitType.MPS.convertFrom(Math.min(machMmoCas, machVmoCas) - 5, UnitType.KNOT), machConversionPressure);
        const maxEconDesMach = AeroMath.casToMach(UnitType.MPS.convertFrom(Math.min(machMmoCas, machVmoCas) - 16, UnitType.KNOT), machConversionPressure);
        const maxSelectedClbCrzMach = maxEconClbCrzMach;
        const maxSelectedDesMach = AeroMath.casToMach(UnitType.MPS.convertFrom(Math.min(machMmoCas, machVmoCas) - 11, UnitType.KNOT), machConversionPressure);
        // For ECON mach calculation, these principles apply:
        //
        // Minimize fuel cost
        // -> Low ci -> lower mach -> results in higher climb rate and lower descend rate
        //
        // Minimize time related direct operating cost (wages, ...)
        // -> High ci -> higher mach -> results in lower climb rate and higher descend rate
        //
        // We use LRC mach as baseline, as it incorporates alt and weight already.
        // Based on LRC mach, the calculations for climb, cruise and descend are done as follows:
        // - Climb: additionaly consider the effect of CI and wind, use cruise ECON mach
        // - Cruise: additionaly consider the effect of CI and wind
        // - Descend: additionaly consider only the effect of CI
        // As current alt gives far too low LRC mach values when on ground, we need to obtain LRC mach at the cruise altitude
        // from the perf plan:
        const lrcMach = this.engineData.getLongRangeCruiseMach(this.grossWeight.get(), cruiseAltitude);
        // As LRC speed matches ECON at a speed of Ci = ~180 and at Ci = 0 we assume a speed drop of -4%. So first
        // we scale LRC speed accordingly:
        const ci0EconMach = lrcMach * 0.96;
        let ciAdjustedEconMach = lrcMach * (0.96 + ((_b = this.performancePlan.costIndex.get()) !== null && _b !== void 0 ? _b : 180) / 4500.0);
        // Next, the observed (or expected while still on ground and climb) headwind is used to calculate a wind related ECON mach offset.
        // From the Econ-mach vs CI-tables of a comparable widebody long range twin, we find that the impact on ECON mach (for a change
        // between 100 kts headwind vs 100 kts tailwind) at mtow is 4 times less than at empty weight. At the same time, changing alt from
        // FL270 to FL Max results also in a 4 times smaller impact.
        const headWindKts = this.windPlanner.getHeadwindForEconSpeedCalculation(BoeingFms.ACT_RTE_PLAN_INDEX, cruiseAltitude, this.lnavLegIndex.get(), this.lnavDistanceAlongLeg.get(), this.trueHeading.get());
        const headWindInducedOffset = (headWindKts / 10000) // Gives a -/+ 0.01 baseline when headwind changes +/- 100 kts
            * (-0.00009375 * this.indicatedAltitude.get() + 4.5317000) // multiplied with 2 @FL270 ... 0.5 @FL430
            * (-0.000009679 * this.grossWeight.get() + 5.891) // and multiplied with 3 @OEW ... 0.3 @MTOW
        ;
        // We can wrap up the calculation by adding the wind induced offset (headwind -> increase ECON mach,
        // tailwind -> decrease ECON mach) and clip the maximum at Mmo and the minimum at ci0CruiseMach (see Boeing PDF on cost index):
        const windAndCiAdjustedEconMach = MathUtils.clamp(ciAdjustedEconMach + headWindInducedOffset, ci0EconMach, this.speedData.getMmo());
        // After that the non-wind baseline (ciAdjustedEconMach) should also be limited to MMO:
        ciAdjustedEconMach = Math.min(ciAdjustedEconMach, this.speedData.getMmo());
        // The two ECON mach values are now used to retrieve two ECON cas values that match at crossover alt:
        const ciAdjustedEconCas = Math.round(UnitType.KNOT.convertFrom(AeroMath.machToCasIsa(ciAdjustedEconMach, UnitType.METER.convertFrom(crossOverAltitude, UnitType.FOOT)), UnitType.MPS));
        const windAndCiAdjustedEconCas = Math.round(UnitType.KNOT.convertFrom(AeroMath.machToCasIsa(windAndCiAdjustedEconMach, UnitType.METER.convertFrom(crossOverAltitude, UnitType.FOOT)), UnitType.MPS));
        // Update perf plan for climb:
        if (this.performancePlan.speedClimbMode.get() === SpeedMode.SEL) {
            // Compute speed commands with MMO/VMO - 5 knots limit
            this.climbCas = Math.round(Math.min((_c = this.performancePlan.speedClimbSelectCas.get()) !== null && _c !== void 0 ? _c : -1, maxSelectedClbCrzCas));
            this.climbMach = MathUtils.round(Math.min((_d = this.performancePlan.speedClimbSelectMach.get()) !== null && _d !== void 0 ? _d : -1, maxSelectedClbCrzMach), 0.001);
        }
        else {
            // Compute speed commands with MMO/VMO - 5 knots limit
            this.climbCas = Math.round(Math.min(windAndCiAdjustedEconCas, maxEconClbCrzCas));
            this.climbMach = MathUtils.round(Math.min(windAndCiAdjustedEconMach, maxEconClbCrzMach), 0.001);
            // Finally store the new ECON speeds in perfplan:
            this.performancePlan.speedClimbEconCas.set(this.climbCas);
            this.performancePlan.speedClimbEconMach.set(this.climbMach);
        }
        // Update perf plan for cruise:
        if (this.performancePlan.speedCruiseMode.get() === SpeedMode.SEL) {
            // Compute speed commands with MMO/VMO - 5 knots limit
            this.cruiseCas = Math.round(Math.min((_e = this.performancePlan.speedCruiseSelectCas.get()) !== null && _e !== void 0 ? _e : -1, maxSelectedClbCrzCas));
            this.cruiseMach = MathUtils.round(Math.min((_f = this.performancePlan.speedCruiseSelectMach.get()) !== null && _f !== void 0 ? _f : -1, maxSelectedClbCrzMach), 0.001);
        }
        else {
            // Compute speed commands with MMO/VMO - 5 knots limit
            this.cruiseCas = Math.round(Math.min(windAndCiAdjustedEconCas, maxEconClbCrzCas));
            this.cruiseMach = MathUtils.round(Math.min(windAndCiAdjustedEconMach, maxEconClbCrzMach), 0.001);
            // Finally store the new ECON speeds in perfplan:
            this.performancePlan.speedCruiseEconCas.set(this.cruiseCas);
            this.performancePlan.speedCruiseEconMach.set(this.cruiseMach);
        }
        // Update perf plan for descent:
        if (this.performancePlan.speedDescentMode.get() === SpeedMode.SEL) {
            // Compute speed commands with MMO/VMO - 11 knots limit
            this.descentCas = Math.round(Math.min((_g = this.performancePlan.speedDescentSelectCas.get()) !== null && _g !== void 0 ? _g : -1, maxSelectedDesCas));
            this.descentMach = MathUtils.round(Math.min((_h = this.performancePlan.speedDescentSelectMach.get()) !== null && _h !== void 0 ? _h : -1, maxSelectedDesMach), 0.001);
        }
        else {
            // Compute speed commands with MMO/VMO - 16 knots limit
            // For descend the ECON speeds, only ci plays a part but not wind:
            this.descentCas = Math.round(Math.min(ciAdjustedEconCas, maxEconDesCas));
            this.descentMach = MathUtils.round(Math.min(ciAdjustedEconMach, maxEconDesMach), 0.001);
            // Finally store the new ECON speeds in perfplan:
            this.performancePlan.speedDescentEconCas.set(this.descentCas);
            this.performancePlan.speedDescentEconMach.set(this.descentMach);
        }
        // The CDU needs to know whether to display econ cruise speed or econ cruise mach:
        this.performancePlan.speedCruiseEconUnit.set(crossOverAltitude < cruiseAltitude ? 'mach' : 'cas');
    }
    /**
     * Updates this manager.
     */
    update() {
        var _a, _b, _c, _d;
        this.updateData();
        this.currentStateIndex = (_c = (_b = (_a = this.currentState).update) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : this.currentStateIndex;
        // we always target 5 knots below the limit max
        const configurationMaxLimit = this.getConfigurationLimit() - 5;
        const configurationMinLimit = Math.round((_d = this.minimumManeuveringSpeed.get()) !== null && _d !== void 0 ? _d : -1);
        const scheduledCas = this.currentState.targetCas();
        const scheduledMach = this.currentState.targetMach();
        switch (this.currentStateIndex) {
            case SpeedStateMachineState.Takeoff:
            case SpeedStateMachineState.GoAround: {
                this.computeTarget(undefined, FmsSpeedTargetSource.ClimbSchedule, scheduledCas, scheduledMach, this.climbSpeedLimitCeiling.get(), this.climbSpeedLimitSpeed.get(), this.climbSpeedRestrictionCeiling.get(), this.climbSpeedRestrictionSpeed.get(), configurationMaxLimit, configurationMinLimit);
                this.apTargetTogaIas = this.currentState.targetCas();
                break;
            }
            case SpeedStateMachineState.Climb: {
                this.computeTarget(VerticalFlightPhase.Climb, FmsSpeedTargetSource.ClimbSchedule, scheduledCas, scheduledMach, this.climbSpeedLimitCeiling.get(), this.climbSpeedLimitSpeed.get(), this.climbSpeedRestrictionCeiling.get(), this.climbSpeedRestrictionSpeed.get(), configurationMaxLimit, configurationMinLimit);
                break;
            }
            case SpeedStateMachineState.Cruise: {
                // when cruise phase is active, the speed target is the most restrictive of speed transition,
                // best hold speed, or ECON cruise (above speed transition altitude)
                this.computeTarget(VerticalFlightPhase.Descent, FmsSpeedTargetSource.CruiseSchedule, scheduledCas, scheduledMach, this.descentSpeedLimitCeiling.get(), this.descentSpeedLimitSpeed.get(), this.descentSpeedRestrictionCeiling.get(), this.descentSpeedRestrictionSpeed.get(), configurationMaxLimit, configurationMinLimit);
                break;
            }
            case SpeedStateMachineState.Approach:
            case SpeedStateMachineState.Descent: {
                this.computeTarget(VerticalFlightPhase.Descent, FmsSpeedTargetSource.DescentSchedule, scheduledCas, scheduledMach, this.descentSpeedLimitCeiling.get(), this.descentSpeedLimitSpeed.get(), this.descentSpeedRestrictionCeiling.get(), this.descentSpeedRestrictionSpeed.get(), configurationMaxLimit, configurationMinLimit);
                break;
            }
        }
        this.reconcileActiveTarget();
        this.publishTargetData();
        if (!this.apSelectedSpeedIsManual.get()) {
            this.setApValues();
        }
    }
    /**
     * Get the current state machine index
     * @returns current state machine index
     */
    get currentStateIndex() {
        return this._currentStateIndex;
    }
    /** Set the current state machine index */
    set currentStateIndex(index) {
        var _a, _b, _c, _d;
        if (index !== this._currentStateIndex) {
            (_b = (_a = this.currentState).onLeave) === null || _b === void 0 ? void 0 : _b.call(_a);
            this._currentStateIndex = index;
            (_d = (_c = this.currentState).onEnter) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    /**
     * Get the currently active state instance
     * @returns currently active state instance
     */
    get currentState() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        return this.states.get(this.currentStateIndex);
    }
    /**
     * Handle/inject events for the speed selection state machine
     * @param event Event to inject
     */
    onEvent(event) {
        var _a, _b, _c;
        this.currentStateIndex = (_c = (_b = (_a = this.currentState).onEvent) === null || _b === void 0 ? void 0 : _b.call(_a, event)) !== null && _c !== void 0 ? _c : this.currentStateIndex;
    }
    /**
     * Gets the speed limit, in knots, imposed by the aircraft's current flaps/gear configuration.
     * @returns The speed limit, in knots, imposed by the aircraft's current flaps/gear configuration. A negative value
     * indicates there is no such limit.
     */
    getConfigurationLimit() {
        const gearExtension = Math.max(this.gearNosePosition.get(), this.gearLeftPosition.get(), this.gearRightPosition.get()) * 100;
        const gearSpeed = gearExtension > 0 ? this.gearExtendedSpeed : -1;
        const flapSpeed = this.flapSpeedLimit.get();
        return gearSpeed > 0 && flapSpeed > 0 ? Math.min(gearSpeed, flapSpeed) : Math.max(gearSpeed, flapSpeed);
    }
    /**
     * Computes a target speed for a given flight phase.
     * @param speedConstraintFlightPhase The current flight phase to use for determining how to follow flight plan speed
     * constraints, or `undefined` if it is unknown.
     * @param scheduleSource The source to use for speeds derived from the active performance schedule.
     * @param scheduledCas The indicated airspeed, in knots, defined by the active performance schedule.
     * @param scheduledMach The mach number defined by the active performance schedule.
     * @param speedLimitCeiling The altitude ceiling, in feet, for the current flight phase's altitude speed limit.
     * @param speedLimitSpeed The altitude speed limit, in knots, for the current flight phase.
     * @param speedRestrictionCeiling The speed limit, in knots, for the current flight phase's speed restriction.
     * @param speedRestrictionSpeed The altitude ceiling, in feet, for the current flight phase's speed restriction.
     * @param configurationMaxIasLimit The maximum speed limit, in knots, imposed by the aircraft's current flaps/gear
     * configuration. A negative value indicates there is no such limit.
     * @param configurationMinIasLimit The minimum speed limit, in knots, imposed by the aircraft's current flaps
     * configuration. A negative value indicates there is no such limit.
     */
    computeTarget(speedConstraintFlightPhase, scheduleSource, scheduledCas, scheduledMach, speedLimitCeiling, speedLimitSpeed, speedRestrictionCeiling, speedRestrictionSpeed, configurationMaxIasLimit, configurationMinIasLimit) {
        const activeLegIndex = this.lnavLegIndex.get();
        const alongTrackSpeed = this.lnavAlongTrackSpeed.get();
        const lateralPlan = this.flightPlanner.hasActiveFlightPlan() ? this.flightPlanner.getActiveFlightPlan() : undefined;
        const currentConstraint = speedConstraintFlightPhase === undefined || lateralPlan === undefined
            ? undefined
            : this.pathCalculator.getCurrentSpeedConstraint(BoeingFms.ACT_RTE_PLAN_INDEX, activeLegIndex, speedConstraintFlightPhase);
        const nextConstraint = speedConstraintFlightPhase === undefined || alongTrackSpeed <= 0 || lateralPlan === undefined
            ? undefined
            : this.pathCalculator.getNextSpeedConstraint(BoeingFms.ACT_RTE_PLAN_INDEX, activeLegIndex, speedConstraintFlightPhase);
        this.speedLimitState = this.getAltitudeLimitState(speedLimitCeiling, speedLimitSpeed, this.speedLimitState);
        this.speedRestrictionState = this.getAltitudeLimitState(speedRestrictionCeiling, speedRestrictionSpeed, this.speedRestrictionState);
        // If the previously anticipated flight plan speed constraint is not the same as the next flight plan speed
        // constraint, then this means we have sequenced the anticipated constraint or the flight plan has changed.
        // Either way, we reset the anticipated constraint state.
        if (this.armedAnticipatedConstraint !== nextConstraint) {
            this.armedAnticipatedConstraint = undefined;
        }
        if (this.anticipatedConstraint !== nextConstraint) {
            this.anticipatedConstraint = undefined;
        }
        // Resolve altitude speed limit and flight plan constraint anticipation
        let speedLimitAnticipationTime = undefined; // seconds
        let speedRestrictionAnticipationTime = undefined; // seconds
        let constraintAnticipationDistance = undefined; // metres
        if (this.speedLimitState === FmsAltitudeLimitState.AnticipationNeeded) {
            const vs = MathUtils.clamp(this.verticalSpeedMps.get(), FmsSpeedManager.SPEED_REDUCTION_MIN_ANTICIPATION_VS, 0);
            speedLimitAnticipationTime = vs >= 0
                ? undefined
                : UnitType.METER.convertFrom((speedLimitCeiling !== null && speedLimitCeiling !== void 0 ? speedLimitCeiling : 10000) - this.indicatedAltitude.get(), UnitType.FOOT) / vs;
        }
        if (this.speedRestrictionState === FmsAltitudeLimitState.AnticipationNeeded) {
            const vs = MathUtils.clamp(this.verticalSpeedMps.get(), FmsSpeedManager.SPEED_REDUCTION_MIN_ANTICIPATION_VS, 0);
            speedRestrictionAnticipationTime = vs >= 0
                ? undefined
                : UnitType.METER.convertFrom((speedRestrictionCeiling !== null && speedRestrictionCeiling !== void 0 ? speedRestrictionCeiling : 10000) - this.indicatedAltitude.get(), UnitType.FOOT) / vs;
        }
        if (nextConstraint !== undefined && lateralPlan !== undefined) {
            constraintAnticipationDistance = FmsSpeedManager.getDistanceToConstraint(lateralPlan, this.lnavLegIndex.get(), UnitType.METER.convertFrom(this.lnavLegDistanceRemaining.get(), UnitType.NMILE), nextConstraint.globalLegIndex);
        }
        let altitudeIasLimitToUse = null;
        if (this.speedLimitState === FmsAltitudeLimitState.InEffect && this.speedRestrictionState === FmsAltitudeLimitState.InEffect) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            altitudeIasLimitToUse = Math.min(speedLimitSpeed, speedRestrictionSpeed);
        }
        else if (this.speedLimitState === FmsAltitudeLimitState.InEffect) {
            altitudeIasLimitToUse = speedLimitSpeed;
        }
        else if (this.speedRestrictionState === FmsAltitudeLimitState.InEffect) {
            altitudeIasLimitToUse = speedRestrictionSpeed;
        }
        const constraintToUse = currentConstraint;
        let isAnticipatedSpeedLimitActive = false;
        let isAnticipatedSpeedRestrictionActive = false;
        let armedAnticipatedConstraint = undefined;
        let anticipatedConstraint = undefined;
        // Compute speed targets with no anticipation.
        let targetSpeedInfo = this.computeSpeedsWithConstraint(scheduleSource, scheduledCas, scheduledMach, altitudeIasLimitToUse, configurationMaxIasLimit, configurationMinIasLimit, constraintToUse === null || constraintToUse === void 0 ? void 0 : constraintToUse.speedConstraint, this.computedSpeedInfo);
        let isAnyDragRequired = false;
        // calculate the idle thrust for one engine
        const idleN1 = this.perfProvider.getEngineIdleCorrectedN1(this.ambientTemperature.get(), this.machNumber.get());
        const idleThrust = this.perfProvider.getEngineUncorrectedNetThrust(idleN1, this.machNumber.get(), UnitType.IN_HG.convertTo(this.ambientPressure.get(), UnitType.HPA), this.ambientTemperature.get());
        // decide which of speed limit, speed restriction, or constraint applies and which is limiting earliest
        let lowestAnticipationTime = Infinity;
        if (speedLimitAnticipationTime !== undefined) {
            const speedLimitTargetSpeedInfo = this.computeSpeedsWithConstraint(scheduleSource, scheduledCas, scheduledMach, speedLimitSpeed, configurationMaxIasLimit, configurationMinIasLimit, constraintToUse === null || constraintToUse === void 0 ? void 0 : constraintToUse.speedConstraint, this.computedSpeedInfoWithSpeedLimit);
            const [useSpeed, dragRequired] = this.shouldUseAnticipatedSpeedForTime(targetSpeedInfo, speedLimitTargetSpeedInfo, speedLimitAnticipationTime, idleThrust, this.isAnticipatedSpeedLimitActive, this.isAnticipatedSpeedLimitDragRequiredActive);
            this.isAnticipatedSpeedLimitDragRequiredActive = dragRequired;
            isAnyDragRequired || (isAnyDragRequired = dragRequired);
            if (useSpeed) {
                targetSpeedInfo = speedLimitTargetSpeedInfo;
                lowestAnticipationTime = speedLimitAnticipationTime;
                isAnticipatedSpeedLimitActive = true;
            }
        }
        if (speedRestrictionAnticipationTime !== undefined) {
            if (lowestAnticipationTime > speedRestrictionAnticipationTime || this.speedRestrictionState === FmsAltitudeLimitState.InEffect) {
                const speedRestrictionTargetSpeedInfo = this.computeSpeedsWithConstraint(scheduleSource, scheduledCas, scheduledMach, speedRestrictionSpeed, configurationMaxIasLimit, configurationMinIasLimit, constraintToUse === null || constraintToUse === void 0 ? void 0 : constraintToUse.speedConstraint, this.computedSpeedInfoWithSpeedRestriction);
                const [useSpeed, dragRequired] = this.shouldUseAnticipatedSpeedForTime(targetSpeedInfo, speedRestrictionTargetSpeedInfo, speedRestrictionAnticipationTime, idleThrust, this.isAnticipatedSpeedRestrictionActive, this.isAnticipatedSpeedRestrictionDragRequiredActive);
                this.isAnticipatedSpeedRestrictionDragRequiredActive = dragRequired;
                isAnyDragRequired || (isAnyDragRequired = dragRequired);
                if (useSpeed) {
                    targetSpeedInfo = speedRestrictionTargetSpeedInfo;
                    lowestAnticipationTime = speedRestrictionAnticipationTime;
                    isAnticipatedSpeedRestrictionActive = true;
                }
            }
        }
        if (constraintAnticipationDistance !== undefined) {
            if (lowestAnticipationTime > constraintAnticipationDistance) {
                const nextConstraintTargetSpeedInfo = this.computeSpeedsWithConstraint(scheduleSource, scheduledCas, scheduledMach, altitudeIasLimitToUse, configurationMaxIasLimit, configurationMinIasLimit, 
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                nextConstraint.speedConstraint, this.computedSpeedInfoWithNextConstraint);
                this.isAnticipatedSpeedConstraintDragRequiredActive && (this.isAnticipatedSpeedConstraintDragRequiredActive = this.anticipatedConstraint !== undefined);
                const [useSpeed, dragRequired] = this.shouldUseAnticipatedSpeedForDistance(targetSpeedInfo, nextConstraintTargetSpeedInfo, constraintAnticipationDistance, idleThrust, this.anticipatedConstraint !== undefined, this.isAnticipatedSpeedConstraintDragRequiredActive);
                this.isAnticipatedSpeedConstraintDragRequiredActive = dragRequired;
                isAnyDragRequired || (isAnyDragRequired = dragRequired);
                if (useSpeed) {
                    targetSpeedInfo = nextConstraintTargetSpeedInfo;
                    lowestAnticipationTime = constraintAnticipationDistance;
                    anticipatedConstraint = nextConstraint;
                }
                else {
                    armedAnticipatedConstraint = nextConstraint;
                }
            }
        }
        this.dragRequired.set(isAnyDragRequired &&
            (this.apVerticalMode.get() === BoeingVNavModes.SPD_DESCENT || this.apVerticalMode.get() === BoeingVNavModes.PATH_DESCENT));
        this.isAnticipatedSpeedLimitActive = isAnticipatedSpeedLimitActive;
        this.isAnticipatedSpeedRestrictionActive = isAnticipatedSpeedRestrictionActive;
        this.armedAnticipatedConstraint = armedAnticipatedConstraint;
        this.anticipatedConstraint = anticipatedConstraint;
        // Save computed speeds
        this.maxIas = targetSpeedInfo.maxIas;
        this.maxIasSource = targetSpeedInfo.maxIasSource;
        this.maxMach = targetSpeedInfo.maxMach;
        this.maxMachSource = targetSpeedInfo.maxMachSource;
        this.maxIsMach = targetSpeedInfo.maxIsMach;
        this.targetIas = targetSpeedInfo.targetIas;
        this.targetIasSource = targetSpeedInfo.targetIasSource;
        this.targetMach = targetSpeedInfo.targetMach;
        this.targetMachSource = targetSpeedInfo.targetMachSource;
        this.targetIsMach = targetSpeedInfo.targetIsMach;
    }
    /**
     * Gets the current state of an altitude speed limit.
     * @param altitudeCeiling The altitude ceiling, in feet
     * @param speedLimit The speed limit, in knots
     * @param previousState The previous state of this limit
     * @returns The current state of the altitude speed limit.
     */
    getAltitudeLimitState(altitudeCeiling, speedLimit, previousState) {
        let anticipationNeeded;
        if (altitudeCeiling === null || speedLimit === null) {
            return FmsAltitudeLimitState.AnticipationNotNeeded;
        }
        const indicatedAltitude = this.indicatedAltitude.get();
        // latch the speed limit state so it doesn't oscillate when level at the limit altitude
        if (previousState === FmsAltitudeLimitState.InEffect && (this.apSelectedAltitude.get() <= altitudeCeiling) && ((indicatedAltitude - altitudeCeiling) < 100)) {
            return FmsAltitudeLimitState.InEffect;
        }
        if (!this.isOnGround.get()) {
            const fmaData = this.apFmaData.get();
            switch (fmaData === null || fmaData === void 0 ? void 0 : fmaData.verticalActive) {
                case APVerticalModes.TO:
                case APVerticalModes.GA:
                    // If AP is in TOGA mode, then the airplane will be expected to always be climbing.
                    anticipationNeeded = false;
                    break;
                case APVerticalModes.GS:
                case APVerticalModes.GP:
                    // If AP is in glideslope/glidepath mode, then the airplane will descend through any selected altitude or VNAV
                    // target altitude, so anticipation is needed as long as the airplane is above the altitude limit ceiling.
                    anticipationNeeded = true;
                    break;
                case APVerticalModes.PITCH:
                case APVerticalModes.VS:
                case APVerticalModes.FLC:
                    // If the AP is in PITCH, VS, or FLC, then anticipation is needed only if the airplane is descending and if the
                    // selected altitude is less than the altitude limit ceiling (otherwise the airplane would be guaranteed to
                    // level off before crossing the ceiling).
                    if (this.apSelectedAltitude.get() < altitudeCeiling) {
                        anticipationNeeded = true;
                    }
                    else {
                        anticipationNeeded = false;
                    }
                    break;
                case BoeingVNavModes.SPD_CLIMB:
                    // TODO: Is this right?
                    anticipationNeeded = false;
                    break;
                case APVerticalModes.PATH:
                case BoeingVNavModes.PATH_DESCENT:
                case BoeingVNavModes.PATH_IDLE:
                case BoeingVNavModes.SPD_DESCENT:
                case BoeingVNavModes.THR_DESCENT:
                    if (this.apSelectedAltitude.get() < altitudeCeiling) {
                        // If VNAV is enabled and active, then AP will capture the VNAV target altitude if one exists and is higher
                        // than the selected altitude. So anticipation is needed if and only if the VNAV target altitude is less than
                        // the altitude limit ceiling (if there is no target altitude, the published value is -1, so the check still
                        // works).
                        anticipationNeeded = this.vnavTargetAltitude.get() < altitudeCeiling;
                    }
                    else {
                        anticipationNeeded = false;
                    }
                    break;
                case APVerticalModes.ALT:
                case APVerticalModes.CAP:
                case BoeingVNavModes.PATH_LEVEL:
                case BoeingVNavModes.ALT:
                    // If the AP is in an altitude capture or hold mode, then anticipation is never needed since the airplane is
                    // expected to hold a constant altitude. We also use the captured altitude instead of indicated altitude to
                    // determine if the speed limit is in effect.
                    return this.apCapturedAltitude.get() < altitudeCeiling
                        ? FmsAltitudeLimitState.InEffect : FmsAltitudeLimitState.AnticipationNotNeeded;
                default:
                    anticipationNeeded = false;
            }
        }
        else {
            anticipationNeeded = false;
        }
        return indicatedAltitude < altitudeCeiling
            ? FmsAltitudeLimitState.InEffect
            : anticipationNeeded ? FmsAltitudeLimitState.AnticipationNeeded : FmsAltitudeLimitState.AnticipationNotNeeded;
    }
    /**
     * Computes maximum and target speeds using a given speed constraint.
     * @param scheduleSource The source to use for speeds derived from the active performance schedule.
     * @param scheduledIas The indicated airspeed, in knots, defined by the active performance schedule.
     * @param scheduledMach The mach number defined by the active performance schedule.
     * @param altitudeIasLimit The altitude speed limit, in knots, for the current flight phase, or `null` if the
     * altitude speed limit is to be ignored.
     * @param configurationMaxIasLimit The maximum speed limit, in knots, imposed by the aircraft's current flaps/gear
     * configuration. A negative value indicates there is no such limit.
     * @param configurationMinIasLimit The minimum speed limit, in knots, imposed by the aircraft's current flaps
     * configuration. A negative value indicates there is no such limit.
     * @param speedConstraint The speed constraint to use.
     * @param out The object to which to write the results.
     * @returns Computed maximum and target speeds using the specified speed constraint.
     */
    computeSpeedsWithConstraint(scheduleSource, scheduledIas, scheduledMach, altitudeIasLimit, configurationMaxIasLimit, configurationMinIasLimit, speedConstraint, out) {
        scheduledIas = Math.round(scheduledIas);
        scheduledMach = MathUtils.round(scheduledMach, 0.001); // FMS mach speed shall have 3 significant digits
        altitudeIasLimit = altitudeIasLimit === null ? null : Math.round(altitudeIasLimit);
        let minIasTarget = -Infinity;
        let minIasTargetSource = FmsSpeedTargetSource.None;
        let maxIasTarget = Infinity;
        let maxIasTargetSource = FmsSpeedTargetSource.None;
        let minMachTarget = -Infinity;
        let minMachTargetSource = FmsSpeedTargetSource.None;
        let maxMachTarget = Infinity;
        let maxMachTargetSource = FmsSpeedTargetSource.None;
        // ---- Flight Plan Speed Constraints ----
        switch (speedConstraint === null || speedConstraint === void 0 ? void 0 : speedConstraint.speedDesc) {
            case SpeedRestrictionType.AtOrAbove:
                if (speedConstraint.speedUnit === SpeedUnit.IAS) {
                    minIasTarget = Math.round(speedConstraint.speed);
                    minIasTargetSource = FmsSpeedTargetSource.Constraint;
                }
                else {
                    minMachTarget = MathUtils.round(speedConstraint.speed, 0.01);
                    minMachTargetSource = FmsSpeedTargetSource.Constraint;
                }
                break;
            case SpeedRestrictionType.AtOrBelow:
                if (speedConstraint.speedUnit === SpeedUnit.IAS) {
                    maxIasTarget = Math.round(speedConstraint.speed);
                    maxIasTargetSource = FmsSpeedTargetSource.Constraint;
                }
                else {
                    maxMachTarget = MathUtils.round(speedConstraint.speed, 0.01);
                    maxMachTargetSource = FmsSpeedTargetSource.Constraint;
                }
                break;
            case SpeedRestrictionType.At:
            case SpeedRestrictionType.Between:
                if (speedConstraint.speedUnit === SpeedUnit.IAS) {
                    minIasTarget = maxIasTarget = Math.round(speedConstraint.speed);
                    minIasTargetSource = maxIasTargetSource = FmsSpeedTargetSource.Constraint;
                }
                else {
                    minMachTarget = maxMachTarget = MathUtils.round(speedConstraint.speed, 0.01);
                    minMachTargetSource = maxMachTargetSource = FmsSpeedTargetSource.Constraint;
                }
                break;
        }
        // ---- Altitude Limit ----
        if (altitudeIasLimit !== null) {
            if (altitudeIasLimit < minIasTarget) {
                minIasTarget = altitudeIasLimit;
                minIasTargetSource = FmsSpeedTargetSource.Altitude;
            }
            if (altitudeIasLimit < maxIasTarget) {
                maxIasTarget = altitudeIasLimit;
                maxIasTargetSource = FmsSpeedTargetSource.Altitude;
            }
        }
        // ---- Airframe limits ----
        const airframeMaxIas = this.speedData.getVmo();
        if (airframeMaxIas < minIasTarget) {
            minIasTarget = airframeMaxIas;
            minIasTargetSource = FmsSpeedTargetSource.Configuration;
        }
        if (airframeMaxIas < maxIasTarget) {
            maxIasTarget = airframeMaxIas;
            maxIasTargetSource = FmsSpeedTargetSource.Configuration;
        }
        const airframeMaxMach = this.speedData.getMmo();
        if (airframeMaxMach < minMachTarget) {
            minMachTarget = airframeMaxMach;
            minMachTargetSource = FmsSpeedTargetSource.Configuration;
        }
        if (airframeMaxMach < maxMachTarget) {
            maxMachTarget = airframeMaxMach;
            maxMachTargetSource = FmsSpeedTargetSource.Configuration;
        }
        // ---- Aircraft configuration ----
        if (configurationMaxIasLimit >= 0) {
            if (configurationMaxIasLimit < minIasTarget) {
                minIasTarget = configurationMaxIasLimit;
                minIasTargetSource = FmsSpeedTargetSource.Configuration;
            }
            if (configurationMaxIasLimit < maxIasTarget) {
                maxIasTarget = configurationMaxIasLimit;
                maxIasTargetSource = FmsSpeedTargetSource.Configuration;
            }
        }
        if (configurationMinIasLimit >= 0) {
            if (configurationMinIasLimit > minIasTarget) {
                minIasTarget = configurationMinIasLimit;
                minIasTargetSource = FmsSpeedTargetSource.Configuration;
            }
            if (configurationMinIasLimit > maxIasTarget) {
                maxIasTarget = configurationMinIasLimit;
                maxIasTargetSource = FmsSpeedTargetSource.Configuration;
            }
        }
        // Save computed maximum speeds
        out.maxIas = maxIasTarget;
        out.maxIasSource = maxIasTargetSource;
        out.maxMach = maxMachTarget;
        out.maxMachSource = maxMachTargetSource;
        const maxSpeedHysteresis = this.maxIsMach ? FmsSpeedManager.IAS_MACH_CONVERSION_HYSTERESIS : 0;
        const maxMachIas = out.maxMach * this.machToKias;
        out.maxIsMach = maxMachIas - maxSpeedHysteresis < out.maxIas;
        // ---- Schedule ----
        if (scheduledIas < 0 && scheduledMach < 0) {
            // Schedule is not targeting speed.
            out.targetIas = -1;
            out.targetIasSource = FmsSpeedTargetSource.None;
            out.targetMach = -1;
            out.targetMachSource = FmsSpeedTargetSource.None;
            out.targetIsMach = false;
            return out;
        }
        if (scheduledIas >= minIasTarget && scheduledIas <= maxIasTarget) {
            minIasTarget = maxIasTarget = scheduledIas;
            minIasTargetSource = maxIasTargetSource = scheduleSource;
        }
        if (scheduledMach > 0 && scheduledMach >= minMachTarget && scheduledMach <= maxMachTarget) {
            minMachTarget = maxMachTarget = scheduledMach;
            minMachTargetSource = maxMachTargetSource = scheduleSource;
        }
        const targetSpeedHysteresis = this.targetIsMach ? FmsSpeedManager.IAS_MACH_CONVERSION_HYSTERESIS : 0;
        const minMachTargetIas = minMachTarget * this.machToKias;
        const maxMachTargetIas = maxMachTarget * this.machToKias;
        const minIasPriority = FmsSpeedManager.SOURCE_PRIORITY[minIasTargetSource];
        const maxIasPriority = FmsSpeedManager.SOURCE_PRIORITY[maxIasTargetSource];
        const minMachPriority = FmsSpeedManager.SOURCE_PRIORITY[minMachTargetSource];
        const maxMachPriority = FmsSpeedManager.SOURCE_PRIORITY[maxMachTargetSource];
        // Initialize the target IAS and mach values to the highest possible values.
        out.targetIas = maxIasTarget;
        out.targetIasSource = maxIasTargetSource;
        out.targetMach = maxMachTarget;
        out.targetMachSource = maxMachTargetSource;
        const targetMachIas = out.targetMach > 0 ? out.targetMach * this.machToKias : -1;
        // Whichever of mac or ias is more limiting wins
        // we only care about source priorities when deciding which mach limit and which ias limit to choose
        out.targetIsMach = out.targetMach > 0 && (out.targetIas < 0 || (targetMachIas - targetSpeedHysteresis) < out.targetIas);
        // TODO this code looks a bit bogus too
        if (out.targetIsMach) {
            // We have chosen the maximum mach value over the maximum IAS value -> the only potentially remaining conflicting
            // speed is the minimum IAS value (the minimum mach value is guaranteed to be less than or equal to the maximum
            // mach value). Therefore, we will choose the minimum IAS value if it is greater and has greater priority and the
            // maximum mach value otherwise.
            if (minIasTarget > maxMachTargetIas - targetSpeedHysteresis && minIasPriority > maxMachPriority) {
                out.targetIas = minIasTarget;
                out.targetIasSource = minIasTargetSource;
                out.targetIsMach = false;
            }
            else {
                out.targetIsMach = true;
            }
        }
        else if (maxIasPriority < maxMachPriority) {
            // We have chosen the maximum IAS value over the maximum mach value -> the only potentially remaining conflicting
            // speed is the minimum mach value (the minimum IAS value is guaranteed to be less than or equal to the maximum
            // IAS value). Therefore, we will choose the minimum mach value if it is greater and has greater priority and the
            // maximum IAS value otherwise.
            if (minMachTargetIas + targetSpeedHysteresis > maxIasTarget && minMachPriority > maxIasPriority) {
                out.targetMach = minMachTarget;
                out.targetMachSource = minMachTargetSource;
                out.targetIsMach = true;
            }
            else {
                out.targetIsMach = false;
            }
        }
        return out;
    }
    /**
     * Checks whether this manager should use the speeds computed for an anticipated limit instead of the ones computed
     * for the non-anticipated limit.
     * @param currentTargetSpeedInfo The computed speeds for the non-anticipated limit.
     * @param anticipatedTargetSpeedInfo The computed speeds for the anticipated limit.
     * @param anticipationDistance The distance remaining, in metres, until the anticipated limit becomes active.
     * @param idleThrust Uncorrected net idle thrust for one engine in pounds
     * @param isUsingAnticipated Whether the anticipated limit is currently being used.
     * @param isDragRequiredActive Whether drag is already required to meet this anticipated speed.
     * @returns Whether this manager should use the speeds computed for an anticipated limit instead of the ones computed
     * for the non-anticipated limit.
     */
    shouldUseAnticipatedSpeedForDistance(currentTargetSpeedInfo, anticipatedTargetSpeedInfo, anticipationDistance, idleThrust, isUsingAnticipated, isDragRequiredActive) {
        const [, decelDistance] = this.getDecelForAnticipatedSpeed(currentTargetSpeedInfo, anticipatedTargetSpeedInfo, idleThrust);
        if (!isFinite(decelDistance)) {
            this.bool2Cache[0] = true;
            this.bool2Cache[1] = false;
            return this.bool2Cache;
        }
        const speed = UnitType.MPS.convertFrom(this.lnavAlongTrackSpeed.get(), UnitType.KNOT);
        const baseDistance = speed * FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_BASE;
        const hysteresisDistance = speed * FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_HYSTERESIS;
        const anticipationThreshold = baseDistance + decelDistance
            + (isUsingAnticipated ? hysteresisDistance : 0);
        const anticipationRequired = anticipationDistance <= anticipationThreshold;
        // send drag required message if needed
        const dragThreshold = decelDistance + (isDragRequiredActive ? hysteresisDistance : 0);
        const dragRequired = anticipationDistance < dragThreshold;
        this.bool2Cache[0] = anticipationRequired;
        this.bool2Cache[1] = dragRequired;
        return this.bool2Cache;
    }
    /**
     * Checks whether this manager should use the speeds computed for an anticipated limit instead of the ones computed
     * for the non-anticipated limit.
     * @param currentTargetSpeedInfo The computed speeds for the non-anticipated limit.
     * @param anticipatedTargetSpeedInfo The computed speeds for the anticipated limit.
     * @param anticipationTime The time remaining, in seconds, until the anticipated limit becomes active.
     * @param idleThrust Uncorrected net idle thrust for one engine in pounds
     * @param isUsingAnticipated Whether the anticipated limit is currently being used.
     * @param isDragRequiredActive Whether drag is already required to meet this anticipated speed.
     * @returns Whether this manager should use the speeds computed for an anticipated limit instead of the ones computed
     * for the non-anticipated limit.
     */
    shouldUseAnticipatedSpeedForTime(currentTargetSpeedInfo, anticipatedTargetSpeedInfo, anticipationTime, idleThrust, isUsingAnticipated, isDragRequiredActive) {
        const [decelTime] = this.getDecelForAnticipatedSpeed(currentTargetSpeedInfo, anticipatedTargetSpeedInfo, idleThrust);
        if (!isFinite(decelTime)) {
            this.bool2Cache[0] = true;
            this.bool2Cache[1] = false;
            return this.bool2Cache;
        }
        const anticipationThreshold = FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_BASE + decelTime
            + (isUsingAnticipated ? FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_HYSTERESIS : 0);
        const anticipationRequired = anticipationTime <= anticipationThreshold;
        // send drag required message if needed
        const dragThreshold = decelTime + (isDragRequiredActive ? FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_HYSTERESIS : 0);
        const dragRequired = anticipationTime < dragThreshold;
        this.bool2Cache[0] = anticipationRequired;
        this.bool2Cache[1] = dragRequired;
        return this.bool2Cache;
    }
    /**
     * Checks whether this manager should use the speeds computed for an anticipated limit instead of the ones computed
     * for the non-anticipated limit.
     * @param currentTargetSpeedInfo The computed speeds for the non-anticipated limit.
     * @param anticipatedTargetSpeedInfo The computed speeds for the anticipated limit.
     * @param idleThrust Uncorrected net idle thrust for one engine in pounds
     * @returns Float64Array containing the deceleration time and deceleration distance.
     * Infinity will be returned if the limit should already be active
     */
    getDecelForAnticipatedSpeed(currentTargetSpeedInfo, anticipatedTargetSpeedInfo, idleThrust) {
        const currentHasTarget = (currentTargetSpeedInfo.targetIsMach ? currentTargetSpeedInfo.targetMach : currentTargetSpeedInfo.targetIas) >= 0;
        const currentHasMax = (currentTargetSpeedInfo.maxIsMach ? currentTargetSpeedInfo.maxMach : currentTargetSpeedInfo.maxIas) >= 0;
        const anticipatedHasTarget = (anticipatedTargetSpeedInfo.targetIsMach ? anticipatedTargetSpeedInfo.targetMach : anticipatedTargetSpeedInfo.targetIas) >= 0;
        const anticipatedHasMax = (anticipatedTargetSpeedInfo.maxIsMach ? anticipatedTargetSpeedInfo.maxMach : anticipatedTargetSpeedInfo.maxIas) >= 0;
        if ((!anticipatedHasTarget && !anticipatedHasMax) || (currentHasTarget && !anticipatedHasTarget) || (currentHasMax && !anticipatedHasMax && !anticipatedHasTarget)) {
            this.vec2Cache[0][0] = 0;
            this.vec2Cache[0][1] = 0;
            return this.vec2Cache[0];
        }
        else if ((anticipatedHasTarget && !currentHasTarget) || (anticipatedHasMax && !currentHasMax)) {
            this.vec2Cache[0][0] = Infinity;
            this.vec2Cache[0][1] = Infinity;
            return this.vec2Cache[0];
        }
        // At this point, both current and anticipated limit are guaranteed to have at least one of max speed or target speed defined.
        let currentIas, currentMach, currentIsMach;
        if (currentHasTarget) {
            currentIas = currentTargetSpeedInfo.targetIas;
            currentMach = currentTargetSpeedInfo.targetMach;
            currentIsMach = currentTargetSpeedInfo.targetIsMach;
        }
        else {
            currentIas = currentTargetSpeedInfo.maxIas;
            currentMach = currentTargetSpeedInfo.maxMach;
            currentIsMach = currentTargetSpeedInfo.maxIsMach;
        }
        let anticipatedIas, anticipatedMach, anticipatedIsMach;
        if (anticipatedHasTarget) {
            anticipatedIas = anticipatedTargetSpeedInfo.targetIas;
            anticipatedMach = anticipatedTargetSpeedInfo.targetMach;
            anticipatedIsMach = anticipatedTargetSpeedInfo.targetIsMach;
        }
        else {
            anticipatedIas = anticipatedTargetSpeedInfo.maxIas;
            anticipatedMach = anticipatedTargetSpeedInfo.maxMach;
            anticipatedIsMach = anticipatedTargetSpeedInfo.maxIsMach;
        }
        const currentSpeedIas = currentIsMach
            ? currentMach * this.machToKias
            : currentIas;
        const limitSpeedIas = anticipatedIsMach
            ? anticipatedMach * this.machToKias
            : anticipatedIas;
        const speedDelta = currentSpeedIas - limitSpeedIas;
        if (speedDelta <= 0) {
            this.vec2Cache[0][0] = 0;
            this.vec2Cache[0][1] = 0;
            return this.vec2Cache[0];
        }
        const anticipatedTas = AeroMath.casToTas(UnitType.KNOT.convertTo(limitSpeedIas, UnitType.MPS), UnitType.IN_HG.convertTo(this.ambientPressure.get(), UnitType.HPA), this.ambientTemperature.get());
        return this.perfProvider.estimateTimeAndDistanceToAccelerate(UnitType.KNOT.convertTo(this.trueAirspeed.get(), UnitType.MPS), anticipatedTas, MathUtils.clamp(this.verticalSpeedMps.get(), FmsSpeedManager.SPEED_REDUCTION_MIN_ANTICIPATION_VS, 0), idleThrust, this.availableEngines.get(), this.perfProvider.getWingArea(), 0, this.grossWeight.get(), UnitType.IN_HG.convertTo(this.ambientPressure.get(), UnitType.HPA), this.ambientTemperature.get(), this.vec2Cache[0], UnitType.SLUG_PER_FT3.convertTo(this.ambientDensity.get(), UnitType.KG_PER_M3));
    }
    /**
     * Reconciles this manager's active target speed from the computed target and any existing user overrides.
     * configuration. A negative value indicates there is no such limit.
     */
    reconcileActiveTarget() {
        if (this.targetIas < 0 && this.targetMach < 0) {
            // If there is no computed target speed, it means the selected performance schedule is not targeting airspeed.
            // In this case we do not allow user speed overrides and just set the active target speeds to -1 to signal they
            // are undefined. We also reset the user speed overrides.
            this.activeIas = -1;
            this.activeMach = -1;
            this.activeIsMach = false;
            this.reconcileSpeedTargetsForAutopilot();
            return;
        }
        this.activeIas = this.targetIas;
        this.activeMach = this.targetMach;
        this.activeIsMach = this.targetIsMach;
        this.reconcileSpeedTargetsForAutopilot();
    }
    /**
     * Reconciles the speed targets for the autopilot.
     */
    reconcileSpeedTargetsForAutopilot() {
        if (this.apSelectedSpeedIsManual.get()) {
            this.apTargetIas = this.apSelectedIas.get();
            this.apTargetMach = this.apSelectedMach.get();
            this.apTargetIsMach = this.apSelectedSpeedIsMach.get();
        }
        else {
            this.apTargetIas = this.activeIas;
            this.apTargetMach = this.activeMach;
            this.apTargetIsMach = this.activeIsMach;
        }
    }
    /**
     * Publishes this manager's current target speed data to the event bus.
     */
    publishTargetData() {
        if (this.maxIas !== this.publishedMaxIas) {
            this.publishedMaxIas = this.maxIas;
            this.publisher.pub('fms_speed_computed_max_ias', this.maxIas, true, true);
        }
        if (this.maxMach !== this.publishedMaxMach) {
            this.publishedMaxMach = this.maxMach;
            this.publisher.pub('fms_speed_computed_max_mach', this.maxMach, true, true);
        }
        const maxSource = this.maxIsMach ? this.maxMachSource : this.maxIasSource;
        if (maxSource !== this.publishedMaxSource) {
            this.publishedMaxSource = maxSource;
            this.publisher.pub('fms_speed_computed_max_source', maxSource, true, true);
        }
        if (this.maxIsMach !== this.publishedMaxIsMach) {
            this.publishedMaxIsMach = this.maxIsMach;
            this.publisher.pub('fms_speed_computed_max_is_mach', this.maxIsMach, true, true);
        }
        if (this.targetIas !== this.publishedTargetIas) {
            this.publishedTargetIas = this.targetIas;
            this.publisher.pub('fms_speed_computed_target_ias', this.targetIas, true, true);
        }
        if (this.targetMach !== this.publishedTargetMach) {
            this.publishedTargetMach = this.targetMach;
            this.publisher.pub('fms_speed_computed_target_mach', this.targetMach, true, true);
        }
        const targetSource = this.targetIsMach ? this.targetMachSource : this.targetIasSource;
        if (targetSource !== this.publishedTargetSource) {
            this.publishedTargetSource = targetSource;
            this.publisher.pub('fms_speed_computed_target_source', targetSource, true, true);
        }
        if (this.targetIsMach !== this.publishedTargetIsMach) {
            this.publishedTargetIsMach = this.targetIsMach;
            this.publisher.pub('fms_speed_computed_target_is_mach', this.targetIsMach, true, true);
        }
        if (this.activeIas !== this.publishedActiveIas) {
            this.publishedActiveIas = this.activeIas;
            this.publisher.pub('fms_speed_active_target_ias', this.activeIas, true, true);
        }
        if (this.activeMach !== this.publishedActiveMach) {
            this.publishedActiveMach = this.activeMach;
            this.publisher.pub('fms_speed_active_target_mach', this.activeMach, true, true);
        }
        if (this.activeIsMach !== this.publishedActiveIsMach) {
            this.publishedActiveIsMach = this.activeIsMach;
            this.publisher.pub('fms_speed_active_target_is_mach', this.activeIsMach, true, true);
        }
        if (this.apTargetIas !== this.publishedApTargetIas) {
            this.publishedApTargetIas = this.apTargetIas;
            this.publisher.pub('fms_speed_autopilot_target_ias', this.apTargetIas, true, true);
        }
        if (this.apTargetMach !== this.publishedApTargetMach) {
            this.publishedApTargetMach = this.apTargetMach;
            this.publisher.pub('fms_speed_autopilot_target_mach', this.apTargetMach, true, true);
        }
        if (this.apTargetIsMach !== this.publishedApTargetIsMach) {
            this.publishedApTargetIsMach = this.apTargetIsMach;
            this.publisher.pub('fms_speed_autopilot_target_is_mach', this.apTargetIsMach, true, true);
        }
        if (this.apTargetTogaIas !== this.publishedApTargetTogaIas) {
            this.publishedApTargetTogaIas = this.apTargetTogaIas;
            // we don't need to sync this across the bus as it's for AP internal use only
            this.publisher.pub('fms_speed_autopilot_target_toga_ias', this.apTargetTogaIas);
        }
    }
    /**
     * Syncs this manager's active target speed to the sim's autopilot simvars.
     */
    setApValues() {
        const keyEventManager = this.keyEventManager;
        if (this.apSelectedSpeedIsMach.get() !== this.activeIsMach) {
            keyEventManager.triggerKey(this.activeIsMach ? 'AP_MANAGED_SPEED_IN_MACH_ON' : 'AP_MANAGED_SPEED_IN_MACH_OFF', true);
        }
        // if (this.activeIsMach) {
        //   if (this.apSelectedMach.get() !== this.activeMach) {
        //     keyEventManager.triggerKey('AP_MACH_VAR_SET', true, Math.max(0, this.activeMach * 100));
        //   }
        // } else {
        //   if (this.apSelectedIas.get() !== this.activeIas) {
        //     keyEventManager.triggerKey('AP_SPD_VAR_SET', true, Math.max(0, this.activeIas));
        //   }
        // }
    }
    /**
     * Destroys this manager.
     */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        this.isAlive = false;
        this.keyEventManagerReadyPromises.forEach(promise => { promise.reject('FmsSpeedManager: manager was destroyed'); });
        for (const state of this.states.values()) {
            (_a = state.destroy) === null || _a === void 0 ? void 0 : _a.call(state);
        }
        this.apSelectedIas.destroy();
        this.apSelectedMach.destroy();
        this.apSelectedSpeedIsMach.destroy();
        this.apSelectedSpeedIsManual.destroy();
        this.apSelectedAltitude.destroy();
        this.mcpTargetIas.destroy();
        this.mcpTargetMach.destroy();
        this.mcpTargetIsMach.destroy();
        this.mcpTargetIsActive.destroy();
        this.isOnGround.destroy();
        this.indicatedAltitude.destroy();
        this.indicatedAirspeed.destroy();
        this.machNumber.destroy();
        this.trueAirspeed.destroy();
        this.pressureAltitude.destroy();
        this.verticalSpeedMps.destroy();
        this.verticalSpeed.destroy();
        this.ambientDensity.destroy();
        this.ambientPressure.destroy();
        this.ambientTemperature.destroy();
        this.grossWeight.destroy();
        this.availableEngines.destroy();
        this.lnavIsTracking.destroy();
        this.lnavLegIndex.destroy();
        this.lnavLegDistanceRemaining.destroy();
        this.lnavAlongTrackSpeed.destroy();
        this.cruiseAltitude.destroy();
        this.vnavState.destroy();
        this.vnavFlightPhase.destroy();
        this.vnavTargetAltitude.destroy();
        this.flapSpeedLimit.destroy();
        this.minimumManeuveringSpeed.destroy();
        this.gearNosePosition.destroy();
        this.gearLeftPosition.destroy();
        this.gearRightPosition.destroy();
        this.pitchAttitude.destroy();
        this.onGround.destroy();
        (_b = this.keySub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clockSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.adcIndexSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.fmsPosIndexSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.machToKiasSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.pposSub) === null || _g === void 0 ? void 0 : _g.destroy();
        (_h = this.pitchAttitudeSub) === null || _h === void 0 ? void 0 : _h.destroy();
        (_j = this.onGroundSub) === null || _j === void 0 ? void 0 : _j.destroy();
        (_k = this.fmsPhaseSub) === null || _k === void 0 ? void 0 : _k.destroy();
        (_l = this.iasMachWindowSub) === null || _l === void 0 ? void 0 : _l.destroy();
        (_m = this.apFmaDataSub) === null || _m === void 0 ? void 0 : _m.destroy();
        (_o = this.apOrFdSub) === null || _o === void 0 ? void 0 : _o.destroy();
        (_p = this.dragRequiredSub) === null || _p === void 0 ? void 0 : _p.destroy();
        this.fplSubs.forEach(sub => { sub.destroy(); });
    }
    /**
     * Gets the distance remaining to a constraint, in meters.
     * @param plan The active flight plan.
     * @param activeLegIndex The index of the active leg.
     * @param activeLegDistanceRemaining The distance remaining to the end of the active leg, in metres.
     * @param constraintLegIndex The index of the constraint's leg.
     * @returns The distance remaining to the specified constraint, in metres.
     */
    static getDistanceToConstraint(plan, activeLegIndex, activeLegDistanceRemaining, constraintLegIndex) {
        var _a, _b;
        const activeLegCalc = (_a = plan.tryGetLeg(activeLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated;
        const constraintLegCalc = (_b = plan.tryGetLeg(constraintLegIndex)) === null || _b === void 0 ? void 0 : _b.calculated;
        if (activeLegCalc === undefined || constraintLegCalc === undefined) {
            return undefined;
        }
        return constraintLegCalc.cumulativeDistanceWithTransitions - activeLegCalc.cumulativeDistanceWithTransitions + activeLegDistanceRemaining;
    }
    /** Check if rotation occured during takeoff (pitch > 2°), note: sim pitch is inverted.. */
    checkRotation() {
        // TODO consider in-flight spawn, and go-around
        if (this.rotationPerformed && this.onGround.get() && this.pitchAttitude.get() >= -2) {
            this.rotationPerformed = false;
        }
        else if (!this.rotationPerformed && this.pitchAttitude.get() < -2) {
            this.rotationPerformed = true;
            this.onEvent(SpeedStateMachineEvents.Rotation);
        }
        if (this.onGround.get()) {
            this.groundAltitude = this.indicatedAltitude.get();
        }
    }
    /**
     * Gets the current calibrated airspeed in knots
     * @returns current calibrated airspeed in knots
     */
    getCurrentCas() {
        return this.indicatedAirspeed.get();
    }
    /**
     * Gets the FMS flight phase
     * @returns current flight phase
     */
    getFlightPhase() {
        return this.fmsPhase.get();
    }
    /**
     * Gets the current econ climb speed in kcas
     * @returns econ climb speed in kcas
     */
    getEconClimbSpeed() {
        return this.climbCas;
    }
    /**
     * Gets the current econ cruise speed in kcas
     * @returns econ cruise speed in kcas
     */
    getEconCruiseSpeed() {
        return this.cruiseCas;
    }
    /**
     * Gets the current econ descent speed in kcas
     * @returns econ descent speed in kcas
     */
    getEconDescentSpeed() {
        return this.descentCas;
    }
    /**
     * Gets the current econ climb mach
     * @returns econ climb mach
     */
    getEconClimbMach() {
        return this.climbMach;
    }
    /**
     * Gets the current econ cruise mach
     * @returns econ cruise mach
     */
    getEconCruiseMach() {
        return this.cruiseMach;
    }
    /**
     * Gets the current econ descent mach
     * @returns econ descent mach
     */
    getEconDescentMach() {
        return this.descentMach;
    }
    /**
     * Gets the approach speed target for the current config
     * @returns current approach speed target in kcas
     */
    getApproachSpeed() {
        // TODO how it should work
        // - if IAS/MACH window closed, manuevering speed for flap profile points passed, or manuevering speed for current flap config if lower
        // - else IAS/MACH window speed
        // IAS/MACH window is set and opened => no more managed speed at some point... when??
        const maneuverSpeed = this.flapManeuverSpeed.get();
        const apprFlapSpeed = this.performancePlan.approachFlapSpeed.get();
        const apprFlaps = apprFlapSpeed !== null ? apprFlapSpeed[0] : null;
        const vRef = apprFlapSpeed !== null ? apprFlapSpeed[1] : -1;
        const vRefCommand = vRef + this.performancePlan.approachWindCorrection.get();
        const useVref = vRef > 0 && (this.flapLimitPosition.get() === apprFlaps || (apprFlaps === null && vRefCommand < maneuverSpeed));
        return useVref ? vRefCommand : maneuverSpeed;
    }
    /**
     * IAS/Mach Window speed if it's IAS
     * @returns IAS/Mach Window speed if it's IAS, or -1 otherwise
     */
    getIasMachWindowSpeed() {
        return this.mcpTargetIsMach.get() ? -1 : this.mcpTargetIas.get();
    }
    /**
     * Gets the active lateral AP mode
     * @returns active lateral AP mode
     */
    getApLateralMode() {
        var _a, _b;
        return (_b = (_a = this.apFmaData.get()) === null || _a === void 0 ? void 0 : _a.lateralActive) !== null && _b !== void 0 ? _b : APLateralModes.NONE;
    }
    /**
     * Gets the active vertical AP mode
     * @returns active vertical AP mode
     */
    getApVerticalMode() {
        var _a, _b;
        return (_b = (_a = this.apFmaData.get()) === null || _a === void 0 ? void 0 : _a.verticalActive) !== null && _b !== void 0 ? _b : APVerticalModes.NONE;
    }
    /**
     * Is any AP or FD currently engaged?
     * @returns true if any are engaged
     */
    isApOrFdEngaged() {
        return this.apOrFdEngaged.get();
    }
    /**
     * Is any engine out?
     * @returns true if an engine is out
     */
    isAnEngineOut() {
        return this.engineOut.get();
    }
    /**
     * Get the takeoff field elevation.
     * Will use navdata, or fall back to indicated alt when last on the ground
     * @returns takeoff field elevation in feet MSL
     */
    getTakeoffFieldElevation() {
        const originRunway = this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX).procedureDetails.originRunway;
        const fieldElevation = originRunway ? UnitType.FOOT.convertFrom(originRunway.elevation, UnitType.METER) : this.groundAltitude;
        return fieldElevation;
    }
    /**
     * Gets the acceleration altitude for initial climb
     * @returns acceleration altitude in feet MSL
     */
    getAccelerationAltitude() {
        const accelHeight = this.performancePlan.takeoffAccelerationHeight.get();
        const fieldElevation = this.getTakeoffFieldElevation();
        return fieldElevation + accelHeight;
    }
    /**
     * Gets the engine out acceleration altitude for initial climb
     * @returns acceleration altitude in feet MSL
     */
    getEngineOutAccelerationAltitude() {
        const accelHeight = this.performancePlan.takeoffEoAccelerationHeight.get();
        const fieldElevation = this.getTakeoffFieldElevation();
        return fieldElevation + accelHeight;
    }
    /**
     * Get the indicated altitude
     * @returns indicated altitude in feet MSL
     */
    getIndicatedAltitude() {
        return this.indicatedAltitude.get();
    }
}
FmsSpeedManager.KEY_INTERCEPTS = [
    // 'AP_SPD_VAR_SET',
    // 'AP_SPD_VAR_SET_EX1',
    // 'AP_SPD_VAR_DEC',
    // 'AP_MACH_VAR_SET',
    // 'AP_MACH_VAR_SET_EX1',
    // 'AP_MACH_VAR_DEC',
    'AP_MANAGED_SPEED_IN_MACH_OFF',
    'AP_MANAGED_SPEED_IN_MACH_ON',
    'AP_MANAGED_SPEED_IN_MACH_SET',
    'AP_MANAGED_SPEED_IN_MACH_TOGGLE'
];
FmsSpeedManager.SOURCE_PRIORITY = {
    [FmsSpeedTargetSource.None]: 0,
    [FmsSpeedTargetSource.ClimbSchedule]: 1,
    [FmsSpeedTargetSource.CruiseSchedule]: 1,
    [FmsSpeedTargetSource.DescentSchedule]: 1,
    [FmsSpeedTargetSource.Constraint]: 2,
    [FmsSpeedTargetSource.Altitude]: 3,
    [FmsSpeedTargetSource.ToGa]: 4,
    [FmsSpeedTargetSource.Configuration]: 5,
};
FmsSpeedManager.MACH_TO_KIAS_SMOOTHING_TAU = 5000 / Math.LN2;
FmsSpeedManager.IAS_MACH_CONVERSION_HYSTERESIS = 1; // knots
/**
 * The minimum amount of time, in seconds, to anticipate a speed constraint when it potentially reduces the computed
 * target speed.
 */
FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_BASE = 10;
/**
 * The amount of extra time, in seconds, to anticipate a speed constraint when it potentially reduces the computed
 * target speed for each knot of reduction in speed.
 */
FmsSpeedManager.SPEED_REDUCTION_ANTICIPATION_HYSTERESIS = Infinity; // seconds
/**
 * The V/S assumed during deceleration to altitude based speed limits, in metres/sec.
 * We are assuming the AP will level off, or at least reduce the rate of descent when we command a lower speed.
 * Should be about -500 fpm according to FCOM.
 */
FmsSpeedManager.SPEED_REDUCTION_MIN_ANTICIPATION_VS = UnitType.MPS.convertFrom(-1000, UnitType.FPM);

/** The VSpeed LVars. */
const BoeingVSpeedLVars = {
    AIRLINER_V1_SPEED: 'L:AIRLINER_V1_SPEED',
};

/**
 * A class that resets VSpeeds based on flight conditions.
 */
class VSpeedConditionsController {
    /**
     * Ctor
     * @param bus The event bus.
     * @param fms The fms
     */
    constructor(bus, fms) {
        this.overAltThreshold = Subject.create(false);
        this.previousFlapsIndex = -1; // Use -1 so changing to 0 would also clear the V2 bug
        this.bus = bus;
        this.vSpeedSettings = VSpeedUserSettings.getManager(this.bus);
        this.timer = new DebounceTimer();
        fms.activePerformancePlan.approachFlapSpeed.sub((v) => {
            var _a;
            this.vSpeedSettings.getSettings(VSpeedType.Vref).value.set((_a = v === null || v === void 0 ? void 0 : v[1]) !== null && _a !== void 0 ? _a : 0);
        }, true);
        this.overAltThreshold.sub((v) => {
            if (v) {
                // Start 10 minute timer at lift off to clear the V2 bug latest at timer expiration:
                this.timer.schedule(() => {
                    this.vSpeedSettings.getSettings(VSpeedType.V2).value.set(0);
                }, 1000 * 600);
                // Immediately clear the V1 and VR bugs:
                this.vSpeedSettings.getSettings(VSpeedType.V1).value.set(0);
                this.vSpeedSettings.getSettings(VSpeedType.Vr).value.set(0);
                SimVar.SetSimVarValue(BoeingVSpeedLVars.AIRLINER_V1_SPEED, SimVarValueType.Knots, 0);
            }
        });
        this.bus.getSubscriber().on('flaps_handle_index').whenChanged().handle((index) => {
            if (index < this.previousFlapsIndex && this.overAltThreshold.get()) {
                // Clear the V2 bug (and delete the timer) by considering any flaps retraction change as trigger
                this.vSpeedSettings.getSettings(VSpeedType.V2).value.set(0);
                this.timer.clear();
            }
            this.previousFlapsIndex = index;
        });
        this.bus.getSubscriber().on('ra_radio_alt_1').whenChangedBy(5).handle((v) => {
            // Obtain reliable "in air" condition:
            this.overAltThreshold.set(v >= 5);
        });
        this.vSpeedSettings.getSettings(VSpeedType.V1).value.sub(speed => SimVar.SetSimVarValue(BoeingVSpeedLVars.AIRLINER_V1_SPEED, SimVarValueType.Knots, speed));
    }
}

/**
 * Correlates flight plan indices with performance plan objects
 */
class PerformancePlanRepository {
    /**
     * Ctor
     * @param flightPlanner a flight planner instance
     * @param bus the event bus
     */
    constructor(flightPlanner, bus) {
        this.flightPlanner = flightPlanner;
        this.bus = bus;
        this.repoId = Math.floor(Math.random() * 10000000);
        this._plans = [];
        this.plans = this._plans;
        this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        this._plans[BoeingFms.ACT_RTE_PLAN_INDEX] = PerformancePlanUtils.createPlanFromDefinitions();
        const sub = this.bus.getSubscriber();
        sub.on('fplOriginDestChanged').handle((data) => {
            if (data.type === OriginDestChangeType.OriginAdded || data.type === OriginDestChangeType.OriginRemoved) {
                this.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, data.planIndex);
            }
        });
        sub.on('performancePlanChanged').handle((data) => {
            if (data.repoId !== this.repoId) {
                PerformancePlanUtils.deserializeInto(data.serializedPlan, this._plans[PerformancePlanRepository.SYNC_PLAN_INDEX]);
                if (this.has(data.planIndex)) {
                    this.copy(PerformancePlanRepository.SYNC_PLAN_INDEX, data.planIndex, true);
                }
            }
        });
    }
    /**
     * Whether the repository has a performance plan already stored for a given index
     *
     * @param index the index
     *
     * @returns boolean
     */
    has(index) {
        return this._plans[index] !== undefined;
    }
    /**
     * Returns a performance plan for a given flight plan index, or creates it
     *
     * @param index flight plan index
     *
     * @throws if an invalid flight plan index is specified
     *
     * @returns the performance plan
     */
    forFlightPlanIndex(index) {
        const existing = this._plans[index];
        if (!existing) {
            return this.create(index);
        }
        return existing;
    }
    /**
     * Gets the active plan. This is the plan that always exists even if there is no valid flight plan yet.
     * @returns the active plan
     */
    getActivePlan() {
        return this._plans[0];
    }
    /**
     * Returns the performance plan containing default values
     *
     * @returns the plan
     */
    defaultValuesPlan() {
        return this._plans[PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX];
    }
    /**
     * Returns whether this plan repository has nay valid plans
     *
     * @returns boolean
     */
    hasAnyPlan() {
        return this._plans.some((it, index) => !!it && this.flightPlanner.hasFlightPlan(index));
    }
    /**
     * Creates a performance plan at the given index if it doesn't exist, or returns the existing one
     *
     * @param atIndex the index
     *
     * @returns the created plan
     */
    create(atIndex) {
        if (!this.has(atIndex)) {
            const newPerformancePlan = PerformancePlanUtils.createPlanFromDefinitions();
            this._plans[atIndex] = newPerformancePlan;
            return newPerformancePlan;
        }
        else {
            return this._plans[atIndex];
        }
    }
    /**
     * Copies a performance plan onto another
     *
     * @param from from index
     * @param to to index
     * @param skipChecks whether to skip flight planner checks
     */
    copy(from, to, skipChecks = false) {
        const fromPlan = this._plans[from];
        const toPlan = skipChecks ? this._plans[to] : this.forFlightPlanIndex(to);
        // Copy data
        for (const key in toPlan) {
            const fromValue = fromPlan[key];
            const toValue = toPlan[key];
            if (fromValue instanceof Subject && toValue instanceof Subject) {
                toValue.set(fromValue.get());
            }
        }
    }
    /**
     * Triggers a synchronisation of the active plan performance plan over the EventBus.
     * @param planIndex the plan index
     */
    triggerSync(planIndex) {
        const packet = {
            repoId: this.repoId,
            planIndex,
            serializedPlan: PerformancePlanUtils.serialize(this._plans[planIndex]),
        };
        this.bus.getPublisher().pub('performancePlanChanged', packet, true, true);
    }
}
PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX = Number.MAX_SAFE_INTEGER;
PerformancePlanRepository.SYNC_PLAN_INDEX = PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX - 1;

var DirectToState;
(function (DirectToState) {
    DirectToState[DirectToState["NONE"] = 0] = "NONE";
    DirectToState[DirectToState["TOEXISTING"] = 1] = "TOEXISTING";
})(DirectToState || (DirectToState = {}));
var ProcedureType;
(function (ProcedureType) {
    ProcedureType[ProcedureType["DEPARTURE"] = 0] = "DEPARTURE";
    ProcedureType[ProcedureType["ARRIVAL"] = 1] = "ARRIVAL";
    ProcedureType[ProcedureType["APPROACH"] = 2] = "APPROACH";
    ProcedureType[ProcedureType["VISUALAPPROACH"] = 3] = "VISUALAPPROACH";
})(ProcedureType || (ProcedureType = {}));
var AirwayLegType;
(function (AirwayLegType) {
    AirwayLegType[AirwayLegType["NONE"] = 0] = "NONE";
    AirwayLegType[AirwayLegType["ENTRY"] = 1] = "ENTRY";
    AirwayLegType[AirwayLegType["EXIT"] = 2] = "EXIT";
    AirwayLegType[AirwayLegType["ONROUTE"] = 3] = "ONROUTE";
    AirwayLegType[AirwayLegType["EXIT_ENTRY"] = 4] = "EXIT_ENTRY";
})(AirwayLegType || (AirwayLegType = {}));
/**
 * A Boeing FMS
 */
class BoeingFms {
    /**
     * Initialize an instance of the FMS.
     * @param bus is the event bus
     * @param flightPlanner is the flight planner
     * @param verticalPathCalculator is the VNAV Path Calculator.
     * @param performancePlanRepository the performance plan repository
     * @param windPlanner Handles wind and temperature entries and propagation for climb, cruise, and descent
     * @param perfProvider the BoeingPathPerformanceProvider
     * @param engineDataProvider the BoeingEngineDataProvider
     * @param isPrimaryFms Whether this is the primary FMS
     * @param activeRoutePredictor The active route predictions provider
     * @param fixInfo The fix info manager
     * @param messageTransmitter A boeing message transmitter
     */
    constructor(bus, flightPlanner, verticalPathCalculator, performancePlanRepository, windPlanner, perfProvider, engineDataProvider, isPrimaryFms, activeRoutePredictor, fixInfo, messageTransmitter) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.verticalPathCalculator = verticalPathCalculator;
        this.performancePlanRepository = performancePlanRepository;
        this.windPlanner = windPlanner;
        this.perfProvider = perfProvider;
        this.engineDataProvider = engineDataProvider;
        this.isPrimaryFms = isPrimaryFms;
        this.activeRoutePredictor = activeRoutePredictor;
        this.fixInfo = fixInfo;
        this.messageTransmitter = messageTransmitter;
        /** Set to true by FMC pages when the plan on this FMS instance is in modification and awaiting a cancel or exec. */
        this.planInMod = Subject.create(false);
        /**
         * Map of routes numbers to whether or not they are activated
         */
        this.routesActivated = {
            1: Subject.create(false),
            2: Subject.create(false),
        };
        this.route1Activated = this.routesActivated['1'];
        /** Set to true when an event is received from the bus indicating that another instrument is in MOD on the plan. */
        this.remotePlanInMod = false;
        this.ppos = new GeoPoint(0, 0);
        this.alternates = new BoeingAlternates(this.bus, this, this.isPrimaryFms);
        this.vnavData = new BoeingFmsVNavDataProvider(this.bus, this, !this.isPrimaryFms);
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        /** Information on our origin, arrival and destination facilities to save lookups.
         * When in MOD, this will reflect the current origin and destination in the MOD plan. */
        this.facilityInfo = {
            originFacility: undefined,
            destinationFacility: undefined
        };
        this.approachDetails = {
            approachLoaded: false,
            approachType: ApproachType.APPROACH_TYPE_UNKNOWN,
            approachRnavType: RnavTypeFlags.None,
            approachIsActive: false,
            approachIsCircling: false,
            approachName: '',
            approachRunway: '',
            missedApproachFacility: null,
            referenceFacility: null,
            finalApproachCourse: -1,
        };
        /** Approach details for the active flight plan. Note `approachIsActive` is **not** synced here! Use {@link approachDetails} for that. */
        this.activeApproachDetails = Object.assign({}, this.approachDetails);
        this._pendingTakeoffDataUplink = Subject.create(null);
        /**
         * The currently pending takeoff data uplink, or null if there is none
         */
        this.pendingTakeoffDataUplink = this._pendingTakeoffDataUplink;
        /** Current true aircraft track */
        this.aircraftTrack = undefined;
        /** Current aircraft indicated altitude */
        this.aircraftAltitude = undefined;
        this.approachFrequency = Subject.create(undefined);
        this._lastApproachFrequencyEventValue = undefined;
        this.cdiSource = { type: NavSourceType.Gps, index: 1 };
        this.missedApproachActive = false;
        this.tunedIlsFrequency = null;
        this.tunedIlsCourse = null;
        this.approachFrequencyMismatch = Subject.create(false);
        this.approachCourseMismatch = Subject.create(false);
        /** Set to true when a leg is activated,
         * meaning that sequencing should be resumed once EXEC is pressed.
         * Should be reset whenever leaving MOD. */
        this.legWasActivatedInModPlan = false;
        /** Set to true when a new DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.dtoWasCreatedInModPlan = false;
        /** Set to true when a new vertical DTO is created,
         * meaning its origin should be regularly updated while in MOD and when hitting EXEC.
         * Should be reset whenever leaving MOD. */
        this.verticalDtoWasCreatedInModPlan = false;
        /**
         * Set to true when the vertical DTO in the mod flight plan was automatic
         */
        this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
        this.operatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT);
        this.onGround = ConsumerValue.create(null, false);
        this._performancePlanProxy = PerformancePlanUtils.createProxyFromDefinitions({
            defaultValuesPlan: this.performancePlanRepository.defaultValuesPlan(),
            /** @inheritDoc */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            onBeforeEdit: (property, newValue) => {
                if (!property.editInPlace) {
                    this.getPlanToModify();
                }
            },
            /** @inheritDoc */
            onAfterEdit: (property, newValue) => {
                if (property.editInPlace) {
                    // We edit all plans, since we do not want to involve an EXEC to confirm a value.
                    // This makes sure that if a value is modified while a MOD plan exists, we modify it, making a copy
                    // from ACT -> MOD not reset the value.
                    for (let i = 0; i < this.performancePlanRepository.plans.length; i++) {
                        const plan = this.performancePlanRepository.plans[i];
                        if (!plan) {
                            continue;
                        }
                        plan[property.key].set(newValue);
                        this.performancePlanRepository.triggerSync(i);
                    }
                }
            },
        });
        this.onOriginDestinationChanged = (e) => {
            if (e.planIndex === this.getPlanIndexForFmcPage()) {
                this.setFacilityInfo();
            }
        };
        /**
         * Called when 'fplProcDetailsChanged' event is fired from changes in procedure details of a flight plan.
         * @param e The event fired when flight plan procedure details change.
         */
        this.onProcedureDetailsChanged = (e) => {
            this.syncProcedureDetailsChangesToPerformancePlan(e);
        };
        this.onPlanCopied = (ev) => {
            this.setFacilityInfo();
            this.ensureActiveHMSuspended();
            this.applyCopyToPerformancePlans(ev);
            if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.tryUnsuspend();
                this.syncFlightPlanToPerformancePlan();
                this.syncHudTakeoff();
            }
            if (ev.planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX && ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.routesActivated[1].set(true);
            }
        };
        this.onPlanCreated = (ev) => {
            this.applyCreationToPerformancePlans(ev);
        };
        this.onPlanCalculated = (e) => {
            if (e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.planInMod.get()) {
                const plan = this.getPlanToModify();
                if (this.verticalDtoWasCreatedInModPlan) {
                    this.updateVerticalDtoOrigin(plan);
                }
                if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX)) {
                    this.updateDtoOrigin(plan);
                }
                this.tryUpdatePposHoldPosition(plan);
            }
        };
        this.onPlanLoaded = (ev) => {
            this.checkApproachState().then();
            this.switchPerformanceProxyToRenderPlan(true);
            this.syncFlightPlanToPerformancePlan();
            const plan = this.flightPlanner.getFlightPlan(ev.planIndex);
            const route = plan.getUserData(BoeingFms.USER_DATA_KEY_ROUTE);
            if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                if (typeof route === 'number') {
                    this.routesActivated[route].set(true);
                }
                this.syncHudTakeoff();
            }
        };
        this.onFmsOperatingPhaseChanged = (newPhase) => {
            if (newPhase === FmsOperatingPhase.COMPLETE) {
                // Reset performance plan
                this.performancePlanRepository.copy(PerformancePlanRepository.DEFAULT_VALUES_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX);
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                // Reset flight plan
                this.emptyFlightPlan();
                this.routesActivated[1].set(false);
            }
        };
        this.onEfbRequestFlightInitializationData = async () => {
            const plan = this.getPrimaryFlightPlan();
            if (plan.originAirport) {
                const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                const runways = airportFacility.runways;
                const takeoffRunway = plan.procedureDetails.originRunway;
                const airportOrigin = plan.originAirport;
                const airportDestination = plan.destinationAirport;
                const oat = this.activePerformancePlan.takeoffTemp.get();
                const gw = this.activePerformancePlan.takeoffGw.get();
                if (takeoffRunway === undefined ||
                    oat === null ||
                    gw === null ||
                    airportOrigin === undefined ||
                    airportDestination === undefined ||
                    runways === undefined) {
                    return;
                }
                const data = {
                    airportOrigin,
                    airportDestination,
                    runways,
                    takeoffRunway,
                    rwyCondition: EfbRunwayCondition.DRY,
                    runwayDisplacement: 0,
                    oat,
                    qnh: 0,
                    gw,
                };
                this.bus.getPublisher().pub('fmc_send_flight_initialization_data', data, true);
            }
        };
        this.onEfbSendTakeoffDataUplink = (data) => {
            this._pendingTakeoffDataUplink.set(data);
            this.messageTransmitter.sendMessage(BoeingFmcErrorKeys.TakeoffDataUplink);
        };
        this.insertApproachOpId = 0;
        /**
         * Sets the approach details when an approach_details_set event is received from the bus.
         * @param approachDetails The approachDetails received from the bus.
         */
        this.onApproachDetailsSet = (approachDetails) => {
            if (approachDetails !== this.approachDetails) {
                this.approachDetails = approachDetails;
                this.checkTunedIlsMismatch();
            }
            const canApproachActivate = this.canApproachActivate();
            if (!canApproachActivate && this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        };
        this.perfInitPageCompleted = MappedSubject.create(([hasZfw, hasReserves, hasCrzAlt, hasCostIndex]) => hasZfw && hasReserves && hasCrzAlt && hasCostIndex, this.activePerformancePlan.manualZfw.map((val) => val !== null), this.activePerformancePlan.reserveFuel.map((val) => val !== null), this.activePerformancePlan.cruiseAltitude.map((val) => val !== null), this.activePerformancePlan.costIndex.map((val) => val !== null));
        this.perfIsInitialized = MappedSubject.create(([posIsInit, routeIsAct, perfInitDone]) => posIsInit && routeIsAct && perfInitDone, ConsumerSubject.create(this.bus.getSubscriber().on('all_irs_systems_operating'), true), this.routesActivated['1'], this.perfInitPageCompleted);
        this.takeoffRefPageCompleted = MappedSubject.create(([hasTakeoffFlaps, hasCog]) => hasTakeoffFlaps && hasCog, this.activePerformancePlan.takeoffFlaps.map((val) => val !== null), this.activePerformancePlan.takeoffCg.map((val) => val !== null));
        this.preflightComplete = MappedSubject.create(([perfInitDone, takeoffRefDone]) => perfInitDone && takeoffRefDone, this.perfIsInitialized, this.takeoffRefPageCompleted);
        this.cdiScaleLabel = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_cdi_scale_label'), 4);
        this.bus.getSubscriber().on('gps-position').atFrequency(1).handle(pos => this.ppos.set(pos.lat, pos.long));
        this.bus.getSubscriber().on('track_deg_true').handle((track) => this.aircraftTrack = track);
        this.bus.getSubscriber().on('indicated_alt').handle((track) => this.aircraftAltitude = track);
        this.bus.getSubscriber().on('cdi_select').handle(source => this.cdiSource = source);
        const planEvents = this.bus.getSubscriber();
        planEvents.on('fplActiveLegChange').handle(data => this.onActiveLegChanged(data.type, data.planIndex));
        planEvents.on('fplLoaded').handle(this.onPlanLoaded);
        planEvents.on('fplCalculated').handle(this.onPlanCalculated);
        planEvents.on('fplCopied').handle(this.onPlanCopied);
        planEvents.on('fplCreated').handle(this.onPlanCreated);
        planEvents.on('fplOriginDestChanged').handle(this.onOriginDestinationChanged);
        planEvents.on('fplProcDetailsChanged').handle(this.onProcedureDetailsChanged);
        planEvents.on('fplUserDataSet').handle(this.onPlanUserDataSet.bind(this));
        const efbFmcCommunicationEvents = this.bus.getSubscriber();
        efbFmcCommunicationEvents.on('efb_request_flight_initialization_data').handle(this.onEfbRequestFlightInitializationData);
        efbFmcCommunicationEvents.on('efb_send_takeoff_data').handle(this.onEfbSendTakeoffDataUplink);
        this.operatingPhase.setConsumer(this.bus.getSubscriber().on('fms_operating_phase'));
        this.operatingPhase.sub(this.onFmsOperatingPhaseChanged.bind(this), true);
        this.onGround.setConsumer(this.bus.getSubscriber().on('on_ground'));
        this.planInMod.sub((v) => {
            if (v) {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 1);
            }
            else {
                SimVar.SetSimVarValue('L:FMC_EXEC_ACTIVE', 'number', 0);
            }
        }, true);
        this.planInMod.sub((v) => {
            if (!v) {
                // Need to update facility info on ERASE
                this.setFacilityInfo();
                // Need to copy the active approach details back in case a mod was cancelled
                this.syncApproachDetailsFromActive();
            }
        });
        this.planInMod.sub(() => {
            this.switchPerformanceProxyToRenderPlan();
        });
        this.bus.getSubscriber().on('fmcExecActive').whenChanged().handle((v) => {
            const state = v === 1;
            this.remotePlanInMod = state;
        });
        this.bus.getSubscriber().on('approach_details_set').handle(this.onApproachDetailsSet);
        this.cdiScaleLabel.sub(v => {
            const canApproachActivate = this.canApproachActivate(v);
            if (canApproachActivate !== this.approachDetails.approachIsActive) {
                this.setApproachDetails(undefined, undefined, undefined, canApproachActivate);
            }
        });
        if (this.isPrimaryFms) {
            this.bus.getSubscriber().on('altimeter_baro_is_std_1').whenChanged().handle((std) => {
                // Reset landing reference to QNH when baro STD is activated in climb phase.
                if (std && this.operatingPhase.get() === FmsOperatingPhase.CLIMB) {
                    this._performancePlanProxy.approachLandingRef.set(1);
                }
            });
        }
        this.bus.getSubscriber().on('nav_active_frequency_3').handle((frequency) => {
            this.tunedIlsFrequency = frequency;
            if (this.hasPrimaryFlightPlan()) {
                this.checkTunedIlsMismatch();
            }
        });
        this.bus.getSubscriber().on('nav_obs_3').handle((obs) => {
            this.tunedIlsCourse = obs;
            if (this.hasPrimaryFlightPlan()) {
                this.checkTunedIlsMismatch();
            }
        });
        this.approachFrequencyMismatch.sub((v) => this.bus.getPublisher().pub('approach_frequency_mismatch', v, true));
        this.approachCourseMismatch.sub((v) => this.bus.getPublisher().pub('approach_course_mismatch', v, true));
        this.activePerformancePlan.glideSlope.sub((v) => this.bus.getPublisher().pub('boeing_glideslope_selected', v === GlideslopeStatus.ON));
        this.activePerformancePlan.approachLandingRef.sub((v) => this.bus.getPublisher().pub('boeing_qfe_approach_selected', v === 0));
    }
    /**
     * Obtain the performance plan for FMC render
     * @returns the plan
     */
    get performancePlanForFmcRender() {
        let index;
        if (this.planInMod.get()) {
            index = BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else {
            index = BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        return this.performancePlanRepository.forFlightPlanIndex(index);
    }
    /**
     * Returns the active performance plan
     *
     * @returns the performance plan for the active flight plan index
     */
    get activePerformancePlan() {
        return this.performancePlanRepository.getActivePlan();
    }
    /**
     * Returns the performance plan proxy
     *
     * @returns the performance plan proxy
     */
    get performancePlanProxy() {
        return this._performancePlanProxy;
    }
    /**
     * Syncs the primary flight plan data to the relevant performance plan values
     */
    syncFlightPlanToPerformancePlan() {
        var _a, _b, _c, _d;
        if (this.hasPrimaryFlightPlan()) {
            const plan = this.getPrimaryFlightPlan();
            this.activePerformancePlan.takeoffAirportIcao.set((_a = plan.originAirport) !== null && _a !== void 0 ? _a : null);
            this.activePerformancePlan.originRunway.set((_b = plan.procedureDetails.originRunway) !== null && _b !== void 0 ? _b : null);
            this.activePerformancePlan.approachAirportIcao.set((_c = plan.destinationAirport) !== null && _c !== void 0 ? _c : null);
            this.activePerformancePlan.approachRunway.set((_d = plan.procedureDetails.destinationRunway) !== null && _d !== void 0 ? _d : null);
        }
    }
    /**
     * Switches the performance proxy to use the FMC render plan
     *
     * @param initial whether this is a call on the initial plan load
     */
    switchPerformanceProxyToRenderPlan(initial = false) {
        this._performancePlanProxy.switchToPlan(this.performancePlanForFmcRender, initial);
    }
    /**
     * Initializes the primary flight plan. Does nothing if the primary flight plan already exists.
     */
    async initPrimaryFlightPlan() {
        if (this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
            // Plan was synced
            await this.setFacilityInfo();
            return;
        }
        this.flightPlanner.createFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const inactivePlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        const modPlanRte1 = this.flightPlanner.createFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        inactivePlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        modPlanRte1.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        const simPlaneLoaded = await FlightPlanAsoboSync.loadFromGame(this);
        if (simPlaneLoaded) {
            this.activate(1);
            this.execute();
        }
    }
    /**
     * Checks whether an indexed flight plan exists.
     * @param index A flight plan index.
     * @returns Whether a flight plan at the specified index exists.
     */
    hasFlightPlan(index) {
        return this.flightPlanner.hasFlightPlan(index);
    }
    /**
     * Gets a specified flightplan, or by default the primary flight plan.
     * @param index The index of the flight plan.
     * @returns the requested flight plan
     * @throws Error if no flight plan exists at the specified index.
     */
    getFlightPlan(index = BoeingFms.ACT_RTE_PLAN_INDEX) {
        return this.flightPlanner.getFlightPlan(index);
    }
    /**
     * Checks whether the primary flight plan exists.
     * @returns Whether the primary flight plan exists.
     */
    hasPrimaryFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary lateral flight plan.
     * @returns The primary flight plan.
     * @throws Error if the primary flight plan does not exist.
     */
    getPrimaryFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Gets the primary vertical flight plan.
     * @returns the primary vertical flight plan.
     */
    getPrimaryVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
    }
    /**
     * Checks whether the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns Whether the Primary Mod Flight Plan Exists flight plan exists.
     */
    hasPrimaryModFlightPlan() {
        return this.flightPlanner.hasFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the Primary Mod Flight Plan Exists - when modifications to the plan are being made.
     * @returns The Primary Mod Flight Plan.
     * @throws Error if the Primary Mod Flight Plan flight plan does not exist.
     */
    getPrimaryModFlightPlan() {
        return this.flightPlanner.getFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Gets the primary mod vertical flight plan.
     * @returns the primary mod vertical flight plan.
     */
    getPrimaryModVerticalFlightPlan() {
        return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
    }
    /**
     * Returns whether the route is activated
     * @param route the route
     * @returns a boolean
     */
    isRouteActivated(route) {
        return this.routesActivated[route].get();
    }
    /**
     * Returns a subscribable the route is activated
     * @param route the route
     * @returns a subscribable
     */
    routeActivated(route) {
        return this.routesActivated[route];
    }
    /**
     * Handles when the EXEC button is pressed and copies the MOD plan back to the PRIMARY plan
     */
    execute() {
        if (this.planInMod.get()) {
            const modPlan = this.getPlanToModify();
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.updateDtoOrigin(modPlan);
            }
            if (this.verticalDtoWasCreatedInModPlan) {
                this.updateVerticalDtoOrigin(modPlan);
            }
            // Make sure this is only reset after the call to updateDTOOrigin
            this.dtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlan = false;
            this.verticalDtoWasCreatedInModPlanWasAutomatic = false;
            this.syncApproachDetailsToActive();
            if (typeof modPlan.getUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN) === 'boolean') {
                // In this case the user changed the origin on an active route, causing a new inactive plan to be created
                modPlan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
                this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX).calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.emptyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
                this.routesActivated[1].set(false);
                this.planInMod.set(false);
                this.legWasActivatedInModPlan = false;
            }
            else {
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.ACT_RTE_PLAN_INDEX, true);
                this.getPrimaryFlightPlan().calculate(0);
                this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
                this.planInMod.set(false);
                // make sure ACT performance plan has new values
                this.syncFlightPlanToPerformancePlan();
                // sync ACT performance plan
                this.performancePlanRepository.triggerSync(BoeingFms.ACT_RTE_PLAN_INDEX);
                if (this.legWasActivatedInModPlan) {
                    this.legWasActivatedInModPlan = false;
                    this.resumeSequencing();
                }
                if (this.getPrimaryFlightPlan().getUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING)) {
                    this.handleVnavDesPending();
                }
                FlightPlanAsoboSync.SaveToGame(this);
            }
            // TODO listen to f-pln events to calculate this
            // If the selected approach is not LOC-based, and there is an approach selected, the lateral approach guidance should be FMS LOC
            this.bus.getPublisher().pub('boeing_fms_loc_approach_selected', !BoeingFmsUtils.isLocalizerApproach(this.approachDetails.approachType) && this.approachDetails.approachType !== ApproachType.APPROACH_TYPE_UNKNOWN);
        }
    }
    /**
     * Activates the indicated route
     * @param route the route index, 1-based
     */
    activate(route) {
        this.flightPlanner.copyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`], BoeingFms[`RTE_${route}_MOD_PLAN_INDEX`], true);
        this.planInMod.set(true);
        this.emptyFlightPlan(BoeingFms[`RTE_${route}_INACTIVE_PLAN_INDEX`]);
    }
    /** Resumes flight plan sequencing. */
    resumeSequencing() {
        this.bus.getPublisher().pub('suspend_sequencing', false, true);
    }
    /**
     * Handles when the ERASE button is pressed.
     */
    cancelMod() {
        if (this.planInMod.get()) {
            if (!this.isRouteActivated(1)) {
                // Copy mod back to inactive when there is no active plan yet
                this.flightPlanner.copyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX, BoeingFms.RTE_1_INACTIVE_PLAN_INDEX, true);
            }
            this.legWasActivatedInModPlan = false;
            this.dtoWasCreatedInModPlan = false;
            this.emptyFlightPlan(BoeingFms.RTE_1_MOD_PLAN_INDEX);
            this.planInMod.set(false);
        }
    }
    /**
     * Handles when a modification is being made to the plan to ensure the plan is in MOD mode
     * @param routeNumber the route number (currently always RTE 1)
     * @returns The Flight Plan to modify
     */
    getPlanToModify(routeNumber = 1) {
        if (this.planInMod.get()) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`]);
        }
        const isRouteActivated = this.isRouteActivated(routeNumber);
        if (!isRouteActivated) {
            return this.getFlightPlan(BoeingFms[`RTE_${routeNumber}_INACTIVE_PLAN_INDEX`]);
        }
        // Active route going into MOD
        this.flightPlanner.copyFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX, BoeingFms[`RTE_${routeNumber}_MOD_PLAN_INDEX`], true);
        this.getPrimaryModFlightPlan().calculate(0);
        this.planInMod.set(true);
        return this.getPrimaryModFlightPlan();
    }
    /**
     * Gets the plan index FMC pages should use to monitor events.
     * @returns A Flight Plan Index
     */
    getPlanIndexForFmcPage() {
        if (this.planInMod.get()) {
            return BoeingFms.RTE_1_MOD_PLAN_INDEX;
        }
        else if (this.isRouteActivated(1)) {
            return BoeingFms.ACT_RTE_PLAN_INDEX;
        }
        else {
            return BoeingFms.RTE_1_INACTIVE_PLAN_INDEX;
        }
    }
    /**
     * Gets the current lateral flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Lateral Flight Plan
     */
    getPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryFlightPlan();
        }
        else {
            return this.getFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Gets the current vertical flight plan for the FMC pages based on whether the plan is in MOD or ACT.
     * @returns A Vertical Flight Plan
     */
    getVerticalPlanForFmcRender() {
        if (this.planInMod.get()) {
            return this.getPrimaryModVerticalFlightPlan();
        }
        else if (this.isRouteActivated(1)) {
            return this.getPrimaryVerticalFlightPlan();
        }
        else {
            return this.verticalPathCalculator.getVerticalFlightPlan(BoeingFms.RTE_1_INACTIVE_PLAN_INDEX);
        }
    }
    /**
     * Checks whether the plan can go into MOD/be edited on this instance of WT21Fms.
     * @returns Whether to allow plan edits or not
     */
    canEditPlan() {
        if (this.remotePlanInMod && !this.planInMod.get()) {
            return false;
        }
        return true;
    }
    /**
     * Sync the procedure details changes from a flight plan to its respective performance plan.
     * Only sync departureFacilityIcao and originRunway changes at the moment.
     * @param e The event fired when flight plan procedure details change.
     */
    syncProcedureDetailsChangesToPerformancePlan(e) {
        var _a, _b;
        const targetPerfPlan = this.performancePlanRepository.forFlightPlanIndex(e.planIndex);
        targetPerfPlan.takeoffAirportIcao.set((_a = e.details.departureFacilityIcao) !== null && _a !== void 0 ? _a : null);
        targetPerfPlan.originRunway.set((_b = e.details.originRunway) !== null && _b !== void 0 ? _b : null);
    }
    /**
     * Accepts a pending takeoff uplink
     */
    acceptPendingTakeoffUplink() {
        const data = this.pendingTakeoffDataUplink.get();
        if (data) {
            const vSpeedsSettings = VSpeedUserSettings.getManager(this.bus);
            vSpeedsSettings.getSettings(VSpeedType.V1).value.set(data.v1);
            vSpeedsSettings.getSettings(VSpeedType.Vr).value.set(data.vr);
            vSpeedsSettings.getSettings(VSpeedType.V2).value.set(data.v2);
            this.performancePlanProxy.takeoffFlaps.set(data.flapSetting);
            this.performancePlanProxy.takeoffThrustMode.set(data.thrustRating);
            this.performancePlanProxy.takeoffAssumedTemp.set(data.assumedTemperature);
            this._pendingTakeoffDataUplink.set(null);
        }
    }
    /**
     * Rejects a pending takeoff uplink
     */
    rejectPendingTakeoffUplink() {
        this._pendingTakeoffDataUplink.set(null);
    }
    /**
     * Sets the Facility Info cache in the Fms.
     */
    async setFacilityInfo() {
        var _a, _b;
        const plan = this.getPlanForFmcRender();
        if (((_a = this.facilityInfo.originFacility) === null || _a === void 0 ? void 0 : _a.icao) !== plan.originAirport) {
            if (plan.originAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
                this.facilityInfo.originFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.originFacility = undefined;
            }
        }
        if (((_b = this.facilityInfo.destinationFacility) === null || _b === void 0 ? void 0 : _b.icao) !== plan.destinationAirport) {
            if (plan.destinationAirport) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                this.facilityInfo.destinationFacility = facility !== null && facility !== void 0 ? facility : undefined;
            }
            else {
                this.facilityInfo.destinationFacility = undefined;
            }
        }
    }
    /**
     * Gets the ALTN airport of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the flight plan index
     *
     * @returns the ALTN airport FS ICAO, or undefined
     */
    getFlightPlanAlternates(planIndex) {
        const plan = this.getFlightPlan(planIndex);
        return plan.getUserData(BoeingFms.USER_DATA_KEY_ALTN);
    }
    /**
     * Sets the ALTN airports of a flight plan
     *
     * **Note:** This method is not meant to be use by front-end clients. Use `BoeingAlternates` instead
     *
     * @param planIndex the plan index to use
     * @param alternates the ALTN airports
     */
    setFlightPlanAlternates(planIndex, alternates) {
        const plan = this.getFlightPlan(planIndex);
        plan.setUserData(BoeingFms.USER_DATA_KEY_ALTN, alternates);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     *
     * @returns a string
     */
    getFlightPlanVisualApproach(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach, as the runway designator of the approach
     *
     * @param planIndex the plan index
     * @param runwayDesignator the visual approach's runway designator
     */
    setFlightPlanVisualApproach(planIndex, runwayDesignator) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH, runwayDesignator);
    }
    /**
     * Deletes a flight plan's visual approach
     *
     * @param planIndex the plan index
     */
    deleteFlightPlanVisualApproach(planIndex) {
        this.getFlightPlan(planIndex).deleteUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH);
    }
    /**
     * Returns a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     *
     * @returns a number, in degrees
     */
    getFlightPlanVisualApproachVfrVpa(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA);
    }
    /**
     * Sets a flight plan's visual approach VFR vertical path angle
     *
     * @param planIndex the plan index
     * @param vpa the visual approach's VFR vertical path angle, in degrees
     */
    setFlightPlanVisualApproachVfrVpa(planIndex, vpa) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA, vpa);
    }
    /**
     * Handle the flightplan user data changed event
     * @param event User data event
     */
    onPlanUserDataSet(event) {
        if (event.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && event.key === BoeingFms.USER_DATA_KEY_HUD_TAKEOFF) {
            this.syncHudTakeoff();
        }
    }
    /**
     * Returns a flight plan's selected HUD takeoff
     *
     * @param planIndex the plan index
     *
     * @returns the HUD takeoff runway, or undefined
     */
    getFlightPlanHudTakeoff(planIndex) {
        return this.getFlightPlan(planIndex).getUserData(BoeingFms.USER_DATA_KEY_HUD_TAKEOFF);
    }
    /**
     * Sets a flight plan's selected HUD takeoff
     *
     * @param planIndex the plan index
     * @param hudTakeoffRunway the HUD takeoff runway, or undefined
     */
    setFlightPlanHudTakeoff(planIndex, hudTakeoffRunway) {
        this.getFlightPlan(planIndex).setUserData(BoeingFms.USER_DATA_KEY_HUD_TAKEOFF, hudTakeoffRunway);
    }
    /**
     * Sync the active HUD takeoff runway to the bus
     */
    syncHudTakeoff() {
        var _a;
        this.bus.getPublisher().pub('boeing_hud_takeoff_runway_set', (_a = this.getFlightPlanHudTakeoff(BoeingFms.ACT_RTE_PLAN_INDEX)) !== null && _a !== void 0 ? _a : null, true);
        this.checkTunedIlsMismatch();
    }
    /**
     * Set VNAV DES DIR/DES NOW pending
     * @param planIndex the plan index
     * @param type Type of descent action or null to clear
     */
    setVnavDesPending(planIndex, type) {
        const plan = this.getFlightPlan(planIndex);
        if (type === null) {
            plan.deleteUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING);
        }
        else {
            plan.setUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING, type);
        }
    }
    /**
     * Handle pending DES DIR/DES NOW in the active f-pln (after copy from mod plan)
     */
    handleVnavDesPending() {
        const plan = this.getPrimaryFlightPlan();
        switch (plan.getUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING)) {
            case BoeingVnavDescentPendingType.DesDir:
                this.bus.getPublisher().pub('boeingvnav_activate_des_dir', undefined);
                break;
            case BoeingVnavDescentPendingType.DesNow:
                this.bus.getPublisher().pub('boeingvnav_activate_des_now', undefined);
                break;
        }
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING);
    }
    /**
     * After a plan copy, ensure that a now active HM causes a suspend
     */
    ensureActiveHMSuspended() {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex === 0 ? 1 : activeLegIndex);
        // TODO considerations for hold exit
        if ((activeLeg === null || activeLeg === void 0 ? void 0 : activeLeg.leg.type) === LegType.HM) {
            this.bus.getPublisher().pub('suspend_sequencing', true);
        }
    }
    /**
     * After a plan copy, ensure that we unsuspend if necessary
     */
    tryUnsuspend() {
        if (this.isPrimaryFms) {
            const activeLegIndex = this.getPrimaryFlightPlan().activeLateralLeg;
            if (activeLegIndex >= 0) {
                const activeLeg = this.getPrimaryFlightPlan().tryGetLeg(activeLegIndex);
                if (activeLeg && BoeingFmsUtils.canLegBeAutoUnsuspended(activeLeg.leg.type)) {
                    this.resumeSequencing();
                }
            }
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCopyToPerformancePlans(ev) {
        if (ev.targetPlanIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX || ev.targetPlanIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            this.performancePlanRepository.copy(BoeingFms.ACT_RTE_PLAN_INDEX, ev.targetPlanIndex);
        }
        else if (ev.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.copy(ev.planIndex, BoeingFms.ACT_RTE_PLAN_INDEX);
        }
    }
    /**
     * Applies flight plan copy events to the performance plan repository
     *
     * @param ev plan copied event
     */
    applyCreationToPerformancePlans(ev) {
        if (ev.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.performancePlanRepository.create(BoeingFms.ACT_RTE_PLAN_INDEX);
            this._performancePlanProxy.switchToPlan(this.activePerformancePlan, true);
        }
        if (!this.performancePlanRepository.hasAnyPlan()) {
            this.performancePlanRepository.forFlightPlanIndex(ev.planIndex);
        }
    }
    /**
     * Handles when a flight plan active leg changes.
     * @param legType The type of flight plan active leg change.
     * @param planIndex The index of the plan whose active leg changed.
     */
    onActiveLegChanged(legType, planIndex) {
        if (legType === ActiveLegType.Lateral && planIndex === 0) {
            const activePlan = this.flightPlanner.getActiveFlightPlan();
            if (activePlan.length < 1 || this.missedApproachActive) {
                this.setApproachDetails(undefined, undefined, undefined, false);
            }
            this.tryUnsuspend();
        }
    }
    /**
     * A method to check the current approach state.
     */
    async checkApproachState() {
        var _a;
        const plan = this.getFlightPlan();
        let approachLoaded = false;
        let approachIsActive = false;
        let approachType;
        let approachRnavType;
        let approachIsCircling = false;
        let approachName = '';
        let approachRunway = '';
        let missedApproachFacility = null;
        let referenceFacility = null;
        let finalApproachCourse = -1;
        if (plan.destinationAirport && (plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined)) {
            approachLoaded = true;
            if (plan.length > 0 && plan.activeLateralLeg < plan.length && plan.activeLateralLeg > 0) {
                const segment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
                approachIsActive = segment.segmentType === FlightPlanSegmentType.Approach;
            }
            if (plan.procedureDetails.approachIndex > -1) {
                const facility = await this.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
                const approach = facility.approaches[plan.procedureDetails.approachIndex];
                if (approach) {
                    approachType = approach.approachType;
                    approachRnavType = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
                    approachIsCircling = !approach.runway;
                    approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
                    approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
                    if (BoeingFmsUtils.approachHasNavFrequency(approach)) {
                        referenceFacility = (_a = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _a !== void 0 ? _a : null;
                    }
                    finalApproachCourse = await this.getFinalApproachCourse(facility, approach);
                    const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
                    const mapLeg = mapIndex >= 0 ? plan.tryGetLeg(mapIndex) : null;
                    missedApproachFacility = mapLeg && mapLeg.leg.fixIcao && mapLeg.leg.fixIcao !== ICAO.emptyIcao
                        ? await this.facLoader.getFacility(ICAO.getFacilityType(mapLeg.leg.fixIcao), mapLeg.leg.fixIcao)
                        : null;
                }
            }
            else {
                approachType = AdditionalApproachType.APPROACH_TYPE_VISUAL;
                approachRnavType = RnavTypeFlags.None;
            }
        }
        this.setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse);
    }
    /**
     * Removes the direct to existing legs from the primary flight plan. If a direct to existing is currently active,
     * this will effectively cancel it.
     * @param planIndex The flight plan index.
     * @param lateralLegIndex The index of the leg to set as the active lateral leg after the removal operation. Defaults
     * @param calculate Whether to calculate the flight plan
     * to the index of the current active primary flight plan leg.
     */
    removeDirectToExisting(planIndex = BoeingFms.RTE_1_MOD_PLAN_INDEX, lateralLegIndex, calculate = true) {
        const plan = this.getFlightPlan(planIndex);
        const directToData = plan.directToData;
        if (directToData && directToData.segmentIndex > -1) {
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            plan.removeLeg(directToData.segmentIndex, directToData.segmentLegIndex + 1, true);
            const activateIndex = lateralLegIndex !== null && lateralLegIndex !== void 0 ? lateralLegIndex : plan.activeLateralLeg;
            const adjustedActivateIndex = activateIndex - Utils.Clamp(activateIndex - (plan.getSegment(directToData.segmentIndex).offset + directToData.segmentLegIndex), 0, 3);
            plan.setDirectToData(-1, true);
            plan.setCalculatingLeg(adjustedActivateIndex);
            plan.setLateralLeg(adjustedActivateIndex);
            if (calculate) {
                plan.calculate(0);
            }
        }
    }
    /**
     * Method to cleanup any legs in segments that exist after the Approach/Arrival Segments.
     * @param plan The Mod Flight Plan.
     */
    cleanupLegsAfterApproach(plan) {
        if (plan.procedureDetails.arrivalIndex > -1 || plan.procedureDetails.approachIndex > -1 || this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            while (plan.getSegment(plan.segmentCount - 1).segmentType === FlightPlanSegmentType.Enroute) {
                this.planRemoveSegment(plan.segmentCount - 1);
            }
        }
    }
    /**
     * Checks whether a leg in the primary flight plan can be manually activated.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg can be manually activated.
     */
    canActivateLeg(segmentIndex, segmentLegIndex) {
        const plan = this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || BitFlags.isAll(leg.flags, LegDefinitionFlags.DirectTo) || leg === plan.getLeg(0)) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.CF:
            case LegType.FC:
            case LegType.FD:
                return true;
            case LegType.CI:
            case LegType.VI:
            case LegType.FA:
            case LegType.CA:
            case LegType.VA:
            case LegType.VM:
                return false;
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        switch (prevLeg.leg.type) {
            case LegType.VA:
            case LegType.CA:
            case LegType.VM:
            case LegType.Discontinuity:
                return false;
        }
        return true;
    }
    /**
     * Checks whether a leg in the primary flight plan is a valid direct to target.
     * @param segmentIndex The index of the segment in which the leg resides.
     * @param segmentLegIndex The index of the leg in its segment.
     * @returns Whether the leg is a valid direct to target.
     * @throws Error if a leg could not be found at the specified location.
     */
    canDirectTo(segmentIndex, segmentLegIndex) {
        const plan = this.hasPrimaryFlightPlan() && this.getPrimaryFlightPlan();
        if (!plan) {
            return false;
        }
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg || leg.leg.fixIcao === '' || leg.leg.fixIcao === ICAO.emptyIcao) {
            return false;
        }
        switch (leg.leg.type) {
            case LegType.IF:
            case LegType.TF:
            case LegType.DF:
            case LegType.CF:
            case LegType.AF:
            case LegType.RF:
                return true;
        }
        return false;
    }
    /**
     * Gets the current Direct To State.
     * @param planIndex The Plan Index to check.
     * @returns the DirectToState.
     */
    getDirectToState(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.hasFlightPlan(planIndex)) {
            return DirectToState.NONE;
        }
        const plan = this.getFlightPlan(planIndex);
        const directDataExists = plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1;
        if (!directDataExists) {
            return DirectToState.NONE;
        }
        // Guarding against rare cases where the segment with the dto has been removed and the dt odata hasn't been updated yet.
        const isDtoSegmentInPlan = plan.segmentCount >= plan.directToData.segmentIndex;
        if (!isDtoSegmentInPlan) {
            return DirectToState.NONE;
        }
        const dtoLegGlobalIndex = plan.getLegIndexFromLeg(plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex]);
        // We subtract 3 to get the index of the original DTO target leg
        const doesDtoLegMatchActiveLeg = dtoLegGlobalIndex === plan.activeLateralLeg - 3;
        // TODO This seems to be returning false positives when in MOD in certain scenarios,
        // TODO like after passing the TO leg of a DTO, then trying to add a new DTO
        if (doesDtoLegMatchActiveLeg) {
            return DirectToState.TOEXISTING;
        }
        else {
            return DirectToState.NONE;
        }
    }
    /**
     * Gets the ICAO string of the current Direct To target.
     * @returns The ICAO string of the current Direct To target, or undefined if Direct To is not active.
     */
    getDirectToTargetIcao() {
        var _a;
        return (_a = this.getDirectToLeg()) === null || _a === void 0 ? void 0 : _a.fixIcao;
    }
    /**
     * Gets the current DTO Target Flight Plan Leg.
     * @returns the FlightPlanLeg.
     */
    getDirectToLeg() {
        switch (this.getDirectToState()) {
            case DirectToState.TOEXISTING: {
                const plan = this.getFlightPlan();
                return plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg;
            }
        }
        return undefined;
    }
    /**
     * Checks if a segment is the first enroute segment that is not an airway.
     * @param segmentIndex is the segment index of the segment to check
     * @returns whether or not the segment is the first enroute segment that is not an airway.
     */
    isFirstEnrouteSegment(segmentIndex) {
        const plan = this.getFlightPlan();
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && !segment.airway) {
                return i === segmentIndex;
            }
        }
        return false;
    }
    /**
     * Adds a user facility.
     * @param userFacility the facility to add.
     */
    addUserFacility(userFacility) {
        this.facRepo.add(userFacility);
    }
    /**
     * Removes a user facility.
     * @param userFacility the facility to remove.
     */
    removeUserFacility(userFacility) {
        this.facRepo.remove(userFacility);
    }
    /**
     * Gets all user facilities.
     *
     * @returns an array of user facilities
     */
    getUserFacilities() {
        const ret = [];
        // FIXME no.
        this.facRepo.forEach((fac) => {
            if (FacilityUtils.isFacilityType(fac, FacilityType.USR)) {
                ret.push(fac);
            }
        });
        return ret;
    }
    /**
     * Adds a visual or runway facility from the FlightPlanLeg.
     * @param leg the leg to build the facility from.
     * @param visualRunwayDesignation is the visual runway this facility belongs to.
     */
    addVisualFacilityFromLeg(leg, visualRunwayDesignation) {
        const fac = {
            icao: leg.fixIcao,
            lat: leg.lat !== undefined ? leg.lat : 0,
            lon: leg.lon !== undefined ? leg.lon : 0,
            approach: `VISUAL ${visualRunwayDesignation}`,
            city: '',
            name: `${visualRunwayDesignation} - ${ICAO.getIdent(leg.fixIcao)}`,
            region: '',
            magvar: 0
        };
        this.facRepo.add(fac);
    }
    /**
     * Method to insert a waypoint to the flightplan.
     * @param facility is the new facility to add a leg to.
     * @param segmentIndex is index of the segment to add the waypoint to
     * @param legIndex is the index to insert the waypoint (if none, append)
     * @returns whether the waypoint was successfully inserted.
     */
    insertWaypoint(facility, segmentIndex, legIndex) {
        var _a;
        const leg = FlightPlan.createLeg({
            type: LegType.TF,
            fixIcao: facility.icao
        });
        let plan = this.getPlanForFmcRender();
        let createdModPlan = false;
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                    if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX && plan.planIndex !== BoeingFms.RTE_2_MOD_PLAN_INDEX) {
                        createdModPlan = true;
                    }
                    plan = this.getPlanToModify();
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return false;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, legIndex !== null && legIndex !== void 0 ? legIndex : Infinity);
        const nextLeg = plan.getNextLeg(segmentIndex, legIndex === undefined ? Infinity : legIndex - 1);
        // Make sure we are not inserting a duplicate leg
        if ((prevLeg && this.isDuplicateLeg(prevLeg.leg, leg)) || (nextLeg && this.isDuplicateLeg(leg, nextLeg.leg))) {
            if (createdModPlan) {
                this.cancelMod();
            }
            return false;
        }
        // Make sure we are not inserting a leg into a direct to sequence
        if (prevLeg) {
            const isInDirectTo = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, LegDefinitionFlags.DirectTo);
            const isDirectToTarget = BitFlags.isAll(prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.flags, BoeingExtraLegDefinitionFlags.DirectToTarget);
            if (isInDirectTo && !isDirectToTarget) {
                if (createdModPlan) {
                    this.cancelMod();
                }
                return false;
            }
        }
        plan = this.getPlanToModify();
        // Deal with whether this insert is in an airway segment
        if (segment.airway) {
            //check to see if this insert will leave more than 1 airway leg
            if (!legIndex || segment.legs.length - legIndex < 3) {
                // we don't need another airway segment,
                // we just need to add the inserted segment, the remaining airway segments into the next enroute segment
                const nextSegment = plan.getSegment(segmentIndex + 1);
                if (nextSegment.airway || nextSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    //the next segment is an airway, arrival, approach or destination, so we need to add an enroute segment
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                }
                //now we can add the new leg into the next enroute segment
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                for (let k = 0; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 1, legsToMove[k]);
                }
            }
            else {
                //we need to create a new airway segment
                //split the segment into three
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                const newAirwaySegment = plan.getSegment(segmentIndex + 2);
                //add the leg to the new enroute segment (between the old and new airway segments)
                this.planAddLeg(segmentIndex + 1, leg);
                //get the legs after the insert index from the first airway segment, if any, and move them to the second airway segment
                legIndex = legIndex ? legIndex : segment.legs.length - 1;
                const legsToMove = [];
                const legsLength = segment.legs.length;
                for (let i = legIndex; i < legsLength; i++) {
                    legsToMove.push(segment.legs[i].leg);
                }
                for (let j = legsLength - 1; j >= legIndex; j--) {
                    this.planRemoveLeg(segmentIndex, j, true, true);
                }
                this.planAddLeg(segmentIndex + 1, legsToMove[0]);
                for (let k = 1; k < legsToMove.length; k++) {
                    this.planAddLeg(segmentIndex + 2, legsToMove[k]);
                }
                const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[legIndex - 1].name : segment.airway;
                plan.setAirway(segmentIndex, segment.airway);
                newAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + newAirwaySegment.legs[newAirwaySegment.legs.length - 1].name : segment.airway;
                plan.setAirway(segmentIndex + 2, newAirwaySegment.airway);
            }
            return true;
        }
        else {
            // WT21 Addition; manage where legs are added from the legs page
            // TODO this maybe needs to go before the airway section
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                    if (legIndex === 0) {
                        segmentIndex -= 1;
                        legIndex = undefined;
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                        }
                        else {
                            segmentIndex += 1;
                        }
                        legIndex = 0;
                    }
                    break;
                case FlightPlanSegmentType.Approach:
                    if (legIndex === 0) {
                        if (plan.procedureDetails.arrivalIndex > -1 && plan.getSegment(segmentIndex - 1).segmentType !== FlightPlanSegmentType.Enroute) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                            legIndex = undefined;
                        }
                        else {
                            segmentIndex -= 1;
                            legIndex = undefined;
                        }
                    }
                    else if (!legIndex) {
                        if (segmentIndex === plan.segmentCount - 1) {
                            segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute);
                        }
                    }
                    break;
            }
            const addedLeg = this.planAddLeg(segmentIndex, leg, legIndex);
            const addedLegGlobalIndex = plan.getLegIndexFromLeg(addedLeg);
            const addedLegSegment = plan.getSegmentFromLeg(addedLeg);
            if (addedLegSegment) {
                const addedLegLocalIndex = plan.getSegmentLegIndex(addedLegGlobalIndex);
                const legAfter = plan.getNextLeg(addedLegSegment === null || addedLegSegment === void 0 ? void 0 : addedLegSegment.segmentIndex, addedLegLocalIndex);
                if (legAfter && !BoeingFmsUtils.isDiscontinuityLeg(legAfter.leg.type)) {
                    this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), addedLegLocalIndex + 1);
                }
            }
            return true;
        }
    }
    /**
     * Removes a leg to a waypoint from the primary flight plan.
     * @param segmentIndex The index of the segment containing the leg to remove.
     * @param segmentLegIndex The index of the leg to remove in its segment.
     * @param skipFafMapCheck Whether to force deletion regardless of FAF/MAP flags
     * @param skipHoldDelete Whether to skip deleting holds associated with this leg
     * @returns Whether the waypoint was successfully removed.
     */
    removeWaypoint(segmentIndex, segmentLegIndex, skipFafMapCheck = false, skipHoldDelete = false) {
        let plan = this.getPlanForFmcRender();
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if (!leg) {
            return false;
        }
        const legGlobalIndex = plan.getLegIndexFromLeg(leg);
        if (!skipFafMapCheck && (!leg || BitFlags.isAny(leg.leg.fixTypeFlags, FixTypeFlags.FAF | FixTypeFlags.MAP))) {
            return false;
        }
        const legDeleted = this.planRemoveLeg(segmentIndex, segmentLegIndex);
        if (legDeleted) {
            plan = this.getPlanToModify();
            const prevLeg = plan.tryGetLeg(legGlobalIndex - 1);
            let nextLeg = plan.tryGetLeg(legGlobalIndex);
            if (!skipHoldDelete && legDeleted && nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type)) {
                if (plan.tryGetLeg(segmentIndex, segmentLegIndex)) {
                    this.planRemoveLeg(segmentIndex, segmentLegIndex, true, true, true);
                }
                nextLeg = plan.tryGetLeg(legGlobalIndex);
            }
            const alreadyDisco = (prevLeg && BoeingFmsUtils.isDiscontinuityLeg(prevLeg.leg.type)) || (nextLeg && BoeingFmsUtils.isDiscontinuityLeg(nextLeg.leg.type));
            if (!BoeingFmsUtils.isDiscontinuityLeg(leg.leg.type) && !alreadyDisco) {
                this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
            }
        }
        return legDeleted;
    }
    /**
     * Sets the speed and altitude constraints for a log.
     * @param globalLegIndex Global leg index of the leg to modify.
     * @param verticalData The vertical data to set on the leg. Will be merged with existing data.
     * @returns Whether the data was set.
     */
    setUserConstraint(globalLegIndex, verticalData) {
        const plan = this.hasPrimaryFlightPlan() && this.getPlanToModify();
        if (!plan) {
            return false;
        }
        const segment = plan.tryGetSegment(plan.getSegmentIndex(globalLegIndex));
        const leg = segment === null || segment === void 0 ? void 0 : segment.legs[globalLegIndex - segment.offset];
        if (segment === null || leg === undefined) {
            return false;
        }
        const isDeparture = segment.segmentType === FlightPlanSegmentType.Departure || segment.segmentType === FlightPlanSegmentType.Origin;
        const isMapr = BitFlags.isAny(leg.flags, LegDefinitionFlags.MissedApproach);
        plan.setLegVerticalData(globalLegIndex, Object.assign({ phase: isDeparture || isMapr ? VerticalFlightPhase.Climb : VerticalFlightPhase.Descent }, verticalData), true);
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Gets the airway leg type of a flight plan leg.
     * @param plan The flight plan containing the query leg.
     * @param segmentIndex The index of the flight plan segment containing the query leg.
     * @param segmentLegIndex The index of the query leg in its segment.
     * @returns The airway leg type of the query leg.
     */
    getAirwayLegType(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        const segmentIsAirway = segment.airway !== undefined;
        const nextSegmentIsAirway = segmentIndex + 1 < plan.segmentCount && plan.getSegment(segmentIndex + 1).airway !== undefined;
        const legIsLast = segmentLegIndex == segment.legs.length - 1;
        if ((segmentIsAirway && legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.EXIT_ENTRY;
        }
        if ((legIsLast && nextSegmentIsAirway)) {
            return AirwayLegType.ENTRY;
        }
        if (segmentIsAirway) {
            if (legIsLast) {
                return AirwayLegType.EXIT;
            }
            return AirwayLegType.ONROUTE;
        }
        return AirwayLegType.NONE;
    }
    /**
     * Method to get the distance of an airway segment.
     * @param segmentIndex is the index of the segment of the airway.
     * @returns the cumulative distance for the airway segment.
     */
    getAirwayDistance(segmentIndex) {
        var _a, _b, _c, _d;
        const plan = this.getFlightPlan();
        const segment = plan.getSegment(segmentIndex);
        const entrySegment = plan.getSegment(segmentIndex - 1);
        const entryCumulativeDistance = (_b = (_a = entrySegment.legs[entrySegment.legs.length - 1]) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistance;
        const exitCumulativeDistance = (_d = (_c = segment.legs[segment.legs.length - 1]) === null || _c === void 0 ? void 0 : _c.calculated) === null || _d === void 0 ? void 0 : _d.cumulativeDistance;
        return exitCumulativeDistance && entryCumulativeDistance ? exitCumulativeDistance - entryCumulativeDistance : -1;
    }
    /**
     * Method to add a new origin airport and runway to the flight plan.
     * @param airport is the facility of the origin airport.
     * @param runway is the onewayrunway
     */
    setOrigin(airport, runway) {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        if (airport) {
            if (plan.originAirport !== airport.icao) {
                plan.setOriginAirport(airport.icao);
            }
            plan.setOriginRunway(runway);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, segmentIndex, airport, runway);
            const prevLeg = plan.getPrevLeg(segmentIndex, 1);
            const nextLeg = plan.getNextLeg(segmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        else {
            plan.removeOriginAirport();
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        }
        this.facilityInfo.originFacility = airport;
        plan.calculate(0);
    }
    /**
     * Method to add a new destination airport and runway to the flight plan.
     * @param airport is the facility of the destination airport.
     * @param runway is the selected runway at the destination facility.
     */
    setDestination(airport, runway) {
        const plan = this.getPlanToModify();
        plan.setProcedureDetails({
            arrivalIndex: -1,
            arrivalRunway: undefined,
            arrivalTransitionIndex: -1,
            arrivalRunwayTransitionIndex: -1,
            approachIndex: -1,
            approachTransitionIndex: -1,
        });
        if (airport) {
            plan.setDestinationAirport(airport.icao);
            plan.setDestinationRunway(runway);
        }
        else {
            plan.removeDestinationAirport();
        }
        this.facilityInfo.destinationFacility = airport;
        plan.calculate(0);
        this.performancePlanForFmcRender.transitionLevel.set(definitions.transitionLevel.defaultValue);
    }
    /**
     * Method to ensure only one segment of a specific type exists in the flight plan and optionally insert it if needed.
     * @param segmentType is the segment type we want to evaluate.
     * @param insert is whether to insert the segment if missing
     * @returns segmentIndex of the only segment of this type in the flight plan, -1 if insert is false and and the segment does not exist.
     */
    ensureOnlyOneSegmentOfType(segmentType, insert = true) {
        const plan = this.getPlanToModify();
        let segmentIndex;
        const selectedSegments = plan.segmentsOfType(segmentType);
        const segmentIndexArray = [];
        for (const element of selectedSegments) {
            segmentIndexArray.push(element.segmentIndex);
        }
        if (segmentIndexArray.length === 0) {
            if (insert) {
                segmentIndex = this.planInsertSegmentOfType(segmentType);
            }
            else {
                segmentIndex = -1;
            }
        }
        else if (segmentIndexArray.length > 1) {
            for (let i = 0; i < segmentIndexArray.length; i++) {
                this.planRemoveSegment(segmentIndexArray[i]);
            }
            segmentIndex = this.planInsertSegmentOfType(segmentType);
        }
        else {
            segmentIndex = segmentIndexArray[0];
        }
        return segmentIndex;
    }
    /**
     * Method to invert the flightplan.
     * TODO Does the WT21 support this?
     */
    invertFlightplan() {
        var _a;
        const plan = this.getPlanToModify();
        if (plan.directToData.segmentIndex >= 0 && plan.directToData.segmentLegIndex >= 0) {
            this.removeDirectToExisting();
        }
        const newOriginIcao = plan.destinationAirport;
        const newDestinationIcao = plan.originAirport;
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (lastEnrouteSegmentIndex === 1 && plan.getSegment(1).legs.length > 0) {
            //case for when there is only 1 enroute segment and it has at least 1 waypoint, a simple reversal is all that's required.
            const segment = Object.assign({}, plan.getSegment(1));
            this.emptyFlightPlan();
            for (let l = segment.legs.length - 1; l >= 0; l--) {
                plan.addLeg(1, segment.legs[l].leg);
            }
        }
        else if (lastEnrouteSegmentIndex > 1) {
            //case for when there is more than 1 enroute segment we know we have to deal with airways
            const legs = [];
            for (let i = 1; i <= lastEnrouteSegmentIndex; i++) {
                //create a temporary list of legs that looks like what a flight plan import looks like with ICAO and the airway
                //we fly FROM the leg on.
                const oldSegment = plan.getSegment(i);
                const airway = oldSegment.airway ? (_a = oldSegment.airway) === null || _a === void 0 ? void 0 : _a.split('.')[0] : undefined;
                for (const leg of oldSegment.legs) {
                    const legListItem = { icao: leg.leg.fixIcao, airway: airway };
                    legs.push(legListItem);
                }
            }
            //after the array of legs is complete, we just reverse it
            legs.reverse();
            this.emptyFlightPlan();
            let currentSegment = 1;
            let lastLegWasAirway = false;
            //last we go through each leg and use the same logic we use for the flight plan import to go through each leg and create airway
            //segments as appropriate for these legs.
            for (let i = 0; i < legs.length; i++) {
                const wpt = legs[i];
                const segment = plan.getSegment(currentSegment);
                if (wpt.airway) {
                    const leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    plan.addLeg(currentSegment, leg);
                    if (!lastLegWasAirway) {
                        plan.insertSegment(currentSegment + 1, FlightPlanSegmentType.Enroute, wpt.airway);
                        currentSegment += 1;
                    }
                    for (let j = i + 1; j < legs.length; j++) {
                        i++;
                        const airwayLeg = FlightPlan.createLeg({
                            type: LegType.TF,
                            fixIcao: legs[j].icao
                        });
                        plan.addLeg(currentSegment, airwayLeg);
                        if (legs[j].airway !== wpt.airway) {
                            lastLegWasAirway = legs[j].airway ? true : false;
                            break;
                        }
                    }
                    plan.setAirway(currentSegment, wpt.airway + '.' + ICAO.getIdent(legs[i].icao));
                    currentSegment += 1;
                    plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute, lastLegWasAirway ? legs[i].airway : undefined);
                }
                else {
                    let leg = undefined;
                    leg = FlightPlan.createLeg({
                        type: LegType.TF,
                        fixIcao: wpt.icao
                    });
                    if (leg) {
                        plan.addLeg(currentSegment, leg);
                        if (lastLegWasAirway) {
                            plan.setAirway(currentSegment, segment.airway + '.' + ICAO.getIdent(wpt.icao));
                            currentSegment += 1;
                            plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
                        }
                        lastLegWasAirway = false;
                    }
                }
            }
            if (plan.getSegment(currentSegment).airway) {
                currentSegment += 1;
                plan.insertSegment(currentSegment, FlightPlanSegmentType.Enroute);
            }
        }
        else {
            this.emptyFlightPlan();
        }
        if (newOriginIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newOriginIcao).then((facility) => {
                this.setOrigin(facility);
            });
        }
        if (newDestinationIcao) {
            this.facLoader.getFacility(FacilityType.Airport, newDestinationIcao).then((facility) => {
                this.setDestination(facility);
            });
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        plan.calculate(0);
    }
    /**
     * Checks whether the procedure being modified contains the currently active from and to legs and, if so,
     * returns those two legs. If the active leg is a direct to, this returns the entire direct to sequence (3 legs)
     * @param plan The flight plan.
     * @param segmentIndex The Segment Index.
     * @returns The array of active legs.
     */
    getActiveLegsInCurrentProcedure(plan, segmentIndex) {
        if (plan.getSegmentIndex(plan.activeLateralLeg) === segmentIndex) {
            const currentToLeg = plan.tryGetLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.tryGetLeg(plan.activeLateralLeg - 1);
            if (!currentToLeg || !currentFromLeg) {
                return undefined;
            }
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            if (BitFlags.isAll(currentToLeg.flags, LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                return [discoLeg, newFromLeg, newToLeg];
            }
            else {
                return [newFromLeg, newToLeg];
            }
        }
        return undefined;
    }
    /**
     * Method to add or replace a departure procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param departureIndex is the index of the departure
     * @param departureRunwayIndex is the index of the runway transition
     * @param enrouteTransitionIndex is the index of the enroute transition
     * @param oneWayRunway is the one way runway to set as the origin leg.
     */
    insertDeparture(facility, departureIndex, departureRunwayIndex, enrouteTransitionIndex, oneWayRunway) {
        const plan = this.getPlanToModify();
        plan.setDeparture(facility.icao, departureIndex, enrouteTransitionIndex, departureRunwayIndex);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        // Grabbing the active legs (if there are any) in the existing departure semgent,
        // so that we can put them somewhere after clearing the segment.
        const activeLegArray = !Simplane.getIsGrounded() && plan.activeLateralLeg > 0 ? this.getActiveLegsInCurrentProcedure(plan, segmentIndex) : undefined;
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        const insertProcedureObject = this.buildDepartureLegs(facility, departureIndex, enrouteTransitionIndex, departureRunwayIndex, oneWayRunway);
        if (plan.originAirport !== facility.icao) {
            plan.setOriginAirport(facility.icao);
        }
        plan.setOriginRunway(oneWayRunway);
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, BoeingExtraLegDefinitionFlags.ProcedureLeg));
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const depSegment = plan.getSegment(segmentIndex);
        const lastDepLeg = depSegment.legs[depSegment.legs.length - 1];
        if (nextLeg && lastDepLeg && this.isDuplicateLeg(lastDepLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastDepLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(depSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        plan.calculate(0);
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildDepartureLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, oneWayRunway) {
        const departure = facility.departures[procedureIndex];
        const enRouteTransition = departure.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = departure.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        let originLeg;
        if (oneWayRunway) {
            originLeg = BoeingFmsUtils.buildRunwayLeg(facility, oneWayRunway, true);
        }
        else {
            originLeg = FlightPlan.createLeg({
                lat: facility.lat,
                lon: facility.lon,
                type: LegType.IF,
                fixIcao: facility.icao
            });
        }
        insertProcedureObject.procedureLegs.push(originLeg);
        if (runwayTransition !== undefined && runwayTransition.legs.length > 0) {
            for (const leg of runwayTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < departure.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(departure.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (enRouteTransition) {
            for (let i = 0; i < enRouteTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(enRouteTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(enRouteTransition.legs[i]);
            }
        }
        return insertProcedureObject;
    }
    /**
     * Method to add or replace an arrival procedure in the flight plan.
     * @param facility is the facility that contains the procedure to add.
     * @param arrivalIndex is the index of the arrival procedure.
     * @param arrivalRunwayTransitionIndex is the index of the arrival runway transition.
     * @param enrouteTransitionIndex is the index of the enroute transition.
     * @param oneWayRunway is the one way runway to set as the destination leg.
     */
    insertArrival(facility, arrivalIndex, arrivalRunwayTransitionIndex, enrouteTransitionIndex, oneWayRunway) {
        var _a, _b;
        const plan = this.getPlanToModify();
        const activeSegment = BoeingFmsUtils.getActiveSegment(plan);
        if (plan.procedureDetails.approachIndex < 0) {
            if (plan.destinationAirport !== facility.icao) {
                plan.setDestinationAirport(facility.icao);
            }
            plan.setDestinationRunway(oneWayRunway);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        let arrivalActiveLegIcao;
        if (arrivalIndex > -1 && arrivalIndex === plan.procedureDetails.arrivalIndex && activeSegment !== undefined && activeLegArray !== undefined) {
            arrivalActiveLegIcao = (_b = (_a = plan.tryGetLeg(plan.activeLateralLeg)) === null || _a === void 0 ? void 0 : _a.leg) === null || _b === void 0 ? void 0 : _b.fixIcao;
        }
        plan.setArrival(facility.icao, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex);
        if (plan.getSegment(segmentIndex).legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Arrival);
        }
        const insertProcedureObject = this.buildArrivalLegs(facility, arrivalIndex, enrouteTransitionIndex, arrivalRunwayTransitionIndex, oneWayRunway);
        let directTargetLeg;
        let handleDirectToDestination = false;
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        if (directToState === DirectToState.TOEXISTING) {
            directTargetLeg = this.getDirectToLeg();
            if ((directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === plan.destinationAirport &&
                (directTargetLeg === null || directTargetLeg === void 0 ? void 0 : directTargetLeg.fixIcao) === insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1].fixIcao) {
                handleDirectToDestination = true;
            }
        }
        if (!handleDirectToDestination) {
            this.tryMoveDestinationLeg(plan);
        }
        insertProcedureObject.procedureLegs.forEach(l => this.planAddLeg(segmentIndex, l, undefined, BoeingExtraLegDefinitionFlags.ProcedureLeg));
        const arrSegment = plan.getSegment(segmentIndex);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstArrLeg = arrSegment.legs[0];
        let deduplicatedEnrouteLeg = null;
        if (prevLeg && firstArrLeg && this.isDuplicateLeg(prevLeg.leg, firstArrLeg.leg)) {
            deduplicatedEnrouteLeg = this.planRemoveDuplicateLeg(prevLeg, firstArrLeg);
        }
        const nextLeg = plan.getNextLeg(segmentIndex, Infinity);
        const lastArrLeg = arrSegment.legs[arrSegment.legs.length - 1];
        if (nextLeg && lastArrLeg && this.isDuplicateLeg(lastArrLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(lastArrLeg, nextLeg);
        }
        if (handleDirectToDestination) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Arrival, segmentIndex);
            this.activateLeg(segmentIndex, arrSegment.legs.length - 1);
        }
        // If we didn't remove a duplicate, insert a discontinuity at the start of the arrival
        if (!deduplicatedEnrouteLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        const matchingActiveProcedureLegIndex = BoeingFmsUtils.findIcaoInSegment(arrSegment, arrivalActiveLegIcao);
        if (activeLegArray && matchingActiveProcedureLegIndex === undefined) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(arrSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        else if (matchingActiveProcedureLegIndex !== undefined) {
            plan.setLateralLeg(arrSegment.offset + matchingActiveProcedureLegIndex);
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate(0);
    }
    /**
     * Tries to add a discontinuity when needed at the start of a procedure.
     * @param plan The Flight Plan
     * @param segmentIndex The procedure segment index.
     */
    tryInsertDiscontinuity(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.legs.length > 0) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Arrival:
                case FlightPlanSegmentType.Approach:
                    this.insertDiscontinuity(plan, segmentIndex, 0);
            }
        }
    }
    /**
     * Method to connect an arrival and approach when the approach begins at a leg that exists in the arrival.
     * @param plan The Lateral Flight Plan.
     */
    tryConnectProcedures(plan) {
        if (plan.procedureDetails.approachIndex > -1 && plan.procedureDetails.arrivalIndex > -1) {
            // find the first leg in the approach
            let firstApproachLeg;
            let firstApproachSegmentLegIndex;
            let matchedArrivalLegSegmentLegIndex;
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, false);
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (approachSegmentIndex > -1 && arrivalSegmentIndex > -1) {
                const approachSegment = plan.getSegment(approachSegmentIndex);
                const arrivalSegment = plan.getSegment(arrivalSegmentIndex);
                for (let l = 0; l < approachSegment.legs.length; l++) {
                    const approachLeg = approachSegment.legs[l];
                    if (approachLeg.leg.type !== LegType.Discontinuity && approachLeg.leg.type !== LegType.ThruDiscontinuity) {
                        firstApproachLeg = approachLeg;
                        firstApproachSegmentLegIndex = l;
                        break;
                    }
                }
                for (let i = arrivalSegment.legs.length - 1; i > 0; i--) {
                    const arrivalLeg = arrivalSegment.legs[i];
                    if ((arrivalLeg === null || arrivalLeg === void 0 ? void 0 : arrivalLeg.name) && (firstApproachLeg === null || firstApproachLeg === void 0 ? void 0 : firstApproachLeg.name) && arrivalLeg.name === firstApproachLeg.name) {
                        matchedArrivalLegSegmentLegIndex = i;
                        break;
                    }
                }
                if (firstApproachSegmentLegIndex !== undefined && matchedArrivalLegSegmentLegIndex !== undefined) {
                    while (arrivalSegment.legs.length > matchedArrivalLegSegmentLegIndex) {
                        plan.removeLeg(arrivalSegmentIndex, matchedArrivalLegSegmentLegIndex);
                    }
                    for (let j = 0; j < firstApproachSegmentLegIndex; j++) {
                        plan.removeLeg(approachSegmentIndex, j);
                    }
                }
            }
        }
    }
    /**
     * Method to insert the arrival legs.
     * @param facility is the facility to build legs from.
     * @param procedureIndex is the procedure index to build legs from.
     * @param enrouteTransitionIndex is the enroute transition index to build legs from.
     * @param runwayTransitionIndex is the runway transition index to build legs from.
     * @param oneWayRunway is the one way runway, if one is specified in the procedure.
     * @returns InsertProcedureObject to insert into the flight plan.
     */
    buildArrivalLegs(facility, procedureIndex, enrouteTransitionIndex, runwayTransitionIndex, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    oneWayRunway) {
        const arrival = facility.arrivals[procedureIndex];
        const enRouteTransition = arrival.enRouteTransitions[enrouteTransitionIndex];
        const runwayTransition = arrival.runwayTransitions[runwayTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (enRouteTransition !== undefined && enRouteTransition.legs.length > 0) {
            for (const leg of enRouteTransition.legs) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(leg));
            }
        }
        for (let i = 0; i < arrival.commonLegs.length; i++) {
            const leg = FlightPlan.createLeg(arrival.commonLegs[i]);
            if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                    this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                continue;
            }
            insertProcedureObject.procedureLegs.push(leg);
        }
        if (runwayTransition) {
            for (let i = 0; i < runwayTransition.legs.length; i++) {
                const leg = FlightPlan.createLeg(runwayTransition.legs[i]);
                if (i == 0 && insertProcedureObject.procedureLegs.length > 0 &&
                    this.isDuplicateIFLeg(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg)) {
                    insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] =
                        this.mergeDuplicateLegData(insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1], leg);
                    continue;
                }
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        this.tryInsertIFLeg(insertProcedureObject);
        return insertProcedureObject;
    }
    /**
     * Method to move a direct to destination to a specified target segment.
     * @param plan is the primary flight plan.
     * @param targetSegmentType is the target segment type.
     * @param arrivalSegmentIndex is the arrival segment index
     * @returns whether a direct to destination was moved.
     */
    moveDirectToDestinationLeg(plan, targetSegmentType, arrivalSegmentIndex) {
        const directTargetSegmentIndex = targetSegmentType === FlightPlanSegmentType.Arrival ? arrivalSegmentIndex : this.findLastEnrouteSegmentIndex(plan);
        if (directTargetSegmentIndex !== undefined && directTargetSegmentIndex > 0 && plan.getLeg(plan.activeLateralLeg).leg.fixIcao === plan.destinationAirport) {
            const destinationLeg = Object.assign({}, plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex].leg);
            const directTargetLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg).leg);
            const directOriginLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 1).leg);
            const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
            const newDirectLegIndex = plan.getSegment(directTargetSegmentIndex).legs.length;
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex);
            plan.setDirectToData(directTargetSegmentIndex, newDirectLegIndex);
            plan.addLeg(directTargetSegmentIndex, destinationLeg);
            plan.addLeg(directTargetSegmentIndex, discoLeg, undefined, LegDefinitionFlags.DirectTo);
            plan.addLeg(directTargetSegmentIndex, directOriginLeg, undefined, LegDefinitionFlags.DirectTo);
            const newActiveLeg = plan.addLeg(directTargetSegmentIndex, directTargetLeg, undefined, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            const newActiveLegIndex = plan.getLegIndexFromLeg(newActiveLeg);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
            plan.planIndex !== BoeingFms.ACT_RTE_PLAN_INDEX && plan.calculate(newActiveLegIndex);
            return true;
        }
        return false;
    }
    /**
     * Checks if the last leg in the last enroute segment is the destination airport and, if so, moves it into the approach segment.
     * @param plan The lateral flight plan.
     */
    tryMoveDestinationLeg(plan) {
        const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
        const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
        if (lastEnrouteSegment !== undefined && lastEnrouteSegment.legs.length > 0 &&
            lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg.fixIcao === plan.destinationAirport) {
            const approachSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach, true);
            const approachSegment = plan.getSegment(approachSegmentIndex);
            if (approachSegment.legs.length < 1) {
                const destinationLeg = Object.assign({}, lastEnrouteSegment.legs[lastEnrouteSegment.legs.length - 1].leg);
                plan.removeLeg(lastEnrouteSegmentIndex);
                plan.addLeg(approachSegmentIndex, destinationLeg);
            }
        }
    }
    /**
     * Method to find the last enroute segment of the supplied flight plan.
     * @param plan is the flight plan to find the last enroute segment in.
     * @returns a segment index.
     */
    findLastEnrouteSegmentIndex(plan) {
        let enrouteSegmentFound = 0;
        for (let i = 1; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute) {
                enrouteSegmentFound = i;
            }
        }
        return enrouteSegmentFound;
    }
    /**
     * Method to check whether an approach can load, or only activate.
     * @returns true if the approach can be loaded and not activated, otherwise the approach can only be immediatly activated.
     */
    canApproachLoad() {
        const plan = this.getFlightPlan();
        if (plan.length > 0) {
            const activeSegment = plan.getSegment(plan.getSegmentIndex(plan.activeLateralLeg));
            if (activeSegment.segmentType !== FlightPlanSegmentType.Approach && plan.length > 1) {
                return true;
            }
        }
        return false;
    }
    /**
     * Method to add or replace an approach procedure in the flight plan.
     *
     * @param description the approach procedure description
     *
     * @returns A Promise which is fulfilled with whether the approach was inserted.
     */
    async insertApproach(description) {
        var _a, _b, _c, _d;
        const plan = this.getPlanToModify();
        if (plan.length > 0 && plan.procedureDetails.approachIndex < 0) {
            const lastLeg = plan.tryGetLeg(plan.length - 1);
            if ((lastLeg === null || lastLeg === void 0 ? void 0 : lastLeg.leg.fixIcao) === plan.destinationAirport) {
                plan.removeLeg(plan.getSegmentIndex(plan.length - 1));
            }
        }
        let visualRunway;
        if (description.visualRunwayNumber !== undefined && description.visualRunwayDesignator !== undefined) {
            visualRunway = RunwayUtils.matchOneWayRunway(description.facility, description.visualRunwayNumber, description.visualRunwayDesignator);
            if (!visualRunway) {
                return false;
            }
        }
        let approach;
        if (visualRunway) {
            approach = BoeingFmsUtils.buildVisualApproach(this.facRepo, description.facility, visualRunway, (_a = description.visualRunwayOffset) !== null && _a !== void 0 ? _a : 5, description.vfrVerticalPathAngle);
        }
        else {
            approach = description.facility.approaches[description.approachIndex];
        }
        const opId = ++this.insertApproachOpId;
        const insertProcedureObject = await this.buildApproachLegs(description, approach, visualRunway);
        if (visualRunway) {
            this.setFlightPlanVisualApproach(plan.planIndex, visualRunway.designation);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, description.vfrVerticalPathAngle);
        }
        else if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.setFlightPlanVisualApproach(plan.planIndex, undefined);
            this.setFlightPlanVisualApproachVfrVpa(plan.planIndex, undefined);
        }
        plan.setApproach(description.facility.icao, description.approachIndex, description.approachTransitionIndex);
        const directToState = this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        let skipDestinationLegCheck = false;
        if (directToState === DirectToState.TOEXISTING) {
            if (((_b = this.getDirectToLeg()) === null || _b === void 0 ? void 0 : _b.fixIcao) === plan.destinationAirport) {
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                skipDestinationLegCheck = true;
            }
        }
        if (directToState === DirectToState.TOEXISTING && plan.procedureDetails.arrivalIndex < 0 && !skipDestinationLegCheck) {
            this.moveDirectToDestinationLeg(plan, FlightPlanSegmentType.Enroute);
        }
        if (plan.destinationAirport !== description.facility.icao) {
            plan.setDestinationAirport(description.facility.icao);
        }
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        let apprSegment = plan.getSegment(segmentIndex);
        if (apprSegment.legs.length > 0) {
            this.planClearSegment(segmentIndex, FlightPlanSegmentType.Approach);
            const newSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
            apprSegment = plan.getSegment(newSegmentIndex);
        }
        if (opId !== this.insertApproachOpId) {
            return false;
        }
        if (insertProcedureObject.runway) {
            plan.setDestinationRunway(insertProcedureObject.runway);
        }
        else {
            plan.setDestinationRunway(undefined);
        }
        let haveAddedMap = false;
        insertProcedureObject.procedureLegs.forEach((l) => {
            var _a;
            let isMissedLeg = false;
            if (visualRunway !== undefined) {
                this.addVisualFacilityFromLeg(l, visualRunway.designation);
                if (haveAddedMap) {
                    isMissedLeg = true;
                }
                if (l.fixTypeFlags & FixTypeFlags.MAP) {
                    haveAddedMap = true;
                }
            }
            let flags = (_a = l.flags) !== null && _a !== void 0 ? _a : LegDefinitionFlags.None;
            flags |= BoeingExtraLegDefinitionFlags.ProcedureLeg;
            if (isMissedLeg) {
                flags |= LegDefinitionFlags.MissedApproach;
            }
            this.planAddLeg(segmentIndex, l, undefined, flags);
        });
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const firstAppLeg = apprSegment.legs[0];
        let deduplicatedArrivalLeg = null;
        if (prevLeg && firstAppLeg && this.isDuplicateLeg(prevLeg.leg, firstAppLeg.leg)) {
            deduplicatedArrivalLeg = this.planRemoveDuplicateLeg(prevLeg, firstAppLeg);
        }
        // Adds missed approach legs
        if (!visualRunway && insertProcedureObject.procedureLegs.length > 0) {
            const missedLegs = (_c = description.facility.approaches[description.approachIndex].missedLegs) !== null && _c !== void 0 ? _c : [];
            if (missedLegs.length > 0) {
                let maphIndex = -1;
                for (let m = missedLegs.length - 1; m >= 0; m--) {
                    switch (missedLegs[m].type) {
                        case LegType.HA:
                        case LegType.HF:
                        case LegType.HM:
                            maphIndex = m - 1;
                            break;
                    }
                }
                let flags = LegDefinitionFlags.MissedApproach;
                flags |= BoeingExtraLegDefinitionFlags.ProcedureLeg;
                for (let n = 0; n < missedLegs.length; n++) {
                    const newLeg = FlightPlan.createLeg(missedLegs[n]);
                    if (maphIndex >= 0 && n === maphIndex) {
                        newLeg.fixTypeFlags |= FixTypeFlags.MAHP;
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                    else {
                        this.planAddLeg(segmentIndex, newLeg, undefined, flags);
                    }
                }
            }
        }
        const rnavTypeFlag = BoeingFmsUtils.getBestRnavType(approach.rnavTypeFlags);
        const approachIsCircling = !visualRunway && !(approach === null || approach === void 0 ? void 0 : approach.runway);
        const approachName = BoeingFmsUtils.getApproachNameAsEfisString(approach);
        const approachRunway = RunwayUtils.getRunwayNameString(approach.runwayNumber, approach.runwayDesignator, true, 'RW');
        const mapIndex = VNavUtils.getMissedApproachLegIndex(plan);
        const mapLeg = mapIndex >= 0 ? plan.tryGetLeg(mapIndex) : null;
        const missedApproachFacility = mapLeg && mapLeg.leg.fixIcao && mapLeg.leg.fixIcao !== ICAO.emptyIcao
            ? await this.facLoader.getFacility(ICAO.getFacilityType(mapLeg.leg.fixIcao), mapLeg.leg.fixIcao)
            : null;
        let referenceFacility = null;
        if (approach && BoeingFmsUtils.approachHasNavFrequency(approach)) {
            referenceFacility = (_d = await ApproachUtils.getReferenceFacility(approach, this.facLoader)) !== null && _d !== void 0 ? _d : null;
        }
        const finalApproachCourse = await this.getFinalApproachCourse(description.facility, approach);
        this.setApproachDetails(true, approach.approachType, rnavTypeFlag, false, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse);
        // set the G/S flag default state
        this.performancePlanProxy.glideSlope.set(approach.approachType === ApproachType.APPROACH_TYPE_ILS ? GlideslopeStatus.ON : GlideslopeStatus.OFF);
        // If we didn't remove a duplicate, insert a discontinuity at the start of the approach
        if (!deduplicatedArrivalLeg && (!prevLeg || !BoeingFmsUtils.isVectorsLeg(prevLeg.leg.type))) {
            this.tryInsertDiscontinuity(plan, segmentIndex);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            const segmentFirstLeg = plan.getSegment(segmentIndex).legs[0];
            // We don't want to insert duplicate discontinuities if there is already one at the start of the approach
            const discontinuityAlreadyPresent = segmentFirstLeg && BoeingFmsUtils.isDiscontinuityLeg(segmentFirstLeg.leg.type);
            if (activeLegArray.length === 2) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[1].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[1], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[0].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[0], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                plan.setLateralLeg(apprSegment.offset + 1);
            }
            else if (activeLegArray.length === 3) {
                if (!discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                // We should really never get into the scenario where this leg is a discontinuity, but let's be safe
                if (!BoeingFmsUtils.isDiscontinuityLeg(activeLegArray[2].type) || !discontinuityAlreadyPresent) {
                    plan.addLeg(segmentIndex, activeLegArray[2], 0, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
                }
                this.createDirectTo(segmentIndex, 0);
            }
        }
        this.generateSegmentVerticalData(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.tryConnectProcedures(plan);
        plan.calculate();
        return true;
    }
    /**
     * Method to build the approach legs.
     *
     * @param description the approach procedure description
     * @param resolvedApproach the resolved approach procedure
     * @param resolvedVisualRunway the resolved visual runway, if applicable
     *
     * @returns A Promise which is fulfilled with an `InsertProcedureObject` containing the flight plan legs to insert
     * into the flight plan.
     */
    async buildApproachLegs(description, resolvedApproach, resolvedVisualRunway) {
        const isVisual = resolvedApproach.approachType === AdditionalApproachType.APPROACH_TYPE_VISUAL;
        const transition = resolvedApproach.transitions[description.approachTransitionIndex];
        const insertProcedureObject = { procedureLegs: [] };
        if (transition !== undefined && transition.legs.length > 0) {
            const startIndex = description.transStartIndex !== undefined ? description.transStartIndex : 0;
            for (let t = startIndex; t < transition.legs.length; t++) {
                insertProcedureObject.procedureLegs.push(FlightPlan.createLeg(transition.legs[t]));
            }
        }
        const lastTransitionLeg = insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1];
        const finalLegs = resolvedApproach.finalLegs;
        for (let i = 0; i < finalLegs.length; i++) {
            const leg = FlightPlan.createLeg(finalLegs[i]);
            if (i === 0 && lastTransitionLeg && this.isDuplicateIFLeg(lastTransitionLeg, leg)) {
                insertProcedureObject.procedureLegs[insertProcedureObject.procedureLegs.length - 1] = this.mergeDuplicateLegData(lastTransitionLeg, leg);
                continue;
            }
            if (!isVisual && leg.fixIcao[0] === 'R') {
                const approachRunway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
                if (approachRunway) {
                    insertProcedureObject.runway = approachRunway;
                    const runwayLeg = BoeingFmsUtils.buildRunwayLeg(description.facility, approachRunway, false);
                    runwayLeg.verticalAngle = leg.verticalAngle;
                    insertProcedureObject.procedureLegs.push(runwayLeg);
                }
            }
            else if (isVisual && i === finalLegs.length - 1) {
                insertProcedureObject.runway = resolvedVisualRunway;
                insertProcedureObject.procedureLegs.push(leg);
                if (resolvedApproach.missedLegs.length > 0) {
                    insertProcedureObject.procedureLegs.push(resolvedApproach.missedLegs[0]);
                }
            }
            else {
                insertProcedureObject.procedureLegs.push(leg);
            }
        }
        if (!isVisual) {
            this.tryInsertIFLeg(insertProcedureObject);
            this.tryReconcileIAFLeg(insertProcedureObject);
            this.manageFafAltitudeRestriction(insertProcedureObject);
            this.tryCleanupHold(insertProcedureObject);
            this.tryInsertMap(insertProcedureObject);
            if (!insertProcedureObject.runway && resolvedApproach.runway) {
                insertProcedureObject.runway = RunwayUtils.matchOneWayRunway(description.facility, resolvedApproach.runwayNumber, resolvedApproach.runwayDesignator);
            }
            return insertProcedureObject;
        }
        return insertProcedureObject;
    }
    /**
     * Manages the altitude constraints in a segment when adding a procedure by creating a VerticalData object for each leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index for the inserted procedure.
     */
    generateSegmentVerticalData(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        for (let l = 0; l < segment.legs.length; l++) {
            this.generateLegVerticalData(plan, segmentIndex, l);
        }
    }
    /**
     * Manages the altitude constraints for a leg when adding a procedure by creating a VerticalData object for the leg.
     * @param plan The Flight Plan.
     * @param segmentIndex The segment index.
     * @param localLegIndex The local leg index.
     * @param forceVerticalFlightPhase The vertical flight phase to force on the vertical data. Otherwise, determined by the leg segment type.
     */
    generateLegVerticalData(plan, segmentIndex, localLegIndex, forceVerticalFlightPhase) {
        const segment = plan.getSegment(segmentIndex);
        const leg = segment.legs[localLegIndex];
        const altitude1 = leg.leg.altitude1;
        const altitude2 = leg.leg.altitude2;
        const altDesc = (BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.MAP) && altitude1 !== 0) ? AltitudeRestrictionType.At : leg.leg.altDesc;
        const speedRestriction = leg.leg.speedRestriction;
        const verticalData = {
            phase: forceVerticalFlightPhase !== null && forceVerticalFlightPhase !== void 0 ? forceVerticalFlightPhase : (segment.segmentType === FlightPlanSegmentType.Departure || BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)
                ? VerticalFlightPhase.Climb
                : VerticalFlightPhase.Descent),
            altDesc: altDesc,
            altitude1: altitude1,
            altitude2: altitude2,
            speed: speedRestriction <= 0 ? 0 : speedRestriction,
            speedDesc: speedRestriction <= 0 ? SpeedRestrictionType.Unused : SpeedRestrictionType.AtOrBelow,
            speedUnit: SpeedUnit.IAS
        };
        plan.setLegVerticalData(segmentIndex, localLegIndex, verticalData);
    }
    /**
     * Manages the altitude constraints for FAF legs where vertical angle info is also provided.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    manageFafAltitudeRestriction(proc) {
        proc.procedureLegs.forEach(leg => {
            if (leg.fixTypeFlags === FixTypeFlags.FAF && leg.altitude2 > 0) {
                const alt = leg.altitude1 <= leg.altitude2 ? leg.altitude1 : leg.altitude2;
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude1 = alt;
                leg.altitude2 = alt;
            }
            else if (leg.fixTypeFlags === FixTypeFlags.FAF) {
                leg.altDesc = AltitudeRestrictionType.At;
                leg.altitude2 = leg.altitude1;
            }
        });
        return proc;
    }
    /**
     * Inserts an IF leg at the beginning of a procedure if it begins with a leg type which defines a fixed origin.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertIFLeg(proc) {
        const firstLeg = proc.procedureLegs[0];
        let icao;
        switch (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) {
            case LegType.HA:
            case LegType.HF:
            case LegType.HM:
            case LegType.PI:
            case LegType.FD:
            case LegType.FC:
                icao = firstLeg.fixIcao;
                break;
            case LegType.FM:
            case LegType.VM:
                icao = firstLeg.originIcao;
                break;
        }
        if (icao && icao !== ICAO.emptyIcao) {
            proc.procedureLegs.unshift(FlightPlan.createLeg({
                type: LegType.IF,
                fixIcao: icao,
                fixTypeFlags: firstLeg.fixTypeFlags & (FixTypeFlags.IF | FixTypeFlags.IAF)
            }));
            if ((firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.HF || (firstLeg === null || firstLeg === void 0 ? void 0 : firstLeg.type) === LegType.PI) {
                proc.procedureLegs[0].altDesc = firstLeg.altDesc;
                proc.procedureLegs[0].altitude1 = firstLeg.altitude1;
                proc.procedureLegs[0].altitude2 = firstLeg.altitude2;
            }
            // need to remove IF/IAF flags from the original first leg (now the second leg)
            const replacementLeg = FlightPlan.createLeg(proc.procedureLegs[1]);
            replacementLeg.fixTypeFlags = replacementLeg.fixTypeFlags & ~(FixTypeFlags.IF | FixTypeFlags.IAF);
            proc.procedureLegs[1] = replacementLeg;
        }
        return proc;
    }
    /**
     * Checks the approach legs for an IAF fix type flag, and if one exists, amend the approach to ensure that
     * the IAF is not on a hold/pt leg and that we do not add legs prior to the IAF except in cases where we needed to add
     * an IF leg type.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryReconcileIAFLeg(proc) {
        let iafIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.IAF) {
                iafIndex = i;
                switch (leg.type) {
                    case LegType.HA:
                    case LegType.HF:
                    case LegType.HM:
                    case LegType.PI:
                    case LegType.FD:
                    case LegType.FC:
                        if (iafIndex > 0) {
                            leg.fixTypeFlags &= ~FixTypeFlags.IAF;
                            proc.procedureLegs[iafIndex - 1].fixTypeFlags |= FixTypeFlags.IAF;
                            iafIndex--;
                        }
                }
                break;
            }
        }
        return proc;
    }
    /**
     * Inserts a MAP fix type flag if none exists on the approach.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryInsertMap(proc) {
        let addMap = true;
        let runwayIndex = -1;
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.fixTypeFlags === FixTypeFlags.MAP) {
                addMap = false;
                break;
            }
            if (leg.fixIcao.search('R') === 0) {
                runwayIndex = i;
                break;
            }
        }
        if (addMap && runwayIndex > -1) {
            proc.procedureLegs[runwayIndex].fixTypeFlags = FixTypeFlags.MAP;
        }
        return proc;
    }
    /**
     * Method to remove the duplicate leg after the hold leg.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryCleanupHold(proc) {
        for (let i = 0; i < proc.procedureLegs.length; i++) {
            const leg = proc.procedureLegs[i];
            if (leg.type === LegType.HF) {
                const next = proc.procedureLegs[i + 1];
                if (leg.fixIcao === next.fixIcao && next.type === LegType.IF) {
                    proc.procedureLegs.splice(i + 1, 1);
                }
            }
        }
        return proc;
    }
    /**
     * Method to remove a course reversal in an approach procedure.
     * @param proc A procedure object.
     * @returns the procedure object, after it has been changed.
     */
    tryRemoveCourseReversal(proc) {
        let canRemove = false;
        if (proc.procedureLegs.length > 2) {
            const leg = proc.procedureLegs[1];
            switch (leg.type) {
                case LegType.HA:
                case LegType.HF:
                case LegType.HM:
                case LegType.PI:
                    canRemove = true;
            }
        }
        if (canRemove) {
            proc.procedureLegs.splice(1, 1);
        }
        return proc;
    }
    /**
     * Method to remove the departure from the flight plan.
     */
    async removeDeparture() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
        plan.setDeparture();
        this.planClearSegment(segmentIndex, FlightPlanSegmentType.Departure);
        // Remove constraints from first enroute leg
        this.clearFirstEnrouteLegVerticalData(plan);
        if (plan.originAirport) {
            const airport = await this.facLoader.getFacility(FacilityType.Airport, plan.originAirport);
            const updatedSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Departure);
            this.planAddOriginDestinationLeg(true, updatedSegmentIndex, airport, plan.procedureDetails.originRunway);
            const prevLeg = plan.getPrevLeg(updatedSegmentIndex, 1);
            const nextLeg = plan.getNextLeg(updatedSegmentIndex, 0);
            if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
                this.planRemoveDuplicateLeg(prevLeg, nextLeg);
            }
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the arrival from the flight plan.
     */
    async removeArrival() {
        const plan = this.getPlanToModify();
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival);
        plan.setArrival();
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        // Remove constraints from last enroute leg
        this.clearLastEnrouteLegVerticalData(plan);
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray && activeLegArray.length === 2) {
            this.addActiveLegsToEnroute(plan, activeLegArray);
        }
        plan.calculate(0);
    }
    /**
     * Method to remove the approach from the flight plan.
     */
    async removeApproach() {
        const plan = this.getPlanToModify();
        if (this.getFlightPlanVisualApproach(plan.planIndex) !== undefined) {
            this.deleteFlightPlanVisualApproach(plan.planIndex);
        }
        this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        // set the G/S enabled for non-FMS approach
        this.performancePlanProxy.glideSlope.set(GlideslopeStatus.ON);
        const segmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Approach);
        const activeLegArray = this.getActiveLegsInCurrentProcedure(plan, segmentIndex);
        plan.procedureDetails.arrivalRunwayTransitionIndex = -1;
        plan.setDestinationRunway(undefined, false);
        plan.setApproach();
        this.cleanupLegsAfterApproach(plan);
        this.planRemoveSegment(segmentIndex);
        // Remove constraints from last enroute leg if there wasn't an arrival
        if (plan.procedureDetails.arrivalIndex === -1) {
            this.clearLastEnrouteLegVerticalData(plan);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, 0);
        const nextLeg = plan.getNextLeg(segmentIndex, -1);
        if (prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (activeLegArray) {
            BoeingFmsUtils.removeDisplacedActiveLegs(plan);
            this.addActiveLegsToEnroute(plan, activeLegArray, true);
        }
        plan.calculate(0);
    }
    /**
     * Clears the vertical data of the last enroute leg, if applicable
     *
     * @param plan the lateral flight plan
     */
    clearFirstEnrouteLegVerticalData(plan) {
        let firstEnrouteSegment;
        for (let i = 0; i < plan.segmentCount; i++) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.legs.length > 0) {
                firstEnrouteSegment = segment;
                break;
            }
        }
        if (firstEnrouteSegment) {
            plan.setLegVerticalData(firstEnrouteSegment.offset, { altDesc: AltitudeRestrictionType.Unused, speedDesc: SpeedRestrictionType.Unused });
        }
    }
    /**
     * Clears the vertical data of the last enroute leg, if applicable
     *
     * @param plan the lateral flight plan
     */
    clearLastEnrouteLegVerticalData(plan) {
        let lastEnrouteSegment;
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            const segment = plan.getSegment(i);
            if (segment.segmentType === FlightPlanSegmentType.Enroute && segment.legs.length > 0) {
                lastEnrouteSegment = segment;
                break;
            }
        }
        if (lastEnrouteSegment) {
            plan.setLegVerticalData(lastEnrouteSegment.offset + (lastEnrouteSegment.legs.length - 1), { altDesc: AltitudeRestrictionType.Unused, speedDesc: SpeedRestrictionType.Unused });
        }
    }
    /**
     * Adds active leg pair to the last enroute segment when a procedure is deleted and the current activeLateralLeg is in that procedure.
     * @param plan The FlightPlan.
     * @param activeLegArray The Active Leg Pair.
     * @param checkForArrivalSegment Whether to check first for an arrival segment to add the legs to.
     */
    addActiveLegsToEnroute(plan, activeLegArray, checkForArrivalSegment = false) {
        let segmentIndex = this.findLastEnrouteSegmentIndex(plan);
        if (checkForArrivalSegment && plan.procedureDetails.arrivalIndex > -1) {
            const arrivalSegmentIndex = this.ensureOnlyOneSegmentOfType(FlightPlanSegmentType.Arrival, false);
            if (arrivalSegmentIndex > -1) {
                segmentIndex = arrivalSegmentIndex;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (activeLegArray.length === 2) {
            plan.addLeg(segmentIndex, activeLegArray[0], undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            plan.addLeg(segmentIndex, activeLegArray[1], undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            plan.setLateralLeg(segment.offset + segment.legs.length - 2);
        }
        else if (activeLegArray.length === 3) {
            plan.addLeg(segmentIndex, activeLegArray[1]);
            this.planAddLeg(segmentIndex, FlightPlan.createLeg({
                type: LegType.Discontinuity
            }), undefined, BoeingExtraLegDefinitionFlags.DisplacedActiveLeg);
            this.createDirectTo(segmentIndex, segment.legs.length - 2);
        }
    }
    /**
     * Method to activate a leg in the flight plan.
     * @param segmentIndex is the index of the segment containing the leg to activate.
     * @param legIndex is the index of the leg in the selected segment activate.
     * @param removeExistingDTO Whether to check for and remove the existing direct to legs.
     */
    activateLeg(segmentIndex, legIndex, removeExistingDTO = true) {
        const modPlan = this.getPlanToModify();
        const indexInFlightplan = modPlan.getSegment(segmentIndex).offset + legIndex;
        if (removeExistingDTO && this.getDirectToState(modPlan.planIndex) === DirectToState.TOEXISTING) {
            this.removeDirectToExisting(modPlan.planIndex, indexInFlightplan);
            // The call above handles setting the active leg
        }
        else {
            modPlan.setCalculatingLeg(indexInFlightplan);
            modPlan.setLateralLeg(indexInFlightplan);
            modPlan.calculate(Math.max(0, indexInFlightplan - 1));
        }
        this.legWasActivatedInModPlan = true;
    }
    /**
     * Method to create a direct to in the plan. This method will also then call activateLeg.
     * A DTO consists of 4 legs:
     * 1. The original leg that was used to create the DTO.
     * a. We preserve this leg so that we will have a vlid FROM leg in case the DTO needs to be removed.
     * 2. A DISCO leg, because a DTO is not connected to any legs that came before it.
     * 3. The FROM leg, initializes to the present position (PPOS).
     * 4. The TO leg.
     * @param segmentIndex is the index of the segment containing the leg to activate as direct to.
     * @param segmentLegIndex is the index of the leg in the specified segment to activate as direct to.
     * @param isNewDTO whether to treat this as a new directo to or not.
     * @param course is the course for this direct to in magnetic degrees, if specified.
     * @param facility is the new facility to add to the plan and then create a direct to for, for the case of a direct to random.
     */
    createDirectTo(segmentIndex, segmentLegIndex, isNewDTO = true, course, facility) {
        var _a, _b;
        let newLeg;
        if (isNewDTO) {
            this.dtoWasCreatedInModPlan = true;
            if (facility !== undefined) {
                newLeg = FlightPlan.createLeg({
                    type: LegType.TF,
                    fixIcao: facility.icao
                });
            }
        }
        const plan = this.getPlanToModify();
        if (segmentIndex === undefined) {
            const lastSegment = plan.segmentCount > 0 ? plan.getSegment(plan.segmentCount - 1) : undefined;
            if (lastSegment) {
                if (lastSegment.segmentType !== FlightPlanSegmentType.Enroute) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, lastSegment.segmentIndex + 1);
                }
                else {
                    segmentIndex = lastSegment.segmentIndex;
                }
            }
            else {
                return;
            }
        }
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        let modLegVerticalData;
        if (!isNewDTO && this.dtoWasCreatedInModPlan) {
            const existingModDtoTargetLeg = segment.legs[segmentLegIndex + 3];
            if (existingModDtoTargetLeg !== undefined) {
                modLegVerticalData = existingModDtoTargetLeg.verticalData;
                if (existingModDtoTargetLeg.leg.type === LegType.CF) {
                    if (existingModDtoTargetLeg.leg.trueDegrees) {
                        // FIXME we give up if no magvar available from calculations
                        course = MagVar.trueToMagnetic(existingModDtoTargetLeg.leg.course, (_b = (_a = existingModDtoTargetLeg.calculated) === null || _a === void 0 ? void 0 : _a.courseMagVar) !== null && _b !== void 0 ? _b : 0);
                    }
                    else {
                        course = existingModDtoTargetLeg.leg.course;
                    }
                }
            }
        }
        let legIndexDelta = 0;
        if (plan.directToData.segmentIndex > -1 && plan.directToData.segmentLegIndex > -1) {
            legIndexDelta -= plan.directToData.segmentIndex === segmentIndex && segmentLegIndex > plan.directToData.segmentLegIndex ? 3 : 0;
            if (this.getDirectToState(BoeingFms.RTE_1_MOD_PLAN_INDEX) === DirectToState.TOEXISTING) {
                this.removeDirectToExisting(BoeingFms.RTE_1_MOD_PLAN_INDEX, undefined, false);
            }
            else {
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
            }
        }
        if (newLeg !== undefined) {
            this.planAddLeg(segmentIndex, newLeg, segmentLegIndex + legIndexDelta);
        }
        const leg = segment.legs[segmentLegIndex + legIndexDelta];
        plan.setDirectToData(segmentIndex, segmentLegIndex + legIndexDelta);
        if (segment && leg) {
            let originPos = this.ppos;
            if (course) {
                originPos = this.ppos.offset(NavMath.normalizeHeading(course + 180), UnitType.NMILE.convertTo(50, UnitType.GA_RADIAN), new GeoPoint(0, 0));
            }
            const discoLeg = FlightPlan.createLeg({ type: LegType.Discontinuity });
            const dtoOriginLeg = this.createDTOOriginLeg(originPos);
            const dtoTargetLeg = this.createDTODirectLeg(leg.leg.fixIcao, leg.leg, course);
            // We do a +1,2,3 here so that the original TO leg is preserved, in case the DTO gets removed
            plan.addLeg(segmentIndex, discoLeg, segmentLegIndex + legIndexDelta + 1, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoOriginLeg, segmentLegIndex + legIndexDelta + 2, LegDefinitionFlags.DirectTo);
            plan.addLeg(segmentIndex, dtoTargetLeg, segmentLegIndex + legIndexDelta + 3, (leg.flags & LegDefinitionFlags.MissedApproach) | LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            const newVerticalData = modLegVerticalData !== null && modLegVerticalData !== void 0 ? modLegVerticalData : leg.verticalData;
            plan.setLegVerticalData(segmentIndex, segmentLegIndex + legIndexDelta + 3, newVerticalData);
            this.activateLeg(segmentIndex, segmentLegIndex + legIndexDelta + 3, false);
        }
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - creates a direct-to sequence to that facility.
     *
     * @param airportFacility the airport facility to go direct to
     */
    createDirectToAirport(airportFacility) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        this.setDestination(airportFacility);
        this.createDirectTo(undefined, undefined, true, undefined, airportFacility);
    }
    /**
     * Method to create a direct to in the flight plan to an arbitrary airport+runway using a visual approach.
     *
     * This:
     *
     * - empties out the flight plan;
     * - sets the destination as the provided airport facility;
     * - inserts a visual approach to the provided runway;
     * - creates a direct-to sequence to the FAF of that approach.
     *
     * @param airportFacility the airport facility to go direct to
     * @param runway the one way runway to insert a visual approach for
     */
    async createDirectToRunwayVisualApproach(airportFacility, runway) {
        const plan = this.getPlanToModify();
        const segmentCount = plan.segmentCount;
        for (let i = segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i, true);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure, undefined, true);
        plan.addSegment(1, FlightPlanSegmentType.Enroute, undefined, true);
        BoeingFmsUtils.reconcileDirectToData(plan);
        await this.insertApproach({
            facility: airportFacility,
            approachIndex: -1,
            approachTransitionIndex: -1,
            visualRunwayNumber: runway.direction,
            visualRunwayDesignator: runway.runwayDesignator,
        });
        const approachSegment = Array.from(plan.segmentsOfType(FlightPlanSegmentType.Approach))[0];
        if (approachSegment) {
            let activateIndex = -1;
            for (let i = 0; i < approachSegment.legs.length; i++) {
                activateIndex = i;
                const leg = approachSegment.legs[i];
                const isFaf = BitFlags.isAll(leg.leg.fixTypeFlags, FixTypeFlags.FAF);
                if (isFaf) {
                    break;
                }
            }
            if (activateIndex !== -1) {
                this.createDirectTo(approachSegment.segmentIndex, activateIndex, true, undefined);
            }
        }
    }
    /**
     * Creates a Direct-To origin IF leg.
     * @param ppos The current plane position.
     * @returns a Direct-To origin IF leg.
     */
    createDTOOriginLeg(ppos) {
        return FlightPlan.createLeg({
            type: LegType.IF,
            lat: ppos.lat,
            lon: ppos.lon
        });
    }
    /**
     * Creates a Direct-To target leg.
     * @param icao is the icao.
     * @param leg The FlightPlanLeg.
     * @param course The magnetic course for the Direct To.
     * @returns a Direct-To leg.
     */
    createDTODirectLeg(icao, leg, course) {
        let legType;
        if (course === undefined) {
            legType = LegType.DF;
            const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES MAGNETIC', 'degrees');
            course = planeHeading === 0 ? 360 : planeHeading;
        }
        else {
            legType = LegType.CF;
        }
        if (leg) {
            const directLeg = Object.assign({}, leg);
            directLeg.type = legType;
            directLeg.course = course;
            directLeg.trueDegrees = false;
            directLeg.turnDirection = LegTurnDirection.None;
            return directLeg;
        }
        else {
            return FlightPlan.createLeg({
                type: legType,
                fixIcao: icao,
                course,
                trueDegrees: false
            });
        }
        // const planeHeading = SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', 'degrees');
        // if (leg) {
        //   const directLeg = Object.assign({}, leg);
        //   directLeg.type = LegType.DF;
        //   directLeg.course = planeHeading === 0 ? 360 : planeHeading;
        //   return directLeg;
        // } else {
        //   return FlightPlan.createLeg({
        //     type: LegType.DF,
        //     fixIcao: icao,
        //     course: planeHeading === 0 ? 360 : planeHeading
        //   });
        // }
    }
    /**
     * Updates the DTO Origin Leg Lat/Lon with the PPOS.
     * @param plan The Flight Plan.
     */
    updateDtoOrigin(plan) {
        // We only want to update the DTO origin if the DTO was created in this current MOD plan
        if (!this.dtoWasCreatedInModPlan) {
            return;
        }
        const pposLeg = plan.tryGetLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 2);
        // Making sure that we are in a DTO
        if (!pposLeg) {
            return;
        }
        // We need to recreate the DTO so that the proper events get sent and legs get recreated and what not
        this.createDirectTo(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex, false);
    }
    /**
     * Creates a vertical direct-to to a leg. This creates a manual constraint with an fpa that reaches
     * the desired altitude using a continuous descent from the present position and altitude.
     *
     * **NOTE:** This will not delete any constraints - it is the responsibility of the caller to do so.
     *
     * @param plan the plan to use
     * @param globalIndex the global leg index to apply the constraint to
     * @param finalAltitude the altitude to target, in metres.
     * @param isAutomatic whether this was an automatic VDTO (created with a lateral DTO)
     *
     * @returns whether the vdto was successfully created
     */
    createVerticalDirectTo(plan, globalIndex, finalAltitude, isAutomatic = false) {
        var _a;
        const distanceToConstraint = isAutomatic
            ? (_a = plan.getLeg(globalIndex).calculated) === null || _a === void 0 ? void 0 : _a.distanceWithTransitions
            : BoeingFmsUtils.getDistanceFromPposToLegEnd(plan, globalIndex);
        if (distanceToConstraint === undefined) {
            return false;
        }
        const currentAltitude = this.aircraftAltitude;
        if (currentAltitude === undefined) {
            return false;
        }
        const currentAltitudeMetres = UnitType.METER.convertFrom(currentAltitude, UnitType.FOOT);
        const fpa = VNavUtils.getFpa(distanceToConstraint, 75 + currentAltitudeMetres - finalAltitude);
        const isFpaValid = fpa > 1 && fpa <= 6;
        if (!isFpaValid) {
            return false;
        }
        plan.setLegVerticalData(globalIndex, {
            phase: VerticalFlightPhase.Descent,
            altDesc: AltitudeRestrictionType.At,
            altitude1: finalAltitude,
            altitude2: undefined,
            fpa: isAutomatic ? Math.max(3, fpa) : fpa,
        });
        this.verticalPathCalculator.requestPathCompute(BoeingFms.RTE_1_MOD_PLAN_INDEX);
        this.verticalDtoWasCreatedInModPlan = true;
        this.verticalDtoWasCreatedInModPlanWasAutomatic = isAutomatic;
        return true;
    }
    /**
     * Updates the vertical DTO origin with the current altitude and distance to constraint.
     * @param plan The Flight Plan.
     * @returns whether the vertical DTO is still valid
     */
    updateVerticalDtoOrigin(plan) {
        const constraintIndex = VNavUtils.getConstraintIndexFromLegIndex(this.getVerticalPlanForFmcRender(), plan.activeLateralLeg);
        if (constraintIndex === -1) {
            return false;
        }
        const constraint = this.getVerticalPlanForFmcRender().constraints[constraintIndex];
        return this.createVerticalDirectTo(plan, constraint.index, constraint.targetAltitude, this.verticalDtoWasCreatedInModPlanWasAutomatic);
    }
    /**
     * Creates a direct to existing to the next valid leg in the plan after the input global leg index.
     * @param globalLegIndex The global leg index.
     * @returns Whether a direct to existing was created.
     */
    createDirectToExistingNextValidLeg(globalLegIndex) {
        const modPlan = this.getPrimaryModFlightPlan();
        for (let l = globalLegIndex + 1; l < modPlan.length; l++) {
            const leg = modPlan.tryGetLeg(l);
            if ((leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.Discontinuity && (leg === null || leg === void 0 ? void 0 : leg.leg.type) !== LegType.ThruDiscontinuity) {
                const targetSegmentIndex = modPlan.getSegmentIndex(l);
                const targetSegment = modPlan.getSegment(targetSegmentIndex);
                const targetSegmentLegIndex = l - targetSegment.offset;
                this.createDirectTo(targetSegmentIndex, targetSegmentLegIndex, true);
                return true;
            }
        }
        return false;
    }
    /**
     * Creates an alternate diversion in the MOD plan based on provided alternate data
     *
     * @param alternateData the alternate data to use
     *
     * @throws if the alternate diversion mode is unknown or not implemented yet
     */
    createAlternateDiversion(alternateData) {
        const plan = this.getPlanToModify();
        // Always create a direct diversion if no legs in front of us
        if (((plan.length - 1) - plan.activeLateralLeg) < 0) {
            this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
            return;
        }
        switch (alternateData.diversion.mode) {
            case AlternateDiversionMode.Direct:
                this.createDirectAlternateDiversion(plan, alternateData.facilityIcao).then();
                break;
            case AlternateDiversionMode.Overhead:
                this.createOverheadAlternateDiversion(plan, alternateData.facilityIcao, alternateData.diversion.legIndex);
                break;
            default: throw new Error(`Unknown or unimplemented alternate diversion mode: ${alternateData.diversion.mode}`);
        }
    }
    /**
     * Creates a DIRECT alternate diversion
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     */
    async createDirectAlternateDiversion(plan, alternateFacilityIcao) {
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.createDirectToAirport(airportFacility);
    }
    /**
     * Creates an OVERHEAD alternate diversion. This should only be called with an {@link overheadLegIndex} that is
     * in the flight plan, or if `undefined`, with a flight plan that contains an active leg.
     *
     * @param plan the flight plan to create the diversion in
     * @param alternateFacilityIcao the ICAO of the alternate facility to divert to
     * @param overheadLegIndex the leg index of the overhead point, or `undefined` if the active leg shall be used
     */
    async createOverheadAlternateDiversion(plan, alternateFacilityIcao, overheadLegIndex) {
        const segmentCount = plan.segmentCount;
        // Find leg index of the overhead fix
        const overheadFixLegIndex = overheadLegIndex !== null && overheadLegIndex !== void 0 ? overheadLegIndex : plan.activeLateralLeg; // TODO what if there are no legs in the plan after active?
        const activeSegmentIndex = plan.getSegmentIndex(overheadFixLegIndex);
        // Remove all next segments
        for (let i = segmentCount - 1; i > activeSegmentIndex + 1; i--) {
            plan.removeSegment(i, true);
        }
        // Remove everything after that leg
        while ((plan.length - 1) > overheadFixLegIndex) {
            const lastLegGlobalIndex = plan.length - 1;
            const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
            const lastLegLocalIndex = plan.getSegmentLegIndex(lastLegGlobalIndex);
            plan.removeLeg(lastLegSegmentIndex, lastLegLocalIndex);
        }
        // Create a DF leg to that airport
        const dfLeg = this.createDTODirectLeg(alternateFacilityIcao);
        // Add that DF leg at the end of the plan
        const lastLegGlobalIndex = plan.length - 1;
        const lastLegSegmentIndex = plan.getSegmentIndex(lastLegGlobalIndex);
        plan.addLeg(lastLegSegmentIndex, dfLeg);
        const airportFacility = await this.facLoader.getFacility(FacilityType.Airport, alternateFacilityIcao);
        this.setDestination(airportFacility);
    }
    /**
     * Updates an existing PPOS hold if it exists and is in the MOD flight plan
     *
     * @param plan the plan
     */
    tryUpdatePposHoldPosition(plan) {
        const modPlan = this.getPrimaryModFlightPlan();
        const activePlan = this.getPrimaryFlightPlan();
        const modActiveLeg = modPlan.tryGetLeg(modPlan.activeLateralLeg);
        const activeActiveLeg = activePlan.tryGetLeg(activePlan.activeLateralLeg);
        // We don't wanna update any PPOS hold in the mod flight plan if that hold is already confirmed (in the active flight plan)
        const pposHoldInActive = activeActiveLeg && activeActiveLeg.leg.type === LegType.HM && activeActiveLeg.leg.fixIcao === ICAO.emptyIcao;
        const notPposHold = modActiveLeg && (modActiveLeg.leg.type !== LegType.HM || modActiveLeg.leg.fixIcao !== ICAO.emptyIcao);
        if (plan.planIndex !== BoeingFms.RTE_1_MOD_PLAN_INDEX || pposHoldInActive || !modActiveLeg || notPposHold) {
            // Not in MOD or no PPOS hold at FROM leg
            return;
        }
        this.insertPposHold();
    }
    /**
     * Empties the primary flight plan.
     * @param planIndex The plan index to empty. Defaults to the active plan index.
     */
    emptyFlightPlan(planIndex = BoeingFms.ACT_RTE_PLAN_INDEX) {
        if (!this.flightPlanner.hasFlightPlan(planIndex)) {
            return;
        }
        const plan = this.flightPlanner.getFlightPlan(planIndex);
        for (let i = plan.segmentCount - 1; i >= 0; i--) {
            plan.removeSegment(i);
        }
        plan.addSegment(0, FlightPlanSegmentType.Departure);
        plan.addSegment(1, FlightPlanSegmentType.Enroute);
        plan.addSegment(2, FlightPlanSegmentType.Destination);
        plan.removeOriginAirport();
        plan.removeDestinationAirport();
        plan.setDirectToData(-1);
        if (planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
            this.setApproachDetails(false, ApproachType.APPROACH_TYPE_UNKNOWN, RnavTypeFlags.None, false, false, '', '', null, null, -1);
        }
        plan.setCalculatingLeg(0);
        plan.setLateralLeg(0);
        plan.setVerticalLeg(0);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ALTN);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_ROUTE);
        plan.deleteUserData(BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN);
        // Just making sure that these plans still have their route key set
        if (planIndex === BoeingFms.RTE_1_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_1_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 1);
        }
        else if (planIndex === BoeingFms.RTE_2_INACTIVE_PLAN_INDEX || planIndex === BoeingFms.RTE_2_MOD_PLAN_INDEX) {
            plan.setUserData(BoeingFms.USER_DATA_KEY_ROUTE, 2);
        }
    }
    /**
     * Adds an airway and airway segment to the flight plan.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     */
    insertAirwaySegment(airway, entry, exit, segmentIndex, legIndex) {
        const plan = this.getPlanToModify();
        const airwaySegmentIndex = this.prepareAirwaySegment(`${airway.name}`, segmentIndex, legIndex);
        const airwayLegObject = this.buildAirwayLegs(airway, entry, exit);
        const airwayLegs = airwayLegObject.procedureLegs;
        for (let i = 1; i < airwayLegs.length; i++) {
            this.planAddLeg(airwaySegmentIndex, airwayLegs[i]);
        }
        // handle duplicates
        const airwaySegment = plan.getSegment(airwaySegmentIndex);
        const lastLeg = airwaySegment.legs[airwaySegment.legs.length - 1];
        const nextLeg = plan.getNextLeg(airwaySegmentIndex + 1, -1);
        if (lastLeg && nextLeg && this.isDuplicateLeg(lastLeg.leg, nextLeg.leg)) {
            const nextLegIndex = plan.getLegIndexFromLeg(nextLeg);
            const nextLegSegmentIndex = plan.getSegmentIndex(nextLegIndex);
            const nextLegSegment = plan.getSegment(nextLegSegmentIndex);
            if (this.getAirwayLegType(plan, nextLegSegmentIndex, nextLegIndex - nextLegSegment.offset) === AirwayLegType.ENTRY) {
                // the duplicated leg is an airway entry -> remove the segment containing it (the segment is guaranteed to
                // contain just the one leg)
                this.planRemoveSegment(nextLegSegmentIndex);
            }
            else {
                this.planRemoveDuplicateLeg(lastLeg, nextLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Prepares a new, empty airway segment in the primary flight plan which is ready to accept airway legs. Also
     * modifies the segment containing the entry leg, if necessary, either splitting it following the entry leg if it is
     * a non-airway enroute segment, or removing all legs following the entry leg if it is an airway segment. If the
     * entry leg is the last leg in its segment, a new non-airway enroute segment will be inserted after the entry leg
     * segment if the entry leg segment is the last segment in the flight plan or if the following segment is not an
     * enroute segment. If the entry leg is the entry for an existing airway segment, the existing airway segment will be
     * removed.
     * @param airwayName The name of the airway.
     * @param entrySegmentIndex The index of the segment containing the airway entry leg.
     * @param entrySegmentLegIndex The index of the airway entry leg in its segment.
     * @returns The index of the new airway segment.
     */
    prepareAirwaySegment(airwayName, entrySegmentIndex, entrySegmentLegIndex) {
        const plan = this.getPlanToModify();
        if (entrySegmentIndex < plan.directToData.segmentIndex
            || (entrySegmentIndex === plan.directToData.segmentIndex && entrySegmentLegIndex < plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
        }
        const entrySegment = plan.getSegment(entrySegmentIndex);
        const nextSegment = entrySegmentIndex + 1 < plan.segmentCount ? plan.getSegment(entrySegmentIndex + 1) : undefined;
        let airwaySegmentIndex = entrySegmentIndex + 1;
        let removeLegsSegmentIndex = -1;
        let removeLegsFromIndex = -1;
        if (entrySegment.airway !== undefined) {
            // the entry leg is within an existing airway segment -> remove all legs in the same segment after the entry leg
            removeLegsSegmentIndex = entrySegmentIndex;
            removeLegsFromIndex = entrySegmentLegIndex + 1;
        }
        else if (entrySegmentLegIndex === entrySegment.legs.length - 1 && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.airway) !== undefined) {
            // the entry leg is the entry leg for an existing airway segment -> remove all legs from the existing airway segment
            removeLegsSegmentIndex = entrySegmentIndex + 1;
            removeLegsFromIndex = 0;
        }
        // remove legs as required
        if (removeLegsSegmentIndex >= 0) {
            const removeLegsSegment = plan.getSegment(removeLegsSegmentIndex);
            if (this.getAirwayLegType(plan, removeLegsSegmentIndex, removeLegsSegment.legs.length - 1) === AirwayLegType.EXIT_ENTRY) {
                // preserve the airway entry leg
                const lastLeg = removeLegsSegment.legs[removeLegsSegment.legs.length - 1];
                this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, removeLegsSegmentIndex + 1);
                this.planAddLeg(removeLegsSegmentIndex + 1, lastLeg.leg, 0);
            }
            if (removeLegsFromIndex > 0) {
                while (removeLegsSegment.legs.length > removeLegsFromIndex) {
                    this.planRemoveLeg(removeLegsSegmentIndex, removeLegsSegment.legs.length - 1, true, true);
                }
            }
            else {
                this.planRemoveSegment(removeLegsSegmentIndex);
            }
        }
        if (entrySegment.legs.length - 1 > entrySegmentLegIndex) {
            // entry leg is not the last leg in its segment -> split the segment after the entry leg
            airwaySegmentIndex = this.splitSegment(plan, entrySegmentIndex, entrySegmentLegIndex);
        }
        else if (plan.getSegment(entrySegmentIndex).segmentType === FlightPlanSegmentType.Enroute
            && ((nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) !== FlightPlanSegmentType.Enroute)) {
            // entry leg is the last leg in its segment and the following segment doesn't exist or is not an enroute segment
            plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute);
        }
        plan.insertSegment(airwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
        return airwaySegmentIndex;
    }
    /**
     * Splits a segment into two segments if type is enroute; if departure, remove legs after the legIndex, else do nothing.
     * @param plan is the flight plan to edit.
     * @param segmentIndex Is the segment index for the entry leg.
     * @param legIndex Is the leg index of the entry leg in the segment of the
     * @returns the segment number of the new airway segment if one was created, else the current segment or if no action was taken.
     */
    splitSegment(plan, segmentIndex, legIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segment.segmentType === FlightPlanSegmentType.Enroute) {
            const nextSegmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
            // Move legs after leg index to new segment
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                const leg = segment.legs[i].leg;
                this.planAddLeg(nextSegmentIndex, leg);
                this.planRemoveLeg(segmentIndex, i);
            }
            return nextSegmentIndex;
        }
        else if (segment.segmentType === FlightPlanSegmentType.Departure) {
            // Remove legs after leg index
            // It's funky without the i++, but it works correctly because the length of the segment is changing
            for (let i = legIndex + 1; i < segment.legs.length;) {
                this.planRemoveLeg(segmentIndex, i);
            }
        }
        return segmentIndex;
    }
    /**
     * Builds a legs for an airway.
     * @param airway The airway object.
     * @param entry The entry intersection facility.
     * @param exit The exit intersection facility.
     * @returns the InsertProcedureObject.
     */
    buildAirwayLegs(airway, entry, exit) {
        const insertAirwayObject = { procedureLegs: [] };
        const waypoints = airway.waypoints;
        const entryIndex = waypoints.findIndex((w) => w.icao === entry.icao);
        const exitIndex = waypoints.findIndex((w) => w.icao === exit.icao);
        const ascending = exitIndex > entryIndex;
        if (ascending) {
            for (let i = entryIndex; i <= exitIndex; i++) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        else {
            for (let i = entryIndex; i >= exitIndex; i--) {
                const leg = FlightPlan.createLeg({
                    fixIcao: waypoints[i].icao,
                    type: i === entryIndex ? LegType.IF : LegType.TF
                });
                insertAirwayObject.procedureLegs.push(leg);
            }
        }
        return insertAirwayObject;
    }
    /**
     * Method to remove an airway from the flight plan.
     * @param segmentIndex is the segment index of the airway to remove.
     */
    removeAirway(segmentIndex) {
        const plan = this.getPlanToModify();
        let combineSegments = false;
        const segment = plan.getSegment(segmentIndex);
        const exitLeg = segment.legs[segment.legs.length - 1].leg;
        if (segmentIndex > 0) {
            const priorSegmentEnrouteNonAirway = plan.getSegment(segmentIndex - 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex - 1).airway === undefined;
            const nextSegmentEnrouteNonAirway = plan.getSegment(segmentIndex + 1).segmentType === FlightPlanSegmentType.Enroute
                && plan.getSegment(segmentIndex + 1).airway === undefined;
            if (priorSegmentEnrouteNonAirway && nextSegmentEnrouteNonAirway) {
                combineSegments = true;
            }
            // Add the exit leg as a direct in the prior segment if it is enroute and not an airway.
            if (priorSegmentEnrouteNonAirway) {
                this.planAddLeg(segmentIndex - 1, exitLeg);
            }
            // Remove the airway segment
            this.planRemoveSegment(segmentIndex);
            // If we have two adjacent enroute non-airway segments, merge them.
            if (combineSegments) {
                this.mergeSegments(plan, segmentIndex - 1);
            }
            // If we need to add a non-airway enroute segment
            if (!priorSegmentEnrouteNonAirway) {
                if (!nextSegmentEnrouteNonAirway) {
                    segmentIndex = this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex);
                }
                this.planAddLeg(segmentIndex, exitLeg);
            }
        }
        plan.calculate(0, true);
    }
    /**
     * Merges the legs of two consecutive segments into a single segment. All legs in the second segment are moved to the
     * first, and the second segment is removed from the flight plan.
     * @param plan The flight plan to modify.
     * @param segmentIndex The index of the first segment to merge.
     */
    mergeSegments(plan, segmentIndex) {
        const segmentToGrow = plan.getSegment(segmentIndex);
        const segmentToRemove = plan.getSegment(segmentIndex + 1);
        const segmentToGrowOrigLength = segmentToGrow.legs.length;
        segmentToRemove.legs.forEach((l) => {
            plan.addLeg(segmentIndex, l.leg, undefined, l.flags);
        });
        if (plan.directToData.segmentIndex === segmentIndex + 1) {
            plan.setDirectToData(segmentIndex, segmentToGrowOrigLength + plan.directToData.segmentLegIndex);
        }
        this.planRemoveSegment(segmentIndex + 1);
    }
    /**
     * Insert a hold into the flight plan.
     * @param globalLegIndex The global index of the parent leg.
     * @returns Whether the hold was inserted in the flight plan.
     * */
    createHold(globalLegIndex) {
        const plan = this.getPlanToModify();
        const parentLeg = plan.getLeg(globalLegIndex);
        const parentLegIndex = plan.getLegIndexFromLeg(parentLeg);
        const parentLegSegmentIndex = plan.getSegmentIndex(parentLegIndex);
        const parentLegSegment = plan.getSegment(parentLegSegmentIndex);
        let course = 100;
        if (parentLeg.calculated) {
            const trueCourse = FlightPathUtils.getLegFinalCourse(parentLeg.calculated);
            if (trueCourse !== undefined) {
                course = MagVar.trueToMagnetic(trueCourse, parentLeg.calculated.courseMagVar);
            }
        }
        const holdLeg = FlightPlan.createLeg({
            type: LegType.HM,
            fixIcao: parentLeg.leg.fixIcao,
            turnDirection: LegTurnDirection.Right,
            distanceMinutes: true,
            distance: 1,
            course,
        });
        return this.insertHold(parentLegSegmentIndex, parentLegIndex - parentLegSegment.offset, holdLeg);
    }
    /**
     * Inserts a hold-at-waypoint leg to the primary flight plan. The hold leg will be inserted immediately after the
     * specified parent leg. The hold leg must have the same fix as the parent leg.
     * @param segmentIndex The index of the segment that contains the hold's parent leg.
     * @param legIndex The index of the hold's parent leg in its segment.
     * @param holdLeg The hold leg to add.
     * @returns Whether the hold-at-waypoint leg was successfully inserted.
     */
    insertHold(segmentIndex, legIndex, holdLeg) {
        const plan = this.getPlanForFmcRender();
        if (!plan) {
            return false;
        }
        const modPlan = this.getPlanToModify();
        const prevLeg = modPlan.getPrevLeg(segmentIndex, legIndex + 1);
        if ((prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.fixIcao) !== holdLeg.fixIcao) {
            return false;
        }
        const nextLeg = modPlan.getNextLeg(segmentIndex, legIndex);
        // If we are editing a hold, delete the old leg.
        if (nextLeg && BoeingFmsUtils.isHoldAtLeg(nextLeg.leg.type) && nextLeg.leg.fixIcao === holdLeg.fixIcao) {
            const segment = modPlan.getSegmentFromLeg(nextLeg);
            segment && modPlan.removeLeg(segment.segmentIndex, segment.legs.indexOf(nextLeg));
        }
        this.planAddLeg(segmentIndex, holdLeg, legIndex + 1);
        return true;
    }
    /**
     * Inserts a PPOS hold as the active leg
     *
     * @param partial an object to modify the PPOS hold leg with, if applicable
     *
     * @returns whether the leg was inserted
     */
    insertPposHold(partial) {
        const activeLegIndex = this.getPlanForFmcRender().activeLateralLeg;
        const activeLeg = this.getPlanForFmcRender().tryGetLeg(activeLegIndex);
        let activeSegmentIndex = this.getPlanForFmcRender().getSegmentIndex(activeLegIndex);
        const plan = this.getPlanToModify();
        if (activeSegmentIndex === -1) {
            plan.addSegment(0, FlightPlanSegmentType.Enroute);
            activeSegmentIndex = 0;
        }
        const { lon, lat } = this.ppos;
        const magVar = MagVar.get(lat, lon);
        const insertAfterActive = activeLegIndex === 0;
        const activeLegSegment = plan.getSegment(activeSegmentIndex);
        let insertIndex = activeLegIndex - activeLegSegment.offset + (insertAfterActive ? 1 : 0);
        const parentLeg = FlightPlan.createLeg({ type: LegType.IF, fixIcao: 'W      PPOS', lat, lon });
        if (!activeLeg) {
            plan.addLeg(activeSegmentIndex, parentLeg);
            // There was no active leg, meaning an empty plan - we want to add at the end of the newly created segment
            insertIndex = undefined;
        }
        else {
            if (activeLeg.leg.type === LegType.HM && activeLeg.leg.fixIcao === ICAO.emptyIcao) {
                activeLegSegment && this.removeWaypoint(activeLegSegment.segmentIndex, activeLegIndex - activeLegSegment.offset);
            }
            else {
                plan.addLeg(activeSegmentIndex, parentLeg, insertIndex);
                insertIndex++;
            }
        }
        const pposHold = FlightPlan.createLeg(Object.assign({ type: LegType.HM, fixIcao: ICAO.emptyIcao, turnDirection: LegTurnDirection.Right, distanceMinutes: true, distance: 1, course: this.aircraftTrack ? this.aircraftTrack - magVar : 100, // I think the leg path builder adds magvar
            lat,
            lon }, partial !== null && partial !== void 0 ? partial : {}));
        let insertHoldLeg;
        try {
            // If the active leg is 0 (only airport or runway in the flight plan), we want to insert the hold after the active leg
            insertHoldLeg = plan.addLeg(activeSegmentIndex, pposHold, insertIndex);
        }
        catch (e) {
            console.error(e);
            return false;
        }
        plan.setLateralLeg(plan.getLegIndexFromLeg(insertHoldLeg));
        return true;
    }
    /**
     * Returns the index of the last element in the array where predicate is true, and -1
     * otherwise.
     * @param array The source array to search in
     * @param predicate find calls predicate once for each element of the array, in descending
     * order, until it finds one where predicate returns true. If such an element is found,
     * findLastIndex immediately returns that element index. Otherwise, findLastIndex returns -1.
     * @param defaultReturn is the default value
     * @returns either the index or the default if the predicate criteria is not met
     */
    findLastSegmentIndex(array, predicate, defaultReturn = -1) {
        let l = array.length;
        while (l--) {
            if (predicate(array[l], l, array)) {
                return array[l].segmentIndex;
            }
        }
        return defaultReturn;
    }
    /**
     * Method to insert a discontinuity in a provided plan at a specified position.
     * @param plan The FlightPlan to modify.
     * @param segmentIndex The segment index to insert the disco in.
     * @param segmentLegIndex The leg index to insert the disco at.
     */
    insertDiscontinuity(plan, segmentIndex, segmentLegIndex) {
        const segment = plan.getSegment(segmentIndex);
        if (segmentLegIndex === undefined) {
            segmentLegIndex = Math.max(0, segment.legs.length - 1);
        }
        const prevLeg = plan.getPrevLeg(segmentIndex, segmentLegIndex);
        const leg = plan.tryGetLeg(segmentIndex, segmentLegIndex);
        if ((prevLeg && prevLeg.leg.type === LegType.Discontinuity) || (leg && leg.leg.type === LegType.Discontinuity)) {
            return;
        }
        this.planAddLeg(segmentIndex, FlightPlan.createLeg({ type: LegType.Discontinuity }), segmentLegIndex);
    }
    /**
     * Adds a leg to the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param leg The leg to add to the plan.
     * @param index The index of the leg in the segment to insert. Will add to the end of the segment if ommitted.
     * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
     * @param notify Whether or not to send notifications after the operation.
     * @returns the {@link LegDefinition} that was added to the plan
     */
    planAddLeg(segmentIndex, leg, index, flags = 0, notify = true) {
        const plan = this.getPlanToModify();
        const dtoLegIndex = plan.directToData.segmentLegIndex;
        const dtoSegmentIndex = plan.directToData.segmentIndex;
        // TODO Removed the segmentIndex < dtoSegmentIndex from Garmin as it does not apply to WT21 (I think, but want to verify)
        // if (
        //   dtoSegmentIndex >= 0
        //   && (
        //     segmentIndex < dtoSegmentIndex
        //     || (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)
        //   )
        // ) {
        //   this.removeDirectToExisting(plan.planIndex);
        // }
        if (dtoSegmentIndex >= 0
            && (segmentIndex === dtoSegmentIndex && index !== undefined && index <= dtoLegIndex)) {
            this.removeDirectToExisting(plan.planIndex);
        }
        const segment = plan.getSegment(segmentIndex);
        const addIndex = index !== undefined ? index : Math.max(segment.legs.length - 1, 0);
        if (segment.segmentType === FlightPlanSegmentType.Approach
            && addIndex > 0
            && BitFlags.isAll(segment.legs[addIndex - 1].flags, LegDefinitionFlags.MissedApproach)) {
            flags |= LegDefinitionFlags.MissedApproach;
        }
        const legDefinition = plan.addLeg(segmentIndex, leg, index, flags, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (activeSegmentIndex !== -1) {
            const activeLegIndex = plan.activeLateralLeg - plan.getSegment(activeSegmentIndex).offset;
            if (segmentIndex < activeSegmentIndex || (index && segmentIndex == activeSegmentIndex && index < activeLegIndex)) {
                const newActiveLegIndex = plan.activeLateralLeg + 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        else {
            console.error('planAddLeg: activeSegmentIndex was -1');
        }
        return legDefinition;
    }
    /**
     * Removes a leg from the flight plan.
     * @param segmentIndex The segment to add the leg to.
     * @param segmentLegIndex The index of the leg in the segment to remove.
     * @param notify Whether or not to send notifications after the operation. True by default.
     * @param skipDupCheck Whether to skip checking for duplicates. False by default.
     * @param skipCancelDirectTo Whether to skip canceling a direct to existing if the removed leg is equal to or is
     * located before the direct to target. False by default.
     * @returns whether a leg was removed.
     */
    planRemoveLeg(segmentIndex, segmentLegIndex, notify = true, skipDupCheck = false, skipCancelDirectTo = false) {
        let plan = this.getPlanForFmcRender();
        if (segmentIndex < 0 || segmentIndex >= plan.segmentCount) {
            return false;
        }
        const toRemoveLeg = plan.getSegment(segmentIndex).legs[segmentLegIndex];
        if (!toRemoveLeg) {
            return false;
        }
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        this.getDirectToState() === DirectToState.TOEXISTING;
        plan = this.getPlanToModify();
        let removed = false;
        const airwayLegType = this.getAirwayLegType(plan, segmentIndex, segmentLegIndex);
        if (airwayLegType !== AirwayLegType.NONE) {
            removed = this.removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex);
        }
        else {
            removed = plan.removeLeg(segmentIndex, segmentLegIndex, notify) !== null;
            if (!removed) {
                return false;
            }
            const dtoLegIndex = plan.directToData.segmentLegIndex;
            const dtoSegmentIndex = plan.directToData.segmentIndex;
            if (!skipCancelDirectTo
                && dtoSegmentIndex >= 0
                && (segmentIndex < dtoSegmentIndex
                    || (segmentIndex === dtoSegmentIndex && segmentLegIndex <= dtoLegIndex))) {
                // Need to adjust direct to data to compensate for removed leg.
                if (segmentIndex === dtoSegmentIndex) {
                    plan.directToData.segmentLegIndex--;
                }
                // if (isDirectToExistingActive && segmentIndex === dtoSegmentIndex && segmentLegIndex === dtoLegIndex) {
                // Create a DTO random to replace the canceled DTO existing if we are directly removing the target leg of the DTO existing.
                //   const directIcao = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex + 3].leg.fixIcao;
                //   this.createDirectToRandom(directIcao);
                // }
                this.removeDirectToExisting(plan.planIndex, plan.activeLateralLeg - 1);
            }
            else if (removeLegGlobalIndex < plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        const prevLeg = removeLegGlobalIndex - 1 >= 0 ? plan.getLeg(removeLegGlobalIndex - 1) : null;
        const nextLeg = removeLegGlobalIndex < plan.length ? plan.getLeg(removeLegGlobalIndex) : null;
        // Detect if we have created consecutive duplicate legs. If we have, we need to delete one of them.
        if (!skipDupCheck && prevLeg && nextLeg && this.isDuplicateLeg(prevLeg.leg, nextLeg.leg)) {
            this.planRemoveDuplicateLeg(prevLeg, nextLeg);
        }
        if (!skipDupCheck) {
            this.checkAndRemoveEmptySegment(plan, segmentIndex);
        }
        plan.calculate(plan.activeLateralLeg - 1);
        return true;
    }
    /**
     * Method to handle a remove leg request t.
     * @param plan is the flight plan.
     * @param airwayLegType is the airwayLegType returned from the checkIfAirwayLeg method.
     * @param segmentIndex The segment we are removing from.
     * @param segmentLegIndex is the leg index in the segment we are removing.
     * @returns whether this handler processed the remove request.
     */
    removeLegAirwayHandler(plan, airwayLegType, segmentIndex, segmentLegIndex) {
        var _a, _b;
        const removeLegGlobalIndex = plan.getSegment(segmentIndex).offset + segmentLegIndex;
        let removed = false;
        let needReconcileDto = plan.directToData.segmentIndex >= 0;
        if (segmentIndex < plan.directToData.segmentIndex
            || (segmentIndex === plan.directToData.segmentIndex && segmentLegIndex <= plan.directToData.segmentLegIndex)) {
            this.removeDirectToExisting();
            needReconcileDto = false;
        }
        switch (airwayLegType) {
            case AirwayLegType.ONROUTE: {
                const segment = plan.getSegment(segmentIndex);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex > 0) {
                    // Need to rename the airway segment with the new exit (if we removed the first leg after the entry, the
                    // airway segment will be deleted so no need to bother)
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    plan.setAirway(segmentIndex, segment.airway.replace(/\..*/, `.${segment.legs[segmentLegIndex - 1].name}`));
                }
                // We need to move the leg immediately after the removed leg to the next enroute segment
                // (if the next enroute segment does not exist we will create one)
                if (plan.segmentCount <= segmentIndex + 1 || plan.getSegment(segmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                }
                const legAfterRemoved = segment.legs[segmentLegIndex].leg;
                plan.addLeg(segmentIndex + 1, legAfterRemoved, 0);
                plan.removeLeg(segmentIndex, segmentLegIndex);
                if (segmentLegIndex < segment.legs.length) {
                    // There is at least one more leg in the original airway segment after the one we moved to the next enroute
                    // segment -> move these remaining legs into a new airway segment
                    const newEntrySegment = plan.getSegment(segmentIndex + 1);
                    let newAirwaySegmentIndex = segmentIndex + 2;
                    if (newEntrySegment.legs.length > 1) {
                        // need to split the segment containing the entry leg of the new airway segment
                        newAirwaySegmentIndex = this.splitSegment(plan, segmentIndex + 1, 0);
                    }
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    const airwayName = segment.airway.replace(/\..*/, `.${segment.legs[segment.legs.length - 1].name}`);
                    plan.insertSegment(newAirwaySegmentIndex, FlightPlanSegmentType.Enroute, airwayName);
                    while (segment.legs.length > segmentLegIndex) {
                        const leg = segment.legs[segmentLegIndex].leg;
                        plan.removeLeg(segmentIndex, segmentLegIndex);
                        plan.addLeg(newAirwaySegmentIndex, leg);
                    }
                    // If the newly added airway segment is the last enroute segment, we need to insert an empty enroute segment
                    // after it to ensure that the last enroute segment in the plan is not an airway segment
                    if (newAirwaySegmentIndex >= plan.segmentCount - 1 || plan.getSegment(newAirwaySegmentIndex + 1).segmentType !== FlightPlanSegmentType.Enroute) {
                        plan.insertSegment(newAirwaySegmentIndex + 1, FlightPlanSegmentType.Enroute);
                    }
                }
                removed = true;
                break;
            }
            case AirwayLegType.ENTRY: {
                if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Enroute) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into the previous enroute segment to serve as the new entry leg.
                    const segment = plan.getSegment(segmentIndex + 1);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 1, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 1);
                    this.planAddLeg(segmentIndex, leg);
                }
                else if (plan.getSegment(segmentIndex).segmentType === FlightPlanSegmentType.Departure) {
                    // We need to remove the entry leg, then move the first leg in the airway segment out of the airway segment
                    // and into a newly created enroute segment placed before the airway segment to serve as the new entry leg.
                    this.planInsertSegmentOfType(FlightPlanSegmentType.Enroute, segmentIndex + 1);
                    const segment = plan.getSegment(segmentIndex + 2);
                    const leg = segment.legs[0].leg;
                    plan.removeLeg(segmentIndex + 2, 0);
                    this.checkAndRemoveEmptySegment(plan, segmentIndex + 2);
                    this.planAddLeg(segmentIndex + 1, leg, 0);
                }
                removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                break;
            }
            case AirwayLegType.EXIT: {
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the airway segment, so just delete the segment.
                    this.removeAirway(segmentIndex);
                    return true;
                }
                else {
                    // Remove the leg, then change the name of the airway segment to reflect the new exit waypoint.
                    const segment = plan.getSegment(segmentIndex);
                    const airway = (_a = segment.airway) === null || _a === void 0 ? void 0 : _a.split('.');
                    segment.airway = airway && airway[0] ? airway[0] + '.' + segment.legs[segmentLegIndex - 1].name : segment.airway;
                    plan.setAirway(segmentIndex, segment.airway);
                    removed = plan.removeLeg(segmentIndex, segmentLegIndex) !== null;
                }
                break;
            }
            case AirwayLegType.EXIT_ENTRY: {
                // We need to move the first leg in the next airway segment out of that segment and into an enroute segment
                // before the next airway segment.
                const segment = plan.getSegment(segmentIndex + 1);
                const leg = segment.legs[0].leg;
                plan.removeLeg(segmentIndex + 1, 0);
                if (segmentLegIndex < 1) {
                    // We are removing the only leg in the first airway segment, so just remove the segment.
                    plan.removeSegment(segmentIndex);
                    let prevSegmentIndex = segmentIndex - 1;
                    const prevSegment = plan.getSegment(prevSegmentIndex);
                    if (prevSegment.segmentType !== FlightPlanSegmentType.Enroute || prevSegment.airway !== undefined) {
                        plan.insertSegment(segmentIndex, FlightPlanSegmentType.Enroute);
                        prevSegmentIndex = segmentIndex;
                    }
                    plan.addLeg(prevSegmentIndex, leg);
                }
                else {
                    // Remove the leg from the first airway segment, then change the name of the airway segment to reflect the
                    // new exit waypoint.
                    plan.removeLeg(segmentIndex, segmentLegIndex);
                    plan.insertSegment(segmentIndex + 1, FlightPlanSegmentType.Enroute);
                    plan.addLeg(segmentIndex + 1, leg);
                    const firstAirwaySegment = plan.getSegment(segmentIndex);
                    const airway = (_b = firstAirwaySegment.airway) === null || _b === void 0 ? void 0 : _b.split('.');
                    firstAirwaySegment.airway = airway && airway[0] ? airway[0] + '.' + firstAirwaySegment.legs[segmentLegIndex - 1].name : firstAirwaySegment.airway;
                    plan.setAirway(segmentIndex, firstAirwaySegment.airway);
                }
                removed = true;
            }
        }
        if (removed) {
            if (needReconcileDto) {
                BoeingFmsUtils.reconcileDirectToData(plan);
            }
            if (removeLegGlobalIndex <= plan.activeLateralLeg || plan.activeLateralLeg >= plan.length) {
                const newActiveLegIndex = plan.activeLateralLeg - 1;
                plan.setCalculatingLeg(newActiveLegIndex);
                plan.setLateralLeg(newActiveLegIndex);
            }
        }
        return removed;
    }
    /**
     * Checks if a flight plan segment is empty, and removes the segment if it is eligible to be removed. Only Enroute
     * segments that are followed by another Enroute segment are eligible to be removed if empty.
     * @param plan A flight plan.
     * @param segmentIndex The index of the segment to check.
     * @returns Whether the segment was removed.
     */
    checkAndRemoveEmptySegment(plan, segmentIndex) {
        if (this.checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex)) {
            this.planRemoveSegment(segmentIndex);
            const prevSegmentIndex = segmentIndex - 1;
            const nextSegmentIndex = segmentIndex;
            const prevSegment = prevSegmentIndex >= 0 ? plan.getSegment(prevSegmentIndex) : undefined;
            const nextSegment = nextSegmentIndex < plan.segmentCount ? plan.getSegment(nextSegmentIndex) : undefined;
            if ((prevSegment === null || prevSegment === void 0 ? void 0 : prevSegment.segmentType) === FlightPlanSegmentType.Enroute
                && prevSegment.airway === undefined
                && (nextSegment === null || nextSegment === void 0 ? void 0 : nextSegment.segmentType) === FlightPlanSegmentType.Enroute
                && nextSegment.airway === undefined) {
                // We are left with two consecutive non-airway enroute segments -> merge the two
                this.mergeSegments(plan, prevSegmentIndex);
            }
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Checks if a remove left an empty segment that also needs to be removed.
     * @param plan is the flight plan
     * @param segmentIndex The segment to add the leg to.
     * @returns whether to remove the segment.
     */
    checkIfRemoveLeftEmptySegmentToDelete(plan, segmentIndex) {
        const segment = plan.getSegment(segmentIndex);
        let nextSegment;
        if (segmentIndex < plan.segmentCount - 1) {
            nextSegment = plan.getSegment(segmentIndex + 1);
        }
        if (segment.legs.length < 1) {
            switch (segment.segmentType) {
                case FlightPlanSegmentType.Enroute:
                    {
                        if (nextSegment && nextSegment.segmentType === FlightPlanSegmentType.Enroute) {
                            return true;
                        }
                        const priorSegment = plan.getSegment(segmentIndex - 1);
                        if (priorSegment.segmentType === FlightPlanSegmentType.Approach || priorSegment.segmentType === FlightPlanSegmentType.Arrival) {
                            return true;
                        }
                    }
                    break;
                //TODO: Add more cases as appropriate
            }
        }
        return false;
    }
    /**
     * Adds an appropriate origin or destination leg (either an airport or runway fix) to the primary flight plan. Origin
     * legs are added to the beginning of the specified segment. Destination legs are added to the end of the specified
     * segment.
     * @param isOrigin Whether to add an origin leg.
     * @param segmentIndex The index of the segment to which to add the leg.
     * @param airport The origin airport.
     * @param runway The origin runway.
     */
    planAddOriginDestinationLeg(isOrigin, segmentIndex, airport, runway) {
        let leg;
        if (runway) {
            leg = BoeingFmsUtils.buildRunwayLeg(airport, runway, isOrigin);
        }
        else {
            leg = FlightPlan.createLeg({
                lat: airport.lat,
                lon: airport.lon,
                type: isOrigin ? LegType.IF : LegType.TF,
                fixIcao: airport.icao,
                altitude1: airport.runways[0].elevation + UnitType.FOOT.convertTo(50, UnitType.METER)
            });
        }
        if (leg) {
            this.planAddLeg(segmentIndex, leg, isOrigin ? 0 : undefined);
            if (!isOrigin) {
                const plan = this.getPlanToModify();
                const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
                const lastEnrouteSegment = plan.getSegment(lastEnrouteSegmentIndex);
                for (let i = lastEnrouteSegment.legs.length - 1; i >= 0; i--) {
                    if (lastEnrouteSegment.legs[i].leg.fixIcao === airport.icao) {
                        this.planRemoveLeg(lastEnrouteSegmentIndex, i, true, true);
                    }
                }
            }
        }
    }
    /**
     * Method to add a segment to the flightplan.
     * @param segmentType is the FlightPlanSegmentType.
     * @param index is the optional segment index to insert the segment.
     * @returns the segment index of the inserted segment.
     */
    planInsertSegmentOfType(segmentType, index) {
        const plan = this.getPlanToModify();
        let segmentIndex = -1;
        if (index) {
            segmentIndex = index - 1;
        }
        else {
            const segments = [];
            for (const segment of plan.segments()) {
                segments.push(segment);
            }
            switch (segmentType) {
                case FlightPlanSegmentType.Origin:
                    break;
                case FlightPlanSegmentType.Departure:
                    segmentIndex = 0;
                    break;
                case FlightPlanSegmentType.Arrival:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Approach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival;
                    }, 2);
                    break;
                case FlightPlanSegmentType.MissedApproach:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Approach;
                    }, 2);
                    break;
                case FlightPlanSegmentType.Destination:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach;
                    }, 5);
                    break;
                default:
                    segmentIndex = this.findLastSegmentIndex(segments, (v) => {
                        return v.segmentType === FlightPlanSegmentType.Enroute || v.segmentType === FlightPlanSegmentType.Arrival
                            || v.segmentType === FlightPlanSegmentType.Approach || v.segmentType === FlightPlanSegmentType.Destination;
                    }, 1);
                    segmentIndex--;
                    break;
            }
        }
        return this.planInsertSegment(segmentIndex + 1, segmentType).segmentIndex;
    }
    /**
     * Method to remove all legs from a segment.
     * @param segmentIndex is the index of the segment to delete all legs from.
     * @param segmentType is the type if segment to delete all legs from, if known.
     */
    planClearSegment(segmentIndex, segmentType) {
        this.planRemoveSegment(segmentIndex);
        this.planInsertSegment(segmentIndex, segmentType);
    }
    /**
     * Inserts a segment into the flight plan at the specified index and
     * reflows the subsequent segments.
     * @param segmentIndex The index to insert the flight plan segment.
     * @param segmentType The type of segment this will be.
     * @param airway The airway this segment is made up of, if any
     * @param notify Whether or not to send notifications after the operation.
     * @returns The new flight plan segment.
     */
    planInsertSegment(segmentIndex, segmentType = FlightPlanSegmentType.Enroute, airway, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.insertSegment(segmentIndex, segmentType, airway, notify);
        plan.calculate(plan.activeLateralLeg - 1);
        if (plan.directToData.segmentIndex >= 0 && segmentIndex <= plan.directToData.segmentIndex) {
            plan.setDirectToData(plan.directToData.segmentIndex + 1, plan.directToData.segmentLegIndex);
        }
        return segment;
    }
    /**
     * Removes a segment from the flight plan and reflows the segments following
     * the removed segment, not leaving an empty segment at the specified index.
     * @param segmentIndex The index of the segment to remove.
     * @param notify Whether or not to send notifications after the operation.
     */
    planRemoveSegment(segmentIndex, notify = true) {
        const plan = this.getPlanToModify();
        const segment = plan.getSegment(segmentIndex);
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const activeSegmentIndex = plan.getSegmentIndex(plan.activeLateralLeg);
        if (plan.directToData.segmentIndex >= 0) {
            if (segmentIndex < plan.directToData.segmentIndex) {
                plan.setDirectToData(plan.directToData.segmentIndex - 1, plan.directToData.segmentLegIndex);
            }
            else if (segmentIndex === plan.directToData.segmentIndex) {
                plan.setDirectToData(-1);
            }
        }
        // If the segment we are trying to delete is the active one,
        // then we need to do something to preserve the active legs so they aren't deleted.
        // We only need to do this for the Enroute segment, because if other segments are getting deleted,
        // their functions are already handling this.
        if (activeSegmentIndex === segmentIndex && !Simplane.getIsGrounded() && plan.length > 1 && segment.segmentType === FlightPlanSegmentType.Enroute) {
            // I think this block of code is only supposed to run when called from the cleanupLegsAfterApproach() function
            const currentToLeg = plan.getLeg(plan.activeLateralLeg);
            const currentFromLeg = plan.getLeg(plan.activeLateralLeg - 1);
            const newToLeg = Object.assign({}, currentToLeg.leg);
            const newFromLeg = Object.assign({}, currentFromLeg.leg);
            const lastEnrouteSegmentIndex = this.findLastEnrouteSegmentIndex(plan);
            if (BitFlags.isAll(currentToLeg.flags, LegDefinitionFlags.DirectTo)) {
                const discoLeg = Object.assign({}, plan.getLeg(plan.activeLateralLeg - 2).leg);
                plan.addLeg(lastEnrouteSegmentIndex, discoLeg, undefined, LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined, LegDefinitionFlags.DirectTo);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
            }
            else {
                plan.addLeg(lastEnrouteSegmentIndex, newFromLeg, undefined);
                plan.addLeg(lastEnrouteSegmentIndex, newToLeg, undefined);
            }
            const newSegment = plan.getSegment(lastEnrouteSegmentIndex);
            const newActiveLegIndex = newSegment.offset + newSegment.legs.length - 1;
            plan.setCalculatingLeg(newActiveLegIndex - 2);
            plan.setLateralLeg(newActiveLegIndex);
        }
        else {
            const newActiveLegIndex = plan.activeLateralLeg - Utils.Clamp(plan.activeLateralLeg - segment.offset, 0, segment.legs.length);
            plan.setCalculatingLeg(newActiveLegIndex);
            plan.setLateralLeg(newActiveLegIndex);
        }
        plan.removeSegment(segmentIndex, notify);
        plan.calculate(plan.activeLateralLeg - 1);
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is a duplicate of the first. The second leg is
     * considered a duplicate if and only if it is an IF, TF, or DF leg with the same terminator fix as the first leg,
     * which is also an IF, TF, or DF leg.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is a duplicate of the first.
     */
    isDuplicateLeg(leg1, leg2) {
        if (leg1.type === LegType.Discontinuity && leg2.type === LegType.Discontinuity) {
            return true;
        }
        if (leg2.type !== LegType.IF
            && leg2.type !== LegType.DF
            && leg2.type !== LegType.TF
            && leg2.type !== LegType.CF) {
            return false;
        }
        return (leg1.type === LegType.IF
            || leg1.type === LegType.TF
            || leg1.type === LegType.DF
            || leg1.type === LegType.CF)
            && leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Checks whether of two consecutive flight plan legs, the second is an IF leg and is a duplicate of the first. The
     * IF leg is considered a duplicate if and only if its fix is the same as the fix at which the first leg terminates.
     * @param leg1 The first leg.
     * @param leg2 The second leg.
     * @returns whether the second leg is an duplicate IF leg of the first.
     */
    isDuplicateIFLeg(leg1, leg2) {
        if (leg2.type !== LegType.IF) {
            return false;
        }
        if (leg1.type !== LegType.TF
            && leg1.type !== LegType.DF
            && leg1.type !== LegType.RF
            && leg1.type !== LegType.CF
            && leg1.type !== LegType.AF
            && leg1.type !== LegType.IF) {
            return false;
        }
        return leg1.fixIcao === leg2.fixIcao;
    }
    /**
     * Merges two duplicate legs such that the new merged leg contains the fix type and altitude data from the source leg
     * and all other data is derived from the target leg.
     * @param target The target leg.
     * @param source The source leg.
     * @returns the merged leg.
     */
    mergeDuplicateLegData(target, source) {
        const merged = FlightPlan.createLeg(target);
        merged.fixTypeFlags |= source.fixTypeFlags;
        merged.altDesc = source.altDesc;
        merged.altitude1 = source.altitude1;
        merged.altitude2 = source.altitude2;
        merged.speedRestriction = source.speedRestriction;
        return merged;
    }
    /**
     * Deletes one of two consecutive duplicate legs. If one leg is in a procedure and the other is not, the leg that is
     * a procedure will be deleted. If the legs are in different procedures, the earlier leg will be deleted.
     * Otherwise, the later leg will be deleted. If the deleted leg is the target leg of a direct to, the legs in the
     * direct to sequence will be copied and moved to immediately follow the duplicate leg that was not deleted.
     * @param leg1 The first duplicate leg.
     * @param leg2 The second duplicate leg.
     * @returns the leg that was deleted, or null if neither leg was deleted.
     * @throws Error if direct to legs could not be updated.
     */
    planRemoveDuplicateLeg(leg1, leg2) {
        const plan = this.getPlanToModify();
        const leg1Segment = plan.getSegmentFromLeg(leg1);
        const leg2Segment = plan.getSegmentFromLeg(leg2);
        const leg1GlobalIndex = plan.getLegIndexFromLeg(leg1);
        const leg2GlobalIndex = plan.getLegIndexFromLeg(leg2);
        if (!leg1Segment || !leg2Segment) {
            return null;
        }
        const isLeg1DirectToLeg = BitFlags.isAll(leg1.flags, LegDefinitionFlags.DirectTo);
        const isLeg2DirectToLeg = BitFlags.isAll(leg2.flags, LegDefinitionFlags.DirectTo);
        const dupDirectToLeg = isLeg1DirectToLeg ? leg1
            : isLeg2DirectToLeg ? leg2
                : null;
        if (dupDirectToLeg) {
            if (dupDirectToLeg.leg.type === LegType.IF) {
                // Technically this should never happen.
                return null;
            }
            else {
                // If one of the duplicates is the second leg in a direct to sequence, then the true duplicated leg is the
                // target leg of the DTO. In this case, we call this method with the DTO target leg replacing the DTO leg.
                const dtoTargetLeg = plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
                return isLeg1DirectToLeg ? this.planRemoveDuplicateLeg(dtoTargetLeg, leg2) : this.planRemoveDuplicateLeg(leg1, dtoTargetLeg);
            }
        }
        const isLeg1InProc = leg1Segment.segmentType !== FlightPlanSegmentType.Enroute;
        const isLeg2InProc = leg2Segment.segmentType !== FlightPlanSegmentType.Enroute;
        let toDeleteSegment;
        let toDeleteIndex;
        let toDeleteLeg;
        // TODO Probably shouldn't modify the LegDefinition like this,
        // TODO because events won't fire and things won't know that it changed.
        // If leg1 is in a procedure, and leg2 not, we want to delete leg1 because when reloading that procedure, it will
        // come back - unlike leg2, which is in the enroute, and would not be reloaded.
        // The opposite is true if leg1 is not, and leg2 is in a procedure.
        if (isLeg1InProc && !isLeg2InProc) {
            // Leg1 in proc + Leg2 not in proc - take data from Leg1
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1GlobalIndex - leg1Segment.offset;
            leg2.leg = this.mergeDuplicateLegData(leg2.leg, leg1.leg);
            toDeleteLeg = leg1;
        }
        else if (isLeg1InProc && isLeg2InProc) {
            // Leg1 in proc + Leg2 in proc - leave Leg2 alone
            toDeleteSegment = leg1Segment;
            toDeleteIndex = leg1GlobalIndex - leg1Segment.offset;
            toDeleteLeg = leg1;
        }
        else {
            // Leg1 not in proc + Leg2 in proc - take data from Leg2
            toDeleteSegment = leg2Segment;
            toDeleteIndex = leg2GlobalIndex - leg2Segment.offset;
            leg1.leg = this.mergeDuplicateLegData(leg1.leg, leg2.leg);
            toDeleteLeg = leg2;
        }
        // If the kept leg is not in a procedure, we need to manually generate the leg vertical data, as we won't get to it when doing it for
        // the procedure segments later
        if (isLeg1InProc !== isLeg2InProc) {
            const keptLeg = toDeleteLeg === leg1 ? leg2 : leg1;
            const keptLegSegment = toDeleteLeg === leg1 ? leg2Segment : leg1Segment;
            const forceVerticalFlightPhase = (toDeleteSegment.segmentType === FlightPlanSegmentType.Departure || BitFlags.isAll(keptLeg.flags, LegDefinitionFlags.MissedApproach))
                ? VerticalFlightPhase.Climb
                : VerticalFlightPhase.Descent;
            this.generateLegVerticalData(plan, keptLegSegment.segmentIndex, (toDeleteLeg === leg1 ? leg2GlobalIndex : leg1GlobalIndex) - keptLegSegment.offset, forceVerticalFlightPhase);
        }
        if (toDeleteIndex >= 0) {
            const dtoTargetLeg = plan.directToData.segmentIndex < 0 ? null : plan.getSegment(plan.directToData.segmentIndex).legs[plan.directToData.segmentLegIndex];
            const needMoveDtoLegs = toDeleteLeg === dtoTargetLeg;
            if (needMoveDtoLegs) {
                const isDtoExistingActive = this.getDirectToState() === DirectToState.TOEXISTING;
                // If the removed leg was the target leg of a DTO existing, we need to shift the DTO legs to target the leg
                // that was not removed.
                const oldDiscoLeg = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg1 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                const oldDtoLeg2 = plan.removeLeg(plan.directToData.segmentIndex, plan.directToData.segmentLegIndex + 1);
                if (!oldDtoLeg1 || !oldDtoLeg2 || !oldDiscoLeg) {
                    throw new Error(`Fms: Could not remove direct to legs starting at segment index ${plan.directToData.segmentIndex}, leg index ${plan.directToData.segmentLegIndex} during duplicate leg resolution.`);
                }
                const preservedLeg = toDeleteLeg === leg1 ? leg2 : leg1;
                const preservedLegIndex = plan.getLegIndexFromLeg(preservedLeg);
                const newTargetSegmentIndex = plan.getSegmentIndex(preservedLegIndex);
                const newTargetSegmentLegIndex = preservedLegIndex - plan.getSegment(newTargetSegmentIndex).offset;
                plan.setDirectToData(newTargetSegmentIndex, newTargetSegmentLegIndex);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDiscoLeg.leg), newTargetSegmentLegIndex + 1, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg1.leg), newTargetSegmentLegIndex + 2, LegDefinitionFlags.DirectTo);
                plan.addLeg(newTargetSegmentIndex, FlightPlan.createLeg(oldDtoLeg2.leg), newTargetSegmentLegIndex + 3, LegDefinitionFlags.DirectTo | BoeingExtraLegDefinitionFlags.DirectToTarget);
                if (isDtoExistingActive) {
                    plan.setLateralLeg(preservedLegIndex + 3);
                }
            }
            const success = this.planRemoveLeg(toDeleteSegment.segmentIndex, toDeleteIndex, true, false, needMoveDtoLegs);
            if (success) {
                return toDeleteLeg;
            }
        }
        return null;
    }
    /**
     * Resets the subject to force a cross-instrument notification.
     */
    forceNotifyApproachFrequency() {
        const approachFrequency = this.approachFrequency.get();
        this.approachFrequency.set(undefined);
        this.approachFrequency.set(approachFrequency);
    }
    /**
     * Sets the approach details for the loaded approach and sends an event across the bus.
     * @param approachLoaded Whether an approach is loaded.
     * @param approachType The approach type.
     * @param approachRnavType The approach RNAV type.
     * @param approachIsActive Whether the approach is active.
     * @param approachIsCircling Whether the approach is a circling approach.
     * @param approachName The name of the approach.
     * @param approachRunway The runway associated with the approach
     * @param missedApproachFacility Missed Approach Point facility for the approach
     * @param referenceFacility The reference navaid for the approach
     * @param finalApproachCourse The final approach course (-1 is invalid)
     * @todo This data is currently set with any flightplan approach edits and isn't aware of mod plan, secondary plan etc.
     * If an edit is cancelled it will retain the previously edited data. It **does not** reflect the active flightplan state.
     */
    setApproachDetails(approachLoaded, approachType, approachRnavType, approachIsActive, approachIsCircling, approachName, approachRunway, missedApproachFacility, referenceFacility, finalApproachCourse) {
        // reduce the MAP facility down to the basic facility fields for syncing on the bus
        const baseMissedApproachFacility = missedApproachFacility ? BoeingFmsUtils.getBaseFacility(missedApproachFacility) : missedApproachFacility;
        const approachDetails = {
            approachLoaded: approachLoaded !== undefined ? approachLoaded : this.approachDetails.approachLoaded,
            approachType: approachType !== undefined ? approachType : this.approachDetails.approachType,
            approachRnavType: approachRnavType !== undefined ? approachRnavType : this.approachDetails.approachRnavType,
            approachIsActive: approachIsActive !== undefined ? approachIsActive : this.approachDetails.approachIsActive,
            approachIsCircling: approachIsCircling !== undefined ? approachIsCircling : this.approachDetails.approachIsCircling,
            approachName: approachName !== undefined ? approachName : this.approachDetails.approachName,
            approachRunway: approachRunway !== undefined ? approachRunway : this.approachDetails.approachRunway,
            missedApproachFacility: baseMissedApproachFacility !== undefined ? baseMissedApproachFacility : this.approachDetails.missedApproachFacility,
            referenceFacility: referenceFacility !== undefined ? referenceFacility : this.approachDetails.referenceFacility,
            finalApproachCourse: finalApproachCourse !== undefined ? finalApproachCourse : this.approachDetails.finalApproachCourse,
        };
        if (approachDetails.approachIsActive && !approachDetails.approachLoaded) {
            this.checkApproachState();
            return;
        }
        if (approachDetails !== this.approachDetails) {
            this.approachDetails = approachDetails;
            this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
            this.bus.getPublisher().pub('approach_available', approachDetails.approachIsActive && approachDetails.approachLoaded, true);
            // this.bus.getPublisher<WT21VNavDataEvents>().pub('approach_supports_gp', this.doesApproachSupportGp(), true);
        }
    }
    /** Set edited approach details for the active flight plan (on exec) */
    syncApproachDetailsToActive() {
        this.activeApproachDetails = Object.assign({}, this.approachDetails);
        this.bus.getPublisher().pub('active_approach_details_set', this.activeApproachDetails, true);
    }
    /** Set approach details from the active flight plan (on cancel/erase of mod plan) */
    syncApproachDetailsFromActive() {
        this.approachDetails = Object.assign({}, this.activeApproachDetails);
        this.bus.getPublisher().pub('approach_details_set', this.approachDetails, true);
    }
    /**
     * Checks whether the approach details indicate that vertical guidance (GP) can be supported.
     * @returns whether or not vertical guidance is supported.
     */
    doesApproachSupportGp() {
        if (this.approachDetails.approachLoaded && this.approachDetails.approachIsActive && !this.approachDetails.approachIsCircling) {
            switch (this.approachDetails.approachType) {
                case ApproachType.APPROACH_TYPE_GPS:
                case ApproachType.APPROACH_TYPE_RNAV:
                case AdditionalApproachType.APPROACH_TYPE_VISUAL:
                    return true;
            }
        }
        return false;
    }
    /**
     * Checks if an RNAV approach can be activated in the AP.
     * @param cdiScaling The current CDI Scaling Label
     * @returns Whether approach can activate.
     */
    canApproachActivate(cdiScaling = this.cdiScaleLabel.get()) {
        const apprModeAvailable = cdiScaling === CDIScaleLabel.Terminal || cdiScaling === CDIScaleLabel.TerminalArrival || cdiScaling === CDIScaleLabel.Approach;
        return this.approachDetails.approachLoaded && apprModeAvailable;
    }
    /** Check if the tuned ILS frequency and course match the selected approach */
    checkTunedIlsMismatch() {
        var _a, _b, _c, _d;
        // we need to consider HUD takeoff as it also uses the approach reference data block
        const hudRunway = this.onGround.get() && this.operatingPhase.get() <= FmsOperatingPhase.TAKEOFF ? this.getFlightPlanHudTakeoff(BoeingFms.ACT_RTE_PLAN_INDEX) : undefined;
        if (hudRunway && hudRunway.ilsFrequency) {
            this.approachFrequencyMismatch.set(!!(hudRunway.ilsFrequency.freqMHz)
                && !BoeingFmsUtils.vhfFrequenciesEqual(hudRunway.ilsFrequency.freqMHz, (_a = this.tunedIlsFrequency) !== null && _a !== void 0 ? _a : -1));
            this.approachCourseMismatch.set(hudRunway.ilsFrequency.localizerCourse >= 0
                && Math.round(hudRunway.ilsFrequency.localizerCourse) !== Math.round((_b = this.tunedIlsCourse) !== null && _b !== void 0 ? _b : -1));
        }
        else {
            // consider approach
            this.approachFrequencyMismatch.set(!!(this.activeApproachDetails.referenceFacility)
                && !BoeingFmsUtils.vhfFrequenciesEqual(this.activeApproachDetails.referenceFacility.freqMHz, (_c = this.tunedIlsFrequency) !== null && _c !== void 0 ? _c : -1));
            this.approachCourseMismatch.set(this.activeApproachDetails.finalApproachCourse >= 0
                && Math.round(this.activeApproachDetails.finalApproachCourse) !== Math.round((_d = this.tunedIlsCourse) !== null && _d !== void 0 ? _d : -1));
        }
    }
    /**
     * Get the true course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     */
    async getFinalApproachTrueCourse(facility, approach) {
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        if (finalLeg.type === LegType.CF && finalLeg.trueDegrees) {
            return finalLeg.course;
        }
        let trueCourse = MagVar.magneticToTrue(finalLeg.course, facility.lat, facility.lon);
        if (finalLeg.type === LegType.TF) {
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const penultimateLeg = approach.finalLegs[approach.finalLegs.length - 2];
            if (!finalFacility || !penultimateLeg) {
                return -1;
            }
            // guaranteed to be XF
            const penultimateFacility = await this.facLoader.getFacility(ICAO.getFacilityType(penultimateLeg.fixIcao), penultimateLeg.fixIcao);
            if (!penultimateFacility) {
                return -1;
            }
            const penultimatePoint = BoeingFms.geoPointCache[0].set(penultimateFacility);
            trueCourse = penultimatePoint.bearingTo(finalFacility);
        }
        else if (finalLeg.type === LegType.RF) {
            // for exactly one airport in the world... but it is legal
            const finalFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.fixIcao), finalLeg.fixIcao);
            const centreFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.arcCenterFixIcao), finalLeg.arcCenterFixIcao);
            if (!finalFacility || !centreFacility) {
                return -1;
            }
            const finalPoint = BoeingFms.geoPointCache[0].set(finalFacility);
            trueCourse = NavMath.normalizeHeading(finalPoint.bearingTo(centreFacility) + (finalLeg.turnDirection === LegTurnDirection.Left ? 90 : -90));
        }
        return trueCourse;
    }
    /**
     * Get the magnetic course for the final approach
     * @param facility Destination airport facility
     * @param approach The approach
     * @param trueCourse The true course if already calculated, else it will be calculated
     */
    async getFinalApproachCourse(facility, approach, trueCourse) {
        if (trueCourse === undefined) {
            trueCourse = await this.getFinalApproachTrueCourse(facility, approach);
        }
        // the final leg is guaranteed to be CF, TF, or RF
        // the default navdata doesn't code a course on TFs (navigraph does)
        const finalLeg = approach.finalLegs[approach.finalLegs.length - 1];
        // use the published airport magvar for terminal legs, except VHF navaids which use station declination
        let magVar = MagVar.get(facility.lat, facility.lon);
        if (finalLeg.originIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.originIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const originFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            // ILS approach must use the ILS declination
            if (originFacility && originFacility.type === VorType.ILS) {
                magVar = -originFacility.magneticVariation;
            }
        }
        else if (finalLeg.fixIcao !== ICAO.emptyIcao && ICAO.getFacilityType(finalLeg.fixIcao) === FacilityType.VOR && finalLeg.type !== LegType.TF) {
            const fixFacility = await this.facLoader.getFacility(ICAO.getFacilityType(finalLeg.originIcao), finalLeg.originIcao);
            if (fixFacility) {
                magVar = -fixFacility.magneticVariation;
            }
        }
        return MagVar.trueToMagnetic(trueCourse, magVar);
    }
}
BoeingFms.ACT_RTE_PLAN_INDEX = 0;
BoeingFms.RTE_1_INACTIVE_PLAN_INDEX = 1;
BoeingFms.RTE_1_MOD_PLAN_INDEX = 2;
BoeingFms.RTE_2_INACTIVE_PLAN_INDEX = 3;
BoeingFms.RTE_2_MOD_PLAN_INDEX = 4;
BoeingFms.USER_DATA_KEY_ALTN = 'wtboeing.altn';
BoeingFms.USER_DATA_KEY_FIX_INFO = 'wtboeing.fix-info';
BoeingFms.USER_DATA_KEY_NEW_INACTIVE_PLAN = 'wtboeing.new-inactive-plan';
BoeingFms.USER_DATA_KEY_ROUTE = 'wtboeing.route';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH = 'wtboeing.visual-approach';
BoeingFms.USER_DATA_KEY_VISUAL_APPROACH_VFR_VPA = 'wtboeing.visual-approach-vfr-vpa';
BoeingFms.USER_DATA_KEY_HUD_TAKEOFF = 'wtboeing.hud-takeoff';
BoeingFms.USER_DATA_KEY_VNAV_DES_PENDING = 'wtboeing.vnav-des-pending';
BoeingFms.geoPointCache = [new GeoPoint(0, 0)];

/**
 * A Boeing VNav Manager.
 */
class BoeingVNavManager {
    /**
     * Creates an instance of the VNAV director.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param calculator The VNAV path calculator to use with this instance.
     * @param performancePlan a performance plan
     * @param messageService The WT21 Message Service.
     * @param apValues are the autopilot ap values.
     * @param options The options for this vnav manager.
     * @param shouldActivateAltCapturing Callback to Boeing AP config to trigger alt capturings
     */
    constructor(bus, flightPlanner, calculator, performancePlan, messageService, apValues, options, shouldActivateAltCapturing) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.calculator = calculator;
        this.performancePlan = performancePlan;
        this.messageService = messageService;
        this.apValues = apValues;
        this.options = options;
        this.shouldActivateAltCapturing = shouldActivateAltCapturing;
        this._realTime = 0;
        this.state = VNavState.Enabled_Inactive;
        this.minimumActivationAltitude = 400; // In Feet RA
        this.pathMode = Subject.create(VNavPathMode.None);
        this.boeingVNavModeSub = Subject.create(BoeingVNavModes.NONE);
        this.planePos = new GeoPoint(0, 0);
        this.altimeterIsStd = false;
        this.currentAltitude = 0;
        this.currentRadioAltitude = 0;
        this.preselectedAltitude = 0;
        /** current ground speed in knots. */
        this.currentGroundSpeed = 0;
        this.currentVS = 0;
        this.trueTrack = 0;
        this.currentIas = 0;
        this.isVNavUnavailable = Subject.create(false);
        this.boeingVNavMode = this.boeingVNavModeSub;
        this.pathDeviationMode = Subject.create(PathDeviationMode.NONE);
        this.capturedAltitude = 0;
        this.isAltCaptured = false;
        this.awaitingClimbRearm = false;
        this.awaitingPathRearm = false;
        this.pathRearmIndex = -1;
        this.pilotPathIntervention = false;
        this.activeLegChangedWhilePathActive = false;
        this.lateralPlanChangedTimer = 0;
        this.lateralPlanChangedCheckDeviation = false;
        this.cruiseAltitude = 30000; //in Feet
        /** The global index of the last leg in the last non-missed approach climb constraint in the primary flight plan. */
        this.lastClimbConstraintLegIndex = -1;
        this.todCalculatedTimer = 0;
        this.anticipatedVectorIndexes = {
            legIndex: -1,
            vectorIndex: -1
        };
        this.anticipatedVectorStartDistanceToLegEnd = 0;
        this.anticipatedVectorStartAltitude = 0;
        this.anticipatedVectorGradient = 0;
        this.vectorAnticipationCircle = {
            x: 0,
            y: 0,
            radius: 0,
            anticipationDistance: 0
        };
        this.glidepathCalculator = new GlidePathCalculator(this.bus, this.flightPlanner, this.options.primaryPlanIndex);
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT);
        this.fmsOnApproachMode = this.fmsOperatingPhase.map(v => v === FmsOperatingPhase.APPROACH);
        this.tocTodBodDetails = {
            todLegIndex: -1,
            bodLegIndex: -1,
            todLegDistance: 0,
            distanceFromTod: 0,
            bodConstraintIndex: -1,
            todConstraintIndex: -1,
            performanceTodLegDistance: 0,
            performanceTodLegIndex: -1,
            distanceFromPerformanceTod: 0,
            performanceTodExists: false,
            tocLegIndex: -1,
            tocLegDistance: 0,
            tocAltitude: 0,
            distanceFromToc: 0
        };
        this.activeVerticalVectorIndex = 0;
        this.tocTodDetailsSub = ObjectSubject.create(Object.assign({}, this.tocTodBodDetails));
        this.manualRnp = Subject.create(null);
        this.defaultRnp = Subject.create(null);
        // Subjects for each vnav var to be set
        this.vnavState = Subject.create(VNavState.Enabled_Inactive);
        this.pathAvailable = Subject.create(false);
        this.currentConstraintAltitude = Subject.create(null);
        this.currentConstraintDistance = Subject.create(null);
        this.nextConstraintAltitude = Subject.create(null);
        this.nextConstraintDetails = Subject.create(null);
        this.nextVnavLeg = Subject.create(null);
        /** Vnav Target Altitude, in feet */
        this.targetAltitude = Subject.create(null);
        this.fpa = Subject.create(null);
        this.verticalDeviation = Subject.create(null);
        this.captureType = Subject.create(BoeingVNavAltCaptureType.None);
        this.vnavNextLegTargetAltitude = Subject.create(null);
        this.rnp = MappedSubject.create(([manualRnp, defaultRnp]) => manualRnp !== null ? manualRnp : defaultRnp, this.manualRnp, this.defaultRnp);
        /** The maximum speed shown on the VNAV speed band, beyond which DRAG REQUIRED may be displayed */
        this.bandMaxSpeed = Subject.create(null);
        /** The minimum speed shown on the VNAV speed band, beyond which THRUST REQUIRED may be displayed */
        this.bandMinSpeed = Subject.create(null);
        /** The maximum speed above which the aircraft starts deviating from the path */
        this.pathMaxSpeed = Subject.create(null);
        /** The minimum speed below which the aircraft starts deviating from the path */
        this.pathMinSpeed = Subject.create(null);
        this.vnavTrackingPhase = Subject.create(BoeingVNavTrackingPhase.None);
        // FMC/MCP DES DIR/DES NOW functions
        this.desDirAvailable = Subject.create(false);
        this.desNowAvailable = Subject.create(false);
        /** undefined prior to ToD, and true if active after ToD, false if inactive */
        this.descentInitiated = undefined;
        // VNAV Error Subjects
        this.pathArmedError = Subject.create(false);
        this.pathBelowAircraft = Subject.create(false);
        this.noPathTae = Subject.create(false);
        this.noPathXtk = Subject.create(false);
        this.noPathThisLeg = Subject.create(false);
        this.noPathPilotCmd = Subject.create(false);
        this.noPathConditionPlanChanged = Subject.create(false);
        this.noPathConditionDisco = Subject.create(false);
        this.noPathVectors = Subject.create(false);
        this.checkAltSel = Subject.create(false);
        this.withinOneMinuteTod = Subject.create(false);
        this.withinFiveSecondsTod = Subject.create(false);
        this.checkFplnAlt = Subject.create(false);
        this.unableNextAlt = Subject.create(false);
        this.unableNextAltTimer = Subject.create(-1);
        this.thrustRequired = Subject.create(false);
        this.dragRequired = Subject.create(false);
        this.resetMcpAlt = Subject.create(false);
        // Fms Speed Values
        /** ambient pressure in in.Hg */
        this.ambientPressure = ConsumerValue.create(null, 0);
        this.apSpeedInMachMode = ConsumerSubject.create(null, false);
        this.apActiveMach = ConsumerSubject.create(null, 0);
        this.apActiveIas = ConsumerSubject.create(null, 0);
        this.apActiveSpeedInIas = MappedSubject.create(([machMode, activeMach, activeIas]) => {
            return machMode ? Simplane.getMachToKias(activeMach) : activeIas;
        }, this.apSpeedInMachMode, this.apActiveMach, this.apActiveIas);
        this.speedInterventionActive = ConsumerSubject.create(null, false);
        // Flap Computer Speed Limits
        this.maneuveringSpeed = ConsumerValue.create(null, 0);
        this.holdingSpeed = ConsumerValue.create(null, 0);
        this.flapLimitSpeed = ConsumerValue.create(null, 0);
        // Autothrottle Status
        this.autothrottleStatus = ConsumerSubject.create(null, BoeingAutothrottleStatus.Off);
        const sub = this.bus.getSubscriber();
        this.lnavLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
        this.lnavLegDistanceAlong = ConsumerSubject.create(sub.on('lnav_leg_distance_along'), 0);
        this.lnavLegDistanceRemaining = ConsumerSubject.create(sub.on('lnav_leg_distance_remaining'), 0);
        this.lnavXtk = ConsumerSubject.create(sub.on('lnav_xtk'), 0);
        this.lnavDtk = ConsumerSubject.create(sub.on('lnav_dtk'), 0);
        this.lnavDataCdiScaleLabel = ConsumerSubject.create(sub.on('lnavdata_cdi_scale_label'), 4);
        this.lnavDataDestinationDistanceDirect = ConsumerSubject.create(sub.on('lnavdata_destination_distance_direct'), Number.MAX_SAFE_INTEGER);
        this.lnavDataDistanceToFaf = ConsumerSubject.create(sub.on('lnavdata_distance_to_faf'), Number.MAX_SAFE_INTEGER);
        sub.on('indicated_alt').handle(alt => {
            this.currentAltitude = alt;
        });
        sub.on('altimeter_baro_is_std_1').handle(std => {
            this.altimeterIsStd = std;
        });
        sub.on('ias').withPrecision(0).handle(ias => this.currentIas = ias);
        sub.on('ra_radio_alt_1').whenChangedBy(1).handle(agl => this.currentRadioAltitude = agl);
        sub.on('vertical_speed').whenChangedBy(1).handle(vs => this.currentVS = vs);
        sub.on('track_deg_true').whenChangedBy(1).handle(trueTrack => this.trueTrack = trueTrack);
        sub.on('realTime').whenChangedBy(100).handle(t => this._realTime = t);
        this.apValues.selectedAltitude.sub(selected => this.preselectedAltitude = selected);
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        // Proxy for executing a plan change
        sub.on('fplCopied').handle(e => {
            if (e.targetPlanIndex === this.options.primaryPlanIndex) {
                this.onLateralPlanChanged();
            }
        });
        sub.on('gps-position').handle(lla => {
            this.planePos.set(lla.lat, lla.long);
        });
        sub.on('ground_speed').handle(gs => this.currentGroundSpeed = gs);
        this.apValues.approachHasGP.sub(v => {
            this.bus.getPublisher().pub('gp_available', v, true);
        });
        sub.on('vnav_set_state').handle(d => {
            if (d) {
                this.setState(VNavState.Enabled_Inactive);
            }
            else {
                this.setState(VNavState.Disabled);
            }
        });
        this.apValues.verticalActive.sub(mode => {
            if (mode === APVerticalModes.ALT) {
                this.handleApAltModeActive();
            }
            if (this.awaitingPathRearm && mode !== APVerticalModes.ALT && mode !== APVerticalModes.CAP) {
                this.awaitingPathRearm = false;
                this.pathRearmIndex = -1;
            }
            if (mode === APVerticalModes.FLC && this.awaitingClimbRearm) {
                this.awaitingClimbRearm = false;
            }
            if ((this.noPathConditionDisco.get() || this.noPathConditionPlanChanged.get()) && mode !== APVerticalModes.PITCH) {
                this.noPathConditionDisco.set(false);
                this.noPathConditionPlanChanged.set(false);
            }
        });
        this.apValues.lateralActive.sub(mode => {
            if (mode === APLateralModes.LOC && this.pathMode.get() === VNavPathMode.PathArmed) {
                this.tryDeactivate();
            }
        });
        // Publish ToD/BoD details
        this.tocTodDetailsSub.sub(this.publishTODBODDetails.bind(this), true);
        this.isVNavUnavailable.sub(v => {
            if (v) {
                this.bus.getPublisher().pub('vnav_availability', VNavAvailability.InvalidLegs, true, false);
            }
            else {
                this.bus.getPublisher().pub('vnav_availability', VNavAvailability.Available, true, false);
            }
        });
        this.vnavTrackingPhase.sub((v) => this.bus.getPublisher().pub('vnav_boeing_vnav_tracking_phase', v));
        // TODO: temp set this to default to 30000' if no value received from perf plan.
        this.performancePlan.cruiseAltitude.sub(v => this.cruiseAltitude = v && v > 0 ? v : 30000);
        this.performancePlan.manualVerticalRnp.pipe(this.manualRnp);
        this.lnavLegIndex.sub(() => {
            if (this.pathMode.get() === VNavPathMode.PathActive) {
                this.activeLegChangedWhilePathActive = true;
            }
        });
        // Update last climb/first descent constraint indexes
        this.calculator.vnavCalculated.on((sender, planIndex) => {
            var _a;
            if (planIndex === this.options.primaryPlanIndex) {
                const verticalPlan = this.calculator.getVerticalFlightPlan(planIndex);
                const missedApproachStartIndex = (_a = verticalPlan.missedApproachStartIndex) !== null && _a !== void 0 ? _a : Infinity;
                const verticalPlanConstraints = verticalPlan.constraints;
                this.lastClimbConstraintLegIndex = -1;
                for (let i = 0; i < verticalPlanConstraints.length; i++) {
                    const constraint = verticalPlanConstraints[i];
                    if (constraint.index < missedApproachStartIndex && constraint.type === 'climb') {
                        this.lastClimbConstraintLegIndex = constraint.index;
                        break;
                    }
                }
            }
        });
        this.ambientPressure.setConsumer(sub.on('ambient_pressure_inhg'));
        this.apSpeedInMachMode.setConsumer(sub.on('fms_speed_autopilot_target_is_mach'));
        this.apActiveIas.setConsumer(sub.on('fms_speed_autopilot_target_ias'));
        this.apActiveMach.setConsumer(sub.on('fms_speed_autopilot_target_mach'));
        this.flapLimitSpeed.setConsumer(sub.on('flap_computer_limit_speed'));
        this.maneuveringSpeed.setConsumer(sub.on('flap_computer_maneuver_speed'));
        this.holdingSpeed.setConsumer(sub.on('flap_computer_holding_speed'));
        this.speedInterventionActive.setConsumer(sub.on('ap_selected_speed_is_manual'));
        this.autothrottleStatus.setConsumer(sub.on('boeing_at_status'));
        this.calculator.vnavCalculated.on((_, planIndex) => {
            if (planIndex === this.options.primaryPlanIndex) {
                this.bus.getPublisher().pub('vnav_path_calculated', planIndex, true, false);
            }
        });
        this.desDirAvailable.sub((v) => this.bus.getPublisher().pub('vnav_boeing_des_dir_available', v, true, true));
        this.desNowAvailable.sub((v) => this.bus.getPublisher().pub('vnav_boeing_des_now_available', v, true, true));
        sub.on('boeingvnav_activate_des_dir').handle(this.activateDesDir.bind(this));
        sub.on('boeingvnav_activate_des_now').handle(this.activateDesNow.bind(this));
        this.fmsOperatingPhase.sub((phase) => phase !== FmsOperatingPhase.DESCENT && phase !== FmsOperatingPhase.APPROACH && this.clearDescentState());
        this.monitorVars();
        this.monitorMode();
        this.monitorMessages();
        this.setState(VNavState.Enabled_Inactive);
    }
    /** @inheritdoc */
    setState(vnavState) {
        if (vnavState === VNavState.Disabled) {
            // We do not support disabled state on boeing vnav.
            return;
        }
        if (vnavState !== this.state) {
            switch (vnavState) {
                case VNavState.Enabled_Active:
                    this.tryActivate();
                    break;
                case VNavState.Enabled_Inactive:
                    this.tryDeactivate();
                    break;
            }
            SimVar.SetSimVarValue(VNavVars.VNAVState, SimVarValueType.Number, this.state);
        }
    }
    /** @inheritdoc */
    tryActivate() {
        if (this.state !== VNavState.Disabled) {
            this.state = VNavState.Enabled_Active;
            SimVar.SetSimVarValue(VNavVars.VNAVState, SimVarValueType.Number, this.state);
            this.pathMode.set(VNavPathMode.None);
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /** @inheritdoc */
    tryDeactivate(newMode) {
        if (this.state !== VNavState.Disabled) {
            if (this.state !== VNavState.Enabled_Inactive) {
                this.state = VNavState.Enabled_Inactive;
                SimVar.SetSimVarValue(VNavVars.VNAVState, SimVarValueType.Number, this.state);
                if (this.pathMode.get() !== VNavPathMode.None) {
                    this.disarmPath(newMode);
                }
                this.reset();
                SimVar.SetSimVarValue('L:XMLVAR_VNAVButtonValue', 'Bool', false);
            }
        }
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    canVerticalModeActivate(mode) {
        // TODO: Should this still apply?
        // if (this.awaitingClimbRearm && (mode === APVerticalModes.FLC || mode === APVerticalModes.VS)) {
        //   // Logic that prevents the pilot from engaging FLC or VS mode while VNAV is active and holding alt for a climb constraint.
        //   return false;
        // }
        if (this.state === VNavState.Enabled_Active) {
            // VNAV is disabled if it is active and a user presses another vertical mode button
            this.tryDeactivate();
        }
        // TODO: is pilot path intervention a thing on the Boeing?
        // if (this.pathMode.get() === VNavPathMode.PathActive && this.apValues.verticalActive.get() === APVerticalModes.PATH) {
        //   this.pilotPathIntervention = true;
        // }
        return true;
    }
    /** @inheritdoc */
    onPathDirectorDeactivated() {
        const verticalActive = this.apValues.verticalActive.get();
        if (verticalActive === APVerticalModes.GP || verticalActive === APVerticalModes.GS) {
            this.pathMode.set(VNavPathMode.None);
            this.tryDeactivate();
        }
        else if (this.pathMode.get() === VNavPathMode.PathActive || this.pathMode.get() === VNavPathMode.PathArmed) {
            this.pathMode.set(VNavPathMode.None);
            this.isAltCaptured = false;
            this.checkAltSel.set(false);
        }
    }
    /**
     * Method to call when VNAV Encounters a failed state.
     */
    failed() {
        if (this.pathMode.get() === VNavPathMode.PathActive && !this.isAltCaptured) {
            this.tryDeactivate(APVerticalModes.PITCH);
        }
        this.reset();
    }
    /**
     * Resets this vnav manager.
     */
    reset() {
        this.captureType.set(BoeingVNavAltCaptureType.None);
        this.setBoeingVNavMode(BoeingVNavModes.NONE);
        this.pathMode.set(VNavPathMode.None);
        this.isAltCaptured = false;
        this.awaitingClimbRearm = false;
        this.awaitingPathRearm = false;
        this.pathRearmIndex = -1;
        this.pilotPathIntervention = false;
        this.lateralPlanChangedTimer = 0;
        this.activeLegChangedWhilePathActive = false;
        this.anticipatedVectorIndexes.legIndex = -1;
        this.anticipatedVectorIndexes.vectorIndex = -1;
        this.anticipatedVectorStartDistanceToLegEnd = 0;
        this.anticipatedVectorStartAltitude = 0;
        this.anticipatedVectorGradient = 0;
        this.clearAllMessages();
        this.resetVNavVars();
        this.resetTodBodVars();
    }
    /**
     * Method called to delegate altitude capture to the Alt Cap Director.
     * @param altitude The altitude to capture.
     * @param flightPhase The flightphase to rearm for, or undefined if no re-arm is desired.
     * @param pathRearmIndex The global leg index at which we want to rearm path, otherwise the next leg index.
     */
    delegateAltCap(altitude, flightPhase, pathRearmIndex) {
        this.isAltCaptured = true;
        this.capturedAltitude = Math.round(altitude);
        this.apValues.capturedAltitude.set(this.capturedAltitude);
        if (flightPhase !== undefined) {
            switch (flightPhase) {
                case VerticalFlightPhase.Climb:
                    this.awaitClimbRearm();
                    break;
                case VerticalFlightPhase.Descent:
                    this.awaitPathRearm(pathRearmIndex);
                    break;
            }
        }
        // TODO: Is there still a situation where we need to set the mode during alt cap?
        // const captureType = this.captureType.get();
        // this.setBoeingVNavMode(captureType === BoeingVNavAltCaptureType.VNAV ? BoeingVNavModes.PATH_LEVEL : BoeingVNavModes.ALT);
        this.activateMode && this.activateMode(APVerticalModes.CAP);
    }
    /**
     * Awaits a path rearm.
     * @param pathRearmIndex Optionally, the global leg index to rearm PATH after reaching.
     */
    awaitPathRearm(pathRearmIndex) {
        this.awaitingPathRearm = true;
        this.pathRearmIndex = pathRearmIndex !== null && pathRearmIndex !== void 0 ? pathRearmIndex : this.lnavLegIndex.get() + 1;
    }
    /**
     * Awaits a climb rearm.
     */
    awaitClimbRearm() {
        this.awaitingClimbRearm = true;
    }
    /** Method called to arm Path Mode. */
    armPath() {
        if (this.pathMode.get() !== VNavPathMode.PathArmed) {
            this.pathMode.set(VNavPathMode.PathArmed);
        }
        this.isAltCaptured = false;
        this.awaitingPathRearm = false;
        this.pathRearmIndex = -1;
        this.armMode && this.armMode(APVerticalModes.PATH);
    }
    /** Method called to activate Path Mode. */
    activatePath() {
        if (this.pathMode.get() !== VNavPathMode.PathActive) {
            this.pathMode.set(VNavPathMode.PathActive);
        }
        this.dragRequired.set(false);
        this.thrustRequired.set(false);
        this.awaitingPathRearm = false;
        this.pathRearmIndex = -1;
        this.activateMode && this.activateMode(APVerticalModes.PATH);
    }
    /**
     * Method to call when VNAV needs to disarm the path, without deactivating VNAV entirely.
     * @param newMode is the vertical mode to set the Autopilot to if Path is currently active.
     */
    disarmPath(newMode = APVerticalModes.PITCH) {
        if (this.pathMode.get() !== VNavPathMode.None) {
            if (this.pathMode.get() === VNavPathMode.PathActive) {
                this.activateMode && this.activateMode(newMode);
            }
            if (this.pathMode.get() === VNavPathMode.PathArmed) {
                this.armMode && this.armMode(APVerticalModes.NONE);
            }
            this.pathMode.set(VNavPathMode.None);
            this.isAltCaptured = false;
            this.checkAltSel.set(false);
        }
    }
    /**
     * Method called when the lateral plan changes via an EXEC press.
     */
    onLateralPlanChanged() {
        this.lateralPlanChangedTimer = Date.now();
        if (this.pathMode.get() === VNavPathMode.PathActive) {
            this.lateralPlanChangedCheckDeviation = true;
        }
    }
    /**
     * Method to check the class flags related to a lateral plan change.
     */
    checkLateralPlanChangedFlags() {
        if (this.lateralPlanChangedTimer > 0 && this._realTime - this.lateralPlanChangedTimer > 1500) {
            this.lateralPlanChangedTimer = 0;
            if (this.lateralPlanChangedCheckDeviation) {
                this.lateralPlanChangedCheckDeviation = false;
            }
        }
    }
    /**
     * Controller method to monitor Boeing VNav Mode and set AP/AT modes accordingly.
     */
    monitorMode() {
        this.boeingVNavMode.sub(mode => {
            this.bus.getPublisher().pub('vnav_boeing_vnav_mode', mode, true, true);
        });
    }
    /**
     * Handles when the Alt Intervention button was pressed on the FCU.
     */
    onAltInterventionPressed() {
        const fmsOperatingPhase = this.fmsOperatingPhase.get();
        const canDesNow = this.desNowAvailable.get() && this.tocTodBodDetails.distanceFromTod < BoeingVNavManager.EARLY_DESCENT_TOD_DISTANCE;
        const isMcpAltitudeAbove = this.preselectedAltitude > this.currentAltitude + 50;
        const isMcpAltitudeBelow = this.preselectedAltitude < this.currentAltitude - 50;
        switch (fmsOperatingPhase) {
            case FmsOperatingPhase.CRUISE: {
                const altWindow = this.apValues.selectedAltitude.get();
                const verticalPlan = this.calculator.getVerticalFlightPlan(this.options.primaryPlanIndex);
                const lateralLegIndex = this.lnavLegIndex.get();
                const reachedTd = this.isPastTod(verticalPlan, lateralLegIndex, this.tocTodBodDetails);
                if (isMcpAltitudeBelow && this.canDescend()) {
                    if (reachedTd) {
                        // initiate descent phase and descend in VNAV SPD
                        this.descentInitiated = true;
                        this.commandDescent();
                    }
                    else if (canDesNow) {
                        // early descent, will be at approx -1250 fpm initially
                        this.descentInitiated = true;
                        this.commandEarlyDescent();
                    }
                    else {
                        // cruise descent, will be at approx -1250 fpm initially
                        this.performancePlan.cruiseAltitude.set(altWindow);
                        this.commandCruiseDescent();
                    }
                }
                else if (isMcpAltitudeAbove) {
                    // cruise climb
                    this.performancePlan.cruiseAltitude.set(altWindow);
                    // we need to force the target alt for canClimb to succeed
                    this.targetAltitude.set(altWindow);
                    if (this.canClimb()) {
                        this.commandClimb();
                    }
                }
                break;
            }
            case FmsOperatingPhase.CLIMB: {
                const plan = this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
                const constraintLookupGlobalLegIndex = plan.activeLateralLeg;
                const nextConstraint = VNavUtils.getNextClimbTargetConstraint(this.calculator.getVerticalFlightPlan(this.options.primaryPlanIndex), constraintLookupGlobalLegIndex);
                const altWindow = this.apValues.selectedAltitude.get();
                const altWindowMetres = UnitType.METER.convertFrom(altWindow, UnitType.FOOT);
                if (nextConstraint && (nextConstraint.maxAltitude === Infinity || nextConstraint.maxAltitude < altWindowMetres)) {
                    this.deleteVnavConstraint(plan, nextConstraint);
                }
                else {
                    const cruiseAltitude = this.performancePlan.cruiseAltitude.get();
                    if (cruiseAltitude === null || altWindow > cruiseAltitude) {
                        this.performancePlan.cruiseAltitude.set(altWindow);
                    }
                }
                // TODO check we don't need to command anything here if mcp alt is below
                // perhaps we should be able to skip straight to descent
                if (isMcpAltitudeAbove && this.canClimb()) {
                    this.commandClimb();
                }
                break;
            }
            case FmsOperatingPhase.APPROACH:
            case FmsOperatingPhase.DESCENT: {
                if (isMcpAltitudeBelow && this.canDescend() && this.boeingVNavMode.get() === BoeingVNavModes.ALT) {
                    this.commandDescent();
                }
                else if (isMcpAltitudeBelow) {
                    this.tryDeleteNextDesAltitudeConstraintAbove(this.preselectedAltitude);
                }
                // TODO check we don't need to command anything here if mcp alt is above
                break;
            }
        }
    }
    /**
     * Deletes an altitude constraint from the lateral flight plan
     *
     * @param plan the lateral flight plan
     * @param vnavConstraint the VNAV Constraint object
     */
    deleteVnavConstraint(plan, vnavConstraint) {
        plan.setLegVerticalData(vnavConstraint.index, {
            altDesc: AltitudeRestrictionType.Unused,
            altitude1: 0,
            altitude2: 0,
            displayAltitude1AsFlightLevel: false,
            displayAltitude2AsFlightLevel: false,
        });
    }
    /**
     * Sets a new Boeing vnav mode.
     * @param mode The mode to set.
     */
    setBoeingVNavMode(mode) {
        const currentMode = this.boeingVNavModeSub.get();
        const currentModeIsNoneArmed = currentMode === BoeingVNavModes.NONE || currentMode === BoeingVNavModes.ARMED;
        const newModeIsNoneArmed = mode === BoeingVNavModes.NONE || mode === BoeingVNavModes.ARMED;
        if (currentModeIsNoneArmed && !newModeIsNoneArmed) {
            this.setManualSpeedActive(false);
        }
        else if (!currentModeIsNoneArmed && newModeIsNoneArmed) {
            this.setManualSpeedActive(true);
        }
        this.boeingVNavModeSub.set(mode);
    }
    /**
     * Handles setting manual speed mode when the vnav mode changes.
     * @param setActive Whether manual speed should be active.
     */
    setManualSpeedActive(setActive) {
        if (setActive) {
            this.setManualTargetSpeed();
        }
        else {
            SimVar.SetSimVarValue('L:XMLVAR_SpeedIsManuallySet', SimVarValueType.Bool, setActive);
        }
    }
    /**
     * Finds and sets the current vnav state when vnav is activated.
     * @param fmsOperatingPhase The current FMS Operating Phase.
     */
    findAndSetCurrentVNavState(fmsOperatingPhase) {
        var _a;
        const currentApVerticalMode = this.apValues.verticalActive.get();
        if (currentApVerticalMode !== APVerticalModes.ALT && currentApVerticalMode !== APVerticalModes.CAP) {
            switch (fmsOperatingPhase) {
                case FmsOperatingPhase.TAKEOFF:
                case FmsOperatingPhase.CLIMB:
                    if (this.canClimb()) {
                        this.commandClimb();
                        return;
                    }
                    break;
                case FmsOperatingPhase.CRUISE:
                case FmsOperatingPhase.DESCENT:
                case FmsOperatingPhase.APPROACH:
                    if (this.vnavTrackingPhase.get() === BoeingVNavTrackingPhase.MissedApproach) {
                        if (this.canClimb()) {
                            this.commandClimb();
                        }
                        else {
                            this.tryDeactivate();
                        }
                        return;
                    }
                    if (this.canDescend()) {
                        this.commandDescent();
                        return;
                    }
                    break;
            }
            this.captureCurrentAltitude();
        }
        else {
            const capturedAltitude = Math.round(this.apValues.capturedAltitude.get());
            const cruiseAltitude = (_a = this.performancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : 0;
            const constraintAltitude = this.calculator.getCurrentConstraintAltitude(this.options.primaryPlanIndex, this.lnavLegIndex.get());
            const constraintAltitudeFeet = constraintAltitude ? Math.round(UnitType.METER.convertTo(constraintAltitude, UnitType.FOOT)) : undefined;
            if (capturedAltitude === Math.round(cruiseAltitude)) {
                this.captureType.set(BoeingVNavAltCaptureType.Cruise);
                this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
            }
            else if (constraintAltitudeFeet !== undefined && capturedAltitude === constraintAltitudeFeet) {
                this.captureType.set(BoeingVNavAltCaptureType.VNAV);
                this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
            }
            else {
                this.captureType.set(BoeingVNavAltCaptureType.Selected);
                this.setBoeingVNavMode(BoeingVNavModes.ALT);
            }
        }
    }
    /**
     * Captures the current altitude based on current positive or negative VS, or the nearest 100'.
     */
    captureCurrentAltitude() {
        this.captureType.set(BoeingVNavAltCaptureType.Selected);
        this.setBoeingVNavMode(BoeingVNavModes.ALT);
        let altitudeToCapture = 100 * Math.round(this.currentAltitude / 100);
        if (this.currentVS > 100) {
            altitudeToCapture = 100 * Math.ceil(this.currentAltitude / 100);
        }
        else if (this.currentVS < -100) {
            altitudeToCapture = 100 * Math.floor(this.currentAltitude / 100);
        }
        this.delegateAltCap(altitudeToCapture);
    }
    /**
     * Updates the VNAV director.
     */
    update() {
        this.checkLateralPlanChangedFlags();
        this.manageDefaultRnp();
        this.manageDesDirNow();
        if (!this.flightPlanner.hasFlightPlan(this.options.primaryPlanIndex)) {
            this.state === VNavState.Enabled_Active && this.failed();
            return;
        }
        const verticalFlightPath = this.calculator.getVerticalFlightPath(this.options.primaryPlanIndex);
        if (verticalFlightPath.isPending) {
            return;
        }
        const lateralPlan = this.flightPlanner.getFlightPlan(this.options.primaryPlanIndex);
        const verticalPlan = this.calculator.getVerticalFlightPlan(this.options.primaryPlanIndex);
        const lateralLegIndex = this.lnavLegIndex.get();
        if (lateralPlan.length > 0 && lateralLegIndex < lateralPlan.length && VNavUtils.verticalPlanHasLeg(verticalPlan, lateralLegIndex)) {
            this.trackProfile(verticalPlan, verticalFlightPath, lateralPlan, lateralLegIndex);
        }
        else {
            this.state === VNavState.Enabled_Active && this.failed();
        }
        if (this.state === VNavState.Enabled_Active) {
            this.manageBoeingVnavState(verticalPlan, lateralPlan, lateralLegIndex);
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
            this.pathMode.set(VNavPathMode.None);
        }
    }
    /**
     * Tracks the vnav profile.
     * @param verticalPlan The vertical flight plan.
     * @param verticalFlightPath The vertical flight path.
     * @param lateralPlan The lateral flight plan.
     * @param lateralLegIndex The current lateral leg index.
     */
    trackProfile(verticalPlan, verticalFlightPath, lateralPlan, lateralLegIndex) {
        const currentAlongLegDistance = UnitType.NMILE.convertTo(this.lnavLegDistanceAlong.get(), UnitType.METER);
        const legDistanceRemaining = UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER);
        const currentConstraintIndex = VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, lateralLegIndex);
        const currentVerticalFlightPathLeg = verticalFlightPath.legs[lateralLegIndex];
        this.activeVerticalVectorIndex = this.getCurrentVerticalFlightPathVectorIndex(currentVerticalFlightPathLeg, legDistanceRemaining);
        this.updateTrackingPhase(verticalPlan, lateralPlan, lateralLegIndex, this.manageTocTodBodDetails(verticalPlan, verticalFlightPath, lateralPlan, currentConstraintIndex, lateralLegIndex, currentAlongLegDistance, legDistanceRemaining));
        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, lateralLegIndex);
        const firstDescentConstraintLegIndex = verticalPlan.firstDescentConstraintLegIndex;
        const firstDescentConstraint = firstDescentConstraintLegIndex ? VNavUtils.getConstraintFromLegIndex(verticalPlan, firstDescentConstraintLegIndex) : undefined;
        const currentConstraintIsFirstDescentConstraint = currentConstraint !== undefined &&
            firstDescentConstraint !== undefined
            && firstDescentConstraint.index === currentConstraint.index;
        const currentConstraintIsDescent = currentConstraint !== undefined && currentConstraint.type !== 'climb' && currentConstraint.type !== 'missed';
        const trackingPhase = this.vnavTrackingPhase.get();
        const trackingClimb = trackingPhase === BoeingVNavTrackingPhase.Climb;
        const trackingDescent = trackingPhase === BoeingVNavTrackingPhase.Descent || trackingPhase === BoeingVNavTrackingPhase.Cruise;
        const trackingMissed = trackingPhase === BoeingVNavTrackingPhase.MissedApproach;
        let vnavTargetAltitudeMeters;
        if (trackingMissed) {
            vnavTargetAltitudeMeters = VNavUtils.getNextMaprTargetAltitude(verticalPlan, lateralLegIndex);
        }
        else if (trackingClimb) {
            vnavTargetAltitudeMeters = VNavUtils.getNextClimbTargetAltitude(verticalPlan, lateralLegIndex);
        }
        else if (trackingDescent) {
            vnavTargetAltitudeMeters = this.calculator.getTargetAltitude(this.options.primaryPlanIndex, lateralLegIndex);
        }
        const vnavTargetAltitudeFeet = trackingClimb && vnavTargetAltitudeMeters === undefined ? this.cruiseAltitude :
            vnavTargetAltitudeMeters !== undefined ? Math.round(UnitType.METER.convertTo(vnavTargetAltitudeMeters, UnitType.FOOT)) : undefined;
        this.targetAltitude.set(vnavTargetAltitudeFeet !== null && vnavTargetAltitudeFeet !== void 0 ? vnavTargetAltitudeFeet : null);
        let nextConstraintAltitudeForCurrentPhaseFeet = null;
        if (!trackingDescent) {
            this.fpa.set(null);
            nextConstraintAltitudeForCurrentPhaseFeet = vnavTargetAltitudeFeet !== null && vnavTargetAltitudeFeet !== void 0 ? vnavTargetAltitudeFeet : Number.MAX_SAFE_INTEGER;
        }
        this.manageAltCaptureType();
        this.setPathSpeedLimits(lateralLegIndex);
        if (currentConstraintIsDescent && this.vnavTrackingPhase.get() === BoeingVNavTrackingPhase.Descent) {
            this.managePathSpeedBand(lateralLegIndex);
            if (this.trackDescentFromVerticalFlightPath(lateralLegIndex)) {
                if (this.pathMode.get() === VNavPathMode.PathActive) {
                    if (currentConstraintIsFirstDescentConstraint) {
                        this.setBoeingVNavMode(BoeingVNavModes.PATH_IDLE);
                    }
                    else {
                        this.setBoeingVNavMode(BoeingVNavModes.PATH_DESCENT);
                    }
                }
            }
            else {
                this.anticipatedVectorIndexes.legIndex = -1;
                this.anticipatedVectorIndexes.vectorIndex = -1;
                this.anticipatedVectorStartDistanceToLegEnd = 0;
                this.anticipatedVectorStartAltitude = 0;
                this.anticipatedVectorGradient = 0;
                this.pathAvailable.set(currentConstraintIsDescent);
                const desiredAltitude = VNavUtils.getDesiredAltitude(verticalPlan, lateralLegIndex, currentAlongLegDistance);
                this.verticalDeviation.set(UnitType.METER.convertTo(desiredAltitude, UnitType.FOOT) - this.currentAltitude);
                this.fpa.set(currentConstraint.fpa);
                if (this.pathMode.get() === VNavPathMode.PathActive) {
                    this.setBoeingVNavMode(BoeingVNavModes.PATH_DESCENT);
                }
            }
            const nextConstraintAltitudeForCurrentPhase = VNavUtils.getNextDescentTargetAltitude(verticalPlan, lateralLegIndex);
            nextConstraintAltitudeForCurrentPhaseFeet =
                nextConstraintAltitudeForCurrentPhase !== undefined ? Math.round(UnitType.METER.convertTo(nextConstraintAltitudeForCurrentPhase, UnitType.FOOT))
                    : null;
            const isPathEnd = currentConstraint.isPathEnd;
            this.nextVnavLeg.set(isPathEnd ? null : VNavUtils.getVerticalLegFromPlan(verticalPlan, currentConstraint.index + 1));
        }
        else {
            this.verticalDeviation.set(null);
            this.anticipatedVectorIndexes.legIndex = -1;
            this.anticipatedVectorIndexes.vectorIndex = -1;
            this.anticipatedVectorStartDistanceToLegEnd = 0;
        }
        this.currentConstraintDistance.set(currentConstraint !== undefined ?
            VNavUtils.getDistanceToConstraint(currentConstraint, lateralPlan, lateralLegIndex, UnitType.NMILE.convertTo(this.lnavLegDistanceAlong.get(), UnitType.METER))
            : null);
        this.nextConstraintAltitude.set(nextConstraintAltitudeForCurrentPhaseFeet);
        this.checkPathValidity(lateralPlan, this.verticalDeviation.get(), currentConstraint);
        this.manageAltCaptureType();
    }
    /**
     * Check if we are past the ToD
     * @param verticalPlan The vertical plan.
     * @param lateralLegIndex The current lateral leg index.
     * @param todBodDetails The tod bod details object.
     * @returns true if past ToD
     */
    isPastTod(verticalPlan, lateralLegIndex, todBodDetails) {
        var _a;
        const firstDescentConstraintLegIndex = (_a = verticalPlan.firstDescentConstraintLegIndex) !== null && _a !== void 0 ? _a : -1;
        const firstDescentConstraintIndex = firstDescentConstraintLegIndex < 0
            ? -1
            : VNavUtils.getConstraintIndexFromLegIndex(verticalPlan, firstDescentConstraintLegIndex);
        return firstDescentConstraintLegIndex >= 0 && firstDescentConstraintIndex >= 0 // There is at least one descent constraint and...
            && (
            // ... we are past the first descent constraint...
            lateralLegIndex > firstDescentConstraintLegIndex
                // ... or we are within threshold distance of TOD
                || (todBodDetails.performanceTodLegIndex >= 0 && todBodDetails.distanceFromPerformanceTod <= BoeingVNavManager.DESCENT_PHASE_TOD_DISTANCE)
                // ... or we are within threshold distance of the first descent constraint
                || (this.getDistanceToConstraint(verticalPlan, firstDescentConstraintIndex, lateralLegIndex, this.lnavLegDistanceAlong.get()) <= BoeingVNavManager.DESCENT_PHASE_TOD_DISTANCE));
    }
    /**
     * Updated the VNAV tracking phase.
     * @param verticalPlan The vertical plan.
     * @param lateralPlan The lateral plan.
     * @param lateralLegIndex The current lateral leg index.
     * @param todBodDetails The tod bod details object.
     */
    updateTrackingPhase(verticalPlan, lateralPlan, lateralLegIndex, todBodDetails) {
        // Update VNAV flight and tracking phases.
        const isInDeparture = lateralPlan.getSegment(lateralPlan.getSegmentIndex(lateralLegIndex)).segmentType === FlightPlanSegmentType.Departure;
        const isInMapr = BitFlags.isAll(lateralPlan.getLeg(lateralLegIndex).flags, LegDefinitionFlags.MissedApproach);
        const isPastTod = this.isPastTod(verticalPlan, lateralLegIndex, todBodDetails);
        if (isPastTod && this.descentInitiated === undefined) {
            this.descentInitiated = this.preselectedAltitude < (this.cruiseAltitude - 50);
        }
        const isInCruise = lateralLegIndex > this.lastClimbConstraintLegIndex // We have sequenced all climb constraints and...
            // ... we are within threshold vertical distance of the cruise altitude
            && this.currentAltitude >= this.cruiseAltitude - BoeingVNavManager.CRUISE_PHASE_ALTITUDE_THRESHOLD;
        // VNAV tracking phase (determines whether VNAV will track climb or descent):
        // Climb: airplane is not past 10 NM to go to the first TOD in the flight plan and is in the departure segment,
        //        or has not sequenced all climb constraints or is lower than 500 feet below the cruise altitude.
        // Cruise: airplane is not in the departure segment and has sequenced all climb constraints (excluding the ones
        //         in the missed approach) and the airplane is higher than 500 feet below the cruise altitude.
        // Descent: airplane is at or past 10 NM to go to the first TOD in the flight plan and is not in the missed
        //          approach, or is in an early descent.
        // Missed approach: airplane is in the missed approach.
        if (isInMapr) {
            this.vnavTrackingPhase.set(BoeingVNavTrackingPhase.MissedApproach);
        }
        else if (this.descentInitiated) {
            this.vnavTrackingPhase.set(BoeingVNavTrackingPhase.Descent);
        }
        else if (isInDeparture) {
            this.vnavTrackingPhase.set(BoeingVNavTrackingPhase.Climb);
        }
        else if (isInCruise) {
            this.vnavTrackingPhase.set(BoeingVNavTrackingPhase.Cruise);
        }
        else {
            this.vnavTrackingPhase.set(BoeingVNavTrackingPhase.Climb);
        }
    }
    /**
     * Handles when ALT mode becomes the active mode.
     */
    handleApAltModeActive() {
        const currentMode = this.boeingVNavMode.get();
        if (this.apValues.capturedAltitude.get() === this.performancePlan.cruiseAltitude.get()) {
            this.captureType.set(BoeingVNavAltCaptureType.Cruise);
        }
        if (this.state === VNavState.Enabled_Active) {
            if (currentMode !== BoeingVNavModes.NONE && currentMode !== BoeingVNavModes.ARMED) {
                switch (this.captureType.get()) {
                    case BoeingVNavAltCaptureType.VNAV:
                    case BoeingVNavAltCaptureType.Cruise:
                        this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
                        break;
                    default:
                        this.setBoeingVNavMode(BoeingVNavModes.ALT);
                }
            }
        }
    }
    /**
     * Method to manage the state of vnav.
     * @param verticalPlan The Vertical Flight Plan.
     * @param lateralPlan The Lateral Flight Plan.
     * @param lateralLegIndex The active lateral leg index.
     */
    manageBoeingVnavState(verticalPlan, lateralPlan, lateralLegIndex) {
        const currentMode = this.boeingVNavMode.get();
        switch (currentMode) {
            case BoeingVNavModes.ALT:
                // We are level at the preselector
                this.updateAltMode();
                break;
            case BoeingVNavModes.PATH_LEVEL:
                // We are level at a constraint or the cruise altitude
                this.updatePathLevelMode(verticalPlan, lateralPlan);
                break;
            case BoeingVNavModes.PATH_IDLE:
                // We are in the initial performance path descent
                this.updatePathIdleMode(verticalPlan, lateralLegIndex);
                break;
            case BoeingVNavModes.PATH_DESCENT:
                // We are in a standard path descent
                this.updatePathDescentMode(verticalPlan, lateralLegIndex);
                break;
            case BoeingVNavModes.SPD_CLIMB:
                // We are in an FLC climb at climb power
                this.updateSpdClimbMode();
                break;
            case BoeingVNavModes.THR_DESCENT:
                // We are in an (early or cruise) FLC descent with thrust for -1250 fpm (or as set by pilot)
                this.updateThrDescentMode();
                break;
            case BoeingVNavModes.SPD_DESCENT:
                // We are in an FLC descent at idle/hold power
                this.updateSpdDescentMode();
                break;
            case BoeingVNavModes.ARMED:
                // Vnav is armed and waiting for an activation
                this.updateArmedMode();
                break;
            default: // BoeingVNavModes.NONE
                this.setBoeingVNavMode(BoeingVNavModes.ARMED);
        }
    }
    /**
     * Updates the ARMED mode.
     */
    updateArmedMode() {
        // We are waiting for something to happen.
        if (this.state === VNavState.Enabled_Active) {
            // const activeVerticalApMode = this.apValues.verticalActive.get();
            // VNav is on and armed.
            if (this.currentRadioAltitude < this.minimumActivationAltitude) {
                // We can not activate yet because we're too low to the ground; stay armed.
                return;
            }
            const fmsOperatingPhase = this.fmsOperatingPhase.get();
            switch (fmsOperatingPhase) {
                case FmsOperatingPhase.TAKEOFF:
                case FmsOperatingPhase.CLIMB:
                case FmsOperatingPhase.CRUISE:
                case FmsOperatingPhase.DESCENT:
                case FmsOperatingPhase.APPROACH:
                    this.findAndSetCurrentVNavState(fmsOperatingPhase);
                    break;
                default:
                    this.tryDeactivate();
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Command a vnav FLC climb.
     */
    commandClimb() {
        this.setBoeingVNavMode(BoeingVNavModes.SPD_CLIMB);
        this.capturedAltitude = Number.POSITIVE_INFINITY;
        this.isAltCaptured = false;
        this.awaitingClimbRearm = false;
        this.activateMode && this.activateMode(APVerticalModes.FLC);
    }
    /**
     * Check if vnav can climb.
     * @returns Whether vnav can initiate a climb.
     */
    canClimb() {
        var _a;
        const targetAltitude = (_a = this.targetAltitude.get()) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;
        // This is the altitude vnav climb is targeting.
        const climbTargetAltitude = Math.round(Math.min(targetAltitude, this.cruiseAltitude));
        const altitudeToClimbTo = Math.round(Math.min(climbTargetAltitude, this.preselectedAltitude));
        if (this.currentAltitude < altitudeToClimbTo) {
            // If we're in this method, VNAV is on and active then we want to start a climb
            return true;
        }
        return false;
    }
    /**
     * Command a vnav FLC descent.
     */
    commandDescent() {
        this.setBoeingVNavMode(BoeingVNavModes.SPD_DESCENT);
        this.capturedAltitude = Number.POSITIVE_INFINITY;
        this.isAltCaptured = false;
        this.awaitingClimbRearm = false;
        this.activateMode && this.activateMode(APVerticalModes.FLC);
    }
    /**
     * Command a vnav early descent
     */
    commandEarlyDescent() {
        this.descentInitiated = true;
        this.commandCruiseDescent();
    }
    /**
     * Command a vnav cruise descent (-1250 fpm in THR/HOLD)
     */
    commandCruiseDescent() {
        this.setBoeingVNavMode(BoeingVNavModes.THR_DESCENT);
        this.capturedAltitude = Number.POSITIVE_INFINITY;
        this.isAltCaptured = false;
        this.awaitingClimbRearm = false;
        this.activateMode && this.activateMode(APVerticalModes.FLC);
    }
    /**
     * Check if vnav can descend.
     * @returns Whether vnav can initiate a non-path descent.
     */
    canDescend() {
        var _a;
        const targetAltitude = (_a = this.targetAltitude.get()) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;
        // This is the altitude vnav descent is targeting.
        const descentTargetAltitude = Math.round(targetAltitude);
        let altitudeToDescendTo;
        if (this.fmsOnApproachMode.get() === true && this.preselectedAltitude > this.currentAltitude + 300) {
            altitudeToDescendTo = Math.round(descentTargetAltitude);
        }
        else {
            altitudeToDescendTo = Math.round(Math.max(descentTargetAltitude, this.preselectedAltitude));
        }
        if (this.currentAltitude > altitudeToDescendTo) {
            return true;
        }
        return false;
    }
    /** Check if the MCP altitude is less than cruise altitude if we're close to ToD and send FMC message if not */
    updateResetMcpAltMessage() {
        const isPreselectedAltBeneathCruiseAlt = this.preselectedAltitude < this.cruiseAltitude;
        const isTodInvalid = this.tocTodBodDetails.distanceFromPerformanceTod === 0;
        const secondsToTod = isTodInvalid ? undefined : this.tocTodBodDetails.distanceFromPerformanceTod / UnitType.MPS.convertFrom(this.currentGroundSpeed, UnitType.KNOT);
        const isWithin120SecondsOfTod = secondsToTod === undefined ? false : secondsToTod < 120;
        if (isWithin120SecondsOfTod && !isPreselectedAltBeneathCruiseAlt) {
            this.resetMcpAlt.set(true);
        }
        else {
            this.resetMcpAlt.set(false);
        }
    }
    /**
     * Updates the SPD_CLIMB mode.
     */
    updateSpdClimbMode() {
        if (this.state === VNavState.Enabled_Active) {
            const targetAltitude = this.targetAltitude.get();
            if (!this.isAltCaptured && this.apValues.verticalActive.get() !== APVerticalModes.ALT && targetAltitude !== null) {
                if (this.shouldActivateAltCapturing(this.currentVS, targetAltitude, this.currentAltitude)) {
                    this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
                    this.delegateAltCap(targetAltitude, VerticalFlightPhase.Climb);
                }
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the THR_DESCENT mode
     */
    updateThrDescentMode() {
        // if we're on path, active normal descent instead
        if (this.state === VNavState.Enabled_Active) {
            if (this.pathAvailable.get()) {
                this.canPathArm() && this.armPath();
                if (this.canPathActivate()) {
                    this.commandDescent();
                    return;
                }
            }
            const targetAltitude = this.nextConstraintAltitude.get();
            if (!this.isAltCaptured && this.apValues.verticalActive.get() !== APVerticalModes.ALT && targetAltitude !== null) {
                if (this.shouldActivateAltCapturing(this.currentVS, targetAltitude, this.currentAltitude)) {
                    this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
                    this.delegateAltCap(targetAltitude);
                }
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the SPD_DESCENT mode.
     */
    updateSpdDescentMode() {
        if (this.state === VNavState.Enabled_Active) {
            if (this.pathAvailable.get()) {
                this.canPathArm() && this.armPath();
                if (this.canPathActivate()) {
                    this.activatePath();
                    return;
                }
            }
            const targetAltitude = this.nextConstraintAltitude.get();
            if (!this.isAltCaptured && this.apValues.verticalActive.get() !== APVerticalModes.ALT && targetAltitude !== null) {
                if (this.shouldActivateAltCapturing(this.currentVS, targetAltitude, this.currentAltitude)) {
                    this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
                    this.delegateAltCap(targetAltitude);
                }
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the PATH_LEVEL mode.
     * @param verticalPlan The vertical flight plan.
     * @param lateralPlan The lateral flight plan.
     */
    updatePathLevelMode(verticalPlan, lateralPlan) {
        var _a;
        if (this.state === VNavState.Enabled_Active) {
            if (this.vnavTrackingPhase.get() === BoeingVNavTrackingPhase.Cruise && this.apValues.capturedAltitude.get() !== this.performancePlan.cruiseAltitude.get()) {
                this.setBoeingVNavMode(BoeingVNavModes.ALT);
            }
            const fmsOperatingPhase = this.fmsOperatingPhase.get();
            if (fmsOperatingPhase === FmsOperatingPhase.CLIMB) {
                if (this.awaitingClimbRearm) {
                    const targetAltitude = (_a = this.targetAltitude.get()) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER;
                    const climbTargetAltitude = Math.round(Math.min(targetAltitude, this.cruiseAltitude));
                    const altitudeToClimbTo = Math.round(Math.min(climbTargetAltitude, this.preselectedAltitude));
                    const lateralLegIndex = this.lnavLegIndex.get();
                    const activeLateralLeg = lateralPlan.tryGetLeg(lateralLegIndex);
                    if (activeLateralLeg && activeLateralLeg.calculated) {
                        const distanceToBoc = UnitType.METER.convertTo(activeLateralLeg.calculated.distanceWithTransitions, UnitType.NMILE) - this.lnavLegDistanceAlong.get();
                        const currentConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, lateralLegIndex);
                        this.checkAltSel.set(currentConstraint !== undefined &&
                            currentConstraint.index === lateralLegIndex &&
                            distanceToBoc / (this.currentGroundSpeed / 60) < 0.75 &&
                            this.preselectedAltitude <= this.capturedAltitude);
                    }
                    if (altitudeToClimbTo > this.capturedAltitude && altitudeToClimbTo > this.currentAltitude) {
                        this.commandClimb();
                        return;
                    }
                    else {
                        this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
                    }
                }
            }
            else if (fmsOperatingPhase === FmsOperatingPhase.CRUISE || fmsOperatingPhase === FmsOperatingPhase.DESCENT || fmsOperatingPhase === FmsOperatingPhase.APPROACH) {
                if (this.pathAvailable.get()) {
                    this.canPathArm() && this.armPath();
                    if (this.canPathActivate()) {
                        this.activatePath();
                    }
                    else if (!this.awaitingPathRearm && this.pathMode.get() === VNavPathMode.PathArmed && this.pathBelowAircraft.get() === true) {
                        this.commandDescent();
                    }
                }
            }
            if (fmsOperatingPhase === FmsOperatingPhase.CRUISE || fmsOperatingPhase === FmsOperatingPhase.DESCENT) {
                this.updateResetMcpAltMessage();
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the PATH_IDLE mode.
     * @param verticalPlan The vertical flight plan.
     * @param lateralLegIndex The active lateral leg index.
     */
    updatePathIdleMode(verticalPlan, lateralLegIndex) {
        if (this.state === VNavState.Enabled_Active) {
            const pathTargetAltitude = this.targetAltitude.get();
            const nextLeg = this.nextVnavLeg.get();
            const distanceToCurrentConstraint = this.currentConstraintDistance.get();
            if (pathTargetAltitude !== null && distanceToCurrentConstraint !== null) {
                this.trackPath(verticalPlan, lateralLegIndex, pathTargetAltitude, nextLeg, distanceToCurrentConstraint);
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the PATH_DESCENT mode.
     * @param verticalPlan The vertical flight plan.
     * @param lateralLegIndex The active lateral leg index.
     */
    updatePathDescentMode(verticalPlan, lateralLegIndex) {
        if (this.state === VNavState.Enabled_Active) {
            const pathTargetAltitude = this.targetAltitude.get();
            const nextLeg = this.nextVnavLeg.get();
            const distanceToCurrentConstraint = this.currentConstraintDistance.get();
            if (pathTargetAltitude !== null && distanceToCurrentConstraint !== null) {
                this.trackPath(verticalPlan, lateralLegIndex, pathTargetAltitude, nextLeg, distanceToCurrentConstraint);
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Updates the ALT mode.
     */
    updateAltMode() {
        if (this.state === VNavState.Enabled_Active) {
            const fmsOperatingPhase = this.fmsOperatingPhase.get();
            if (this.apValues.capturedAltitude.get() === this.performancePlan.cruiseAltitude.get()) {
                this.setBoeingVNavMode(BoeingVNavModes.PATH_LEVEL);
            }
            if (fmsOperatingPhase === FmsOperatingPhase.CRUISE || fmsOperatingPhase === FmsOperatingPhase.DESCENT || fmsOperatingPhase === FmsOperatingPhase.APPROACH) {
                if (this.pathAvailable.get()) {
                    this.canPathArm() && this.armPath();
                    if (this.canPathActivate()) {
                        this.activatePath();
                    }
                }
            }
        }
        else {
            this.setBoeingVNavMode(BoeingVNavModes.NONE);
        }
    }
    /**
     * Tracks the path descent.
     * @param verticalPlan The vertical flight plan.
     * @param lateralLegIndex The active lateral leg index.
     * @param pathTargetAltitude The path target altitude, in feet.
     * @param nextLeg The next path descent leg, or undefined of none exists.
     * @param distanceToCurrentConstraint The distance to the current constraint, in meters.
     */
    trackPath(verticalPlan, lateralLegIndex, pathTargetAltitude, nextLeg, distanceToCurrentConstraint) {
        let altitudeToCapture;
        if (this.fmsOnApproachMode.get() === true && this.preselectedAltitude > this.currentAltitude + 300) {
            altitudeToCapture = Math.round(pathTargetAltitude);
        }
        else {
            altitudeToCapture = Math.round(Math.max(pathTargetAltitude, this.preselectedAltitude));
        }
        // If PATH is active, then it is our responsibility to capture the next altitude, whether it is a VNAV constraint
        // altitude or a preselected altitude.
        if (this.shouldActivateAltCapturing(this.currentVS, altitudeToCapture, this.currentAltitude)) {
            // Now we know path is active, we are approaching a BOD and the next leg is valid and has a non-zero FPA.
            // If the TOD for the next leg is close to the BOD, we will skip altitude capture because we might fly past the
            // TOD by the time PATH rearms. If we skip capture, then PATH will stay active and pick up the deviation from
            // the next leg once the current leg is sequenced. The new deviation should be small and is guaranteed to be such
            // that the airplane is under the path, so the PATH director should have no problem re-establishing.
            const nextLegTodDistance = nextLeg !== null ?
                VNavUtils.distanceForAltitude(nextLeg.fpa, UnitType.FOOT.convertTo(altitudeToCapture, UnitType.METER) - nextLeg.altitude)
                : 0;
            const distanceToNextTod = nextLeg !== null ? distanceToCurrentConstraint + nextLeg.distance - nextLegTodDistance : 0;
            const capturingSelectedAltitude = this.captureType.get() !== BoeingVNavAltCaptureType.VNAV;
            if (capturingSelectedAltitude || nextLeg === null || nextLeg.fpa === 0 || distanceToNextTod > 1900) {
                const isPathEnd = this.nextConstraintAltitude.get() === null;
                const activeVerticalLeg = VNavUtils.getVerticalLegFromPlan(verticalPlan, lateralLegIndex);
                this.delegateAltCap(altitudeToCapture, !isPathEnd ? VerticalFlightPhase.Descent : undefined, !capturingSelectedAltitude && (activeVerticalLeg === null || activeVerticalLeg === void 0 ? void 0 : activeVerticalLeg.isBod) ? lateralLegIndex + 1
                    : distanceToNextTod > 1900 ? undefined
                        : lateralLegIndex);
                this.setBoeingVNavMode(capturingSelectedAltitude ? BoeingVNavModes.ALT : BoeingVNavModes.PATH_LEVEL);
            }
        }
    }
    /**
     * Sets the fpa and gets the deviation for the idle descent phase.
     * @param lateralLegIndex The lateral leg index.
     * @returns If the fpa and vertical deviation were calculated.
     */
    trackDescentFromVerticalFlightPath(lateralLegIndex) {
        const verticalFlightPath = this.calculator.getVerticalFlightPath(this.options.primaryPlanIndex);
        if (verticalFlightPath.todLegIndex === undefined) {
            return false;
        }
        const lnavLegDistanceRemaining = UnitType.NMILE.convertTo(this.lnavLegDistanceRemaining.get(), UnitType.METER);
        const currentVerticalLeg = verticalFlightPath.legs[lateralLegIndex];
        let currentFpa = 0;
        let currentDesiredAltitudeMeters = 0;
        let pathAvailable = false;
        const verticalVector = currentVerticalLeg.vectors[this.activeVerticalVectorIndex];
        if (!verticalVector) {
            return false;
        }
        const lateralDistanceMeters = verticalVector.startDistanceToLegEnd - verticalVector.endDistanceToLegEnd;
        const verticalDistanceMeters = verticalVector.startAltitude - verticalVector.endAltitude;
        if (this.isVectorTypeClimbOrCruise(verticalVector.type)) {
            currentDesiredAltitudeMeters = verticalVector.endAltitude;
        }
        else if (verticalVector.type === VerticalFlightPathVectorType.LevelDeceleration) {
            currentDesiredAltitudeMeters = verticalVector.endAltitude;
            pathAvailable = true;
        }
        else if (verticalDistanceMeters > 0 && lateralDistanceMeters > 0) {
            currentFpa = VNavUtils.getFpa(lateralDistanceMeters, verticalDistanceMeters);
            currentDesiredAltitudeMeters = Math.min(MathUtils.lerp(lnavLegDistanceRemaining, verticalVector.startDistanceToLegEnd, verticalVector.endDistanceToLegEnd, verticalVector.startAltitude, verticalVector.endAltitude), verticalVector.startAltitude);
            pathAvailable = true;
        }
        else {
            currentDesiredAltitudeMeters = verticalVector.startAltitude;
        }
        const vectorLateralDistanceAlong = MathUtils.lerp(lnavLegDistanceRemaining, verticalVector.startDistanceToLegEnd, verticalVector.endDistanceToLegEnd, 0, lateralDistanceMeters);
        // Figure out vector anticipation.
        if (verticalDistanceMeters >= 0) {
            if (this.anticipatedVectorIndexes.legIndex === lateralLegIndex && lnavLegDistanceRemaining <= this.anticipatedVectorStartDistanceToLegEnd) {
                // We are flying an anticipation curve in lieu of an anticipated vector. We now need to determine if we should
                // continue flying the curve.
                if (
                // Stop flying the anticipation curve if we are past the end of the curve ...
                lnavLegDistanceRemaining <= this.anticipatedVectorStartDistanceToLegEnd - this.vectorAnticipationCircle.anticipationDistance
                    // ... or if the current vector does not match the anticipated vector (this can happen if the flight path
                    // was recalculated due to a flight plan change).
                    || Math.abs((this.anticipatedVectorStartDistanceToLegEnd - lnavLegDistanceRemaining) * this.anticipatedVectorGradient
                        + this.anticipatedVectorStartAltitude - currentDesiredAltitudeMeters) > 1) {
                    this.anticipatedVectorIndexes.legIndex = -1;
                    this.anticipatedVectorIndexes.vectorIndex = -1;
                    this.anticipatedVectorStartDistanceToLegEnd = 0;
                    this.anticipatedVectorStartAltitude = 0;
                    this.anticipatedVectorGradient = 0;
                }
            }
            let distanceToAnticipatedVector = 0;
            if (this.anticipatedVectorIndexes.legIndex !== lateralLegIndex
                || (this.anticipatedVectorIndexes.legIndex >= 0 && lnavLegDistanceRemaining > this.anticipatedVectorStartDistanceToLegEnd + 10)) {
                // We are not flying an anticipation curve in lieu of an anticipated vector. We need to calculate the
                // anticipation curve for the next vector (if one exists) and see if we need to start flying it.
                const nextVerticalVectorIndexes = BoeingVNavManager.getNextAnticipatedVerticalFlightPathVector(verticalFlightPath, lateralLegIndex, this.activeVerticalVectorIndex, this.anticipatedVectorIndexes);
                if (nextVerticalVectorIndexes) {
                    const nextVerticalVector = verticalFlightPath.legs[nextVerticalVectorIndexes.legIndex].vectors[nextVerticalVectorIndexes.vectorIndex];
                    distanceToAnticipatedVector = BoeingVNavManager.getDistanceToVerticalFlightPathVector(verticalFlightPath, lateralLegIndex, this.activeVerticalVectorIndex, this.anticipatedVectorIndexes.legIndex, this.anticipatedVectorIndexes.vectorIndex) + lateralDistanceMeters - vectorLateralDistanceAlong;
                    BoeingVNavManager.computeAnticipationCircle(verticalVector, nextVerticalVector, this.currentGroundSpeed, this.vectorAnticipationCircle);
                    if (this.vectorAnticipationCircle.radius === 0 || distanceToAnticipatedVector >= this.vectorAnticipationCircle.anticipationDistance) {
                        this.anticipatedVectorIndexes.legIndex = -1;
                        this.anticipatedVectorIndexes.vectorIndex = -1;
                        this.anticipatedVectorStartDistanceToLegEnd = 0;
                        this.anticipatedVectorStartAltitude = 0;
                        this.anticipatedVectorGradient = 0;
                    }
                    else {
                        // We need to save some information about the anticipated vector because once we fly past the start of it,
                        // it may be re-calculated with a different start point.
                        this.anticipatedVectorStartDistanceToLegEnd = nextVerticalVector.startDistanceToLegEnd;
                        this.anticipatedVectorStartAltitude = nextVerticalVector.startAltitude;
                        this.anticipatedVectorGradient = (nextVerticalVector.endAltitude - nextVerticalVector.startAltitude)
                            / (nextVerticalVector.startDistanceToLegEnd - nextVerticalVector.endDistanceToLegEnd);
                    }
                }
            }
            if (this.anticipatedVectorIndexes.legIndex >= 0) {
                // We are flying a vector anticipation curve.
                const originAltitude = this.anticipatedVectorStartAltitude;
                let x;
                if (this.anticipatedVectorIndexes.legIndex === lateralLegIndex) {
                    x = this.anticipatedVectorStartDistanceToLegEnd - lnavLegDistanceRemaining;
                }
                else {
                    x = -distanceToAnticipatedVector;
                }
                const { x: circleX, y: circleY, radius } = this.vectorAnticipationCircle;
                const dX = x - circleX;
                // If the current leg is not the same as the anticipated vector's leg, then we need to set the target altitude
                // to that of the anticipated vector's leg. Otherwise, we won't start descending out of level segments until we
                // actually sequence into the anticipated vector's leg.
                if (this.anticipatedVectorIndexes.legIndex !== lateralLegIndex) {
                    const anticipatedTargetAltitude = this.calculator.getTargetAltitude(this.options.primaryPlanIndex, this.anticipatedVectorIndexes.legIndex);
                    if (anticipatedTargetAltitude !== undefined) {
                        this.targetAltitude.set(UnitType.METER.convertTo(anticipatedTargetAltitude, UnitType.FOOT));
                    }
                }
                pathAvailable = true;
                const fpaRad = Math.asin(MathUtils.clamp(dX / radius, -1, 1)); // positive-up
                currentFpa = -fpaRad * Avionics.Utils.RAD2DEG; // positive-down
                currentDesiredAltitudeMeters = -Math.cos(fpaRad) * radius + circleY + originAltitude;
            }
        }
        else {
            this.anticipatedVectorIndexes.legIndex = -1;
            this.anticipatedVectorIndexes.vectorIndex = -1;
            this.anticipatedVectorStartDistanceToLegEnd = 0;
            this.anticipatedVectorStartAltitude = 0;
            this.anticipatedVectorGradient = 0;
        }
        this.pathAvailable.set(pathAvailable);
        this.fpa.set(currentFpa);
        this.verticalDeviation.set(UnitType.METER.convertTo(currentDesiredAltitudeMeters, UnitType.FOOT) - this.currentAltitude);
        return true;
    }
    /**
     * Method to get the first idle descent leg and vector index.
     * @param verticalFlightPath The vertical flight path.
     * @param todLegIndex The TOD leg index.
     * @returns An object of {legIndex, vectorIndex} or undefined if none exists.
     */
    getFirstIdleDescentLegVectorIndex(verticalFlightPath, todLegIndex) {
        if (todLegIndex === undefined) {
            return undefined;
        }
        let globalLegIndex = todLegIndex;
        while (globalLegIndex < verticalFlightPath.legs.length) {
            const verticalLeg = verticalFlightPath.legs[globalLegIndex];
            for (let v = 0; v < verticalLeg.vectors.length; v++) {
                const vector = verticalLeg.vectors[v];
                if (vector.type === 'IdleDescent' && vector.startDistanceToLegEnd > vector.endDistanceToLegEnd) {
                    return {
                        legIndex: globalLegIndex,
                        vectorIndex: v
                    };
                }
            }
            globalLegIndex++;
        }
        return undefined;
    }
    /**
     * Method to get the current idle descent vector index.
     * @param verticalLeg The current vertical leg.
     * @param lnavLegDistanceRemaining The currnet lnavLegDistanceRemaining.
     * @returns The current vector index.
     */
    getCurrentVerticalFlightPathVectorIndex(verticalLeg, lnavLegDistanceRemaining) {
        let vectorIndex = 0;
        while (vectorIndex < verticalLeg.vectors.length) {
            const vector = verticalLeg.vectors[vectorIndex];
            if (lnavLegDistanceRemaining > vector.startDistanceToLegEnd && vector.startDistanceToLegEnd > vector.endDistanceToLegEnd) {
                break;
            }
            vectorIndex++;
        }
        return Math.max(0, vectorIndex - 1);
    }
    /**
     * Is VNAV currently the active AP vertical mode
     * @returns true if active
     */
    isVnavActive() {
        const boeingVNavMode = this.boeingVNavMode.get();
        return this.state === VNavState.Enabled_Active
            && boeingVNavMode !== BoeingVNavModes.NONE
            && boeingVNavMode !== BoeingVNavModes.ARMED;
    }
    /**
     * Manage the min and max speeds for path mode.
     * @param lateralLegIndex The active lateral leg index.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    managePathSpeedBand(lateralLegIndex) {
        // const speedInterventionActive = this.speedInterventionActive.get();
        // eslint-disable-next-line max-len
        // const speedRestrictionAltitude = Math.max(this.performancePlan.descentSpeedRestrAltitude.get() ?? 0, this.performancePlan.descentSpeedLimitAltitude.get() ?? 0);
        var _a, _b;
        // const aboveFirstConstraint =
        //   !this.calculator.getCurrentSpeedConstraint(this.options.primaryPlanIndex, lateralLegIndex, VerticalFlightPhase.Descent, false)
        //   && this.currentAltitude > speedRestrictionAltitude;
        const autothrottleActive = this.autothrottleStatus.get() === BoeingAutothrottleStatus.On;
        // const maneuveringSpeed = this.maneuveringSpeed.get();
        // const bestHoldingSpeed = this.holdingSpeed.get();
        // const rawFlapLimitSpeed = this.flapLimitSpeed.get();
        // const currentFlapLimitSpeed = rawFlapLimitSpeed > 100 ? rawFlapLimitSpeed : this.getLowestVmoMmoCas();
        // const airportTransitionSpeed = 250;
        // eslint-disable-next-line max-len
        // const appliedAirportTransitionSpeed = this.currentAltitude < speedRestrictionAltitude ? airportTransitionSpeed : Number.POSITIVE_INFINITY;
        const bandMaxSpeed = this.bandMaxSpeed.get();
        const bandMinSpeed = this.bandMinSpeed.get();
        // let manualTargetSpeed;
        if (bandMaxSpeed && bandMinSpeed) {
            if (!autothrottleActive && this.currentIas < bandMinSpeed) {
                this.dragRequired.set(false);
                this.thrustRequired.set(this.isVnavActive());
                if (this.currentIas < bandMinSpeed) {
                    this.pathDeviationMode.set(PathDeviationMode.BELOW);
                    if ((_a = this.verticalDeviation.get()) !== null && _a !== void 0 ? _a : Number.POSITIVE_INFINITY > 150) ;
                }
            }
            else if (this.currentIas > bandMaxSpeed) {
                this.dragRequired.set(this.isVnavActive());
                this.thrustRequired.set(false);
                if (this.currentIas > bandMaxSpeed) {
                    this.pathDeviationMode.set(PathDeviationMode.ABOVE);
                    if ((_b = this.verticalDeviation.get()) !== null && _b !== void 0 ? _b : Number.NEGATIVE_INFINITY < 150) ;
                }
            }
            else {
                this.dragRequired.set(false);
                this.thrustRequired.set(false);
            }
        }
        // Above First Speed Constraint
        // with greater than 15 knots below the target speed, and autothrottles not
        // active, the CDU help window message THRUST REQUIRED displays.
        // The airspeed may decrease to minimum maneuvering speed.
        // Subsequently, VNAV commands the airplane to fly below the path to
        // stop the deceleration. If VNAV can no longer maintain the airplane
        // within 150 feet of the path without further deceleration, speed reversion
        // occurs, the pitch mode annunciation changes from VNAV PTH to
        // VNAV SPD, VNAV resets the target speed to 5 knots above the greater
        // of best holding speed or minimum maneuvering speed, and the CDU
        // help window message THRUST REQUIRED displays again. With
        // autothrottles active, this condition should not occur as thrust levers are
        // in SPD and target speed is maintained during the descent
        // with greater than VMO/MMO minus 16 knots, the CDU help window
        // message DRAG REQUIRED displays. The airplane may accelerate up
        // to VMO/MMO minus 11 knots to maintain the path. If further
        // correction is required, VNAV may allow the airplane to rise up to 150
        // feet above the path. If VNAV can no longer maintain the airplane within
        // 150 feet of the path without further acceleration, speed reversion occurs,
        // the pitch mode annunciation changes from VNAV PTH to VNAV SPD,
        // VNAV resets the target speed to VMO/MMO minus 16 knots, and the
        // CDU help window message DRAG REQUIRED displays again
        // Below First Speed Constraint
        // with greater than 15 knots below the target speed, and autothrottles not
        // active, the CDU help window message THRUST REQUIRED displays.
        // The airspeed may decrease to minimum maneuvering speed.
        // Subsequently, VNAV commands the airplane to fly below the path to
        // stop the deceleration. If VNAV can no longer maintain the airplane
        // within 150 feet of the path without further deceleration, speed reversion
        // occurs, the pitch mode annunciation changes from VNAV PTH to
        // VNAV SPD, VNAV resets the target speed to 10 knots less than the
        // transition speed for the destination airport (not less than minimum
        // maneuvering speed), and the CDU help window message THRUST
        // REQUIRED displays again. With autothrottles active, this condition
        // should not occur as thrust levers are in SPD and target speed is
        // maintained during the descent
        // with greater than 10 knots above target speed, the CDU help window
        // message DRAG REQUIRED displays. The airplane may accelerate up
        // to 15 knots above target speed to maintain the path. The maximum
        // speed excursion allowed is 5 knots above the transition speed after the
        // airplane is below transition altitude for the destination airport or 5 knots
        // below the flaps placard speed if flaps are extended. If further correction
        // is required, VNAV may allow the airplane to rise up to 150 feet above
        // the path to stop the acceleration. If VNAV can no longer maintain the
        // airplane within 150 feet of the path without further acceleration, speed
        // reversion occurs, the pitch mode annunciation changes from VNAV
        // PTH to VNAV SPD, VNAV commands a speed 10 knots less than the
        // transition speed for the destination airport, and the CDU help message
        // DRAG REQUIRED displays again
    }
    /**
     * Sets the path limit speeds.
     * @param lateralLegIndex The lateral leg index.
     */
    setPathSpeedLimits(lateralLegIndex) {
        var _a, _b, _c, _d;
        const speedTransitionAltitude = (_a = this.performancePlan.descentSpeedLimitAltitude.get()) !== null && _a !== void 0 ? _a : Number.NEGATIVE_INFINITY;
        const speedRestrictionAltitude = (_b = this.performancePlan.descentSpeedRestrAltitude.get()) !== null && _b !== void 0 ? _b : Number.NEGATIVE_INFINITY;
        const speedInterventionActive = this.speedInterventionActive.get();
        const aboveFirstConstraint = !this.calculator.getCurrentSpeedConstraint(this.options.primaryPlanIndex, lateralLegIndex, VerticalFlightPhase.Descent, false)
            && this.currentAltitude > Math.max(speedRestrictionAltitude, speedTransitionAltitude);
        const vmoMmoCas = this.getLowestVmoMmoCas();
        const targetSpeed = this.apActiveSpeedInIas.get();
        const maneuveringSpeed = this.maneuveringSpeed.get();
        const rawFlapLimitSpeed = this.flapLimitSpeed.get();
        const currentFlapLimitSpeed = rawFlapLimitSpeed > 100 ? rawFlapLimitSpeed : vmoMmoCas;
        const airportTransitionSpeed = (_c = this.performancePlan.descentSpeedLimitCas.get()) !== null && _c !== void 0 ? _c : Number.POSITIVE_INFINITY;
        const airportRestrictionSpeed = (_d = this.performancePlan.descentSpeedRestrCas.get()) !== null && _d !== void 0 ? _d : Number.POSITIVE_INFINITY;
        /** whichever of speed trans or speed limit is most constraining, or infinity if neither */
        let appliedAirportTransitionSpeed = this.currentAltitude < speedTransitionAltitude ? airportTransitionSpeed : Number.POSITIVE_INFINITY;
        if (this.currentAltitude < speedRestrictionAltitude) {
            appliedAirportTransitionSpeed = Math.min(airportRestrictionSpeed, appliedAirportTransitionSpeed);
        }
        // the limits before path deviation occurs
        this.pathMaxSpeed.set(
        // speed intervention active and above first constraint
        speedInterventionActive && aboveFirstConstraint ? MathUtils.clamp(vmoMmoCas - 11, targetSpeed, vmoMmoCas) :
            // above first constraint in fms speed
            aboveFirstConstraint ? vmoMmoCas - 11 :
                // speed intervention active below first constraint
                speedInterventionActive ? MathUtils.clamp(Math.min(targetSpeed + 15, currentFlapLimitSpeed - 5, appliedAirportTransitionSpeed + 5), targetSpeed, vmoMmoCas) :
                    // below first constraint in fms speed
                    Math.min(targetSpeed + 15, currentFlapLimitSpeed - 5, appliedAirportTransitionSpeed + 5, vmoMmoCas - 11));
        this.pathMinSpeed.set(
        // speed intervention active
        speedInterventionActive ? MathUtils.clamp(maneuveringSpeed, maneuveringSpeed, targetSpeed) :
            // in fms speed
            maneuveringSpeed);
        // the limits shown on the speed tape and for the drag/thrust required messages
        let bandMaxSpeed = null;
        const highSpeedMaxSpeed = this.pathMaxSpeed.get();
        let bandMinSpeed = null;
        const lowSpeedMinSpeed = this.pathMinSpeed.get();
        if (highSpeedMaxSpeed && lowSpeedMinSpeed) {
            if (aboveFirstConstraint) {
                bandMaxSpeed = Math.max(highSpeedMaxSpeed - 5, targetSpeed);
                bandMinSpeed = MathUtils.clamp(targetSpeed - 15, maneuveringSpeed + 5, targetSpeed);
            }
            else {
                const highAlertSpeed = Math.min(targetSpeed + 10, currentFlapLimitSpeed - 5, appliedAirportTransitionSpeed + 5);
                bandMaxSpeed = speedInterventionActive ? MathUtils.clamp(highAlertSpeed, targetSpeed, vmoMmoCas) :
                    highAlertSpeed;
                bandMinSpeed = MathUtils.clamp(targetSpeed - 15, maneuveringSpeed, targetSpeed);
            }
        }
        this.bandMaxSpeed.set(bandMaxSpeed);
        this.bandMinSpeed.set(bandMinSpeed);
    }
    /**
     * Degrades Path mode to SPD mode.
     * @param manualSpeedToSet The manual speed override to set, in KIAS.
     */
    degradePathModeToSpeedMode(manualSpeedToSet) {
        manualSpeedToSet && this.setManualTargetSpeed(manualSpeedToSet);
        this.pathMode.set(VNavPathMode.PathArmed);
        this.setBoeingVNavMode(BoeingVNavModes.SPD_DESCENT);
    }
    /**
     * Sets a manual target speed.
     * @param ias The IAS to set, or default to current ap speed target
     */
    setManualTargetSpeed(ias) {
        if (ias) {
            SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', 'number', ias);
            SimVar.SetSimVarValue('L:XMLVAR_AirSpeedIsInMach', 'boolean', false);
        }
        else if (this.apActiveSpeedInIas.get()) {
            SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', 'number', this.apActiveIas.get());
            SimVar.SetSimVarValue('L:XMLVAR_AirSpeedIsInMach', 'boolean', false);
        }
        else {
            SimVar.SetSimVarValue('K:AP_MACH_VAR_SET', 'number', Math.round(this.apActiveMach.get() * 100));
            SimVar.SetSimVarValue('L:XMLVAR_AirSpeedIsInMach', 'boolean', true);
        }
        SimVar.SetSimVarValue('L:XMLVAR_SpeedIsManuallySet', SimVarValueType.Bool, true);
    }
    /**
     * Checks whether the VNav Path can go from an armed state to activated state.
     * @returns Whether Path Can Activate.
     */
    canPathActivate() {
        const fpa = this.fpa.get();
        const verticalDeviation = this.verticalDeviation.get();
        const targetAltitude = this.targetAltitude.get();
        if (this.pathMode.get() === VNavPathMode.PathArmed && fpa !== null && verticalDeviation !== null && targetAltitude !== null) {
            const deviationFromTarget = targetAltitude - this.currentAltitude;
            if (fpa !== 0 && !this.pathArmedError.get()) {
                // if (verticalDeviation <= VNavUtils.getPathErrorDistance(this.currentGroundSpeed) && verticalDeviation >= -15) {
                // TODO: I changed this temporarily to 150 instead of the possible 250
                // because of the path degredation causing an activation/degradation loop.
                if (verticalDeviation < 150 && verticalDeviation >= -50 && Math.abs(deviationFromTarget) > 75 && !this.isAltCaptured) {
                    return true;
                    // TEMPO remove this until we sort it out again
                    // if (Math.abs(deviationFromTarget) > 75 && !this.isAltCaptured) {
                    //   const pathMaxSpeed = this.pathMaxSpeed.get();
                    //   const pathMinSpeed = this.pathMinSpeed.get();
                    //   if (pathMaxSpeed && pathMinSpeed && this.currentIas <= pathMaxSpeed && this.currentIas >= pathMinSpeed) {
                    //     return true;
                    //   }
                    // }
                }
            }
        }
        return false;
    }
    /**
     * Checks whether the VNav Path can arm.
     * @returns Whether Path can arm.
     */
    canPathArm() {
        if (this.apValues.verticalActive.get() === APVerticalModes.CAP) {
            return false;
        }
        if (this.awaitingPathRearm && this.lnavLegIndex.get() >= this.pathRearmIndex && this.apValues.verticalArmed.get() !== APVerticalModes.ALT) {
            this.awaitingPathRearm = false;
        }
        if (this.pathMode.get() === VNavPathMode.None && !this.awaitingPathRearm) {
            if (this.preselectedAltitude + 75 < this.currentAltitude || (this.fmsOnApproachMode.get() === true && this.preselectedAltitude > this.currentAltitude + 300)) {
                return true;
            }
            else if (this.tocTodBodDetails.distanceFromTod > 0 &&
                UnitType.METER.convertTo(this.tocTodBodDetails.distanceFromTod, UnitType.NMILE) / (this.currentGroundSpeed / 60) < 0.75) {
                this.checkAltSel.set(true);
            }
        }
        return false;
    }
    /**
     * Method to check the validity of the path.
     * @param lateralPlan The Lateral Flight Plan.
     * @param verticalDeviation The current vertical deviation value.
     * @param constraint The current vnav constraint.
     * @returns Whether the path is currently valid.
     */
    checkPathValidity(lateralPlan, verticalDeviation, constraint) {
        if (constraint === undefined || this.pathAvailable.get() === false || verticalDeviation === null) {
            this.clearAllMessages();
            this.pathArmedError.set(true);
            return false;
        }
        this.noPathPilotCmd.set(this.checkPathPilotCmd(verticalDeviation));
        const pathArmed = this.pathMode.get() === VNavPathMode.PathArmed;
        const pathActive = this.pathMode.get() === VNavPathMode.PathActive;
        const pathArmedOrActive = pathArmed || pathActive;
        const notInAltHold = this.apValues.verticalActive.get() !== APVerticalModes.ALT;
        // Deal with Path Below Aircraft Message
        if (this.pathBelowAircraft.get() === true && (!pathArmed || verticalDeviation > -10)) {
            this.pathBelowAircraft.set(false);
        }
        if (pathArmed && this.checkPathBelowAircraft(verticalDeviation)) {
            this.pathBelowAircraft.set(true);
        }
        const lateralLegIndex = this.lnavLegIndex.get();
        const ineligibleLeg = this.getIneligibleLeg(lateralPlan, constraint, lateralLegIndex);
        // NO_VPATH_CONDITION: manually terminated leg between the TOD and the
        // altitude constraint waypoint or other FPL edit moved the vertical path.
        if (pathActive && this.lateralPlanChangedCheckDeviation) {
            if (Math.abs(verticalDeviation) > 100) {
                this.noPathConditionPlanChanged.set(true);
            }
        }
        this.noPathConditionDisco.set(pathArmedOrActive && ineligibleLeg !== undefined && this.isLegDiscontinuity(ineligibleLeg));
        // NO_VPATH_VECTORS: Shows when VPATH mode has automatically reverted to VPITCH mode because there is a heading leg in the
        // FMS flight plan. Message also clears after the aircraft passes the heading leg
        this.noPathVectors.set(pathArmedOrActive && ineligibleLeg !== undefined && this.isLegVectors(ineligibleLeg));
        // NO_VPATH_THIS_LEG: Active leg is hold or procedure turn
        const activeLeg = lateralPlan.tryGetLeg(lateralLegIndex);
        if (activeLeg !== null) {
            // TODO: Should this still apply? I have deactivated this rule for now
            // this.noPathThisLeg.set(VNavUtils.isLegTypeHoldOrProcedureTurn(activeLeg));
            this.noPathThisLeg.set(false);
        }
        else {
            this.noPathThisLeg.set(false);
        }
        // NO_VPATH_TAE: Track angle error exceeds an acceptable threshold
        this.noPathTae.set(pathArmedOrActive && this.isTaeOutsideLimits());
        // NO_VPATH_XTK: Cross track deviation exceeds an acceptable threshold
        this.noPathXtk.set(pathArmedOrActive && this.isXtkOutsideLimits());
        // UNABLE_NEXT_ALT: current fpa insufficient OR (in vertical dto) Required FPA on path exceeds limits
        const unableNextAltCondition = notInAltHold && this.isRequiredFpaOutsideLimits();
        if (unableNextAltCondition) {
            const unableNextAltTimer = this.unableNextAltTimer.get();
            if (unableNextAltTimer === -1) {
                this.unableNextAltTimer.set(Date.now());
            }
            else if (Date.now() - unableNextAltTimer > (1000 * 60)) {
                this.unableNextAlt.set(true);
            }
        }
        else {
            this.unableNextAlt.set(false);
            this.unableNextAltTimer.set(-1);
        }
        this.pathArmedError.set(this.pathBelowAircraft.get() ||
            this.noPathTae.get() ||
            this.noPathXtk.get() ||
            this.noPathThisLeg.get() ||
            this.noPathConditionDisco.get() ||
            this.noPathConditionPlanChanged.get() ||
            this.noPathVectors.get() ||
            this.pilotPathIntervention);
        return !this.pathArmedError.get();
    }
    /**
     * Checks if the path is below the aircraft;
     * @param verticalDeviation The current deviation.
     * @returns True if the path is below the aircraft.
     */
    checkPathBelowAircraft(verticalDeviation) {
        // PATH_BELOW_AC: Path is below the aircraft
        return verticalDeviation < -50;
    }
    /**
     * Gets the VPath ineligible leg if one exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param constraint The constraint.
     * @param legIndex The current active leg index.
     * @returns the Leg or undefined.
     */
    getIneligibleLeg(lateralPlan, constraint, legIndex) {
        const lateralLegIndex = this.lnavLegIndex.get();
        if (constraint.nextVnavEligibleLegIndex !== undefined && lateralLegIndex < constraint.nextVnavEligibleLegIndex) {
            for (let l = constraint.nextVnavEligibleLegIndex - 1; l > legIndex; l--) {
                const leg = lateralPlan.tryGetLeg(l);
                if (leg !== null) {
                    const legIsEligible = SmoothingPathCalculator.isLegVnavEligible(leg);
                    if (!legIsEligible) {
                        return leg;
                    }
                }
            }
        }
        return undefined;
    }
    /**
     * Checks if a leg is a vectors leg.
     * @param leg The Leg.
     * @returns Whether the leg is vectors.
     */
    isLegVectors(leg) {
        switch (leg.leg.type) {
            case LegType.FM:
            case LegType.VM:
                return true;
        }
        return false;
    }
    /**
     * Checks if a leg is a discontinuity.
     * @param leg The Leg.
     * @returns Whether the leg is a disco.
     */
    isLegDiscontinuity(leg) {
        switch (leg.leg.type) {
            case LegType.Discontinuity:
            case LegType.ThruDiscontinuity:
                return true;
        }
        return false;
    }
    /**
     * Checks the pilot path command state.
     * @param verticalDeviation The current vertical deviation.
     * @returns whether the pilot has intervened in the path.
     */
    checkPathPilotCmd(verticalDeviation) {
        // NO_VPATH_PILOT_CMD: Pilot selected another mode while path is active
        // and vnav remains on (track deviation > one dot / vnav recycled)
        const oneDotDeviation = 100;
        if (Math.abs(verticalDeviation) > oneDotDeviation && this.pilotPathIntervention) {
            this.pilotPathIntervention = false;
        }
        return this.pilotPathIntervention;
    }
    /**
     * Checks whether the XTK is out of limits for VPATH.
     * @returns if the XTK is out of limits.
     */
    isXtkOutsideLimits() {
        let xtkErrorLimit = 10;
        const distanceToDestinationArp = this.lnavDataDestinationDistanceDirect.get();
        switch (this.lnavDataCdiScaleLabel.get()) {
            case CDIScaleLabel.Terminal:
            case CDIScaleLabel.TerminalArrival:
            case CDIScaleLabel.TerminalDeparture:
                {
                    const minimumTerminalXtkError = 1.1;
                    const minimumTerminalDistance = 5;
                    const maximumTerminalXtkError = 10;
                    const maximumTerminalDistance = 31;
                    const terminalErrorPercentage = (distanceToDestinationArp - minimumTerminalDistance) / (maximumTerminalDistance - minimumTerminalDistance);
                    const terminalErrorRaw = (maximumTerminalXtkError - minimumTerminalXtkError) * terminalErrorPercentage;
                    xtkErrorLimit = MathUtils.clamp(terminalErrorRaw, minimumTerminalXtkError, maximumTerminalXtkError);
                }
                break;
            case CDIScaleLabel.Approach:
                {
                    const distanceToFaf = this.lnavDataDistanceToFaf.get();
                    const minimumApproachXtkError = 0.3;
                    const maximumApproachXtkError = 1;
                    const maximumApproachDistance = 2;
                    const approachErrorPercentage = (distanceToFaf) / (maximumApproachDistance);
                    const approachErrorRaw = (maximumApproachXtkError - minimumApproachXtkError) * approachErrorPercentage;
                    xtkErrorLimit = MathUtils.clamp(approachErrorRaw, minimumApproachXtkError, maximumApproachXtkError);
                }
                break;
        }
        return Math.abs(this.lnavXtk.get()) > xtkErrorLimit;
    }
    /**
     * Checks if the TAE is out of limits for VPATH.
     * @returns if TAE is out of limits.
     */
    isTaeOutsideLimits() {
        const tae = Math.abs(NavMath.diffAngle(this.lnavDtk.get(), this.trueTrack));
        let taeErrorLimit = 75;
        switch (this.lnavDataCdiScaleLabel.get()) {
            case CDIScaleLabel.Approach:
                taeErrorLimit = 30;
                break;
        }
        return tae > taeErrorLimit;
    }
    /**
     * Checks if the required FPA is out of limits.
     * @returns if the required FPA is out of limits.
     */
    isRequiredFpaOutsideLimits() {
        // const currentVs = this.currentVS;
        var _a;
        // In the WT21, we use manual constraints for VDTOs
        const inVerticalDto = ((_a = this.nextConstraintDetails.get()) === null || _a === void 0 ? void 0 : _a.type) === 'manual';
        let requiredFpa = null;
        if (inVerticalDto) {
            const constraint = this.nextConstraintDetails.get();
            // We calculate our own FPA here, since `SmoothingPathCalculator` clamps the fpa to the maximum allowed fpa.
            // Also, in a vdto it seems the fpa is not constantly updated.
            if (constraint) {
                const constraintDistanceNM = UnitType.NMILE.convertFrom(constraint.distance, UnitType.METER);
                const currentAlongLegDistance = this.lnavLegDistanceAlong.get();
                const distanceToConstraint = constraintDistanceNM - currentAlongLegDistance;
                const distanceToConstraintMetres = UnitType.METER.convertFrom(distanceToConstraint, UnitType.NMILE);
                const currentAltitudeMetres = UnitType.METER.convertFrom(this.currentAltitude, UnitType.FOOT);
                const heightToConstraint = currentAltitudeMetres - constraint.targetAltitude;
                requiredFpa = VNavUtils.getFpa(distanceToConstraintMetres, heightToConstraint);
            }
        }
        // const vsCondition = requiredVs !== null && Math.abs(currentVs) < (Math.abs(requiredVs) - 50); // We can be up to 50 fpm below
        // TODO: Fix if needed
        const vsCondition = false;
        const vdtoFpaCondition = inVerticalDto && requiredFpa !== null && requiredFpa > 6.0;
        return vsCondition || vdtoFpaCondition;
    }
    /**
     * Method to reset all error messages.
     */
    clearAllMessages() {
        this.pathBelowAircraft.set(false);
        this.checkAltSel.set(false);
        this.noPathTae.set(false);
        this.noPathXtk.set(false);
        this.noPathThisLeg.set(false);
        this.noPathPilotCmd.set(false);
        this.noPathConditionPlanChanged.set(false);
        this.noPathConditionDisco.set(false);
        this.noPathVectors.set(false);
        this.checkFplnAlt.set(false);
    }
    /**
     * Method to monitor message state.
     */
    monitorMessages() {
        // init messages
        this.clearAllMessages();
        // monitor messages
        this.dragRequired.sub(v => {
            if (v) {
                this.messageService.sendMessage(BoeingFmcErrorKeys.DragRequired);
            }
            else {
                this.messageService.clearMessage(BoeingFmcErrorKeys.DragRequired);
            }
        });
        this.thrustRequired.sub(v => {
            if (v) {
                this.messageService.sendMessage(BoeingFmcErrorKeys.ThrustRequired);
            }
            else {
                this.messageService.clearMessage(BoeingFmcErrorKeys.ThrustRequired);
            }
        });
        this.resetMcpAlt.sub(v => {
            if (v) {
                this.messageService.sendMessage(BoeingFmcErrorKeys.ResetMcpAlt);
            }
            else {
                this.messageService.clearMessage(BoeingFmcErrorKeys.ResetMcpAlt);
            }
        });
        // reset the message on the phase changing, allowing it to be re-triggered
        this.fmsOperatingPhase.sub(() => this.resetMcpAlt.set(false));
        // this.withinOneMinuteTod.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.TOD, undefined, () => this.withinFiveSecondsTod.get());
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.TOD);
        //   }
        // });
        // this.pathBelowAircraft.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.PATH_BELOW_AC);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.PATH_BELOW_AC);
        //   }
        // });
        // this.noPathTae.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_TAE);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_TAE);
        //   }
        // });
        // this.noPathXtk.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_XTK);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_XTK);
        //   }
        // });
        // this.noPathThisLeg.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_THIS_LEG);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_THIS_LEG);
        //   }
        // });
        // this.noPathPilotCmd.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_PILOT_CMD);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_PILOT_CMD);
        //   }
        // });
        // this.noPathConditionDisco.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_CONDITION);
        //   } else if (!this.noPathConditionPlanChanged.get()) {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_CONDITION);
        //   }
        // });
        // this.noPathConditionPlanChanged.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_CONDITION);
        //   } else if (!this.noPathConditionDisco.get()) {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_CONDITION);
        //   }
        // });
        // this.noPathVectors.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.NO_VPATH_VECTORS);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.NO_VPATH_VECTORS);
        //   }
        // });
        // this.checkAltSel.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.CHK_ALT_SEL);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.CHK_ALT_SEL);
        //   }
        // });
        // this.checkFplnAlt.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.CHECK_FPLN_ALT);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.CHECK_FPLN_ALT);
        //   }
        // });
        // this.unableNextAlt.sub(v => {
        //   if (v) {
        //     this.messageService.post(FMS_MESSAGE_ID.UNABLE_NEXT_ALT);
        //   } else {
        //     this.messageService.clear(FMS_MESSAGE_ID.UNABLE_NEXT_ALT);
        //   }
        // });
    }
    /**
     * Method to monitor VNavVars.
     */
    monitorVars() {
        // init vnav vars
        this.initVars();
        this.pathMode.sub(mode => {
            SimVar.SetSimVarValue(VNavVars.PathMode, SimVarValueType.Number, mode);
            if (mode === VNavPathMode.PathArmed || mode === VNavPathMode.PathActive) {
                this.checkAltSel.set(false);
            }
        });
        this.vnavState.sub(state => SimVar.SetSimVarValue(VNavVars.VNAVState, SimVarValueType.Number, state));
        this.pathAvailable.sub(v => SimVar.SetSimVarValue(VNavVars.PathAvailable, SimVarValueType.Bool, v));
        this.currentConstraintAltitude.sub(alt => SimVar.SetSimVarValue(VNavVars.CurrentConstraintAltitude, SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
        this.nextConstraintAltitude.sub(alt => SimVar.SetSimVarValue(VNavVars.NextConstraintAltitude, SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
        this.targetAltitude.sub(alt => SimVar.SetSimVarValue(VNavVars.TargetAltitude, SimVarValueType.Feet, alt !== null && alt !== void 0 ? alt : -1));
        this.fpa.sub(fpa => SimVar.SetSimVarValue(VNavVars.FPA, SimVarValueType.Degree, fpa !== null && fpa !== void 0 ? fpa : 0));
        this.verticalDeviation.sub(dev => SimVar.SetSimVarValue(VNavVars.VerticalDeviation, SimVarValueType.Feet, dev !== null && dev !== void 0 ? dev : Number.MAX_SAFE_INTEGER));
        // this.requiredVS.sub(vs => SimVar.SetSimVarValue(VNavVars.RequiredVS, SimVarValueType.FPM, vs ?? 0));
        this.captureType.sub(type => SimVar.SetSimVarValue(VNavVars.CaptureType, SimVarValueType.Number, type));
        this.vnavNextLegTargetAltitude.sub(v => {
            this.bus.getPublisher().pub('vnav_active_leg_alt', v !== null && v !== void 0 ? v : 0, true, false);
        });
        this.rnp.sub((rnp) => SimVar.SetSimVarValue(BoeingVNavVars.RNP, SimVarValueType.Number, rnp !== null && rnp !== void 0 ? rnp : 400), true);
        const pub = this.bus.getPublisher();
        this.bandMaxSpeed.sub(ias => pub.pub('vnav_boeing_band_speed_max', ias, true, true));
        this.bandMinSpeed.sub(ias => pub.pub('vnav_boeing_band_speed_min', ias, true, true));
        this.pathMaxSpeed.sub(ias => pub.pub('vnav_boeing_path_speed_max', ias, true, true));
        this.pathMinSpeed.sub(ias => pub.pub('vnav_boeing_path_speed_min', ias, true, true));
    }
    /**
     * Method to reset VNAV Vars.
     */
    initVars() {
        SimVar.SetSimVarValue(VNavVars.VNAVState, SimVarValueType.Number, VNavState.Enabled_Inactive);
        SimVar.SetSimVarValue(VNavVars.PathMode, SimVarValueType.Number, VNavPathMode.None);
        SimVar.SetSimVarValue(VNavVars.PathAvailable, SimVarValueType.Bool, false);
        SimVar.SetSimVarValue(VNavVars.CurrentConstraintAltitude, SimVarValueType.Feet, -1);
        SimVar.SetSimVarValue(VNavVars.NextConstraintAltitude, SimVarValueType.Feet, -1);
        SimVar.SetSimVarValue(VNavVars.TargetAltitude, SimVarValueType.Feet, -1);
        SimVar.SetSimVarValue(VNavVars.FPA, SimVarValueType.Degree, 0);
        SimVar.SetSimVarValue(VNavVars.VerticalDeviation, SimVarValueType.Feet, Number.MAX_SAFE_INTEGER);
        SimVar.SetSimVarValue(VNavVars.RequiredVS, SimVarValueType.FPM, 0);
        SimVar.SetSimVarValue(VNavVars.CaptureType, SimVarValueType.Number, BoeingVNavAltCaptureType.None);
        SimVar.SetSimVarValue(VNavVars.GPVerticalDeviation, SimVarValueType.Feet, -1001);
        SimVar.SetSimVarValue(VNavVars.GPDistance, SimVarValueType.Meters, -1);
        SimVar.SetSimVarValue(VNavVars.GPFpa, SimVarValueType.Degree, 0);
    }
    /**
     * Resets the path-related VNavVars
     */
    resetVNavVars() {
        this.pathAvailable.set(false);
        this.currentConstraintAltitude.set(null);
        this.nextConstraintAltitude.set(null);
        this.targetAltitude.set(null);
        this.fpa.set(null);
        this.verticalDeviation.set(null);
        // this.requiredVS.set(null);
        this.captureType.set(BoeingVNavAltCaptureType.None);
    }
    /**
     * Resets the TOD BOD Values
     */
    resetTodBodVars() {
        this.tocTodDetailsSub.set('bodLegIndex', -1);
        this.tocTodDetailsSub.set('todLegIndex', -1);
        this.tocTodDetailsSub.set('todLegDistance', 0);
        this.tocTodDetailsSub.set('distanceFromTod', 0);
        this.tocTodDetailsSub.set('bodConstraintIndex', -1);
        this.tocTodDetailsSub.set('bodLegIndex', -1);
        this.tocTodDetailsSub.set('performanceTodLegIndex', -1);
        this.tocTodDetailsSub.set('performanceTodLegDistance', 0);
        this.tocTodDetailsSub.set('distanceFromPerformanceTod', -1);
    }
    /**
     * Manages The Altitude Capture Type.
     */
    manageAltCaptureType() {
        const targetAltFeet = this.targetAltitude.get();
        const currentMode = this.boeingVNavMode.get();
        switch (currentMode) {
            case BoeingVNavModes.PATH_IDLE:
            case BoeingVNavModes.PATH_DESCENT:
            case BoeingVNavModes.SPD_DESCENT:
            case BoeingVNavModes.THR_DESCENT:
                this.captureType.set(targetAltFeet && Math.round(this.preselectedAltitude) >= Math.round(targetAltFeet) ? BoeingVNavAltCaptureType.Selected :
                    BoeingVNavAltCaptureType.VNAV);
                break;
            case BoeingVNavModes.SPD_CLIMB:
                {
                    const altCapturing = targetAltFeet !== null ? Math.round(Math.min(this.preselectedAltitude, targetAltFeet)) : Math.round(this.preselectedAltitude);
                    this.captureType.set((altCapturing === Math.round(this.cruiseAltitude) ? BoeingVNavAltCaptureType.Cruise :
                        !targetAltFeet || (targetAltFeet && Math.round(this.preselectedAltitude) <= Math.round(targetAltFeet)) ? BoeingVNavAltCaptureType.Selected :
                            BoeingVNavAltCaptureType.VNAV));
                }
                break;
        }
    }
    /**
     * Manages the TOD BOD Details based on any set cruise altitude.
     * @param verticalPlan The vertical flight plan.
     * @param verticalFlightPath The vertical flight path.
     * @param lateralPlan The lateral flight plan.
     * @param activeConstraintIndex The constraint index that containes the active lateral leg.
     * @param lateralLegIndex The current lateral leg index.
     * @param alongLegDistance The current along leg distance.
     * @param legDistanceRemaining The current leg distance remaining.
     * @returns BoeingTodBodDetails.
     */
    manageTocTodBodDetails(verticalPlan, verticalFlightPath, lateralPlan, activeConstraintIndex, lateralLegIndex, alongLegDistance, legDistanceRemaining) {
        const calculate = (this.tocTodBodDetails.todLegIndex === -1 && this.tocTodBodDetails.todLegIndex === -1) || this._realTime - this.todCalculatedTimer > 1000;
        if (calculate) {
            const todBodDetails = this.getTocTodBodDetails(verticalPlan, verticalFlightPath, lateralPlan, activeConstraintIndex, lateralLegIndex, alongLegDistance, legDistanceRemaining, this.tocTodBodDetails);
            this.tocTodDetailsSub.set('tocLegIndex', todBodDetails.tocLegIndex);
            this.tocTodDetailsSub.set('tocLegDistance', todBodDetails.tocLegDistance);
            this.tocTodDetailsSub.set('tocAltitude', todBodDetails.tocAltitude);
            this.tocTodDetailsSub.set('todConstraintIndex', todBodDetails.todConstraintIndex);
            this.tocTodDetailsSub.set('todLegIndex', todBodDetails.todLegIndex);
            this.tocTodDetailsSub.set('todLegDistance', todBodDetails.todLegDistance);
            this.tocTodDetailsSub.set('distanceFromTod', todBodDetails.distanceFromTod);
            this.tocTodDetailsSub.set('performanceTodExists', todBodDetails.performanceTodExists);
            this.tocTodDetailsSub.set('performanceTodLegIndex', todBodDetails.performanceTodLegIndex);
            this.tocTodDetailsSub.set('performanceTodLegDistance', todBodDetails.performanceTodLegDistance);
            this.tocTodDetailsSub.set('distanceFromPerformanceTod', todBodDetails.distanceFromPerformanceTod);
            this.tocTodDetailsSub.set('bodLegIndex', todBodDetails.bodLegIndex);
            this.tocTodDetailsSub.set('bodConstraintIndex', todBodDetails.bodConstraintIndex);
            this.todCalculatedTimer = Date.now();
            return todBodDetails;
        }
        return this.tocTodBodDetails;
    }
    /**
     * Publishes TOD/BOD details to simvars.
     * @param details The TOD/BOD details object.
     * @param key The key to publish.
     * @param value The value to publish.
     */
    publishTODBODDetails(details, key, value) {
        switch (key) {
            case 'bodLegIndex':
                SimVar.SetSimVarValue(VNavVars.BODLegIndex, SimVarValueType.Number, value);
                break;
            case 'todLegIndex':
                SimVar.SetSimVarValue(VNavVars.TODLegIndex, SimVarValueType.Number, value);
                break;
            case 'todLegDistance':
                SimVar.SetSimVarValue(VNavVars.TODDistanceInLeg, SimVarValueType.Meters, value);
                break;
            case 'distanceFromTod':
                SimVar.SetSimVarValue(VNavVars.TODDistance, SimVarValueType.Meters, value);
                break;
            case 'tocLegIndex':
                SimVar.SetSimVarValue(VNavVars.TOCLegIndex, SimVarValueType.Meters, value);
                break;
            case 'tocLegDistance':
                SimVar.SetSimVarValue(VNavVars.TOCDistanceInLeg, SimVarValueType.Meters, value);
                break;
            case 'performanceTodLegIndex':
                SimVar.SetSimVarValue(BoeingVNavVars.PerformanceTODLegIndex, SimVarValueType.Number, value);
                break;
            case 'performanceTodLegDistance':
                SimVar.SetSimVarValue(BoeingVNavVars.PerformanceTODDistanceInLeg, SimVarValueType.Meters, value);
                break;
            case 'distanceFromPerformanceTod':
                SimVar.SetSimVarValue(BoeingVNavVars.PerformanceTODDistance, SimVarValueType.Meters, value);
                break;
        }
    }
    /**
     * Gets the VNAV TOC/TOD/BOD details for a vertical flight plan.
     * @param verticalPlan The vertical flight plan.
     * @param verticalFlightPath The vertical flight path.
     * @param lateralPlan The lateral plan.
     * @param activeConstraintIndex The index of the VNAV constraint containing the active flight plan leg.
     * @param activeLegIndex The global index of the active flight plan leg.
     * @param distanceAlongLeg The along-track distance from the start of the active flight plan leg to the airplane's
     * position, in meters.
     * @param legDistanceRemaining The along-track leg distance remaining, in meters.
     * @param out The object to which to write the TOD/BOD details.
     * @returns The VNAV TOD/BOD details.
     */
    getTocTodBodDetails(verticalPlan, verticalFlightPath, lateralPlan, activeConstraintIndex, activeLegIndex, distanceAlongLeg, legDistanceRemaining, out) {
        var _a;
        out.todLegIndex = -1;
        out.bodLegIndex = -1;
        out.todLegDistance = 0;
        out.distanceFromTod = 0;
        out.bodConstraintIndex = -1;
        out.todConstraintIndex = -1;
        out.performanceTodExists = false;
        out.performanceTodLegDistance = 0;
        out.performanceTodLegIndex = -1;
        out.distanceFromPerformanceTod = 0;
        out.tocLegDistance = 0;
        out.tocLegIndex = -1;
        out.tocAltitude = (_a = this.performancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : 0;
        const activeConstraint = verticalPlan.constraints[activeConstraintIndex];
        // There is no TOD/BOD if...
        if (
        // ... there is no active VNAV constraint.
        !activeConstraint
            // ... there is no first descent constraint index.
            || verticalPlan.firstDescentConstraintLegIndex === undefined) {
            return out;
        }
        // before TOD, TOD is where the deceleration begins, and that is always the verticalFlightPath.todLegIndex + todDistanceToLegEnd
        if (verticalFlightPath.todLegIndex !== undefined && verticalFlightPath.todDistanceToLegEnd !== undefined) {
            const activeVerticalFlightPathLeg = verticalFlightPath.legs[activeLegIndex];
            const activeVector = activeVerticalFlightPathLeg.vectors[this.activeVerticalVectorIndex];
            out.performanceTodLegIndex = verticalFlightPath.todLegIndex;
            out.performanceTodLegDistance = verticalFlightPath.todDistanceToLegEnd;
            if (activeVector && this.isVectorTypeClimbOrCruise(activeVector.type)) {
                // We have not passed the decel TOD
                out.todLegIndex = verticalFlightPath.todLegIndex;
                out.todLegDistance = verticalFlightPath.todDistanceToLegEnd;
            }
            else if (activeVector && activeVector.type === 'LevelDeceleration') {
                // We have passed the decel TOD and now want to find the descent start
                out.todLegIndex = verticalFlightPath.todLegIndex;
                out.todLegDistance = activeVector.endDistanceToLegEnd;
            }
            else {
                // Otherwise there is no TOD.
                out.todLegIndex = -1;
                out.todLegDistance = 0;
            }
            out.performanceTodExists = out.performanceTodLegIndex > -1;
            // Get the distance to TOD
            const currentLeg = lateralPlan.tryGetLeg(activeLegIndex);
            const todLeg = lateralPlan.tryGetLeg(verticalFlightPath.todLegIndex);
            if (out.todLegIndex > -1 && todLeg && todLeg.calculated && currentLeg && currentLeg.calculated) {
                const distanceFromCurrentLegToTodLeg = todLeg.calculated.cumulativeDistanceWithTransitions - currentLeg.calculated.cumulativeDistanceWithTransitions;
                out.distanceFromTod = distanceFromCurrentLegToTodLeg + legDistanceRemaining - out.todLegDistance;
            }
            else {
                out.distanceFromTod = 0;
            }
            // Get the distance to Performance (decel) TOD
            if (out.performanceTodExists && todLeg && todLeg.calculated && currentLeg && currentLeg.calculated) {
                const distanceFromCurrentLegToTodLeg = todLeg.calculated.cumulativeDistanceWithTransitions - currentLeg.calculated.cumulativeDistanceWithTransitions;
                out.distanceFromPerformanceTod = distanceFromCurrentLegToTodLeg + legDistanceRemaining - out.performanceTodLegDistance;
            }
            else {
                out.distanceFromPerformanceTod = 0;
            }
        }
        // Find the top of climb
        if (verticalFlightPath.tocLegIndex !== undefined
            && verticalFlightPath.tocDistanceToLegEnd !== undefined
            && this.vnavTrackingPhase.get() === BoeingVNavTrackingPhase.Climb
            && this.fmsOperatingPhase.get() < 3) { // 3 = cruise
            out.tocLegDistance = verticalFlightPath.tocDistanceToLegEnd;
            out.tocLegIndex = verticalFlightPath.tocLegIndex;
        }
        // Find the end of descent in the vertical plan, which will be the last descent constraint in the plan for the Boeing.
        let bodConstraintIndex = -1;
        let bodConstraint;
        for (let i = 0; i < verticalPlan.constraints.length; i++) {
            const constraint = verticalPlan.constraints[i];
            // If we encounter a climb constraint, skip it.
            if (constraint.type === 'climb' || constraint.type === 'missed' || !isFinite(constraint.maxAltitude)) {
                continue;
            }
            else {
                bodConstraintIndex = i;
                bodConstraint = constraint;
                break;
            }
        }
        if (!bodConstraint) {
            out.bodConstraintIndex = -1;
            out.bodLegIndex = -1;
        }
        else {
            out.bodConstraintIndex = bodConstraintIndex;
            out.bodLegIndex = bodConstraint.index;
        }
        const todConstraint = VNavUtils.getConstraintFromLegIndex(verticalPlan, out.todLegIndex);
        out.todConstraintIndex = todConstraint ? todConstraint.index : -1;
        return out;
    }
    /**
     * Sets the default RNP value based on altitude
     */
    manageDefaultRnp() {
        if (this.altimeterIsStd) {
            this.defaultRnp.set(400);
        }
        else if (this.currentAltitude < 10000 && this.apValues.capturedAltitude.get() !== 10000) {
            this.defaultRnp.set(125);
        }
        else {
            this.defaultRnp.set(200);
        }
    }
    /**
     * Manages the availability of DES DIR and DES NOW functions
     */
    manageDesDirNow() {
        let desDirAvailable = false;
        let desNowAvailable = false;
        const fmsPhase = this.fmsOperatingPhase.get();
        const plan = this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const constraintLookupGlobalLegIndex = plan.activeLateralLeg;
        const nextConstraint = VNavUtils.getNextDescentTargetConstraint(this.calculator.getVerticalFlightPlan(this.options.primaryPlanIndex), constraintLookupGlobalLegIndex);
        const altWindow = this.apValues.selectedAltitude.get();
        const altWindowMetres = UnitType.METER.convertFrom(altWindow, UnitType.FOOT);
        const mcpAltBelowConstraint = !!nextConstraint && (nextConstraint.minAltitude === -Infinity || nextConstraint.minAltitude > altWindowMetres);
        if (fmsPhase === FmsOperatingPhase.DESCENT || fmsPhase === FmsOperatingPhase.APPROACH) {
            if (mcpAltBelowConstraint) {
                const constraintLeg = plan.tryGetLeg(nextConstraint.index);
                // Do not delete past and including MAP constraint
                if (constraintLeg && !BitFlags.isAll(constraintLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                    desDirAvailable = true;
                }
            }
        }
        else if (fmsPhase === FmsOperatingPhase.CRUISE) {
            desNowAvailable = altWindow < (this.cruiseAltitude - 50) || mcpAltBelowConstraint;
        }
        this.desDirAvailable.set(desDirAvailable);
        this.desNowAvailable.set(desNowAvailable);
    }
    /**
     * Activates the DES DIR function, deleting all descent constraints above the MCP altitude
     */
    activateDesDir() {
        if (!this.desDirAvailable.get()) {
            return;
        }
        const mcpAlt = this.apValues.selectedAltitude.get();
        this.tryDeleteNextDesAltitudeConstraintAbove(mcpAlt, undefined, true);
    }
    /**
     * Delete the next descent altitude constraint above the given altitude
     * @param altitude altitude the constraint must be above to be deleted in feet
     * @param startIndex the global leg index to start deleting from. Defaults to active lateral leg global index.
     * @param repeat When false, will only run once, deleting at most 1 constraint,
     * when true, will keep deleting constraints until it hits the MAP or runs out of legs.
     */
    tryDeleteNextDesAltitudeConstraintAbove(altitude, startIndex, repeat = false) {
        const plan = this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (startIndex === undefined) {
            startIndex = plan.activeLateralLeg;
        }
        const nextConstraint = VNavUtils.getNextDescentTargetConstraint(this.calculator.getVerticalFlightPlan(this.options.primaryPlanIndex), startIndex);
        const altitudeMetres = UnitType.METER.convertFrom(altitude, UnitType.FOOT);
        if (nextConstraint && (nextConstraint.minAltitude === -Infinity || nextConstraint.minAltitude > altitudeMetres)) {
            const constraintLeg = plan.getLeg(nextConstraint.index);
            // Do not delete past and including MAP constraint
            if (!BitFlags.isAll(constraintLeg.leg.fixTypeFlags, FixTypeFlags.MAP)) {
                this.deleteVnavConstraint(plan, nextConstraint);
                if (repeat) {
                    const nextStartIndex = plan.getLegIndexFromLeg(constraintLeg) + 1;
                    this.tryDeleteNextDesAltitudeConstraintAbove(altitude, nextStartIndex, true);
                }
            }
        }
    }
    /**
     * Activates the DES NOW function
     */
    activateDesNow() {
        if (this.desNowAvailable.get()) {
            this.commandEarlyDescent();
        }
    }
    /**
     * Gets the along-track distance, in meters, from a point along the flight plan to the end of a VNAV constraint.
     * @param verticalPlan The vertical flight plan.
     * @param constraintIndex The index of the VNAV constraint to calculate the distance to.
     * @param globalLegIndex The global index of the flight plan leg along which the point to check lies.
     * @param distanceAlongLeg The distance, in meters, from the start of the flight plan leg to the point to check.
     * @returns The along-track distance, in meters, from the specified point to the end of the VNAV constraint.
     */
    getDistanceToConstraint(verticalPlan, constraintIndex, globalLegIndex, distanceAlongLeg) {
        const currentConstraintIndex = constraintIndex;
        const currentConstraint = verticalPlan.constraints[currentConstraintIndex];
        if (currentConstraint === undefined) {
            return 0;
        }
        const constraintLegIndex = currentConstraint.index;
        const startIndex = Math.min(constraintLegIndex + 1, globalLegIndex);
        const endIndex = Math.max(constraintLegIndex, globalLegIndex - 1) + 1;
        let distance = 0;
        for (let i = 0; i < verticalPlan.segments.length; i++) {
            const segment = verticalPlan.segments[i];
            const end = Math.min(segment.legs.length, endIndex - segment.offset);
            for (let j = Math.max(0, startIndex - segment.offset); j < end; j++) {
                const leg = segment.legs[j];
                distance += leg.distance * (segment.offset + j < globalLegIndex ? -1 : 1);
            }
        }
        distance -= distanceAlongLeg;
        return distance;
    }
    /**
     * Gets the next vertical flight path vector eligible to be anticipated following a given vector. The anticipated
     * vector is the next non-zero length vector with a flight path angle that is different from the current vector and
     * is connected to the current vector by a series of vectors with no discontinuities in altitude.
     * @param verticalFlightPath The vertical flight path.
     * @param currentLegIndex The index of the leg containing the current vector.
     * @param currentVectorIndex The index of the current vector in its containing leg.
     * @param out The object to which to write the results.
     * @returns The leg and vector indexes of the next vertical flight path vector eligible to be anticipated following
     * the specified vector, or `undefined` if one could not be found.
     */
    static getNextAnticipatedVerticalFlightPathVector(verticalFlightPath, currentLegIndex, currentVectorIndex, out) {
        var _a;
        out.legIndex = -1;
        out.vectorIndex = -1;
        let currentVector = (_a = verticalFlightPath.legs[currentLegIndex]) === null || _a === void 0 ? void 0 : _a.vectors[currentVectorIndex];
        if (!currentVector) {
            return undefined;
        }
        const currentVectorGradient = (currentVector.endAltitude - currentVector.startAltitude) / (currentVector.startDistanceToLegEnd - currentVector.endDistanceToLegEnd);
        for (let i = currentLegIndex; i < verticalFlightPath.legs.length; i++) {
            const leg = verticalFlightPath.legs[i];
            for (let j = i === currentLegIndex ? currentVectorIndex + 1 : 0; j < leg.vectors.length; j++) {
                const vector = leg.vectors[j];
                if (Math.abs(vector.startAltitude - currentVector.endAltitude) > 0.1) {
                    return undefined;
                }
                if (vector.endDistanceToLegEnd < vector.startDistanceToLegEnd) {
                    const vectorGradient = (vector.endAltitude - vector.startAltitude) / (vector.startDistanceToLegEnd - vector.endDistanceToLegEnd);
                    if (Math.abs(vectorGradient - currentVectorGradient) > 0.0001) {
                        out.legIndex = i;
                        out.vectorIndex = j;
                        return out;
                    }
                    currentVector = vector;
                }
            }
        }
        return undefined;
    }
    /**
     * Gets the lateral distance, in meters, from the end of one vertical flight path vector to the start of another
     * vector.
     * @param verticalFlightPath The vertical flight path.
     * @param startLegIndex The index of the leg containing the starting vector.
     * @param startVectorIndex The index of the starting vector in its containing leg.
     * @param targetLegIndex The index of the leg containing the target vector.
     * @param targetVectorIndex The index of the target vector in its containing leg.
     * @returns The lateral distance, in meters, from the end of the starting vector to the start of the target vector.
     * If the target vector does not follow the starting vector, zero will be returned.
     */
    static getDistanceToVerticalFlightPathVector(verticalFlightPath, startLegIndex, startVectorIndex, targetLegIndex, targetVectorIndex) {
        let distance = 0;
        for (let i = startLegIndex; i < targetLegIndex + 1; i++) {
            const leg = verticalFlightPath.legs[i];
            const endVectorIndex = i === targetLegIndex ? targetVectorIndex : leg.vectors.length;
            for (let j = i === startLegIndex ? startVectorIndex + 1 : 0; j < endVectorIndex; j++) {
                const vector = leg.vectors[j];
                distance += vector.startDistanceToLegEnd - vector.endDistanceToLegEnd;
            }
        }
        return distance;
    }
    /**
     * Computes a vertical flight path vector anticipation curve. The curve is a circle that smoothly connects the path
     * of an initial vector to that of a final vector. The flight path angles of the two vectors must differ by at least
     * 0.1 degrees for a curve to be computed. The curve is guaranteed to join the final vector at or before the halfway
     * point of the vector. The curve targets a nominal constant 0.05g maneuver, unless it is constrained by the length
     * of the final vector as described above.
     * @param initialVector The initial vertical flight path vector.
     * @param finalVector The final vertical flight path vector.
     * @param gs The ground speed of the airplane, in knots.
     * @param out The object to which to write the results.
     * @returns A vertical flight path vector anticipation curve connecting the specified vertical path vectors. If a
     * curve could not be computed, then the radius of the curve will be equal to 0.
     */
    static computeAnticipationCircle(initialVector, finalVector, gs, out) {
        out.x = 0;
        out.y = 0;
        out.radius = 0;
        out.anticipationDistance = 0;
        const initialVectorDistance = initialVector.startDistanceToLegEnd - initialVector.endDistanceToLegEnd;
        const initialVectorHeight = initialVector.endAltitude - initialVector.startAltitude;
        const finalVectorDistance = finalVector.startDistanceToLegEnd - finalVector.endDistanceToLegEnd;
        const finalVectorHeight = finalVector.endAltitude - finalVector.startAltitude;
        const initialFpa = VNavUtils.getFpa(initialVectorDistance, initialVectorHeight);
        const finalFpa = VNavUtils.getFpa(finalVectorDistance, finalVectorHeight);
        const deltaFpa = finalFpa - initialFpa;
        const deltaFpaAbs = Math.abs(deltaFpa);
        if (deltaFpaAbs < 0.1) {
            return out;
        }
        const theta = (180 - deltaFpaAbs) / 2;
        const tanTheta = Math.tan(theta * Avionics.Utils.DEG2RAD);
        // Technically we should be using along-vector distance instead of lateral distance, but even with a 6-deg FPA the
        // error is only ~0.5%.
        const maxD = finalVectorDistance * 0.5;
        const maxRadius = maxD * tanTheta;
        const gsMps = UnitType.KNOT.convertTo(gs, UnitType.MPS);
        const desiredRadius = gsMps * gsMps / 0.49; // 0.05g maneuver
        out.radius = Math.min(maxRadius, desiredRadius) * (deltaFpa < 0 ? -1 : 1);
        // Define origin to be the intersection between the initial and final vectors.
        const radial = ((initialFpa + finalFpa) * 0.5 + 90) * Avionics.Utils.DEG2RAD;
        const diagonal = out.radius / Math.sin(theta * Avionics.Utils.DEG2RAD);
        out.x = diagonal * Math.cos(radial);
        out.y = diagonal * Math.sin(radial);
        out.anticipationDistance = Math.abs(out.radius / tanTheta);
        return out;
    }
    /**
     * Get current airframe max speed in kcas
     * @returns VMO in kcas
     */
    getVmo() {
        if (typeof this.options.vmo === 'function') {
            // TODO alt?
            return this.options.vmo();
        }
        return this.options.vmo;
    }
    /**
     * Get current airframe max mach
     * @returns MMO as mach number
     */
    getMmo() {
        return this.options.mmo;
    }
    /**
     * Get the lowest of MMO or VMO in CAS
     * @returns current maximum airframe speed in Kcas
     */
    getLowestVmoMmoCas() {
        const mmoCas = UnitType.KNOT.convertFrom(AeroMath.machToCas(this.getMmo(), UnitType.HPA.convertFrom(this.ambientPressure.get(), UnitType.IN_HG)), UnitType.MPS);
        return Math.min(this.getVmo(), mmoCas);
    }
    /**
     * Get current maneuvering speed in kcas
     * @returns maneuvering speed in kcas
     */
    getManeuveringSpeed() {
        return this.maneuveringSpeed.get();
    }
    /**
     * Gets whether a vector type is part of climb/cruise.
     * @param vectorType The VerticalFlightPathVectorType.
     * @returns whether a vector type is part of climb/cruise.
     */
    isVectorTypeClimbOrCruise(vectorType) {
        switch (vectorType) {
            case VerticalFlightPathVectorType.Climb:
            case VerticalFlightPathVectorType.ClimbAcceleration:
            case VerticalFlightPathVectorType.ClimbLevel:
            case VerticalFlightPathVectorType.ClimbLevelAcceleration:
            case VerticalFlightPathVectorType.Cruise:
            case VerticalFlightPathVectorType.CruiseAcceleration:
            case VerticalFlightPathVectorType.CruiseDeceleration:
                return true;
        }
        return false;
    }
    /** Clears any state as needed at the completion of descent. */
    clearDescentState() {
        this.descentInitiated = undefined;
    }
}
/** The distance, in meters, from the first TOD in the flight plan the airplane must reach in order to enter descent phase. */
BoeingVNavManager.DESCENT_PHASE_TOD_DISTANCE = UnitType.NMILE.convertTo(10, UnitType.METER);
/** The vertical distance, in feet, below the cruise altitude the airplane must reach in order to enter cruise phase. */
BoeingVNavManager.CRUISE_PHASE_ALTITUDE_THRESHOLD = 500;
/** The lateral distance in meters from ToD below which an alt intervention activates early descent/DES NOW in metres */
BoeingVNavManager.EARLY_DESCENT_TOD_DISTANCE = UnitType.NMILE.convertTo(50, UnitType.METER);

/** Boeing VNAV Utilities */
class BoeingVNavUtils {
    /**
     * Utility method that checks if a mode is a vnav mode.
     * @param mode The BoeingVNavMode or APVerticalMode.
     * @returns True if the mode is an active vnav mode.
     */
    static isModeVnav(mode) {
        return mode === BoeingVNavModes.ALT ||
            mode === BoeingVNavModes.PATH_DESCENT ||
            mode === BoeingVNavModes.PATH_IDLE ||
            mode === BoeingVNavModes.PATH_LEVEL ||
            mode === BoeingVNavModes.SPD_CLIMB ||
            mode === BoeingVNavModes.SPD_DESCENT;
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * A VNAV Path autopilot director for Boeing.
 * This director includes the ability to deviate up to 150' from the desired path to maintain speed.
 */
class BoeingAPVNavPathDirector extends APVNavPathDirector {
    /**
     * Creates an instance of BoeingAPVNavPathDirector.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(bus);
        this.pathDeviationMode = ConsumerSubject.create(null, PathDeviationMode.NONE);
        this.pathMaxSpeed = ConsumerValue.create(null, null);
        this.pathMinSpeed = ConsumerValue.create(null, null);
        this.flcComputer = new GenericFlcComputer({ kP: 2, kI: 0, kD: 0, maxOut: 0, minOut: -10 });
        this.flcComputer.setClimbMode(false);
        const sub = bus.getSubscriber();
        this.pathDeviationMode.setConsumer(sub.on('vnav_boeing_path_deviation_mode'));
        this.pathMaxSpeed.setConsumer(sub.on('vnav_boeing_path_speed_max'));
        this.pathMinSpeed.setConsumer(sub.on('vnav_boeing_path_speed_min'));
        this.pathDeviationMode.sub(this.onPathDeviationModeChanged.bind(this), true);
        this.pauseBoeingSubs();
    }
    /** Resumes Subscriptions. */
    resumeBoeingSubs() {
        this.pathDeviationMode.resume();
        this.pathMaxSpeed.resume();
        this.pathMinSpeed.resume();
    }
    /** Pauses Subscriptions. */
    pauseBoeingSubs() {
        this.pathDeviationMode.pause();
        this.pathMaxSpeed.pause();
        this.pathMinSpeed.pause();
    }
    /** Activates this director. */
    activate() {
        this.resumeBoeingSubs();
        super.activate();
    }
    /** Deactivates this director. */
    deactivate() {
        super.deactivate();
        this.pauseBoeingSubs();
    }
    /**
     * Handles when the path deviation mode becomes active.
     * @param mode The path deviation mode.
     */
    onPathDeviationModeChanged(mode) {
        if (mode === PathDeviationMode.ABOVE) {
            const pathMaxSpeed = this.pathMaxSpeed.get();
            pathMaxSpeed !== null && this.flcComputer.setTargetSpeed(pathMaxSpeed);
        }
        else if (mode === PathDeviationMode.BELOW) {
            const pathMinSpeed = this.pathMinSpeed.get();
            pathMinSpeed !== null && this.flcComputer.setTargetSpeed(pathMinSpeed);
        }
        else {
            this.flcComputer.deactivate();
            return;
        }
        this.flcComputer.activate(false);
    }
    /** Updates this director. */
    update() {
        if (this.state === DirectorState.Active) {
            const pathDeviationMode = this.pathDeviationMode.get();
            if (pathDeviationMode === PathDeviationMode.NONE) {
                this.traditionalPathGuidance();
            }
            else {
                this.pathDeviationGuidance();
            }
        }
    }
    /** Provides traditional path guidance maintaining the exact path. */
    traditionalPathGuidance() {
        this.drivePitch && this.drivePitch(this.getDesiredPitch(), true, true);
    }
    /** Provides path guidance when in path deviation mode. */
    pathDeviationGuidance() {
        this.flcComputer.update();
        const pitchTarget = this.flcComputer.pitchTarget.get();
        if (pitchTarget !== null && this.drivePitch !== undefined) {
            this.drivePitch(this.getDesiredPitch(), true, true);
        }
    }
}

/**
 * A Boeing rollout autopilot director.
 */
class BoeingAPRolloutDirector {
    /** @inheritDoc */
    constructor(bus, options) {
        var _a;
        this.bus = bus;
        this.rudderServo = new LinearServo(16384);
        this.rudderPidOptions = {
            kP: 0.5,
            kI: 0.000001,
            kD: 0.00,
            maxOut: 10,
            minOut: -10
        };
        this.maxRudderDeflection = 25;
        this.rudderControllerOutput = 0;
        this._lastRudderTime = 0;
        this.apMaster = ConsumerValue.create(null, false);
        this.loc = ConsumerValue.create(null, { isValid: false, course: 0, source: { index: 0, type: NavSourceType.Nav } });
        this.locMagVar = ConsumerValue.create(null, 0);
        this.ppos = new GeoPoint(NaN, NaN);
        this.runwayCourseTrue = undefined;
        this.locGeoPoint = new GeoPoint(NaN, NaN);
        this.locCircle = new GeoCircle(Vec3Math.create(), 0);
        this.navLocation = new GeoPoint(NaN, NaN);
        this.state = DirectorState.Inactive;
        const sub = this.bus.getSubscriber();
        if (options && options.rudderPidValues !== undefined) {
            this.rudderPidOptions = options.rudderPidValues;
        }
        this.rudderController = new PidController(this.rudderPidOptions.kP, this.rudderPidOptions.kI, this.rudderPidOptions.kD, this.rudderPidOptions.maxOut, this.rudderPidOptions.minOut, this.rudderPidOptions.maxI, this.rudderPidOptions.minI);
        if (options && options.maxRudderDeflection !== undefined) {
            this.maxRudderDeflection = options.maxRudderDeflection;
        }
        const navIndex = (_a = options === null || options === void 0 ? void 0 : options.navIndex) !== null && _a !== void 0 ? _a : 3;
        sub.on(`nav_radio_cdi_${navIndex}`).handle(cdi => this.cdi = cdi);
        this.navLocationSub = sub.on(`nav_radio_nav_location_${navIndex}`).handle(lla => this.navLocation.set(lla.lat, lla.long));
        this.loc.setConsumer(sub.on(`nav_radio_localizer_${navIndex}`));
        this.locMagVar.setConsumer(sub.on(`nav_radio_magvar_${navIndex}`));
        this.apMaster.setConsumer(sub.on('ap_master_status'));
    }
    /** @inheritDoc */
    activate() {
        this.state = DirectorState.Active;
        if (this.onActivate) {
            this.onActivate();
        }
        this.rudderController.reset();
        this.rudderServo.reset();
    }
    /** @inheritDoc */
    arm() {
        this.state = DirectorState.Armed;
        if (this.onArm) {
            this.onArm();
        }
        const loc = this.loc.get();
        if (loc && loc.isValid && loc.course !== undefined) {
            const runwayCourseMag = UnitType.DEGREE.convertFrom(loc.course, UnitType.RADIAN);
            this.runwayCourseTrue = MagVar.magneticToTrue(runwayCourseMag, this.locMagVar.get());
        }
        if (this.runwayCourseTrue !== undefined) {
            this.locGeoPoint.set(this.navLocation.lat, this.navLocation.lon);
            this.locCircle.setAsGreatCircle(this.locGeoPoint, this.runwayCourseTrue);
        }
    }
    /** @inheritDoc */
    deactivate() {
        this.state = DirectorState.Inactive;
        if (this.onDeactivate) {
            this.onDeactivate();
        }
        this.runwayCourseTrue = undefined;
        this.locGeoPoint.set(NaN, NaN);
        this.locCircle.set(Vec3Math.create(), 0);
    }
    /** @inheritDoc */
    update() {
        if (this.state === DirectorState.Active && this.apMaster.get() === true) {
            this.updateRudder();
        }
    }
    /**
     * Updates the rudder position.
     */
    updateRudder() {
        const time = performance.now() / 1000;
        if (this.runwayCourseTrue !== undefined && !isNaN(this.locGeoPoint.lat) && !isNaN(this.locGeoPoint.lon)) {
            const deviationMeters = this.getDeviationMeters();
            const interceptAngle = this.getInterceptAngle(deviationMeters);
            const headingDiff = NavMath.diffAngle(SimVar.GetSimVarValue('PLANE HEADING DEGREES TRUE', SimVarValueType.Degree), this.runwayCourseTrue + interceptAngle);
            const deltaTime = time - this._lastRudderTime;
            const rudderSet = (this.rudderController.getOutput(deltaTime, headingDiff) / this.maxRudderDeflection) * 16384;
            this.rudderControllerOutput = this.rudderServo.drive(this.rudderControllerOutput, rudderSet);
            SimVar.SetSimVarValue('K:AXIS_RUDDER_SET', SimVarValueType.Number, -this.rudderControllerOutput);
        }
    }
    /**
     * Gets the deviation in meters.
     * @returns The deviation in meters.
     */
    getDeviationMeters() {
        this.ppos.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        return MathUtils.clamp(UnitType.GA_RADIAN.convertTo(this.locCircle.distance(this.ppos), UnitType.METER), -20, 20);
    }
    /**
     * Gets the intercept angle.
     * @param xtk The deviation in meters.
     * @returns the intercept angle in degrees.
     */
    getInterceptAngle(xtk) {
        if (Math.abs(xtk) > 0.5) {
            return MathUtils.clamp(-xtk * .5, -5, 5);
        }
        else {
            return 0;
        }
    }
}

const BOEING_FCU_H_EVENT_PREFIX = 'AS01B_FMC_1_';
/**
 * Boeing FCU HEvent manager
 */
class BoeingFcuHEventsManager {
    /**
     * Ctor
     * @param bus The event bus
     * @param onFcuEvent Callback to AP State Manager
     * @param additionalPrefix additional event prefix to check for
     */
    constructor(bus, onFcuEvent, additionalPrefix) {
        this.bus = bus;
        this.onFcuEvent = onFcuEvent;
        this.bus.getSubscriber().on('hEvent').handle(event => {
            let op = '';
            if (event.startsWith(BOEING_FCU_H_EVENT_PREFIX)) {
                op = event.replace(BOEING_FCU_H_EVENT_PREFIX, '');
            }
            else if (additionalPrefix && event.startsWith(additionalPrefix)) {
                op = event.replace(additionalPrefix, '');
            }
            if (op) {
                this.handleEvent(op);
            }
        });
    }
    /**
     * Handles the event.
     * @param event the event.
     */
    handleEvent(event) {
        switch (event) {
            case 'AP_LNAV': {
                SimVar.SetSimVarValue('K:AP_NAV1_HOLD', SimVarValueType.Bool, 1);
                break;
            }
            case 'AP_HEADING_SEL': {
                SimVar.SetSimVarValue('K:AP_HDG_HOLD_ON', SimVarValueType.Bool, 1);
                break;
            }
            case 'AP_FLCH': {
                SimVar.SetSimVarValue('K:FLIGHT_LEVEL_CHANGE_ON', SimVarValueType.Bool, 1);
                break;
            }
            case 'AP_VSPEED': {
                SimVar.SetSimVarValue('K:AP_VS_ON', SimVarValueType.Bool, 1);
                break;
            }
            case 'AP_ALT_HOLD': {
                SimVar.SetSimVarValue('K:AP_ALT_HOLD_ON', SimVarValueType.Bool, 1);
                break;
            }
            case 'AP_VNAV':
            case 'AP_ALT_INTERVENTION':
            case 'AP_SPEED_INTERVENTION':
            case 'AP_AT_ENGAGE':
            case 'AP_SPD':
            case 'AP_THR':
            case 'AP_CLBCON':
            case 'AP_SPEED_MACH_TOGGLE':
                this.onFcuEvent(event);
                break;
            default:
                console.warn(`[BoeingFcuHEventsManager] Unknown H event op: ${event}`);
        }
    }
}

/**
 * A Boeing autopilot state manager.
 */
class BoeingAPStateManager extends APStateManager {
    /**
     * Creates an instance of BoeingAPStateManager.
     * @param bus An instance of the event bus.
     * @param apConfig This autopilot's configuration.
     */
    constructor(bus, apConfig) {
        super(bus, apConfig);
        this.altInterventionPressed = new SubEvent();
        this.spdInterventionPressed = new SubEvent();
        this.spdMachTogglePressed = new SubEvent();
        this.autothrottleTogaPressed = new SubEvent();
        this.autothrottleClbConPressed = new SubEvent();
        this.autothrottleEngagePressed = new SubEvent();
        this.autothrottleSpeedPressed = new SubEvent();
        this.autothrottleThrPressed = new SubEvent();
        // Don't have a better way to set the 747 prefix at the moment, so just going to leave it here for now
        this.fcuEventsManager = new BoeingFcuHEventsManager(this.bus, this.onFcuEvent.bind(this), 'B747_8_FMC_1_');
        this.vsLastPressed = 0;
        this.vsOrFpaActive = false;
        this.hdgOrTrkActive = false;
        // Autopilot disconnect state is activated whenever the autopilot is deactivated (doesn't matter if it was manual
        // or automatic). When the autopilot is activated, the disconnect state is cleared.
        this.apMasterOn.sub(isOn => {
            SimVar.SetSimVarValue('L:WT_Boeing_Autopilot_Disconnected', SimVarValueType.Bool, isOn ? 0 : 1);
        });
    }
    /** @inheritDoc */
    onBeforeInitialize() {
        super.onBeforeInitialize();
        const controlEventPub = this.bus.getPublisher();
        controlEventPub.pub('cdi_select', { type: NavSourceType.Gps, index: 0 }, true);
    }
    /** @inheritdoc */
    initFlightDirector() {
        // Init FD from the sim var, which is set from the flt files.
        this.setFlightDirector(SimVar.GetSimVarValue('A:AUTOPILOT FLIGHT DIRECTOR ACTIVE', SimVarValueType.Bool) === 1);
    }
    /** @inheritdoc */
    onAPListenerRegistered() {
        super.onAPListenerRegistered();
        const sub = this.bus.getSubscriber();
        sub.on('ap_vs_hold').handle((active) => this.vsOrFpaActive = active);
        sub.on('ap_heading_hold').handle((active) => this.hdgOrTrkActive = active);
        const pub = this.bus.getPublisher();
        this.isFlightDirectorOn.sub((v) => pub.pub('ap_boeing_flight_director_is_active_1', v, true, true), true);
        this.isFlightDirectorCoPilotOn.sub((v) => pub.pub('ap_boeing_flight_director_is_active_2', v, true, true), true);
    }
    /**
     * Sets the Flight Director State
     * @param on is wheter to set the FD On.
     * @param setSimFds Set the sim FD state as well?
     */
    setFlightDirector(on, setSimFds = true) {
        this._isFlightDirectorOn.set(on);
        this._isFlightDirectorCoPilotOn.set(on);
        // HINT: Delay this by a frame so we know about the actual FD state
        if (setSimFds) {
            setTimeout(() => {
                if (on !== !!SimVar.GetSimVarValue('A:AUTOPILOT FLIGHT DIRECTOR ACTIVE:1', SimVarValueType.Bool)) {
                    SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 1);
                }
                if (on !== !!SimVar.GetSimVarValue('A:AUTOPILOT FLIGHT DIRECTOR ACTIVE:2', SimVarValueType.Bool)) {
                    SimVar.SetSimVarValue('K:TOGGLE_FLIGHT_DIRECTOR', 'number', 2);
                }
            }, 0);
        }
    }
    /**
     * Checks if MCP VS/FPA mode is FPA
     * @returns true if FPA mode active
     */
    fpaModeActive() {
        return SimVar.GetSimVarValue('L:XMLVAR_FPA_MODE_ACTIVE', SimVarValueType.Bool) > 0;
    }
    /**
     * Handle switch between vs and fpa
     * @param fpaActive fpa currently active?
     */
    handleFpaModeChange(fpaActive) {
        if (this.vsOrFpaActive) {
            // switch mode
            this.sendApModeEvent(APModeType.VERTICAL, fpaActive ? APVerticalModes.FPA : APVerticalModes.VS, true);
        }
    }
    /**
     * Checks if MCP HDG/TRK mode is TRK
     * @returns true if TRK mode active
     */
    trkModeActive() {
        return SimVar.GetSimVarValue('L:XMLVAR_TRK_MODE_ACTIVE', SimVarValueType.Bool) > 0;
    }
    /**
     * Handle switch between hdg and trk
     * @param trkActive trk currently active?
     */
    handleTrkModeChange(trkActive) {
        if (this.hdgOrTrkActive) {
            // switch mode
            this.sendApModeEvent(APModeType.LATERAL, trkActive ? APLateralModes.TRACK : APLateralModes.HEADING, true);
        }
    }
    /** @inheritdoc */
    setupKeyIntercepts(manager) {
        //AP master status
        manager.interceptKey('AP_MASTER', false);
        manager.interceptKey('AUTOPILOT_ON', false);
        manager.interceptKey('AUTOPILOT_OFF', false);
        //alt modes
        manager.interceptKey('AP_ALT_HOLD', false);
        manager.interceptKey('AP_ALT_HOLD', false);
        manager.interceptKey('AP_ALT_HOLD_ON', false);
        manager.interceptKey('AP_ALT_HOLD_OFF', false);
        manager.interceptKey('AP_PANEL_ALTITUDE_HOLD', false);
        manager.interceptKey('AP_PANEL_ALTITUDE_ON', false);
        manager.interceptKey('AP_PANEL_ALTITUDE_OFF', false);
        manager.interceptKey('AP_PANEL_ALTITUDE_SET', false);
        //vs modes
        manager.interceptKey('AP_PANEL_VS_HOLD', false);
        manager.interceptKey('AP_PANEL_VS_ON', false);
        manager.interceptKey('AP_PANEL_VS_OFF', false);
        manager.interceptKey('AP_PANEL_VS_SET', false);
        manager.interceptKey('AP_VS_HOLD', false);
        manager.interceptKey('AP_VS_ON', false);
        manager.interceptKey('AP_VS_OFF', false);
        manager.interceptKey('AP_VS_SET', false);
        //pitch modes
        manager.interceptKey('AP_ATT_HOLD', false);
        manager.interceptKey('AP_ATT_HOLD_ON', false);
        manager.interceptKey('AP_ATT_HOLD_OFF', false);
        manager.interceptKey('AP_PITCH_LEVELER', false);
        manager.interceptKey('AP_PITCH_LEVELER_ON', false);
        manager.interceptKey('AP_PITCH_LEVELER_OFF', false);
        //roll modes
        manager.interceptKey('AP_BANK_HOLD', false);
        manager.interceptKey('AP_BANK_HOLD_ON', false);
        manager.interceptKey('AP_BANK_HOLD_OFF', false);
        manager.interceptKey('AP_WING_LEVELER', false);
        manager.interceptKey('AP_WING_LEVELER_ON', false);
        manager.interceptKey('AP_WING_LEVELER_OFF', false);
        //flc modes
        manager.interceptKey('FLIGHT_LEVEL_CHANGE', false);
        manager.interceptKey('FLIGHT_LEVEL_CHANGE_ON', false);
        manager.interceptKey('FLIGHT_LEVEL_CHANGE_OFF', false);
        //nav modes
        manager.interceptKey('AP_NAV1_HOLD', false);
        manager.interceptKey('AP_NAV1_HOLD_ON', false);
        manager.interceptKey('AP_NAV1_HOLD_OFF', false);
        manager.interceptKey('AP_NAV_SELECT_SET', false);
        manager.interceptKey('TOGGLE_GPS_DRIVES_NAV1', false);
        //hdg modes
        manager.interceptKey('AP_HDG_HOLD', false);
        manager.interceptKey('AP_HDG_HOLD_ON', false);
        manager.interceptKey('AP_HDG_HOLD_OFF', false);
        manager.interceptKey('AP_PANEL_HEADING_HOLD', false);
        manager.interceptKey('AP_PANEL_HEADING_ON', false);
        manager.interceptKey('AP_PANEL_HEADING_OFF', false);
        manager.interceptKey('AP_PANEL_HEADING_SET', false);
        //bank modes
        manager.interceptKey('AP_BANK_HOLD', false);
        manager.interceptKey('AP_BANK_HOLD_ON', false);
        manager.interceptKey('AP_BANK_HOLD_OFF', false);
        //appr modes
        manager.interceptKey('AP_LOC_HOLD', false);
        manager.interceptKey('AP_LOC_HOLD_ON', false);
        manager.interceptKey('AP_LOC_HOLD_OFF', false);
        manager.interceptKey('AP_APR_HOLD', false);
        manager.interceptKey('AP_APR_HOLD_ON', false);
        manager.interceptKey('AP_APR_HOLD_OFF', false);
        manager.interceptKey('AP_BC_HOLD', false);
        manager.interceptKey('AP_BC_HOLD_ON', false);
        manager.interceptKey('AP_BC_HOLD_OFF', false);
        //TOGA intercept
        manager.interceptKey('AUTO_THROTTLE_TO_GA', false);
    }
    /** @inheritdoc */
    handleKeyIntercepted({ key, value0 }) {
        const controlEventPub = this.bus.getPublisher();
        switch (key) {
            case 'AP_MASTER': {
                // We get the AP master state directly from the simvar instead of the apMasterOn subject because the subject
                // is only updated at the glass cockpit refresh rate, and we want the most up-to-date state possible.
                const isApMasterOn = SimVar.GetSimVarValue('AUTOPILOT MASTER', SimVarValueType.Bool);
                this.onApMasterStatusEvent(key, !isApMasterOn, isApMasterOn);
                break;
            }
            case 'AUTOPILOT_ON':
                // We get the AP master state directly from the simvar instead of the apMasterOn subject because the subject
                // is only updated at the glass cockpit refresh rate, and we want the most up-to-date state possible.
                this.onApMasterStatusEvent(key, true, SimVar.GetSimVarValue('AUTOPILOT MASTER', SimVarValueType.Bool));
                break;
            case 'AUTOPILOT_OFF':
                // We get the AP master state directly from the simvar instead of the apMasterOn subject because the subject
                // is only updated at the glass cockpit refresh rate, and we want the most up-to-date state possible.
                this.onApMasterStatusEvent(key, false, SimVar.GetSimVarValue('AUTOPILOT MASTER', SimVarValueType.Bool));
                break;
            // FIXME Boeing doesn't have a NAV mode as such
            case 'AP_NAV1_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV);
                break;
            case 'AP_NAV1_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV, true);
                break;
            case 'AP_NAV1_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.NAV, false);
                break;
            case 'AP_LOC_HOLD':
            case 'AP_LOC_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LOC, true);
                break;
            case 'AP_LOC_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.LOC, false);
                break;
            case 'AP_APR_HOLD':
                this.sendApModeEvent(APModeType.APPROACH);
                break;
            case 'AP_APR_HOLD_ON':
                this.sendApModeEvent(APModeType.APPROACH, undefined, true);
                break;
            case 'AP_APR_HOLD_OFF':
                this.sendApModeEvent(APModeType.APPROACH, undefined, false);
                break;
            case 'AP_BC_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC);
                break;
            case 'AP_BC_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC, true);
                break;
            case 'AP_BC_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.BC, false);
                break;
            case 'AP_HDG_HOLD':
            case 'AP_PANEL_HEADING_HOLD':
                this.sendApModeEvent(APModeType.LATERAL, this.trkModeActive() ? APLateralModes.TRACK : APLateralModes.HEADING);
                break;
            case 'AP_PANEL_HEADING_ON':
            case 'AP_HDG_HOLD_ON':
                this.sendApModeEvent(APModeType.LATERAL, this.trkModeActive() ? APLateralModes.TRACK : APLateralModes.HEADING, true);
                break;
            case 'AP_PANEL_HEADING_OFF':
            case 'AP_HDG_HOLD_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING, false);
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.TRACK, false);
                break;
            case 'AP_PANEL_HEADING_SET':
                if (value0 !== undefined) {
                    this.sendApModeEvent(APModeType.LATERAL, this.trkModeActive() ? APLateralModes.TRACK : APLateralModes.HEADING, value0 === 1 ? true : false);
                }
                break;
            case 'AP_BANK_HOLD':
            case 'AP_BANK_HOLD_ON':
                // TODO no roll mode on Boeing... hook to HDG_HOLD?
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.ROLL, true);
                break;
            case 'AP_WING_LEVELER':
                this.sendApModeEvent(APModeType.LATERAL, this.trkModeActive() ? APLateralModes.TRACK_HOLD : APLateralModes.HEADING_HOLD);
                break;
            case 'AP_WING_LEVELER_ON':
                this.sendApModeEvent(APModeType.LATERAL, this.trkModeActive() ? APLateralModes.TRACK_HOLD : APLateralModes.HEADING_HOLD, true);
                break;
            case 'AP_WING_LEVELER_OFF':
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.HEADING_HOLD, false);
                this.sendApModeEvent(APModeType.LATERAL, APLateralModes.TRACK_HOLD, false);
                break;
            case 'AP_PANEL_VS_HOLD':
            case 'AP_VS_HOLD':
                this.sendApModeEvent(APModeType.VERTICAL, this.fpaModeActive() ? APVerticalModes.FPA : APVerticalModes.VS);
                break;
            case 'AP_PANEL_VS_ON':
            case 'AP_VS_ON':
                this.sendApModeEvent(APModeType.VERTICAL, this.fpaModeActive() ? APVerticalModes.FPA : APVerticalModes.VS, true);
                break;
            case 'AP_PANEL_VS_OFF':
            case 'AP_VS_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.VS, false);
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FPA, false);
                break;
            case 'AP_PANEL_VS_SET':
            case 'AP_VS_SET':
                // TODO Remove this when the Bravo default mapping is fixed.
                if (value0 !== undefined && this.vsLastPressed < Date.now() - 100) {
                    this.sendApModeEvent(APModeType.VERTICAL, this.fpaModeActive() ? APVerticalModes.FPA : APVerticalModes.VS, value0 === 1 ? true : false);
                }
                this.vsLastPressed = Date.now();
                break;
            case 'AP_ALT_HOLD':
            case 'AP_PANEL_ALTITUDE_HOLD':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT);
                break;
            case 'AP_ALT_HOLD_ON':
            case 'AP_PANEL_ALTITUDE_ON':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, true);
                break;
            case 'AP_ALT_HOLD_OFF':
            case 'AP_PANEL_ALTITUDE_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, false);
                break;
            case 'AP_PANEL_ALTITUDE_SET':
                if (value0 !== undefined) {
                    this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.ALT, value0 === 1 ? true : false);
                }
                break;
            case 'FLIGHT_LEVEL_CHANGE':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC);
                break;
            case 'FLIGHT_LEVEL_CHANGE_ON':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC, true);
                break;
            case 'FLIGHT_LEVEL_CHANGE_OFF':
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.FLC, false);
                break;
            case 'TOGGLE_GPS_DRIVES_NAV1':
                controlEventPub.pub('cdi_src_gps_toggle', true, true);
                break;
            case 'AUTO_THROTTLE_TO_GA':
                // TODO
                // - make GA button not a toggle... just a trigger to activate TOGA
                // - on ground:
                //   - pushing above 80 knots disarms LNAV and VNAV
                // - in flight:
                //   - after liftoff with takeoff thrust limit
                //     - disarms AFDS modes
                //     - between 50 and 400 feet selects TO/GA roll mode
                //     - above 400 feet selected TO/GA roll and pitch modes
                //   - on approach with flaps not up or glide path/slope captured
                //     - disarms AFDS modes
                //     - selects TO/GA roll and pitch modes
                //     - arms or activates LNAV if an LNAV path is available
                //     - second push
                //       - with HDG SEL/HOLD active and TO/GA pitch: selects TO/GA roll and pitch modes
                this.sendApModeEvent(APModeType.VERTICAL, APVerticalModes.TO);
                this.autothrottleTogaPressed.notify(this);
        }
    }
    /**
     * Handles FCU Events (we only use this for events that do not have a cooresponding K event we can trigger in the FcuHEventsManager).
     * @param event The event string.
     */
    onFcuEvent(event) {
        switch (event) {
            case 'AP_VNAV':
                this.toggleVnav();
                break;
            case 'AP_ALT_INTERVENTION':
                this.altInterventionPressed.notify(this, true);
                break;
            case 'AP_SPEED_INTERVENTION':
                this.spdInterventionPressed.notify(this, true);
                break;
            case 'AP_SPEED_MACH_TOGGLE':
                this.spdMachTogglePressed.notify(this, true);
                break;
            case 'AP_AT_ENGAGE':
                this.autothrottleEngagePressed.notify(this);
                break;
            case 'AP_SPD':
                this.autothrottleSpeedPressed.notify(this);
                break;
            case 'AP_CLBCON':
                this.autothrottleClbConPressed.notify(this);
                break;
            case 'AP_THR':
                this.autothrottleThrPressed.notify(this);
                break;
        }
    }
    /**
     * Responds to when an key event that changes the master autopilot status is intercepted.
     * @param key The intercepted key event.
     * @param commandedState The autopilot activation state commanded by the key event.
     * @param currentState The current autopilot activation state.
     */
    onApMasterStatusEvent(key, commandedState, currentState) {
        if (!commandedState && !currentState) {
            SimVar.SetSimVarValue('L:WT_Boeing_Autopilot_Disconnected', SimVarValueType.Bool, 0);
        }
        this.setApMasterStatus(key, commandedState, currentState);
    }
    /**
     * Sets the master autopilot status in response to an intercepted key event.
     * @param key The intercepted key event.
     * @param commandedState The autopilot activation state commanded by the key event.
     * @param currentState The current autopilot activation state.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    setApMasterStatus(key, commandedState, currentState) {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        this.keyEventManager.triggerKey(commandedState ? 'AUTOPILOT_ON' : 'AUTOPILOT_OFF', true);
    }
}

/**
 * Handles the calculation of the IAN FAC/GP for ILS-like non-precision approaches
 */
class BoeingIanManager {
    /**
     * Creates an instance of the IAN (FAC/GP) manager
     * @param bus The EventBus to use with this instance.
     * @param fms The FMS
     * @param flightPlanner The flight planner to use with this instance.
     * @param primaryPlanIndex The primary plan index to use for calculating GlidePath.
     */
    constructor(bus, fms, flightPlanner, primaryPlanIndex) {
        this.bus = bus;
        this.fms = fms;
        this.flightPlanner = flightPlanner;
        this.primaryPlanIndex = primaryPlanIndex;
        /** FAC is available for the current approach */
        this.facAvailable = Subject.create(false);
        /** FAC deviation in nautical miles, or null when not computed */
        this.facDeviation = Subject.create(null);
        /** FAC beam bearing in true degrees, or null when not valid */
        this.facBearing = Subject.create(null);
        /** GP is available for the current approach */
        this.gpAvailable = Subject.create(false);
        /** GP deviation in feet, -ve for below the beam, or null when not computed */
        this.gpDeviation = Subject.create(null);
        /** GP slope in degrees, -ve for descending, or null when not valid */
        this.gpSlope = Subject.create(null);
        this.mapLegIndex = 0;
        this.fafLegIndex = 0;
        this.gsSelected = this.fms.activePerformancePlan.glideSlope.map((gs) => gs === GlideslopeStatus.ON);
        this.qfeSelected = this.fms.activePerformancePlan.approachLandingRef.map((qnh) => qnh === 0);
        this.planePosValid = false;
        this.planePos = new GeoPoint(0, 0);
        /** Indicated altitude in metres */
        this.currentIndicatedAltitude = 0;
        /** aircraft track in degrees true */
        this.currentTrack = 0;
        /** altitude at the final end point in metres */
        this.glidePathFinalAltitude = 0;
        /** destination airport altitude in metres */
        this.airportAltitude = 0;
        /** if radius > 0, valid */
        this.facBeamCircle = new GeoCircle(Vec3Math.create(), 0);
        this.facStartPoint = Vec3Math.create();
        this.facEndPoint = new GeoPoint(0, 0);
        this.onPlanChanged = () => {
            if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                this.mapLegIndex = VNavUtils.getMissedApproachLegIndex(plan);
                const faf = VNavUtils.getFafIndex(plan);
                this.fafLegIndex = faf !== undefined ? faf : Math.max(0, plan.length - 1);
            }
        };
        this.onPlanCalculated = () => {
            if (this.flightPlanner.hasFlightPlan(this.primaryPlanIndex)) {
                const plan = this.flightPlanner.getFlightPlan(this.primaryPlanIndex);
                this.calculateFacGp(plan);
            }
        };
        const fpl = bus.getSubscriber();
        fpl.on('fplCopied').handle(e => e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX || e.targetPlanIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.onPlanChanged());
        fpl.on('fplCreated').handle(e => e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.onPlanChanged());
        fpl.on('fplLegChange').handle(e => {
            if (e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.onPlanChanged();
            }
        });
        fpl.on('fplLoaded').handle(e => e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.onPlanChanged());
        fpl.on('fplSegmentChange').handle(e => {
            if (e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX) {
                this.onPlanChanged();
            }
        });
        fpl.on('fplIndexChanged').handle(() => this.onPlanChanged());
        fpl.on('fplCalculated').handle(e => e.planIndex === BoeingFms.ACT_RTE_PLAN_INDEX && this.onPlanCalculated());
        this.gsSelected.sub(this.onPlanCalculated.bind(this));
        this.qfeSelected.sub(this.onPlanCalculated.bind(this));
        const sub = this.bus.getSubscriber();
        sub.on('fms_pos_gps-position_1').handle(lla => {
            this.planePos.set(lla.lat, lla.long);
        });
        sub.on('indicated_alt').handle((alt) => this.currentIndicatedAltitude = UnitType.METER.convertFrom(alt, UnitType.FOOT));
        sub.on('fms_pos_track_deg_true_1').handle((trk) => this.currentTrack = trk);
        sub.on('fms_pos_anp_1').handle((anp) => this.planePosValid = anp >= 0);
        sub.on('simTime').handle(this.updateDeviation.bind(this));
        const pub = this.bus.getPublisher();
        this.facAvailable.sub((v) => pub.pub('boeing_ian_fac_available', v, true));
        this.facDeviation.sub((v) => pub.pub('boeing_ian_fac_deviation', v, true), true);
        this.facBearing.sub((v) => pub.pub('boeing_ian_fac_bearing', v, true), true);
        this.gpAvailable.sub((v) => pub.pub('boeing_ian_gp_available', v, true));
        this.gpDeviation.sub((v) => pub.pub('boeing_ian_gp_deviation', v, true), true);
        this.gpSlope.sub((v) => pub.pub('boeing_ian_gp_slope', v, true), true);
    }
    /**
     * Reset FAC deviation to invalid value
     */
    resetFacDeviation() {
        this.facDeviation.set(null);
    }
    /**
     * Reset GP deviation to invalid value
     */
    resetGpDeviation() {
        this.gpDeviation.set(null);
    }
    /**
     * Update the FAC and GP deviation values
     */
    updateDeviation() {
        // check that the FAC geometry is valid first
        const facBearing = this.facBearing.get();
        if (facBearing === null || !this.planePosValid) {
            this.resetFacDeviation();
            this.resetGpDeviation();
            return;
        }
        // the plane needs to be within 25 NM of the MAP and within 60° of the FAC beam before either deviation will be calculated
        const distanceToEndPoint = this.facEndPoint.distance(this.planePos);
        if (distanceToEndPoint > BoeingIanManager.MAX_DISTANCE) {
            this.resetFacDeviation();
            this.resetGpDeviation();
            return;
        }
        const angularDeviation = NavMath.diffAngle(this.facEndPoint.bearingFrom(this.planePos), facBearing);
        if (Math.abs(angularDeviation) >= BoeingIanManager.MAX_ANGULAR_DEVIATION) {
            this.resetFacDeviation();
            this.resetGpDeviation();
            return;
        }
        // calculate FAC deviation (same as xtk for a normal leg, FAC doesn't use an angular deviation like a LOC)
        if (this.facAvailable.get()) {
            this.facDeviation.set(UnitType.GA_RADIAN.convertTo(this.facBeamCircle.distance(this.planePos), UnitType.NMILE));
        }
        else {
            this.resetFacDeviation();
        }
        if (this.gpAvailable.get()) {
            // GP deviation is only calculated when < 6000 feet above the destination airport,
            // and track is within 90° of the FAC beam, in addition to previous conditions
            const gpSlope = this.gpSlope.get();
            const heightAboveAirport = this.currentIndicatedAltitude - this.airportAltitude;
            const trackAngle = NavMath.diffAngle(this.currentTrack, facBearing);
            if (gpSlope === null
                || heightAboveAirport > BoeingIanManager.MAX_GP_HEIGHT
                || Math.abs(trackAngle) >= BoeingIanManager.MAX_GP_TRACK_DEVIATION) {
                this.resetGpDeviation();
                return;
            }
            // calculate GP deviation (in feet, not angular deviation based like a GS)
            const abeamDistanceToEndPoint = UnitType.METER.convertFrom(this.facBeamCircle.angleAlong(this.planePos, this.facEndPoint, Math.PI), UnitType.GA_RADIAN);
            const desiredAlt = this.glidePathFinalAltitude - VNavUtils.altitudeForDistance(gpSlope, abeamDistanceToEndPoint);
            this.gpDeviation.set(UnitType.FOOT.convertFrom(this.currentIndicatedAltitude - desiredAlt, UnitType.METER));
        }
        else {
            this.resetGpDeviation();
        }
    }
    /**
     * Reset the FAC/GP geometry to invalid
     */
    resetFacGp() {
        this.facAvailable.set(false);
        this.facBeamCircle.set(this.facBeamCircle.center, 0);
        this.facBearing.set(null);
        this.gpAvailable.set(false);
        this.gpSlope.set(null);
    }
    /**
     * Calculate the FAC/GP geometry from the selected approach
     * @param plan Flight plan to caculate FAC/GP from
     */
    async calculateFacGp(plan) {
        if (!plan.destinationAirport) {
            this.resetFacGp();
            return;
        }
        const destinationAirport = await this.fms.facLoader.getFacility(FacilityType.Airport, plan.destinationAirport);
        if (plan.length < 2 || this.fafLegIndex > plan.length || this.mapLegIndex > plan.length) {
            this.resetFacGp();
            return;
        }
        const prevLeg = plan.tryGetLeg(this.mapLegIndex - 1);
        const mapLeg = plan.tryGetLeg(this.mapLegIndex);
        let facAvailable = false;
        let gpAvailable = !this.qfeSelected.get();
        /** FAC beam bearing in true degrees */
        let facBearing;
        const vfrRunwayDesignation = this.fms.getFlightPlanVisualApproach(BoeingFms.ACT_RTE_PLAN_INDEX);
        if (vfrRunwayDesignation !== undefined) {
            // a VFR approach is selected in the CDU.. we use the runway true bearing as the FAC beam bearing
            const vfrRunway = plan.procedureDetails.destinationRunway;
            facBearing = vfrRunway === null || vfrRunway === void 0 ? void 0 : vfrRunway.course;
            facAvailable = true;
        }
        else {
            // an instrument approach is selected.. we need to determine the MAP leg course
            const approach = destinationAirport === null || destinationAirport === void 0 ? void 0 : destinationAirport.approaches[plan.procedureDetails.approachIndex];
            if (approach) {
                facBearing = await this.fms.getFinalApproachTrueCourse(destinationAirport, approach);
                facAvailable = !BoeingFmsUtils.isLocalizerApproach(approach.approachType);
                gpAvailable && (gpAvailable = approach.approachType !== ApproachType.APPROACH_TYPE_ILS || !this.gsSelected.get());
            }
        }
        if (facBearing === undefined || !mapLeg || !mapLeg.calculated || !mapLeg.calculated.endLat || !mapLeg.calculated.endLon) {
            this.resetFacGp();
            return;
        }
        this.facAvailable.set(facAvailable);
        /** G/P angle in degrees, -ve for descending */
        const glidePathAngle = this.calcGlidePathAngle(mapLeg, prevLeg);
        this.gpSlope.set(glidePathAngle);
        gpAvailable && (gpAvailable = glidePathAngle !== null);
        this.glidePathFinalAltitude = mapLeg.leg.altitude1;
        if (plan.procedureDetails.destinationRunway) {
            this.airportAltitude = plan.procedureDetails.destinationRunway.elevation;
        }
        else {
            this.airportAltitude = 0;
        }
        this.facEndPoint.set(mapLeg.calculated.endLat, mapLeg.calculated.endLon);
        this.facBearing.set(facBearing);
        this.facBeamCircle.setAsGreatCircle(this.facEndPoint, facBearing);
        this.facBeamCircle.offsetDistanceAlong(this.facEndPoint, -BoeingIanManager.MAX_DISTANCE, this.facStartPoint);
        this.gpAvailable.set(gpAvailable);
    }
    /**
     * Calculates the Glidepath flight path angle using the MAP altitude constraint,
     * coded glidepath angle, and the previous leg constraint (steeper of the two)
     * @param mapLeg Missed approach point leg i.e. the last leg of the approach
     * @param prevLeg The leg prior to the MAP
     * @returns a glidepath angle, with -ve angles being descending, or null on error
     */
    calcGlidePathAngle(mapLeg, prevLeg) {
        if (!mapLeg.calculated) {
            return null;
        }
        // first get glide path angle from the final leg data...
        const codedGpa = mapLeg.leg.verticalAngle !== 0 ? mapLeg.leg.verticalAngle - 360 : null;
        // check if the path through the alt constraints at the FAF, and the leg before is steeper
        const discontinuity = (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) === LegType.Discontinuity || (prevLeg === null || prevLeg === void 0 ? void 0 : prevLeg.leg.type) === LegType.ThruDiscontinuity;
        if (prevLeg && !discontinuity && prevLeg.leg.altitude1 > 0 && prevLeg.calculated) {
            const distance = mapLeg.calculated.distance;
            const destAltitude = mapLeg.leg.altitude1;
            const constraintGpa = -VNavUtils.getFpa(distance, prevLeg.leg.altitude1 - destAltitude);
            return codedGpa !== null ? Math.min(codedGpa, constraintGpa) : constraintGpa;
        }
        if ((codedGpa !== null && codedGpa !== void 0 ? codedGpa : -Infinity) < BoeingIanManager.MIN_GP_SLOPE) {
            return null;
        }
        return codedGpa;
    }
}
/** maximum distance from the final end point in GA radians */
BoeingIanManager.MAX_DISTANCE = UnitType.GA_RADIAN.convertFrom(25, UnitType.NMILE);
/** maximum angular deviation from the FAC in degrees */
BoeingIanManager.MAX_ANGULAR_DEVIATION = 60;
/** maximum height above the destination airport for GP to be calculated */
BoeingIanManager.MAX_GP_HEIGHT = UnitType.METER.convertFrom(6000, UnitType.FOOT);
/** maximum track deviation from the FAC in degrees for GP to be calculated */
BoeingIanManager.MAX_GP_TRACK_DEVIATION = 90;
/** Steepest certified G/P slope in degrees */
BoeingIanManager.MIN_GP_SLOPE = -3.77;

/**
 * Manages automatically setting the MCP heding to the runway heading when LOC activates.
 */
class BoeingMcpRunwayHeadingManager {
    /**
     * The constructor.
     * @param bus The bus.
     */
    constructor(bus) {
        this.isLocActive = Subject.create(false);
        bus.getSubscriber().on('fma_data').handle(fmaData => {
            this.isLocActive.set(fmaData.lateralActive === APLateralModes.LOC);
        });
        this.isLocActive.sub(isLocActive => {
            if (isLocActive) {
                const ilsCourseDegrees = SimVar.GetSimVarValue('NAV OBS:3', SimVarValueType.Degree);
                SimVar.SetSimVarValue('K:HEADING_BUG_SET', SimVarValueType.Degree, ilsCourseDegrees);
            }
        }, true);
    }
}

/** MessageDefinition */
class MessageDefinition {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(text, target) {
        this.text = text;
        this.target = target;
    }
}
/** An enumeration for CJ4 message target displays */
var MESSAGE_TARGET;
(function (MESSAGE_TARGET) {
    MESSAGE_TARGET[MESSAGE_TARGET["FMC"] = 0] = "FMC";
    MESSAGE_TARGET[MESSAGE_TARGET["PFD_TOP"] = 1] = "PFD_TOP";
    MESSAGE_TARGET[MESSAGE_TARGET["PFD_BOT"] = 2] = "PFD_BOT";
    MESSAGE_TARGET[MESSAGE_TARGET["MAP_MID"] = 3] = "MAP_MID";
    MESSAGE_TARGET[MESSAGE_TARGET["MFD_TOP"] = 4] = "MFD_TOP";
})(MESSAGE_TARGET || (MESSAGE_TARGET = {}));
/**
 * Enumeration of message levels
 * Higher numbers are higher priority
 */
var MESSAGE_LEVEL;
(function (MESSAGE_LEVEL) {
    MESSAGE_LEVEL[MESSAGE_LEVEL["White"] = 0] = "White";
    MESSAGE_LEVEL[MESSAGE_LEVEL["Yellow"] = 1] = "Yellow"; // yellow
})(MESSAGE_LEVEL || (MESSAGE_LEVEL = {}));

/** OperatingMessage */
class OperatingMessage {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(_msgDefs, _level, _weight) {
        this._msgDefs = _msgDefs;
        this._level = _level;
        this._weight = _weight;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get msgDefs() {
        return this._msgDefs;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get level() {
        return this._level;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get weight() {
        return this._weight;
    }
}

/** Enumeration for CJ4 FMS Messages */
var FMS_MESSAGE_ID;
(function (FMS_MESSAGE_ID) {
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["RESET_INITIAL_POS"] = 0] = "RESET_INITIAL_POS";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["INITIALIZE_POSITION"] = 1] = "INITIALIZE_POSITION";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_FLIGHT_PLAN"] = 2] = "NO_FLIGHT_PLAN";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["FPLN_DISCONTINUITY"] = 3] = "FPLN_DISCONTINUITY";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["DISCONTINUITY"] = 4] = "DISCONTINUITY";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["CHECK_SPEED"] = 5] = "CHECK_SPEED";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["CHK_ALT_SEL"] = 6] = "CHK_ALT_SEL";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["HOLD"] = 7] = "HOLD";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["TOD"] = 8] = "TOD";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["OCEANIC"] = 9] = "OCEANIC";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["TERM"] = 10] = "TERM";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["LV_TERM"] = 11] = "LV_TERM";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["LPV_TERM"] = 12] = "LPV_TERM";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["APPR"] = 13] = "APPR";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["GPS_APPR"] = 14] = "GPS_APPR";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["LV_APPR"] = 15] = "LV_APPR";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["LPV_APPR"] = 16] = "LPV_APPR";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["SEQ_INHB"] = 17] = "SEQ_INHB";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["LOC_WILL_BE_TUNED"] = 18] = "LOC_WILL_BE_TUNED";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["CHECK_LOC_TUNING"] = 19] = "CHECK_LOC_TUNING";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["PATH_BELOW_AC"] = 20] = "PATH_BELOW_AC";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_VECTORS"] = 21] = "NO_VPATH_VECTORS";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_CONDITION"] = 22] = "NO_VPATH_CONDITION";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_PILOT_CMD"] = 23] = "NO_VPATH_PILOT_CMD";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_TAE"] = 24] = "NO_VPATH_TAE";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_XTK"] = 25] = "NO_VPATH_XTK";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["NO_VPATH_THIS_LEG"] = 26] = "NO_VPATH_THIS_LEG";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["CHECK_FPLN_ALT"] = 27] = "CHECK_FPLN_ALT";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["DECELERATE"] = 28] = "DECELERATE";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["UNABLE_NEXT_ALT"] = 29] = "UNABLE_NEXT_ALT";
    FMS_MESSAGE_ID[FMS_MESSAGE_ID["KBINPUTACTIVE"] = 30] = "KBINPUTACTIVE";
})(FMS_MESSAGE_ID || (FMS_MESSAGE_ID = {}));
/** A class that contains the CJ4 message definitions */
class MessageDefinitions {
    /** @returns Gets the message definitions */
    static get definitions() {
        return this._definitions;
    }
}
MessageDefinitions._definitions = new Map([
    [FMS_MESSAGE_ID.RESET_INITIAL_POS, new OperatingMessage([new MessageDefinition('RESET INITIAL POS', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.Yellow, 60)],
    [FMS_MESSAGE_ID.INITIALIZE_POSITION, new OperatingMessage([new MessageDefinition('INITIALIZE POSITION', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.Yellow, 50)],
    [FMS_MESSAGE_ID.NO_FLIGHT_PLAN, new OperatingMessage([new MessageDefinition('NO FLIGHT PLAN', MESSAGE_TARGET.FMC),
            new MessageDefinition('NO FLIGHT PLAN', MESSAGE_TARGET.MAP_MID)], MESSAGE_LEVEL.White, 20)],
    [FMS_MESSAGE_ID.FPLN_DISCONTINUITY, new OperatingMessage([new MessageDefinition('FPLN DISCONTINUITY', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.Yellow, 90)],
    [FMS_MESSAGE_ID.DISCONTINUITY, new OperatingMessage([new MessageDefinition('DISCONTINUITY', MESSAGE_TARGET.MAP_MID)], MESSAGE_LEVEL.White, 90)],
    [FMS_MESSAGE_ID.CHECK_SPEED, new OperatingMessage([new MessageDefinition('CHECK SPEED', MESSAGE_TARGET.FMC),
            new MessageDefinition('SPD', MESSAGE_TARGET.PFD_BOT)], MESSAGE_LEVEL.Yellow, 80)],
    [FMS_MESSAGE_ID.CHK_ALT_SEL, new OperatingMessage([new MessageDefinition('CHECK ALT SEL', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 70)],
    [FMS_MESSAGE_ID.HOLD, new OperatingMessage([new MessageDefinition('HOLD', MESSAGE_TARGET.PFD_BOT)], MESSAGE_LEVEL.White, 70)],
    [FMS_MESSAGE_ID.TOD, new OperatingMessage([new MessageDefinition('TOD', MESSAGE_TARGET.PFD_BOT)], MESSAGE_LEVEL.White, 50)],
    [FMS_MESSAGE_ID.OCEANIC, new OperatingMessage([new MessageDefinition('OCEANIC', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 49)],
    [FMS_MESSAGE_ID.TERM, new OperatingMessage([new MessageDefinition('TERM', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 50)],
    [FMS_MESSAGE_ID.LV_TERM, new OperatingMessage([new MessageDefinition('L/V TERM', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 51)],
    [FMS_MESSAGE_ID.LPV_TERM, new OperatingMessage([new MessageDefinition('LPV TERM', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 52)],
    [FMS_MESSAGE_ID.APPR, new OperatingMessage([new MessageDefinition('APPR', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 53)],
    [FMS_MESSAGE_ID.GPS_APPR, new OperatingMessage([new MessageDefinition('GPS APPR', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 54)],
    [FMS_MESSAGE_ID.LV_APPR, new OperatingMessage([new MessageDefinition('L/V APPR', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 55)],
    [FMS_MESSAGE_ID.LPV_APPR, new OperatingMessage([new MessageDefinition('LPV APPR', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 56)],
    [FMS_MESSAGE_ID.SEQ_INHB, new OperatingMessage([new MessageDefinition('SEQ INHB', MESSAGE_TARGET.PFD_TOP)], MESSAGE_LEVEL.White, 60)],
    [FMS_MESSAGE_ID.LOC_WILL_BE_TUNED, new OperatingMessage([new MessageDefinition('LOC WILL BE TUNED', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 50)],
    [FMS_MESSAGE_ID.CHECK_LOC_TUNING, new OperatingMessage([new MessageDefinition('CHECK LOC TUNING', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 75)],
    [FMS_MESSAGE_ID.PATH_BELOW_AC, new OperatingMessage([new MessageDefinition('PATH BELOW A/C', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 61)],
    [FMS_MESSAGE_ID.NO_VPATH_VECTORS, new OperatingMessage([new MessageDefinition('NO VPATH-VECTORS', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 62)],
    [FMS_MESSAGE_ID.NO_VPATH_CONDITION, new OperatingMessage([new MessageDefinition('NO VPATH CONDITION', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 63)],
    [FMS_MESSAGE_ID.NO_VPATH_PILOT_CMD, new OperatingMessage([new MessageDefinition('NO VPATH-PILOT CMD', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 64)],
    [FMS_MESSAGE_ID.NO_VPATH_TAE, new OperatingMessage([new MessageDefinition('NO VPATH-TAE', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 65)],
    [FMS_MESSAGE_ID.NO_VPATH_XTK, new OperatingMessage([new MessageDefinition('NO VPATH-XTK', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 66)],
    [FMS_MESSAGE_ID.NO_VPATH_THIS_LEG, new OperatingMessage([new MessageDefinition('NO VPATH THIS LEG', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 67)],
    [FMS_MESSAGE_ID.CHECK_FPLN_ALT, new OperatingMessage([new MessageDefinition('CHECK FPLN ALT', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 68)],
    [FMS_MESSAGE_ID.DECELERATE, new OperatingMessage([new MessageDefinition('DECELERATE', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 69)],
    [FMS_MESSAGE_ID.UNABLE_NEXT_ALT, new OperatingMessage([new MessageDefinition('UNABLE NEXT ALT', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.Yellow, 70)],
    [FMS_MESSAGE_ID.KBINPUTACTIVE, new OperatingMessage([new MessageDefinition('KB INPUT ACTIVE', MESSAGE_TARGET.FMC)], MESSAGE_LEVEL.White, 999)],
]);

const terminalScalingLabels = [
    CDIScaleLabel.Terminal,
    CDIScaleLabel.TerminalArrival,
    CDIScaleLabel.TerminalDeparture,
];
/**
 * Computes Boeing LNAV-related data.
 */
class BoeingNavDataComputer {
    /**
     * Creates a new instance of the NavdataComputer.
     * @param bus The event bus to use with this instance.
     * @param flightPlanner The flight planner to use with this instance.
     * @param performancePlan The active performance plan
     * @param facilityLoader The facility loader to use with this instance.
     * @param messageService The MessageServiceisntance to use.
     */
    constructor(bus, flightPlanner, performancePlan, facilityLoader, messageService) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.performancePlan = performancePlan;
        this.facilityLoader = facilityLoader;
        this.messageService = messageService;
        this.geoPointCache = [new GeoPoint(0, 0), new GeoPoint(0, 0), new GeoPoint(0, 0)];
        this.geoCircleCache = [new GeoCircle(new Float64Array(3), 0)];
        this.isInDiscontinuity = Subject.create(false);
        this.is2MinutesFromDiscontinuity = Subject.create(false);
        this.planePos = new GeoPoint(0, 0);
        this.publisher = this.bus.getPublisher();
        this.missedApproachManuallyActivated = false;
        this.lnavData = ObjectSubject.create({
            dtkTrue: 0,
            dtkMag: 0,
            xtk: 0,
            nextDtkTrue: 0,
            nextDtkMag: 0,
            cdiScale: 2,
            cdiScaleLabel: CDIScaleLabel.Enroute,
            rnp: 2,
            waypointBearingTrue: 0,
            waypointBearingMag: 0,
            waypointDistance: 0,
            waypointIdent: '',
            destinationDistance: 0,
            totalDistance: 0,
            nominalLegIndex: 0,
            destinationDistanceDirect: Number.MAX_SAFE_INTEGER,
            destinationRunwayDistanceDirect: Number.MAX_SAFE_INTEGER,
            distanceToFaf: Number.MAX_SAFE_INTEGER,
            distanceToMapDirect: Number.MAX_SAFE_INTEGER,
        });
        this.defaultRnp = 2;
        this.originFacility = Subject.create(undefined);
        this.destinationFacility = Subject.create(undefined);
        this.destinationLocation = new GeoPoint(NaN, NaN);
        this.originLocation = new GeoPoint(NaN, NaN);
        this.groundSpeed = 0;
        this.updateScalingMessages = () => {
            this.isOceanic() ? this.messageService.post(FMS_MESSAGE_ID.OCEANIC) : this.messageService.clear(FMS_MESSAGE_ID.OCEANIC);
            this.isTerm() ? this.messageService.post(FMS_MESSAGE_ID.TERM) : this.messageService.clear(FMS_MESSAGE_ID.TERM);
            this.isLVTerm() ? this.messageService.post(FMS_MESSAGE_ID.LV_TERM) : this.messageService.clear(FMS_MESSAGE_ID.LV_TERM);
            this.isLpvTerm() ? this.messageService.post(FMS_MESSAGE_ID.LPV_TERM) : this.messageService.clear(FMS_MESSAGE_ID.LPV_TERM);
            this.isAppr() ? this.messageService.post(FMS_MESSAGE_ID.APPR) : this.messageService.clear(FMS_MESSAGE_ID.APPR);
            this.isGpsAppr() ? this.messageService.post(FMS_MESSAGE_ID.GPS_APPR) : this.messageService.clear(FMS_MESSAGE_ID.GPS_APPR);
            this.isLVAppr() ? this.messageService.post(FMS_MESSAGE_ID.LV_APPR) : this.messageService.clear(FMS_MESSAGE_ID.LV_APPR);
            this.isLpvAppr() ? this.messageService.post(FMS_MESSAGE_ID.LPV_APPR) : this.messageService.clear(FMS_MESSAGE_ID.LPV_APPR);
        };
        const sub = this.bus.getSubscriber();
        this.lnavIsTracking = ConsumerSubject.create(sub.on('lnav_is_tracking'), false);
        this.lnavLegIndex = ConsumerSubject.create(sub.on('lnav_tracked_leg_index'), 0);
        this.lnavVectorIndex = ConsumerSubject.create(sub.on('lnav_tracked_vector_index'), 0);
        this.lnavTransitionMode = ConsumerSubject.create(sub.on('lnav_transition_mode'), LNavTransitionMode.None);
        this.lnavIsSuspended = ConsumerSubject.create(sub.on('lnav_is_suspended'), false);
        sub.on('gps-position').handle(lla => { this.planePos.set(lla.lat, lla.long); });
        // In the Boeing, the active flight plan is never modified directly
        // So instead we listen for when the mod flight plan is copied into the active flight plan
        sub.on('fplCopied').handle(this.updateOriginDest.bind(this));
        sub.on('active_approach_details_set').handle(d => {
            this.approachDetails = d;
            this.updateScalingMessages();
        });
        sub.on('realTime').atFrequency(1).handle(() => {
            this.updateCDIScaling();
        });
        sub.on('cdi_select').handle(x => {
            this.cdiSource = x;
            this.updateScalingMessages();
        });
        sub.on('ground_speed').withPrecision(0).handle(s => {
            this.groundSpeed = s;
        });
        sub.on('activate_missed_approach').handle(v => {
            this.missedApproachManuallyActivated = v;
        });
        this.lnavLegIndex.sub(trackedLegIndex => {
            if (this.missedApproachManuallyActivated) {
                this.handleActiveLegIndexChanged(trackedLegIndex);
            }
        });
        this.isInDiscontinuity.sub(x => {
            if (x) {
                const blinkEndTime = Date.now() + 5000;
                this.messageService.post(FMS_MESSAGE_ID.DISCONTINUITY, undefined, () => Date.now() < blinkEndTime);
            }
            else {
                this.messageService.clear(FMS_MESSAGE_ID.DISCONTINUITY);
            }
        });
        this.is2MinutesFromDiscontinuity.sub(x => {
            if (x) {
                this.messageService.post(FMS_MESSAGE_ID.FPLN_DISCONTINUITY);
            }
            else {
                this.messageService.clear(FMS_MESSAGE_ID.FPLN_DISCONTINUITY);
            }
        });
        // Start with enroute scaling, it should be able to find it's way from there
        // to the correct scaling once an origin or dest is entered.
        this.setEnRouteScaling();
        this.lnavData.sub((obj, key, value) => {
            switch (key) {
                case 'dtkTrue':
                    SimVar.SetSimVarValue(LNavDataVars.DTKTrue, SimVarValueType.Degree, value);
                    break;
                case 'dtkMag':
                    SimVar.SetSimVarValue(LNavDataVars.DTKMagnetic, SimVarValueType.Degree, value);
                    break;
                case 'xtk':
                    SimVar.SetSimVarValue(LNavDataVars.XTK, SimVarValueType.NM, value);
                    break;
                case 'cdiScale':
                    SimVar.SetSimVarValue(LNavDataVars.CDIScale, SimVarValueType.NM, value);
                    break;
                case 'cdiScaleLabel':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.CDIScaleLabel, SimVarValueType.Number, value);
                    this.updateScalingMessages();
                    break;
                case 'rnp':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.RNP, SimVarValueType.Number, value);
                    break;
                case 'waypointBearingTrue':
                    SimVar.SetSimVarValue(LNavDataVars.WaypointBearingTrue, SimVarValueType.Degree, value);
                    break;
                case 'waypointBearingMag':
                    SimVar.SetSimVarValue(LNavDataVars.WaypointBearingMagnetic, SimVarValueType.Degree, value);
                    break;
                case 'waypointDistance':
                    SimVar.SetSimVarValue(LNavDataVars.WaypointDistance, SimVarValueType.NM, value);
                    break;
                case 'waypointIdent':
                    this.publisher.pub('lnavdata_waypoint_ident', value, true, true);
                    break;
                case 'destinationDistance':
                    SimVar.SetSimVarValue(LNavDataVars.DestinationDistance, SimVarValueType.NM, value);
                    break;
                case 'totalDistance':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.TotalDistanceDirect, SimVarValueType.NM, value);
                    break;
                case 'nominalLegIndex':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.NominalLegIndex, SimVarValueType.Number, value);
                    break;
                case 'destinationDistanceDirect':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.DestinationDistanceDirect, SimVarValueType.NM, value);
                    break;
                case 'destinationRunwayDistanceDirect':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.DestinationRunwayDistanceDirect, SimVarValueType.NM, value);
                    break;
                case 'distanceToFaf':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.FafDistance, SimVarValueType.NM, value);
                    break;
                case 'distanceToMapDirect':
                    SimVar.SetSimVarValue(BoeingLNavDataVars.MapDistanceDirect, SimVarValueType.NM, value);
                    break;
            }
        }, true);
        this.lnavData.set('totalDistance', 0);
        this.originFacility.sub(this.updateTotalDirectDistance.bind(this));
        this.destinationFacility.sub(this.updateTotalDirectDistance.bind(this));
    }
    /**
     * Update loop for BoeingNavDataComputer
     */
    update() {
        this.computeTrackingVars(MagVar.get(this.planePos));
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateOriginDest() {
        const flightPlan = this.flightPlanner.hasActiveFlightPlan()
            ? this.flightPlanner.getActiveFlightPlan()
            : undefined;
        if (!flightPlan) {
            this.originFacility.set(undefined);
            this.destinationFacility.set(undefined);
            this.destinationRunway = undefined;
            return;
        }
        const { originAirport, destinationAirport } = flightPlan;
        if (originAirport) {
            this.facilityLoader.getFacility(FacilityType.Airport, originAirport).then(fac => {
                this.originFacility.set(fac);
            });
        }
        else {
            this.originFacility.set(undefined);
        }
        if (destinationAirport) {
            this.facilityLoader.getFacility(FacilityType.Airport, destinationAirport).then(fac => {
                this.destinationFacility.set(fac);
            });
        }
        else {
            this.destinationFacility.set(undefined);
        }
        this.destinationRunway = flightPlan === null || flightPlan === void 0 ? void 0 : flightPlan.procedureDetails.destinationRunway;
    }
    /** Updates the total direct distance when origin/destination change */
    updateTotalDirectDistance() {
        const originFacility = this.originFacility.get();
        const destinationFacility = this.destinationFacility.get();
        if (originFacility && destinationFacility) {
            this.originLocation.set(originFacility.lat, originFacility.lon);
            this.destinationLocation.set(destinationFacility.lat, destinationFacility.lon);
            const totalDistance = UnitType.NMILE.convertFrom(this.originLocation.distance(this.destinationLocation), UnitType.GA_RADIAN);
            this.lnavData.set('totalDistance', totalDistance);
        }
        else {
            this.originLocation.set(NaN, NaN);
            this.destinationLocation.set(NaN, NaN);
            this.lnavData.set('totalDistance', 0);
        }
    }
    /**
     * Computes the nav tracking data, such as XTK, DTK, and distance to turn.
     * @param magVar The computed current location magvar.
     */
    computeTrackingVars(magVar) {
        var _a, _b, _c;
        let xtk = 0;
        let dtkTrue = 0;
        let dtkMag = 0;
        let distance = 0;
        let waypointIdent = '';
        let waypointBearingTrue = 0;
        let waypointBearingMag = 0;
        let destinationDistance = 0;
        let nominalLegIndex = -1;
        let mapDistanceDirect = Number.MAX_SAFE_INTEGER;
        const plan = this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX) && this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const trackedLegIndex = this.lnavLegIndex.get();
        const nextLegIndex = trackedLegIndex + 1;
        const currentLeg = plan && trackedLegIndex >= 0 && trackedLegIndex < plan.length
            ? plan.tryGetLeg(trackedLegIndex)
            : undefined;
        const nextLeg = plan && nextLegIndex >= 0 && nextLegIndex < plan.length
            ? plan.tryGetLeg(nextLegIndex)
            : undefined;
        if (currentLeg !== null && currentLeg !== undefined && trackedLegIndex > 0) {
            nominalLegIndex = trackedLegIndex;
        }
        const isTracking = this.lnavIsTracking.get();
        if (plan && isTracking) {
            const transitionMode = this.lnavTransitionMode.get();
            let nominalLeg;
            let circle;
            if (transitionMode === LNavTransitionMode.Egress) {
                nominalLeg = nextLeg !== undefined && nextLeg !== null ? nextLeg : currentLeg;
                nominalLegIndex = nextLeg !== undefined && nextLeg !== null ? nextLegIndex : nominalLegIndex;
                if ((_a = nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath.length) {
                    circle = this.getNominalPathCircle(nextLeg, 0, LNavTransitionMode.Ingress, this.geoCircleCache[0]);
                }
            }
            else {
                nominalLeg = currentLeg;
                nominalLegIndex = trackedLegIndex;
                if ((_b = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.flightPath.length) {
                    circle = this.getNominalPathCircle(currentLeg, this.lnavVectorIndex.get(), transitionMode, this.geoCircleCache[0]);
                }
            }
            if (nominalLeg === null || nominalLeg === void 0 ? void 0 : nominalLeg.calculated) {
                waypointIdent = (_c = nominalLeg.name) !== null && _c !== void 0 ? _c : '';
                distance = this.getDistanceToTurn(nominalLeg, this.planePos);
                destinationDistance = this.getTotalDistance(nominalLegIndex, distance + UnitType.METER.convertTo(nominalLeg.calculated.egress.reduce((cum, vector) => cum + vector.distance, 0), UnitType.NMILE));
                if (nominalLeg.calculated.endLat !== undefined && nominalLeg.calculated.endLon) {
                    waypointBearingTrue = this.planePos.bearingTo(nominalLeg.calculated.endLat, nominalLeg.calculated.endLon);
                    waypointBearingMag = MagVar.trueToMagnetic(waypointBearingTrue, magVar);
                }
            }
            if (circle !== undefined) {
                xtk = UnitType.GA_RADIAN.convertTo(circle.distance(this.planePos), UnitType.NMILE);
                dtkTrue = circle.bearingAt(this.planePos, Math.PI);
                dtkMag = MagVar.trueToMagnetic(dtkTrue, magVar);
            }
        }
        if (this.approachDetails && this.approachDetails.missedApproachFacility) {
            mapDistanceDirect = UnitType.NMILE.convertFrom(this.planePos.distance(this.approachDetails.missedApproachFacility.lat, this.approachDetails.missedApproachFacility.lon), UnitType.GA_RADIAN);
        }
        this.updateDiscontinuityMessages(currentLeg, nextLeg, isTracking, distance);
        this.lnavData.set('nominalLegIndex', nominalLegIndex);
        this.lnavData.set('dtkTrue', dtkTrue);
        this.lnavData.set('dtkMag', dtkMag);
        this.lnavData.set('xtk', xtk);
        this.lnavData.set('waypointBearingTrue', waypointBearingTrue);
        this.lnavData.set('waypointBearingMag', waypointBearingMag);
        this.lnavData.set('waypointDistance', distance);
        this.lnavData.set('waypointIdent', waypointIdent);
        this.lnavData.set('destinationDistance', destinationDistance);
        this.lnavData.set('distanceToMapDirect', mapDistanceDirect);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    updateDiscontinuityMessages(currentLeg, nextLeg, isTracking, distance) {
        const isOnDiscoLeg = (currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.leg.type) === LegType.Discontinuity;
        const isOnVectorLeg = (currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.leg.type) === LegType.VM || (currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.leg.type) === LegType.FM;
        const isNextLegDiscoLeg = (nextLeg === null || nextLeg === void 0 ? void 0 : nextLeg.leg.type) === LegType.Discontinuity;
        const isOnGround = Simplane.getIsGrounded();
        let isWithin2MinutesOfDiscoLeg = false;
        if (isTracking && isNextLegDiscoLeg && !isOnVectorLeg) {
            const distanceToEndOfLeg = Math.round(distance * 1000) / 1000;
            const ttg = Math.round((distanceToEndOfLeg / this.groundSpeed) * 3600);
            const ttgToDiscoSeconds = isFinite(ttg) ? ttg : Number.MAX_SAFE_INTEGER;
            if (ttgToDiscoSeconds < 120) {
                isWithin2MinutesOfDiscoLeg = true;
            }
        }
        this.isInDiscontinuity.set(!isOnGround && isOnDiscoLeg && this.isGpsActiveSource());
        this.is2MinutesFromDiscontinuity.set(!isOnGround && (isWithin2MinutesOfDiscoLeg || isOnDiscoLeg));
    }
    /**
     * Computes the CDI scaling for the given LNAV data.
     */
    updateCDIScaling() {
        var _a;
        const flightPlan = this.flightPlanner.hasActiveFlightPlan()
            ? this.flightPlanner.getActiveFlightPlan()
            : undefined;
        const originFacility = this.originFacility.get();
        const destinationFacility = this.destinationFacility.get();
        if (!originFacility || !destinationFacility) {
            if (flightPlan !== undefined) {
                this.updateOriginDest();
            }
        }
        // If no origin, then just use 999 NM
        const distanceFromOriginNM = originFacility
            ? UnitType.GA_RADIAN.convertTo(this.planePos.distance(originFacility), UnitType.NMILE)
            : 999;
        // If no destination, then just use 999 NM
        const distanceToArivalNM = destinationFacility
            ? UnitType.GA_RADIAN.convertTo(this.planePos.distance(destinationFacility), UnitType.NMILE)
            : 999;
        const distanceToDestinationRunwayNM = this.destinationRunway
            ? UnitType.GA_RADIAN.convertTo(this.planePos.distance(this.destinationRunway.latitude, this.destinationRunway.longitude), UnitType.NMILE)
            : Number.MAX_SAFE_INTEGER;
        const currentScaling = this.lnavData.get().cdiScaleLabel;
        const isInNorthAtlantic = this.planePos.lat >= 27 && this.planePos.lat <= 67 &&
            this.planePos.lon >= -60 && this.planePos.lon <= -10;
        this.lnavData.set('destinationDistanceDirect', distanceToArivalNM);
        this.lnavData.set('destinationRunwayDistanceDirect', distanceToDestinationRunwayNM);
        // If pilot has manually entered RNP, use that
        const manualRnp = this.performancePlan.manualLateralRnp.get();
        const currentRnp = this.lnavData.get().rnp;
        if (manualRnp !== null && currentRnp !== manualRnp) {
            this.setManualScaling();
        }
        if (manualRnp === null && currentRnp !== this.defaultRnp) {
            this.setDefaultScale(this.defaultRnp);
        }
        // TODO check the following against Boeing default RNP logic
        // Default scaling of 2.0
        if (currentScaling === CDIScaleLabel.Enroute) {
            // Enroute -> Oceanic
            if (isInNorthAtlantic) {
                this.setOceanicScaling();
                return;
            }
            // Enroute -> TerminalDeparture
            if (distanceFromOriginNM <= 31) {
                this.setTerminalDepartureScaling();
                return;
            }
            // Enroute -> TerminalArrival
            if (distanceToArivalNM <= 31) {
                this.setTerminalArrivalScaling();
                return;
            }
            // Enroute -> Approach should not be possible, so not checking it here
            // Stay in Enroute
            return;
        }
        // Oceanic scaling of 4.0
        if (currentScaling === CDIScaleLabel.Oceanic) {
            // Oceanic -> Enroute
            if (!isInNorthAtlantic) {
                this.setEnRouteScaling();
                return;
            }
            // Oceanic -> TerminalArrival
            if (distanceToArivalNM <= 31) {
                this.setTerminalArrivalScaling();
                return;
            }
            // Stay in Oceanic
            return;
        }
        // TODO? REMOTE Scaling? The manual mentions it but doesn't explain
        if (!flightPlan) {
            // If we got here it means no flight plan, and not already in enroute or oceanic
            this.setEnRouteScaling();
            return;
        }
        if (flightPlan.activeLateralLeg < 0 || flightPlan.activeLateralLeg >= flightPlan.length) {
            // If we got here it means no active leg, and not already in enroute or oceanic
            this.setEnRouteScaling();
            return;
        }
        const currentLegIndex = flightPlan.activeLateralLeg;
        const currentLeg = flightPlan.getLeg(currentLegIndex);
        const isOnMissedApproachLeg = BitFlags.isAll(currentLeg.flags, LegDefinitionFlags.MissedApproach);
        const fafIndex = this.getFafIndex(flightPlan);
        const isAfterFAF = fafIndex !== undefined && currentLegIndex > fafIndex;
        const [isWithin2NmOfFAF, distanceToFafNM] = isAfterFAF
            ? [true, 0]
            : this.isWithin2NmOfFAF(flightPlan, currentLeg, fafIndex);
        const activeSegment = flightPlan.getSegment(flightPlan.getSegmentIndex(flightPlan.activeLateralLeg));
        const currentSegmentType = activeSegment.segmentType;
        // Terminal is when aircraft is within 31 NM radius of origin or arrival airport
        // We use TerminalDeparture to differentiate between TerminalArrival for nav-to-nav logic
        if (currentScaling === CDIScaleLabel.TerminalDeparture) {
            // TerminalDeparture -> EnRoute
            if (distanceFromOriginNM > 31) {
                this.setEnRouteScaling();
                return;
            }
            // TerminalDeparture -> TerminalArrival
            if (currentSegmentType !== FlightPlanSegmentType.Departure && distanceToArivalNM <= 31) {
                this.setTerminalArrivalScaling();
                return;
            }
            // TerminalDeparture -> Approach
            if (isAfterFAF || isWithin2NmOfFAF) {
                this.setApproachScaling();
                return;
            }
            // Stay in TerminalDeparture
            return;
        }
        // Terminal is when aircraft is within 31 NM radius of origin or arrival airport
        // We use TerminalArrival to differentiate between TerminalDeparture for nav-to-nav logic
        if (currentScaling === CDIScaleLabel.TerminalArrival) {
            // TerminalArrival -> EnRoute
            if (distanceToArivalNM > 31) {
                this.setEnRouteScaling();
                return;
            }
            // TerminalArrival -> Approach
            if (isAfterFAF || isWithin2NmOfFAF) {
                this.setApproachScaling();
                return;
            }
            // TerminalArrival -> MissedApproach
            if (isOnMissedApproachLeg) {
                this.setMissedApproachScaling();
                return;
            }
            // Stay in TerminalArrival
            return;
        }
        // Approach scaling starts at 1.0 at 2 NM out from FAF, then smoothly down to 0.3 at FAF and beyond
        if (currentScaling === CDIScaleLabel.Approach) {
            if (isWithin2NmOfFAF) {
                // Apply smooth transition
                const normalized = MathUtils.clamp(distanceToFafNM / 2, 0, 1);
                const newScaling = 0.3 + (0.7 * normalized);
                this.lnavData.set('cdiScale', newScaling);
            }
            else {
                this.lnavData.set('cdiScale', 1);
            }
            // Approach -> MissedApproach
            if (isOnMissedApproachLeg) {
                this.setMissedApproachScaling();
                return;
            }
            // Approach -> EnRoute
            if (distanceToArivalNM > 31 || !((_a = this.approachDetails) === null || _a === void 0 ? void 0 : _a.approachLoaded)) {
                this.setEnRouteScaling();
                return;
            }
            // Stay in Approach
            return;
        }
        if (currentScaling === CDIScaleLabel.MissedApproach) {
            // MissedApproach -> EnRoute
            if (!isOnMissedApproachLeg && distanceToArivalNM > 31) {
                this.setEnRouteScaling();
                return;
            }
            // MissedApproach -> TerminalArrival
            if (!isOnMissedApproachLeg && distanceToArivalNM <= 31) {
                this.setTerminalArrivalScaling();
                return;
            }
            // Stay in MissedApproach
            return;
        }
    }
    /** Set the pilot entered/manual RNP */
    setManualScaling() {
        this.lnavData.set('rnp', this.performancePlan.manualLateralRnp.get());
    }
    /**
     * Sets the CDI scale to default RNP if a manual RNP doesn't exist
     * @param defaultRnp default RNP for the current flight area
     */
    setDefaultScale(defaultRnp) {
        this.defaultRnp = defaultRnp;
        if (this.performancePlan.manualLateralRnp.get() === null) {
            this.lnavData.set('rnp', defaultRnp);
        }
    }
    // Honeywell FMS default RNPs are:
    // Oceanic: 12.0 NM
    // Enroute: 2.0 NM
    // Terminal: 1.0 NM
    // Approach: 0.5 NM
    // hint: we should be taking the leg RNP from the navdata if specified,
    // but it's missing in MSFS data
    // eslint-disable-next-line jsdoc/require-jsdoc
    setEnRouteScaling() {
        this.setDefaultScale(2);
        this.lnavData.set('cdiScale', 2);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.Enroute);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setOceanicScaling() {
        this.setDefaultScale(12);
        this.lnavData.set('cdiScale', 12);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.Oceanic);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setTerminalDepartureScaling() {
        this.setDefaultScale(1);
        this.lnavData.set('cdiScale', 1);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.TerminalDeparture);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setTerminalArrivalScaling() {
        this.setDefaultScale(1);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.TerminalArrival);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setApproachScaling() {
        this.setDefaultScale(0.5);
        this.lnavData.set('cdiScale', 1);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.Approach);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    setMissedApproachScaling() {
        this.setDefaultScale(0.5);
        this.lnavData.set('cdiScale', 0.3);
        this.lnavData.set('cdiScaleLabel', CDIScaleLabel.MissedApproach);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isOceanic() {
        return this.isGpsActiveSource() && this.isOceanicScaling();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isTerm() {
        return this.isGpsActiveSource() && this.isTerminalScaling();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isLVTerm() {
        return this.isGpsActiveSource() && this.isTerminalArrivalScaling() && this.isLnavVnavApproachLoaded();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isLpvTerm() {
        return this.isGpsActiveSource() && this.isTerminalArrivalScaling() && this.isSbasLpvApproachLoaded();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isAppr() {
        return this.isGpsActiveSource() && this.isApproachScaling();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isGpsAppr() {
        return this.isGpsActiveSource() && this.isApproachScaling() && this.isGpsApproachLoaded();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isLVAppr() {
        // TODO This isn't excatly right, but it's close enough for now, see manual
        return this.isGpsActiveSource() && this.isApproachScaling() && this.isLnavVnavApproachLoaded();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isLpvAppr() {
        // TODO This isn't excatly right, but it's close enough for now, see manual
        return this.isGpsActiveSource() && this.isApproachScaling() && this.isSbasLpvApproachLoaded();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isOceanicScaling() {
        return this.lnavData.get().cdiScaleLabel === CDIScaleLabel.Oceanic;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isTerminalScaling() {
        return terminalScalingLabels.includes(this.lnavData.get().cdiScaleLabel);
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isTerminalArrivalScaling() {
        return this.lnavData.get().cdiScaleLabel === CDIScaleLabel.TerminalArrival;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isApproachScaling() {
        return this.lnavData.get().cdiScaleLabel === CDIScaleLabel.Approach || this.lnavData.get().cdiScaleLabel === CDIScaleLabel.MissedApproach;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isGpsActiveSource() {
        var _a;
        return ((_a = this.cdiSource) === null || _a === void 0 ? void 0 : _a.type) === NavSourceType.Gps;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isGpsApproachLoaded() {
        if (this.approachDetails) {
            return BoeingFmsUtils.isGpsApproach(this.approachDetails.approachType);
        }
        else {
            return false;
        }
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isLnavVnavApproachLoaded() {
        var _a;
        return ((_a = this.approachDetails) === null || _a === void 0 ? void 0 : _a.approachRnavType) === RnavTypeFlags.LNAVVNAV;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    isSbasLpvApproachLoaded() {
        var _a;
        return ((_a = this.approachDetails) === null || _a === void 0 ? void 0 : _a.approachRnavType) === RnavTypeFlags.LPV;
    }
    /**
     * Gets the geo circle describing the nominal path tracked by LNAV.
     * @param leg The flight plan leg currently tracked by LNAV.
     * @param vectorIndex The index of the vector currently tracked by LNAV.
     * @param transitionMode The current LNAV transition mode.
     * @param out The geo circle to which to write the result.
     * @returns The geo circle describing the initial path of a flight plan leg, or undefined if one could not be
     * determined.
     */
    getNominalPathCircle(leg, vectorIndex, transitionMode, out) {
        if (!leg.calculated) {
            return undefined;
        }
        const legCalc = leg.calculated;
        switch (leg.leg.type) {
            case LegType.DF: {
                const vector = legCalc.flightPath[legCalc.flightPath.length - 1];
                if (!vector) {
                    return undefined;
                }
                if (FlightPathUtils.isVectorGreatCircle(vector)) {
                    return FlightPathUtils.setGeoCircleFromVector(vector, out);
                }
                else {
                    const turn = FlightPathUtils.setGeoCircleFromVector(vector, out);
                    const turnEnd = this.geoPointCache[0].set(vector.endLat, vector.endLon);
                    const bearingAtEnd = turn.bearingAt(turnEnd);
                    return isNaN(bearingAtEnd) ? undefined : out.setAsGreatCircle(turnEnd, bearingAtEnd);
                }
            }
            case LegType.HM:
            case LegType.HF:
            case LegType.HA: {
                const vectors = transitionMode === LNavTransitionMode.None
                    ? LNavUtils.getVectorsForTransitionMode(legCalc, transitionMode, this.lnavIsSuspended.get())
                    : legCalc.flightPath;
                const searchStartIndex = transitionMode === LNavTransitionMode.None || transitionMode === LNavTransitionMode.Unsuspend
                    ? vectorIndex
                    : transitionMode === LNavTransitionMode.Ingress
                        ? 0
                        : 3;
                let vector;
                for (let i = searchStartIndex; i < vectors.length; i++) {
                    const holdVector = vectors[i];
                    if (BitFlags.isAny(holdVector.flags, FlightPathVectorFlags.HoldOutboundLeg | FlightPathVectorFlags.HoldInboundLeg)) {
                        vector = holdVector;
                        break;
                    }
                }
                return vector ? FlightPathUtils.setGeoCircleFromVector(vector, out) : undefined;
            }
            default: {
                let nominalVectorIndex;
                switch (transitionMode) {
                    case LNavTransitionMode.Ingress:
                        nominalVectorIndex = 0;
                        break;
                    case LNavTransitionMode.Egress:
                        nominalVectorIndex = legCalc.flightPath.length - 1;
                        break;
                    default:
                        nominalVectorIndex = vectorIndex;
                }
                const vector = legCalc.flightPath[nominalVectorIndex];
                return vector ? FlightPathUtils.setGeoCircleFromVector(vector, out) : undefined;
            }
        }
    }
    /**
     * Gets the active distance from the plane position to the leg end.
     * @param leg The leg to get the distance for.
     * @param pos The current plane position.
     * @returns The distance, in nautical miles.
     */
    getActiveDistance(leg, pos) {
        var _a;
        const finalVector = (_a = leg.calculated) === null || _a === void 0 ? void 0 : _a.flightPath[leg.calculated.flightPath.length - 1];
        if (finalVector !== undefined) {
            return UnitType.GA_RADIAN.convertTo(pos.distance(finalVector.endLat, finalVector.endLon), UnitType.NMILE);
        }
        return 0;
    }
    /**
     * Gets the total distance from the plane position to the destination leg.
     * @param activeLegIndex The global leg index of the active flight plan leg.
     * @param activeLegDistance The distance from the present position to the end of the active leg, in nautical miles.
     * @returns The distance, in nautical miles.
     */
    getTotalDistance(activeLegIndex, activeLegDistance) {
        var _a, _b, _c, _d, _e, _f;
        const plan = this.flightPlanner.getActiveFlightPlan();
        const activeLegCumulativeDistance = (_c = (_b = (_a = plan.tryGetLeg(activeLegIndex)) === null || _a === void 0 ? void 0 : _a.calculated) === null || _b === void 0 ? void 0 : _b.cumulativeDistanceWithTransitions) !== null && _c !== void 0 ? _c : 0;
        let lastLegIndex = plan.length - 1;
        for (const leg of plan.legs(true)) {
            if (!BitFlags.isAll(leg.flags, LegDefinitionFlags.MissedApproach)) {
                break;
            }
            lastLegIndex--;
        }
        const destinationLegCumulativeDistance = (_f = (_e = (_d = plan.tryGetLeg(lastLegIndex)) === null || _d === void 0 ? void 0 : _d.calculated) === null || _e === void 0 ? void 0 : _e.cumulativeDistanceWithTransitions) !== null && _f !== void 0 ? _f : 0;
        return UnitType.METER.convertTo(destinationLegCumulativeDistance - activeLegCumulativeDistance, UnitType.NMILE) + activeLegDistance;
    }
    /**
     * Gets the active distance from the plane position to the next leg turn.
     * @param leg The leg to get the distance for.
     * @param pos The current plane position.
     * @returns The distance, in nautical miles.
     */
    getDistanceToTurn(leg, pos) {
        if (leg.calculated !== undefined) {
            const firstEgressVector = leg.calculated.egress[0];
            if (firstEgressVector) {
                return UnitType.GA_RADIAN.convertTo(pos.distance(firstEgressVector.startLat, firstEgressVector.startLon), UnitType.NMILE);
            }
            else {
                return this.getActiveDistance(leg, pos);
            }
        }
        return 0;
    }
    /**
     * Starts at FAF and works backwards to current leg to caculate the distance to the FAF and determine if we are within 2 NM of it.
     * Sets the distanceToFaf lnav data value.
     * @param flightPlan flightPlan
     * @param currentLeg currentLeg
     * @param fafIndex fafIndex
     * @returns Whether aircraft is within 2 NM or after the FAF and distance to FAF when within 2 NM before FAF
     */
    isWithin2NmOfFAF(flightPlan, currentLeg, fafIndex) {
        var _a, _b, _c;
        if (((_a = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _a === void 0 ? void 0 : _a.endLat) === undefined || ((_b = currentLeg === null || currentLeg === void 0 ? void 0 : currentLeg.calculated) === null || _b === void 0 ? void 0 : _b.endLon) === undefined || fafIndex === undefined) {
            this.lnavData.set('distanceToFaf', Number.MAX_SAFE_INTEGER);
            return [false, Number.MAX_SAFE_INTEGER];
        }
        let sumNM = 0;
        for (const leg of flightPlan.legs(true, fafIndex)) {
            if (leg === currentLeg) {
                sumNM += UnitType.GA_RADIAN.convertTo(this.planePos.distance(currentLeg.calculated.endLat, currentLeg.calculated.endLon), UnitType.NMILE);
                return [sumNM <= 2, sumNM];
            }
            else {
                sumNM += ((_c = leg.calculated) === null || _c === void 0 ? void 0 : _c.distanceWithTransitions) || 0;
                if (sumNM > 2) {
                    return [false, Number.MAX_SAFE_INTEGER];
                }
            }
        }
        this.lnavData.set('distanceToFaf', sumNM);
        return [sumNM <= 2, sumNM];
    }
    /**
     * Gets the FAF index in the plan.
     * @param plan The flight plan.
     * @returns The FAF index in the plan, or undefined if not found.
     */
    getFafIndex(plan) {
        if (plan.length > 0) {
            for (let l = plan.length - 1; l > 0; l--) {
                const planLeg = plan.tryGetLeg(l);
                if (planLeg && BitFlags.isAll(planLeg.leg.fixTypeFlags, FixTypeFlags.FAF)) {
                    return l;
                }
            }
        }
        return undefined;
    }
    /**
     * Handles resetting whether the missed approach is active on a tracked leg change.
     * @param trackedLegIndex The currently tracked leg index.
     */
    handleActiveLegIndexChanged(trackedLegIndex) {
        const plan = this.flightPlanner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX) && this.flightPlanner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
        const currentLeg = plan && trackedLegIndex >= 0 && trackedLegIndex < plan.length
            ? plan.tryGetLeg(trackedLegIndex)
            : undefined;
        if (!currentLeg || !BitFlags.isAny(currentLeg.flags, LegDefinitionFlags.MissedApproach)) {
            this.bus.getPublisher().pub('activate_missed_approach', false, true);
        }
    }
}

/* eslint-disable @typescript-eslint/no-empty-function */
/** NavToNav manager using the state pattern */
class BoeingNavToNavManager {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(bus, apValues) {
        this.bus = bus;
        this.apValues = apValues;
        this.onTransferred = () => { };
        this.localizerCourse = Subject.create(null);
        this.approachFrequency = Subject.create(null);
        this.nav3LateralDeviation = 0;
        this.currentHeading = 0;
        this.hudTakeoffRunway = null;
        /** Direct distance to the destination in nautical miles from ppos. */
        this.destinationDistance = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_destination_distance_direct').whenChangedBy(1), Infinity);
        /** Direct from origin to destination in nautical miles, or 0 when invalid. */
        this.totalDistance = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_total_distance_direct').whenChangedBy(1), Infinity);
        /** Past the halfway point between the origin and the destination, or less than 50 NM to destination as a fallback */
        this.pastHalfway = MappedSubject.create(([totalDistance, destinationDistance]) => (totalDistance > 0 && destinationDistance / totalDistance < 0.5) || destinationDistance < 50, this.totalDistance, this.destinationDistance);
        /** Direct distance to the destination runway in nautical miles */
        this.distanceToRunway = ConsumerSubject.create(this.bus.getSubscriber().on('lnavdata_destination_runway_distance_direct').atFrequency(0.1), Infinity);
        this.todLeg = ConsumerSubject.create(this.bus.getSubscriber().on('vnav_tod_global_leg_index'), -1);
        this.todDistance = ConsumerSubject.create(this.bus.getSubscriber().on('vnav_tod_distance').atFrequency(0.1), 0);
        /** Distance to ToD in nautical miles, or infinity when invalid. */
        this.distanceToToD = MappedSubject.create(([todLeg, todDistance]) => todLeg >= 0 ? UnitType.NMILE.convertFrom(todDistance, UnitType.METER) : 0, this.todLeg, this.todDistance);
        this.frequencyManuallyTuned = ConsumerSubject.create(this.bus.getSubscriber().on('approach_frequency_manually_tuned'), null);
        this.takeoffTimer = new DebounceTimer();
        this.inhibitAfterTakeoff = Subject.create(false);
        this.onGround = ConsumerSubject.create(this.bus.getSubscriber().on('on_ground'), true);
        this.apEngaged = ConsumerSubject.create(this.bus.getSubscriber().on('ap_master_status'), false);
        this.fd1Engaged = ConsumerSubject.create(this.bus.getSubscriber().on('ap_boeing_flight_director_is_active_1'), false);
        this.fd2Engaged = ConsumerSubject.create(this.bus.getSubscriber().on('ap_boeing_flight_director_is_active_2'), false);
        this.eitherFdEngaged = MappedSubject.create(([fd1, fd2]) => (fd1 || fd2), this.fd1Engaged, this.fd2Engaged);
        this.radioHeightUnder10 = Subject.create(false);
        this.radioHeightUnder500 = Subject.create(false);
        this.radioHeightUnder1500 = Subject.create(false);
        this.fmsOperatingPhase = ConsumerSubject.create(this.bus.getSubscriber().on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.automaticApproachTuningInhibited = MappedSubject.create(([inhibitAfterTakeoff, onGround, fmsOperatingPhase]) => inhibitAfterTakeoff
            || onGround && (fmsOperatingPhase <= FmsOperatingPhase.TAKEOFF || fmsOperatingPhase === FmsOperatingPhase.COMPLETE), this.inhibitAfterTakeoff, this.onGround, this.fmsOperatingPhase);
        /** @inheritdoc */
        this.canLocArm = () => {
            // The AP LOC director handles this
            return false;
        };
        /** @inheritdoc */
        this.canLocActivate = () => {
            // The AP LOC director handles this
            return false;
        };
        this.currentState = new NavToNavOff(this, bus);
        this.currentState.enter();
        this.bus.getSubscriber().on('active_approach_details_set').handle(x => {
            var _a, _b;
            // assuming this means destination runway change...
            this.inhibitAfterTakeoff.set(false);
            this.localizerCourse.set((_a = x.finalApproachCourse) !== null && _a !== void 0 ? _a : null);
            const locFreq = BoeingFmsUtils.isLocalizerApproach(x.approachType) ? (_b = x.referenceFacility) === null || _b === void 0 ? void 0 : _b.freqMHz : undefined;
            this.approachFrequency.set(locFreq !== null && locFreq !== void 0 ? locFreq : null);
        });
        this.bus.getSubscriber().on('nav_cdi_3').whenChanged().handle(x => {
            this.nav3LateralDeviation = x;
            this.currentState.onLateralDeviationChange();
        });
        this.bus.getSubscriber().on('hdg_deg').withPrecision(0).handle(x => {
            this.currentHeading = x;
            this.currentState.onCurrentHeadingChange();
        });
        this.bus.getSubscriber().on('boeing_hud_takeoff_runway_set').handle(x => {
            this.hudTakeoffRunway = x;
            this.currentState.onHudTakeoffRunwayChange();
        });
        this.pastHalfway.sub(() => this.currentState.onPastHalfwayChange());
        this.distanceToRunway.sub(() => this.currentState.onDistanceToRunwayChange());
        this.distanceToToD.sub(() => this.currentState.onDistanceToToDChange());
        this.frequencyManuallyTuned.sub(() => this.currentState.onFrequencyManuallyTuned());
        this.apValues.lateralActive.sub(() => this.currentState.onApFdChange());
        this.apValues.verticalActive.sub(() => this.currentState.onApFdChange());
        this.apValues.apApproachModeOn.sub(() => this.currentState.onApFdChange());
        this.apEngaged.sub(() => this.currentState.onApFdChange());
        this.eitherFdEngaged.sub(() => this.currentState.onApFdChange());
        this.radioHeightUnder10.sub(() => this.currentState.onRadioHeightChange());
        this.radioHeightUnder500.sub(() => this.currentState.onRadioHeightChange());
        this.radioHeightUnder1500.sub(() => this.currentState.onRadioHeightChange());
        this.fmsOperatingPhase.sub(() => this.currentState.onFmsOperatingPhaseChange());
        this.localizerCourse.sub(() => this.currentState.onLocalizerCourseChange());
        this.approachFrequency.sub(() => this.currentState.onApproachFrequencyChange());
        this.bus.getSubscriber().on('ra_radio_alt_1').atFrequency(1).handle((ra) => {
            this.radioHeightUnder10.set(ra < 10);
            this.radioHeightUnder500.set(ra < 500);
            this.radioHeightUnder1500.set(ra < 1500);
        });
        this.bus.getSubscriber().on('ra_state_1').handle((state) => {
            if (state.current !== AvionicsSystemState.On) {
                this.radioHeightUnder10.set(false);
                this.radioHeightUnder500.set(false);
                this.radioHeightUnder1500.set(false);
            }
        });
        this.onGround.sub((onGround) => {
            if (onGround) {
                this.takeoffTimer.clear();
                this.inhibitAfterTakeoff.set(false);
            }
            else {
                this.inhibitAfterTakeoff.set(true);
                this.takeoffTimer.schedule(() => this.inhibitAfterTakeoff.set(false), BoeingNavToNavManager.INHIBIT_TIME_AFTER_TAKEOFF);
            }
            this.currentState.onGroundChange();
        });
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getApproachFrequency() {
        return this.approachFrequency.get();
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getScalingLabel() {
        return this.scalingLabel;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getLocalizerCourse() {
        var _a;
        return (_a = this.localizerCourse.get()) !== null && _a !== void 0 ? _a : 0;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getNav3LateralDeviation() {
        return this.nav3LateralDeviation;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getActiveNavSourceType() {
        return this.activeNavSourceType;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    getCurrentHeading() {
        return this.currentHeading;
    }
    /**
     * Past the halfway point between the origin and the destination
     * @returns Past the halfway point between the origin and the destination
     */
    getPastHalfway() {
        return this.pastHalfway.get();
    }
    /**
     * Direct distance to the destination runway in nautical miles
     * @returns Direct distance to the destination runway in nautical miles
     */
    getDistanceToRunway() {
        return this.distanceToRunway.get();
    }
    /**
     * Distance to ToD in nautical miles, or infinity when invalid
     * @returns Distance to ToD in nautical miles, or infinity when invalid
     */
    getDistanceToToD() {
        return this.distanceToToD.get();
    }
    /**
     * Check if approach frequency was manually tuned
     * @returns true if manually tuned
     */
    getFrequencyManuallyTuned() {
        return this.frequencyManuallyTuned.get();
    }
    /**
     * Is the autopilot currently engaged/active
     * @returns true when AP engaged
     */
    getAutopilotEngaged() {
        return this.apEngaged.get();
    }
    /**
     * Is a flight director currently engaged/active
     * @returns true if either FD is engaged
     */
    getFlightDirectorEngaged() {
        return this.eitherFdEngaged.get();
    }
    /**
     * Check if the radio height is under 10 feet
     * @returns true when RA valid and under 10 feet
     */
    getRadioHeightUnder10() {
        return this.radioHeightUnder10.get();
    }
    /**
     * Check if the radio height is under 500 feet
     * @returns true when RA valid and under 500 feet
     */
    getRadioHeightUnder500() {
        return this.radioHeightUnder500.get();
    }
    /**
     * Check if the radio height is under 1500 feet
     * @returns true when RA valid and under 1500 feet
     */
    getRadioHeightUnder1500() {
        return this.radioHeightUnder1500.get();
    }
    /**
     * Check if the aircraft is on the ground
     * @returns true when on the ground
     */
    getOnGround() {
        return this.onGround.get();
    }
    /**
     * Check if approach tuning is inhibited during/after takeoff (10 minutes unless dest runway changed)
     * @returns true when inhibited
     */
    isAutomaticApproachTuningInhibited() {
        return this.automaticApproachTuningInhibited.get();
    }
    /**
     * Gets the current FMS operating phase
     * @returns current phase
     */
    getFmsOperatingPhase() {
        return this.fmsOperatingPhase.get();
    }
    /**
     * Gets the active HUD takeoff runway
     * @returns HUD takeoff runway or null if deselected
     */
    getHudTakeoffRunway() {
        return this.hudTakeoffRunway;
    }
    /** Clears the active HUD takeoff runway */
    clearHudTakeoffRunway() {
        this.hudTakeoffRunway = null;
    }
    /** Changes to next state. Meant to be called by the state instances themselves.
     * @param newState newState */
    changeState(newState) {
        this.currentState.exit();
        this.currentState = newState;
        this.currentState.enter();
    }
    /**
     * Set the current approach tuning mode
     * @param mode Current approach tuning mode to set
     */
    setTuningMode(mode) {
        this.bus.getPublisher().pub('approach_tuning_mode', mode, true, true);
    }
    /**
     * Set whether approach tuning is inhibited
     * @param inhibited true if inhibited
     */
    setTuningInhibited(inhibited) {
        this.bus.getPublisher().pub('approach_tuning_inhibited', inhibited, true, true);
    }
}
/** Time to inhibit autotuning after takeoff (unless dest runway is changed) */
BoeingNavToNavManager.INHIBIT_TIME_AFTER_TAKEOFF = 10 * 60000;
/** A NavToNav state in the state pattern. */
class NavToNavState {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(navToNav, bus) {
        this.navToNav = navToNav;
        this.bus = bus;
        this.onApproachFrequencyChange = () => { };
        this.onLocalizerCourseChange = () => { };
        this.onLateralDeviationChange = () => { };
        this.onCurrentHeadingChange = () => { };
        this.onPastHalfwayChange = () => { };
        this.onDistanceToToDChange = () => { };
        this.onDistanceToRunwayChange = () => { };
        this.onFrequencyManuallyTuned = () => { };
        this.onRadioHeightChange = () => { };
        this.onApFdChange = () => { };
        // all phases except off should reset to off when the flight is completed
        this.onFmsOperatingPhaseChange = () => {
            if (this.navToNav.getFmsOperatingPhase() === FmsOperatingPhase.COMPLETE) {
                this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
            }
        };
        this.onHudTakeoffRunwayChange = () => { };
        this.onGroundChange = () => { };
    }
    /** Is called when it becomes the current state */
    enter() { }
    /** Is called just before moving to a new state */
    exit() { }
}
/** NavToNav is OFF and waiting to turn on once in terminal area with localizer approach in flight plan. AKA PARK */
class NavToNavOff extends NavToNavState {
    constructor() {
        super(...arguments);
        // eslint-disable-next-line jsdoc/require-jsdoc
        this.tryGoToNextState = () => {
            if (this.navToNav.getOnGround() && this.navToNav.getFmsOperatingPhase() <= FmsOperatingPhase.TAKEOFF
                && this.navToNav.getHudTakeoffRunway() !== null && this.navToNav.getFlightDirectorEngaged()) {
                this.navToNav.changeState(new NavToNavHudTakeoff(this.navToNav, this.bus));
                return;
            }
            const hasApproachFrequency = !!this.navToNav.getApproachFrequency();
            const manuallyTuned = this.navToNav.getFrequencyManuallyTuned() !== null;
            // When to move to next state?
            // ILS, LOC, LOC-BC, or GLS (TODO) approach is selected, and within 200 NM of ToD and halfway to destination
            // or manually tuned
            const autotuneInhibited = this.navToNav.isAutomaticApproachTuningInhibited() || !hasApproachFrequency;
            // Can we "park" tune?
            const canParkAutoTune = !autotuneInhibited && this.navToNav.getDistanceToToD() < 200 && this.navToNav.getPastHalfway();
            // Otherwise, if we meet the conditions for directly autotuning, we want to jump through
            const inDescent = this.navToNav.getFmsOperatingPhase() === FmsOperatingPhase.DESCENT || this.navToNav.getFmsOperatingPhase() === FmsOperatingPhase.APPROACH;
            const canAutoTune = !autotuneInhibited &&
                (this.navToNav.getDistanceToToD() < 50 || this.navToNav.getDistanceToRunway() < 150 || inDescent);
            if (manuallyTuned || canParkAutoTune || canAutoTune) {
                this.navToNav.changeState(new NavToNavTunePending(this.navToNav, this.bus));
            }
        };
    }
    /** @inheritdoc */
    enter() {
        // clear tuned frequency
        SimVar.SetSimVarValue('K:NAV3_RADIO_SET_HZ', 'Hz', 0);
        this.navToNav.setTuningMode(ApproachTuningMode.Park);
        // on manually tuned go straight to armed?
        this.onPastHalfwayChange = this.tryGoToNextState;
        this.onDistanceToToDChange = this.tryGoToNextState;
        this.onApproachFrequencyChange = this.tryGoToNextState;
        this.onFrequencyManuallyTuned = this.tryGoToNextState;
        this.onHudTakeoffRunwayChange = this.tryGoToNextState;
        this.onApFdChange = this.tryGoToNextState;
        this.onFmsOperatingPhaseChange = this.tryGoToNextState;
        this.tryGoToNextState();
    }
}
// TODO consider any tuning outside of this state to be manual tuning
/** Tunes the nav radios to the localizer. */
class NavToNavTunePending extends NavToNavState {
    /** @inheritdoc */
    enter() {
        var _a;
        if (this.navToNav.getFrequencyManuallyTuned() !== null) {
            // the pilot has manually tuned the ILS, so we go straight to armed ready for an approach
            SimVar.SetSimVarValue('K:NAV3_RADIO_SET_HZ', 'Hz', this.navToNav.getFrequencyManuallyTuned() * 1000000);
            this.navToNav.setTuningMode(ApproachTuningMode.ManuallyTuned);
            this.navToNav.changeState(new NavToNavArmed(this.navToNav, this.bus));
        }
        else {
            // we're autotuning the approach
            SimVar.SetSimVarValue('K:NAV3_RADIO_SET_HZ', 'Hz', ((_a = this.navToNav.getApproachFrequency()) !== null && _a !== void 0 ? _a : 0) * 1000000);
            this.navToNav.setTuningMode(ApproachTuningMode.ParkTuned);
            this.navToNav.changeState(new NavToNavApproachParked(this.navToNav, this.bus));
        }
    }
}
/** LOC tuned but parked */
class NavToNavApproachParked extends NavToNavState {
    constructor() {
        super(...arguments);
        // eslint-disable-next-line jsdoc/require-jsdoc
        this.tryGoToNextState = () => {
            const inDescent = this.navToNav.getFmsOperatingPhase() === FmsOperatingPhase.DESCENT || this.navToNav.getFmsOperatingPhase() === FmsOperatingPhase.APPROACH;
            if (this.navToNav.getDistanceToToD() < 50 || this.navToNav.getDistanceToRunway() < 150 || inDescent) {
                this.navToNav.setTuningMode(ApproachTuningMode.Autotuned);
                this.navToNav.changeState(new NavToNavArmed(this.navToNav, this.bus));
            }
        };
    }
    /** @inheritdoc */
    enter() {
        this.setCourseToLocalizerCourse();
        // Setup a handler to reset nav to nav if approach freq changes
        this.onApproachFrequencyChange = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onDistanceToToDChange = this.tryGoToNextState;
        this.onDistanceToRunwayChange = this.tryGoToNextState;
        this.tryGoToNextState();
    }
    /** Set the NAV course/obs to the localiser course */
    setCourseToLocalizerCourse() {
        const course = this.navToNav.getLocalizerCourse();
        SimVar.SetSimVarValue('K:VOR3_SET', 'number', Math.round(course));
    }
}
/** LOC tuned and waiting to capture */
class NavToNavArmed extends NavToNavState {
    constructor() {
        super(...arguments);
        // eslint-disable-next-line jsdoc/require-jsdoc
        this.tryGoToNextState = () => {
            if (this.navToNav.apValues.lateralActive.get() === APLateralModes.LOC) {
                this.navToNav.changeState(new NavToNavCaptured(this.navToNav, this.bus));
            }
        };
    }
    /** @inheritdoc */
    enter() {
        // Setup a handler to reset nav to nav if approach freq changes
        this.onApproachFrequencyChange = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onFrequencyManuallyTuned = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onLocalizerCourseChange = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onCurrentHeadingChange = this.tryGoToNextState;
        this.onLateralDeviationChange = this.tryGoToNextState;
        this.navToNav.apValues.lateralArmed.sub(this.tryGoToNextState);
        this.tryGoToNextState();
    }
    /** @inheritdoc */
    exit() {
        this.navToNav.apValues.lateralArmed.unsub(this.tryGoToNextState);
    }
}
/** We are switching the active nav source to be the localizer. */
class NavToNavCaptured extends NavToNavState {
    constructor() {
        super(...arguments);
        // eslint-disable-next-line jsdoc/require-jsdoc
        this.tryGoToNextState = () => {
            const locOrGsCaptured = (this.navToNav.apValues.lateralActive.get() === APLateralModes.LOC || this.navToNav.apValues.verticalActive.get() === APVerticalModes.GS);
            if (!locOrGsCaptured) {
                this.navToNav.changeState(new NavToNavArmed(this.navToNav, this.bus));
            }
            if ((this.navToNav.getAutopilotEngaged() && locOrGsCaptured)
                || (this.navToNav.getFlightDirectorEngaged() && locOrGsCaptured && this.navToNav.getRadioHeightUnder500())) {
                this.navToNav.changeState(new NavToNavInhibit(this.navToNav, this.bus));
            }
        };
    }
    /** @inheritdoc */
    enter() {
        // Setup a handler to reset nav to nav if approach freq changes
        this.onApproachFrequencyChange = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onFrequencyManuallyTuned = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onLocalizerCourseChange = () => this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        this.onRadioHeightChange = this.tryGoToNextState;
        this.onApFdChange = this.tryGoToNextState;
    }
}
/**
 * Tuning is inhibited
 */
class NavToNavInhibit extends NavToNavState {
    constructor() {
        super(...arguments);
        this.tryGoToNextState = () => {
            const locOrGsCaptured = (this.navToNav.apValues.lateralActive.get() === APLateralModes.LOC || this.navToNav.apValues.verticalActive.get() === APVerticalModes.GS);
            if (!(this.navToNav.getAutopilotEngaged() && locOrGsCaptured)
                && !(this.navToNav.getFlightDirectorEngaged() && locOrGsCaptured && this.navToNav.getRadioHeightUnder500())) {
                this.navToNav.changeState(new NavToNavArmed(this.navToNav, this.bus));
            }
            if (this.navToNav.getFrequencyManuallyTuned() !== null) {
                const toga = this.navToNav.apValues.verticalActive.get() === APVerticalModes.TO || this.navToNav.apValues.verticalActive.get() === APVerticalModes.GA;
                const noApFd = !this.navToNav.getAutopilotEngaged() && !this.navToNav.getFlightDirectorEngaged();
                if (toga || noApFd || (!this.navToNav.apValues.apApproachModeOn.get() && this.navToNav.getRadioHeightUnder1500())) {
                    this.navToNav.changeState(new NavToNavArmed(this.navToNav, this.bus));
                }
            }
        };
    }
    /** @inheritdoc */
    enter() {
        this.navToNav.setTuningInhibited(true);
        this.onRadioHeightChange = this.tryGoToNextState;
        this.onApFdChange = this.tryGoToNextState;
    }
    /** @inheritdoc */
    exit() {
        this.navToNav.setTuningInhibited(false);
    }
}
/**
 * HUD Takeoff State
 */
class NavToNavHudTakeoff extends NavToNavState {
    /** @inheritdoc */
    enter() {
        this.navToNav.setTuningInhibited(true);
        this.onApFdChange = this.tryGoToNextState;
        this.onRadioHeightChange = this.tryGoToNextState;
        const runway = this.navToNav.getHudTakeoffRunway();
        if (runway !== null && runway.ilsFrequency && runway.ilsFrequency.freqMHz > 0) {
            SimVar.SetSimVarValue('K:NAV3_RADIO_SET_HZ', 'Hz', runway.ilsFrequency.freqMHz * 1000000);
            SimVar.SetSimVarValue('K:VOR3_SET', 'number', Math.round(runway.ilsFrequency.localizerCourse));
            this.navToNav.setTuningMode(ApproachTuningMode.Autotuned);
        }
        else {
            this.navToNav.clearHudTakeoffRunway();
            this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        }
    }
    /** @inheritdoc */
    exit() {
        this.navToNav.setTuningInhibited(false);
    }
    /** @inheritdoc */
    tryGoToNextState() {
        // HUD takeoff is locked in until AP and FDs are off, even if a different runway is selected in the FMS
        // Flight crew procedure on changing HUD takeoff runway or de-selecting HUD takeoff is to cycle FDs
        // LOC is detuned at approx 10 feet RA on takeoff
        if (!this.navToNav.getRadioHeightUnder10() || (!this.navToNav.getAutopilotEngaged() && !this.navToNav.getFlightDirectorEngaged())) {
            this.navToNav.changeState(new NavToNavOff(this.navToNav, this.bus));
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
var BoeingMaxBankIndex;
(function (BoeingMaxBankIndex) {
    BoeingMaxBankIndex[BoeingMaxBankIndex["THIRTY_DEGREES"] = 0] = "THIRTY_DEGREES";
    BoeingMaxBankIndex[BoeingMaxBankIndex["TWENTY_FIVE_DEGREES"] = 1] = "TWENTY_FIVE_DEGREES";
    BoeingMaxBankIndex[BoeingMaxBankIndex["TWENTY_DEGREES"] = 2] = "TWENTY_DEGREES";
    BoeingMaxBankIndex[BoeingMaxBankIndex["FIFTEEN_DEGREES"] = 3] = "FIFTEEN_DEGREES";
    BoeingMaxBankIndex[BoeingMaxBankIndex["TEN_DEGREEs"] = 4] = "TEN_DEGREEs";
    BoeingMaxBankIndex[BoeingMaxBankIndex["AUTO"] = 5] = "AUTO";
})(BoeingMaxBankIndex || (BoeingMaxBankIndex = {}));
/**
 * Class to manage the Boeing Half Bank Setting
 */
class BoeingVariableBankManager {
    /**
     * Creates an instance of the WT21 Variable Bank Manager.
     * @param bus The event bus to use with this instance.
     * @param apValues The autopilot ap values.
     * @param bankAngleConfigTable Table of bank angle breakpoints
     */
    constructor(bus, apValues, bankAngleConfigTable) {
        this.bus = bus;
        this.apValues = apValues;
        this.maxBank = Subject.create(30);
        this.lateralActiveMode = APLateralModes.NONE;
        this.tas = 0;
        /**
         * Handles when the lateral active AP mode changes.
         * @param mode The Active Lateral AP Mode.
         */
        this.updateMaxBank = (mode) => {
            if (this.isHeadingMode(mode)) {
                this.maxBank.set(this.getHeadingModeMaxBank());
            }
            else {
                this.maxBank.set(Math.min(this.autoBankAngleTable.get(this.tas), 30));
            }
        };
        this.autoBankAngleTable = new LerpLookupTable(bankAngleConfigTable);
        const ap = this.bus.getSubscriber();
        this.maxBankIndex = ConsumerSubject.create(ap.on('ap_max_bank_id').whenChanged(), BoeingMaxBankIndex.AUTO);
        // Sets the correct variable bank rate for the altitude when LNAV is engaged.
        this.apValues.lateralActive.sub((mode) => {
            this.lateralActiveMode = mode;
            this.updateMaxBank(mode);
        });
        // Sets the max bank angle to be used by FlightPathCalculator to calculate the flight path.
        this.maxBankIndex.sub(() => this.updateMaxBank(this.lateralActiveMode));
        const adc = this.bus.getSubscriber();
        adc.on('tas').whenChangedBy(2).handle((tas) => {
            this.tas = tas;
            this.updateMaxBank(this.lateralActiveMode);
        });
        this.maxBank.sub((maxBank) => {
            this.apValues.maxBankAngle.set(maxBank);
            SimVar.SetSimVarValue('K:AP_MAX_BANK_ANGLE_SET', 'degree', maxBank);
        }, true);
        // Set the max bank velocity as it defaults to 3 when using the max bank angle override
        SimVar.SetSimVarValue('K:AP_MAX_BANK_VELOCITY_SET', 'number', 5);
    }
    /**
     * Check if the given lateral mode is a heading mode (subject to the max bank selection)
     * @param mode AP lateral mode
     * @returns true if the given mode is subject to the max bank selection
     */
    isHeadingMode(mode) {
        switch (mode) {
            case APLateralModes.HEADING:
            case APLateralModes.HEADING_HOLD:
            case APLateralModes.TRACK:
            case APLateralModes.TRACK_HOLD:
                return true;
            default:
                return false;
        }
    }
    /**
     * Get the max bank for heading modes
     * @returns max bank in degrees for heading modes
     */
    getHeadingModeMaxBank() {
        var _a;
        if (this.maxBankIndex.get() === BoeingMaxBankIndex.AUTO) {
            return Math.min(this.autoBankAngleTable.get(this.tas), 30);
        }
        else {
            return (_a = BoeingVariableBankManager.headingBankAngleTable[this.maxBankIndex.get()]) !== null && _a !== void 0 ? _a : 30;
        }
    }
}
/** bank angles for the bank limit knob positions */
BoeingVariableBankManager.headingBankAngleTable = [30, 25, 20, 15, 10];

/**
 * A Boeing HUD Takeoff autopilot director.
 */
class BoeingAPHudTakeoffDirector {
    /** @inheritDoc */
    constructor(bus, options) {
        var _a;
        this.bus = bus;
        /** Runway locked in when the director activates, until it deactivates. */
        this.activeRunway = null;
        /**
         * This is the live received localiser, but not necessarily the one we're "using",
         * as some runways share the same frequency for both ends.
         */
        this.receivedLoc = ConsumerValue.create(null, { isValid: false, course: 0, source: { index: 0, type: NavSourceType.Nav } });
        this.locMagVar = ConsumerValue.create(null, 0);
        /** this is the last runway selected in the active FP, but not necessarily the one we've locked in on activation */
        this.selectedRunway = ConsumerValue.create(null, null);
        this.planeHeading = ConsumerValue.create(null, 0);
        this.ppos = new GeoPoint(NaN, NaN);
        // LOC, once it has been identified and acquired, is locked in until the director deactivates.
        this.locCourseTrue = null;
        this.locGeoPoint = new GeoPoint(NaN, NaN);
        this.locCircle = new GeoCircle(Vec3Math.create(), 0);
        this.navLocation = new GeoPoint(NaN, NaN);
        this.fdPublisher = this.bus.getPublisher();
        this.fdDeviation = Subject.create(null);
        this.state = DirectorState.Inactive;
        const sub = this.bus.getSubscriber();
        const navIndex = (_a = options === null || options === void 0 ? void 0 : options.navIndex) !== null && _a !== void 0 ? _a : 3;
        this.navLocationSub = sub.on(`nav_radio_nav_location_${navIndex}`).handle(lla => this.navLocation.set(lla.lat, lla.long));
        this.receivedLoc.setConsumer(sub.on(`nav_radio_localizer_${navIndex}`));
        this.locMagVar.setConsumer(sub.on(`nav_radio_magvar_${navIndex}`));
        this.selectedRunway.setConsumer(sub.on('boeing_hud_takeoff_runway_set'));
        this.planeHeading.setConsumer(sub.on('actual_hdg_deg_true'));
        this.fdDeviation.sub((v) => this.fdPublisher.pub('fd_takeoff_deviation', v, true));
    }
    /** @inheritDoc */
    activate() {
        this.state = DirectorState.Active;
        this.activeRunway = this.selectedRunway.get();
        if (this.onActivate) {
            this.onActivate();
        }
    }
    /** @inheritDoc */
    arm() {
        this.state = DirectorState.Armed;
        if (this.onArm) {
            this.onArm();
        }
    }
    /** @inheritDoc */
    deactivate() {
        this.state = DirectorState.Inactive;
        if (this.onDeactivate) {
            this.onDeactivate();
        }
        this.activeRunway = null;
        this.locCourseTrue = null;
        this.locGeoPoint.set(NaN, NaN);
        this.locCircle.set(Vec3Math.create(), 0);
    }
    /** @inheritDoc */
    update() {
        if (this.state === DirectorState.Active) {
            if (this.locCourseTrue === null) {
                this.tryAcquireLoc();
            }
            this.setFlightDirector();
        }
    }
    /**
     * Try to acquire the localiser for the active runway
     */
    tryAcquireLoc() {
        const loc = this.receivedLoc.get();
        if (this.activeRunway !== null && loc && loc.isValid && loc.course !== undefined) {
            const locCourseMag = UnitType.DEGREE.convertFrom(loc.course, UnitType.RADIAN);
            const locCourseTrue = MagVar.magneticToTrue(locCourseMag, this.locMagVar.get());
            if (Math.abs(NavMath.diffAngle(this.activeRunway.course, locCourseTrue)) < 3) {
                this.locCourseTrue = locCourseTrue;
                this.locGeoPoint.set(this.navLocation.lat, this.navLocation.lon);
                this.locCircle.setAsGreatCircle(this.locGeoPoint, locCourseTrue);
            }
        }
    }
    /**
     * Checks if HUD takeoff guidance is available
     * @returns true if available
     */
    isGuidanceAvailable() {
        if (this.locCourseTrue === null || isNaN(this.locGeoPoint.lat) || isNaN(this.locGeoPoint.lon) || this.activeRunway === null) {
            return false;
        }
        // within 45° of runway heading
        const headingDiff = NavMath.diffAngle(this.planeHeading.get(), this.activeRunway.course);
        if (Math.abs(headingDiff) >= 45) {
            return false;
        }
        // within 2° of LOC beam centre
        const locAngle = NavMath.diffAngle(this.ppos.bearingTo(this.locGeoPoint), this.locCourseTrue);
        if (Math.abs(locAngle) >= 2) {
            return false;
        }
        return true;
    }
    /**
     * Sets the FD display deviation value.
     */
    setFlightDirector() {
        this.ppos.set(SimVar.GetSimVarValue('PLANE LATITUDE', SimVarValueType.Degree), SimVar.GetSimVarValue('PLANE LONGITUDE', SimVarValueType.Degree));
        if (this.isGuidanceAvailable()) {
            this.fdDeviation.set(this.getDeviationFeet());
        }
        else {
            this.fdDeviation.set(null);
        }
    }
    /**
     * Gets the deviation in meters.
     * @returns The deviation in meters.
     */
    getDeviationFeet() {
        return MathUtils.clamp(UnitType.GA_RADIAN.convertTo(this.locCircle.distance(this.ppos), UnitType.FOOT), -65, 65);
    }
}

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * An IAN FAC lateral autopilot director.
 */
class BoeingFACDirector {
    /**
     * Creates an instance of the LateralDirector.
     * @param bus The event bus to use with this instance.
     * @param apValues Autopilot values from this director's parent autopilot.
     * @param options Options to configure the new director. Option values default to the following if not defined:
     * * `maxBankAngle`: `undefined`
     * * `lateralInterceptCurve`: A default function tuned for slow GA aircraft.
     * * `disableArming`: `false`
     */
    constructor(bus, apValues, options) {
        var _a;
        this.bus = bus;
        this.apValues = apValues;
        this.sub = this.bus.getSubscriber();
        this.bankServo = new LinearServo(BoeingFACDirector.BANK_SERVO_RATE);
        this.currentBankRef = 0;
        this.facBearing = ConsumerValue.create(null, null);
        this.facDeviation = ConsumerValue.create(null, null);
        this.tas = ConsumerValue.create(null, 0);
        this.trueTrack = ConsumerValue.create(null, 0);
        this.state = DirectorState.Inactive;
        const maxBankAngleOpt = (_a = options === null || options === void 0 ? void 0 : options.maxBankAngle) !== null && _a !== void 0 ? _a : undefined;
        switch (typeof maxBankAngleOpt) {
            case 'number':
                this.maxBankAngleFunc = () => maxBankAngleOpt;
                break;
            case 'function':
                this.maxBankAngleFunc = maxBankAngleOpt;
                break;
            default:
                this.maxBankAngleFunc = this.apValues.maxBankAngle.get.bind(this.apValues.maxBankAngle);
        }
        this.lateralInterceptCurve = options === null || options === void 0 ? void 0 : options.lateralInterceptCurve;
        this.facBearing.setConsumer(this.sub.on('boeing_ian_fac_bearing'));
        this.facDeviation.setConsumer(this.sub.on('boeing_ian_fac_deviation'));
        this.tas.setConsumer(this.sub.on('tas'));
        this.trueTrack.setConsumer(this.sub.on('track_deg_true'));
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.facBearing.resume();
        //this.facDeviation.resume();
        this.tas.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.facBearing.pause();
        //this.facDeviation.pause();
        this.tas.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        this.state = DirectorState.Active;
        this.currentBankRef = SimVar.GetSimVarValue('PLANE BANK DEGREES', SimVarValueType.Degree);
        this.bankServo.reset();
    }
    /**
     * Arms this director.
     */
    arm() {
        this.resumeSubs();
        if (this.state === DirectorState.Inactive && this.canArm()) {
            this.state = DirectorState.Armed;
            if (this.onArm !== undefined) {
                this.onArm();
            }
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        if (!this.canArm()) {
            this.deactivate();
        }
        if (this.state === DirectorState.Armed) {
            if (this.canActivate()) {
                this.activate();
            }
        }
        if (this.state === DirectorState.Active) {
            this.calcBank(this.desiredBank());
            this.setBank && this.setBank(this.currentBankRef);
        }
    }
    /**
     * Method to check whether the director can arm.
     * @returns Whether or not this director can arm.
     */
    canArm() {
        return this.facDeviation.get() !== null;
    }
    /**
     * Method to check whether the director can activate.
     * @returns Whether or not this director can activate.
     */
    canActivate() {
        const facBearing = this.facBearing.get();
        const facDeviation = this.facDeviation.get();
        if (facBearing === null || facDeviation === null) {
            return false;
        }
        const baseBank = 0.8 * this.maxBankAngleFunc();
        const turnAngle = Math.abs(NavMath.diffAngle(this.trueTrack.get(), facBearing));
        // FIXME not accounting for wind here
        const turnRadius = NavMath.turnRadius(this.tas.get(), baseBank);
        const maxXtkMetres = Math.sin(turnAngle * Avionics.Utils.DEG2RAD) * turnRadius;
        return Math.abs(facDeviation) <= UnitType.NMILE.convertFrom(maxXtkMetres, UnitType.METER);
    }
    /**
     * Gets a desired bank from the nav input data.
     * @returns The desired bank angle.
     */
    desiredBank() {
        const dtk = this.facBearing.get();
        const xtk = this.facDeviation.get();
        if (dtk === null || xtk === null) {
            this.deactivate();
            return 0;
        }
        let absInterceptAngle;
        let naturalAbsInterceptAngle = 0;
        if (this.lateralInterceptCurve !== undefined) {
            naturalAbsInterceptAngle = this.lateralInterceptCurve(dtk, xtk, this.tas.get());
        }
        else {
            naturalAbsInterceptAngle = Math.min(Math.pow(Math.abs(xtk) * 20, 1.35) + (Math.abs(xtk) * 50), 45);
            if (naturalAbsInterceptAngle <= 2.5) {
                naturalAbsInterceptAngle = NavMath.clamp(Math.abs(xtk * 150), 0, 2.5);
            }
        }
        /*if (bankAngleState.isInterceptingFromArmedState) {
          absInterceptAngle = Math.abs(NavMath.diffAngle(bankAngleState.trackAtActivation, dtk));
          if (
            absInterceptAngle > naturalAbsInterceptAngle || absInterceptAngle < 5
            || absInterceptAngle < Math.abs(NavMath.diffAngle(dtk, bearingToVectorEnd))
          ) {
            absInterceptAngle = naturalAbsInterceptAngle;
            bankAngleState.isInterceptingFromArmedState = false;
          }
        } else {
          absInterceptAngle = naturalAbsInterceptAngle;
        }*/
        // eslint-disable-next-line prefer-const
        absInterceptAngle = naturalAbsInterceptAngle;
        const interceptAngle = xtk < 0 ? absInterceptAngle : -1 * absInterceptAngle;
        const courseToSteer = NavMath.normalizeHeading(dtk + interceptAngle);
        const turnDirection = NavMath.getTurnDirection(this.trueTrack.get(), courseToSteer);
        const headingDiff = Math.abs(NavMath.diffAngle(this.trueTrack.get(), courseToSteer));
        let baseBank = Math.min(1.25 * headingDiff, this.maxBankAngleFunc());
        baseBank *= (turnDirection === 'left' ? 1 : -1);
        return baseBank;
    }
    /**
     * Calcs the desired AP bank angle.
     * @param bankAngle The desired AP bank angle.
     */
    calcBank(bankAngle) {
        if (isFinite(bankAngle)) {
            this.bankServo.rate = BoeingFACDirector.BANK_SERVO_RATE * SimVar.GetSimVarValue('E:SIMULATION RATE', SimVarValueType.Number);
            this.currentBankRef = this.bankServo.drive(this.currentBankRef, bankAngle);
        }
    }
}
BoeingFACDirector.BANK_SERVO_RATE = 10; // degrees per second

/// <reference types="@microsoft/msfs-types/js/simvar" />
/**
 * An IAN glidepath autopilot director.
 */
class BoeingGPDirector {
    /**
     * Creates an instance of the GP director.
     * @param bus The event bus to use with this instance.
     * @param apValues are the ap selected values for the autopilot.
     */
    constructor(bus, apValues) {
        this.apValues = apValues;
        this.gpDeviation = ConsumerValue.create(null, null);
        this.gpa = ConsumerValue.create(null, null);
        this.state = DirectorState.Inactive;
        const sub = bus.getSubscriber();
        this.gpDeviation.setConsumer(sub.on('boeing_ian_gp_deviation').whenChanged());
        this.gpa.setConsumer(sub.on('boeing_ian_gp_slope').whenChanged());
        this.pauseSubs();
    }
    /** Resumes Subscriptions. */
    resumeSubs() {
        this.gpDeviation.resume();
        this.gpa.resume();
    }
    /** Pauses Subscriptions. */
    pauseSubs() {
        this.gpDeviation.pause();
        this.gpa.pause();
    }
    /**
     * Activates this director.
     */
    activate() {
        this.resumeSubs();
        this.state = DirectorState.Active;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GPActive);
        if (this.onActivate !== undefined) {
            this.onActivate();
        }
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
    }
    /**
     * Arms this director.
     */
    arm() {
        this.resumeSubs();
        if (this.state === DirectorState.Inactive) {
            this.state = DirectorState.Armed;
            SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.GPArmed);
            if (this.onArm !== undefined) {
                this.onArm();
            }
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', true);
            SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
            SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', true);
        }
    }
    /**
     * Deactivates this director.
     */
    deactivate() {
        this.state = DirectorState.Inactive;
        SimVar.SetSimVarValue(VNavVars.GPApproachMode, SimVarValueType.Number, ApproachGuidanceMode.None);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ARM', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT GLIDESLOPE ACTIVE', 'Bool', false);
        SimVar.SetSimVarValue('AUTOPILOT APPROACH ACTIVE', 'Bool', false);
        this.pauseSubs();
    }
    /**
     * Updates this director.
     */
    update() {
        const lateralMode = this.apValues.lateralActive.get();
        const suitableLateralMode = lateralMode === APLateralModes.FMS_LOC || lateralMode === APLateralModes.LOC || lateralMode === APLateralModes.BC;
        if (this.state === DirectorState.Armed) {
            const gpDeviation = this.gpDeviation.get();
            if (gpDeviation === null) {
                this.deactivate();
                return;
            }
            if (suitableLateralMode && gpDeviation <= 15 && gpDeviation >= -100 && this.gpa.get() !== null) {
                this.activate();
            }
        }
        if (this.state === DirectorState.Active) {
            const gpa = this.gpa.get();
            const gpDeviation = this.gpDeviation.get();
            if (!suitableLateralMode || gpa === null || gpDeviation === null) {
                this.deactivate();
                return;
            }
            const groundSpeed = SimVar.GetSimVarValue('GROUND VELOCITY', SimVarValueType.Knots);
            // TODO consider increasing gain... always has a steady state error - increased to 1.2*
            const fpaPercentage = Math.max(1.2 * gpDeviation / VNavUtils.getPathErrorDistance(groundSpeed), -1) + 1;
            this.drivePitch && this.drivePitch(-gpa * fpaPercentage, true, true);
        }
    }
}

/**
 * A Boeing autopilot configuration.
 */
class BoeingAPConfig {
    /**
     * Instantiates the AP Config for the Autopilot.
     * @param bus is an instance of the Event Bus.
     * @param flightPlanner is an instance of the flight planner.
     * @param messageService The instance of MessageService to use.
     * @param verticalPathCalculator The instance of the vertical path calculator to use for the vnav director.
     * @param activePerformancePlan The instance of the active performance plan to use for the vnav director.
     * @param boeingVNavOptions The options for vnav for this aircraft.
     * @param autopilotDriverOptions The options for the autopilot driver.
     * @param radioAltimeterOffset The RA offset to read 0 feet at normal landing pitch when the main gear touches down
     * @param rolloutDirectorPid The PID options for rollout director.
     * @param flareVsFunction The desired V/S function for the flare director
     * @param gsDirectorOptions Options to configure the glideslope director.
     */
    constructor(bus, flightPlanner, messageService, verticalPathCalculator, activePerformancePlan, boeingVNavOptions, autopilotDriverOptions, radioAltimeterOffset, rolloutDirectorPid, flareVsFunction, gsDirectorOptions) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.messageService = messageService;
        this.verticalPathCalculator = verticalPathCalculator;
        this.activePerformancePlan = activePerformancePlan;
        this.boeingVNavOptions = boeingVNavOptions;
        this.autopilotDriverOptions = autopilotDriverOptions;
        this.radioAltimeterOffset = radioAltimeterOffset;
        this.rolloutDirectorPid = rolloutDirectorPid;
        this.flareVsFunction = flareVsFunction;
        this.gsDirectorOptions = gsDirectorOptions;
        this.altitudeHoldDefaultAltitude = 10000;
        // both not used, see getDefaultLateralMode and getDefaultVerticalMode in BoeingAutoPilot
        this.defaultLateralMode = APLateralModes.NONE;
        this.defaultVerticalMode = APVerticalModes.NONE;
        this.defaultMaxBankAngle = 30;
        this.altitudeHoldSlotIndex = 3;
        this.onlyDisarmLnavOnOffEvent = true;
        this.autoEngageFd = false;
        //  We don't want AP to auto init, because we manage ap init in the onFlightStart methods in the instrument containing autopilot.
        this.initializeStateManagerOnFirstFlightPlanSync = false;
        this.simRate = ConsumerSubject.create(null, 1);
        this.lastDesiredVs = 0;
        this.previousTimestamp = 0; // [msec] Timestamp when the capturing will end
        this.previousVelY = 0;
        const sub = this.bus.getSubscriber();
        this.simRate.setConsumer(sub.on('simRate'));
    }
    /** @inheritdoc */
    createHeadingDirector(apValues) {
        return new APHdgDirector(this.bus, apValues, {
            maxBankAngle: this.getHeadingModeMaxBank.bind(this),
            turnReversalThreshold: 360
        });
    }
    /** @inheritdoc */
    createHeadingHoldDirector(apValues) {
        return new APHdgHoldDirector(this.bus, apValues, {
            maxBankAngle: this.getHeadingModeMaxBank.bind(this),
        });
    }
    /** @inheritdoc */
    createTrackDirector(apValues) {
        return new APTrkDirector(this.bus, apValues, {
            maxBankAngle: this.getHeadingModeMaxBank.bind(this),
            turnReversalThreshold: 360
        });
    }
    /** @inheritdoc */
    createTrackHoldDirector(apValues) {
        return new APTrkHoldDirector(this.bus, apValues, {
            maxBankAngle: this.getHeadingModeMaxBank.bind(this),
        });
    }
    /** @inheritdoc */
    createRollDirector(apValues) {
        return new APRollDirector(apValues);
    }
    /** @inheritdoc */
    createWingLevelerDirector(apValues) {
        return new APLvlDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createGpssDirector(apValues) {
        return new LNavDirector(this.bus, apValues, this.flightPlanner, undefined, {
            lateralInterceptCurve: this.lnavInterceptCurve.bind(this),
            hasVectorAnticipation: true,
            vectorAnticipationBankRate: 5,
            minimumActivationAltitude: 50,
            disableAutoSuspendAtMissedApproachPoint: true,
        });
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    createVorDirector(apValues) {
        return undefined;
    }
    /** @inheritdoc */
    createLocDirector(apValues) {
        const options = {
            lateralInterceptCurve: this.navInterceptCurve.bind(this),
            forceNavSource: 3,
        };
        return new APNavDirector(this.bus, apValues, APLateralModes.LOC, options);
    }
    /** @inheritdoc */
    createBcDirector() {
        return undefined;
    }
    /** @inheritDoc */
    createRolloutDirector() {
        return new BoeingAPRolloutDirector(this.bus, {
            navIndex: 3, rudderPidValues: this.rolloutDirectorPid
        });
    }
    /** @inheritdoc */
    createPitchDirector(apValues) {
        return new APPitchDirector(this.bus, apValues, 0.5, -20, 25);
    }
    /** @inheritdoc */
    createVsDirector(apValues) {
        return new APVSDirector(apValues, 100);
    }
    /** @inheritdoc */
    createFpaDirector(apValues) {
        return new APFPADirector(apValues, { maxFpa: 9.9 });
    }
    /** @inheritdoc */
    createFlcDirector(apValues) {
        return new APFLCDirector(apValues, { maxPitchUpAngle: 25, maxPitchDownAngle: 25, setSpeedOnActivation: () => { } });
    }
    /** @inheritdoc */
    createAltHoldDirector(apValues) {
        return new APAltDirector(apValues);
    }
    /** @inheritdoc */
    createAltCapDirector(apValues) {
        return new APAltCapDirector(apValues, {
            shouldActivate: this.shouldActivateAltitudeCapture.bind(this),
            captureAltitude: this.captureAltitude.bind(this)
        });
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    createVNavManager(apValues) {
        var _a;
        return (_a = this.vnavManager) !== null && _a !== void 0 ? _a : (this.vnavManager = new BoeingVNavManager(this.bus, this.flightPlanner, this.verticalPathCalculator, this.activePerformancePlan, this.messageService, apValues, this.boeingVNavOptions, this.shouldActivateAltitudeCapture.bind(this)));
    }
    /** @inheritdoc */
    createVNavPathDirector() {
        return new BoeingAPVNavPathDirector(this.bus);
    }
    /** @inheritdoc */
    createGpDirector(apValues) {
        return new BoeingGPDirector(this.bus, apValues);
    }
    /** @inheritdoc */
    createGsDirector(apValues) {
        return new APGSDirector(this.bus, apValues, Object.assign({ forceNavSource: 3 }, this.gsDirectorOptions));
    }
    /** @inheritdoc */
    createFlareDirector() {
        return new BoeingAPFlareDirector(this.bus, {
            radioAltimeterOffset: this.radioAltimeterOffset,
            activationAltitude: 80,
            desiredVs: this.flareVsFunction,
        });
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    createNavToNavManager(apValues) {
        return new BoeingNavToNavManager(this.bus, apValues);
    }
    /** @inheritdoc */
    createVariableBankManager(apValues) {
        this.variableBankManager = new BoeingVariableBankManager(this.bus, apValues, BoeingAPConfig.bankAngleTable);
        return this.variableBankManager;
    }
    /** @inheritdoc */
    createToVerticalDirector(apValues) {
        //TODO: This value should be read in from the systems.cfg 'pitch_takeoff_ga' value
        return new BoeingAPTogaDirector(this.bus, apValues, 8);
    }
    /** @inheritdoc */
    createGaVerticalDirector(apValues) {
        return this.createToVerticalDirector(apValues);
    }
    /** @inheritdoc */
    createToLateralDirector(apValues) {
        return new APHdgDirector(this.bus, apValues, { isToGaMode: true });
    }
    /** @inheritdoc */
    createGaLateralDirector(apValues) {
        return new APHdgDirector(this.bus, apValues, { isToGaMode: true });
    }
    /** @inheritdoc */
    createFmsLocLateralDirector(apValues) {
        return new BoeingFACDirector(this.bus, apValues, {
            lateralInterceptCurve: this.lnavInterceptCurve.bind(this),
        });
    }
    /** @inheritdoc */
    createTakeoffLocLateralDirector() {
        return new BoeingAPHudTakeoffDirector(this.bus, {
            navIndex: 3,
        });
    }
    /**
     * Calculates intercept angles for radio nav.
     * @param distanceToSource The distance from the plane to the source of the navigation signal, in nautical miles.
     * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
     * Positive values indicate that the desired track is to the right of the plane.
     * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
     * indicate that the plane is to the right of the track.
     * @param tas The true airspeed of the plane, in knots.
     * @param isLoc Whether the source of the navigation signal is a localizer. Defaults to `false`.
     * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
     */
    navInterceptCurve(distanceToSource, deflection, xtk, tas, isLoc) {
        if (isLoc) {
            return this.localizerInterceptCurve(deflection, xtk, tas);
        }
        else {
            return this.defaultInterceptCurve(xtk, tas);
        }
    }
    /**
     * Calculates intercept angles for LNAV.
     * @param dtk The desired track, in degrees true.
     * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
     * desired track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the desired track from the navigation signal.
     */
    lnavInterceptCurve(dtk, xtk, tas) {
        return this.defaultInterceptCurve(xtk, tas);
    }
    /**
     * Calculates intercept angles for localizers.
     * @param deflection The lateral deflection of the desired track relative to the plane, normalized from `-1` to `1`.
     * Negative values indicate that the desired track is to the left of the plane.
     * @param xtk The cross-track error of the plane from the desired track, in nautical miles. Positive values indicate
     * indicate that the plane is to the right of the track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the localizer course.
     */
    localizerInterceptCurve(deflection, xtk, tas) {
        const xtkMeters = UnitType.NMILE.convertTo(xtk, UnitType.METER);
        const xtkMetersAbs = Math.abs(xtkMeters);
        if (Math.abs(deflection) < .02 || xtkMetersAbs < 4) {
            return 0;
        }
        else if (xtkMetersAbs < 200) {
            return NavMath.clamp(Math.abs(xtk * 75), 1, 5);
        }
        const turnRadiusMeters = NavMath.turnRadius(tas, 22.5);
        const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
        return NavMath.clamp(interceptAngle, 0, 20);
    }
    /**
     * Calculates non-localizer intercept angles.
     * @param xtk The cross-track error, in nautical miles. Negative values indicate that the plane is to the left of the
     * desired track.
     * @param tas The true airspeed of the plane, in knots.
     * @returns The intercept angle, in degrees, to capture the desired track.
     */
    defaultInterceptCurve(xtk, tas) {
        const xtkMeters = UnitType.NMILE.convertTo(xtk, UnitType.METER);
        const xtkMetersAbs = Math.abs(xtkMeters);
        if (xtkMetersAbs < 250) {
            return NavMath.clamp(Math.abs(xtk * 75), 0, 5);
        }
        const turnRadiusMeters = NavMath.turnRadius(tas, 22.5);
        const interceptAngle = this.calculateTurnBasedInterceptAngle(turnRadiusMeters, xtkMeters);
        return NavMath.clamp(interceptAngle, 0, 45);
    }
    /**
     * Calculates an intercept angle to a track such that the intercept course, projected forward from the plane's
     * position, intercepts the desired track at the same point as a constant-radius turn overlapping the plane's
     * position configured to be tangent to the desired track. This has the effect of producing an intercept angle which
     * guarantees a no-overshoot intercept for all initial ground tracks for which a no-overshoot intercept is possible
     * given the specified turn radius and cross-track error.
     *
     * If the magnitude of the cross-track error is greater than twice the turn radius, no constant-radius turn
     * overlapping the plane's position will be tangent to the desired track; in this case the maximum possible intercept
     * angle of 90 degrees is returned.
     * @param turnRadius The turn radius, in the same units as `xtk`.
     * @param xtk The cross-track error, in the same units as `turnRadius`.
     * @returns The calculated intercept angle, in degrees.
     */
    calculateTurnBasedInterceptAngle(turnRadius, xtk) {
        return UnitType.RADIAN.convertTo(Math.acos(NavMath.clamp((turnRadius - Math.abs(xtk)) / turnRadius, -1, 1)), UnitType.DEGREE) / 2;
    }
    /**
     * A function which returns true if the capturing shall be activated
     * @param currentVs Current vertical speed in [ft/min]
     * @param targetAltitude Target altitude [ft]
     * @param currentAltitude Current altitude [ft]
     * @returns True if the capturing shall be activated
     */
    shouldActivateAltitudeCapture(currentVs, targetAltitude, currentAltitude) {
        // Determine the altitude capture range, i.e. the altitude deviation from target altitude at which the
        // capturing shall begin to achieve a steady capturing with an average nominal vs-rate of dVsNominal.
        const altCapturingRange = ((currentVs / 60) ** 2) / (2 * (BoeingAPConfig.dVsNominal / 60)) + (Math.abs(currentVs) / 20);
        const deviationFromTarget = Math.abs(targetAltitude - currentAltitude);
        if (deviationFromTarget <= altCapturingRange) {
            this.lastDesiredVs = currentVs;
            this.previousTimestamp = Date.now();
            this.previousVelY = SimVar.GetSimVarValue('VELOCITY WORLD Y', 'feet per second');
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Method to use for capturing a target altitude.
     * @param targetAltitude is the captured targed altitude
     * @param indicatedAltitude is the current indicated altitude
     * @param initialFpa is the FPA when capture was initiatiated
     * @param tas The current true airspeed of the airplane, in knots.
     * @returns The target pitch value to set.
     */
    captureAltitude(targetAltitude, indicatedAltitude, initialFpa, tas) {
        const newTimestamp = Date.now();
        const cycleDuration = (newTimestamp - this.previousTimestamp) / 1000.0;
        this.previousTimestamp = newTimestamp;
        const currentVs = SimVar.GetSimVarValue('VERTICAL SPEED', SimVarValueType.FPM);
        const deltaAltitude = targetAltitude - indicatedAltitude;
        // If active pause is switched on we want to pause the capturing logic as well. The only simvar
        // that reliably freezes in active pause is world velocity Y:
        const newVelY = SimVar.GetSimVarValue('VELOCITY WORLD Y', 'feet per second');
        if (newVelY !== this.previousVelY) {
            // For the actual capturing, we freshly calculate dVsAdaptive in each cycle. For any given delta altitude and vs,
            // dVsAdaptive is the steady decceleration, that would bring us exactly to the target altitude:
            const dVsAdaptive = 60 * ((currentVs / 60) ** 2) / (2 * Math.abs(deltaAltitude)); // [ft/min/s] !
            // We want desiredVs to only converge towards zero, therefore we apply the sign of lastDesiredVs:
            const thisCycleVsReduction = dVsAdaptive * cycleDuration * this.simRate.get() * Math.sign(this.lastDesiredVs);
            if (Math.abs(this.lastDesiredVs) > Math.abs(thisCycleVsReduction)) {
                // Apply the the reduction for this cycle as long as it is smaller than desiredVs:
                this.lastDesiredVs -= thisCycleVsReduction;
            }
            else {
                // Otherwise set desiredVs like the alt director does:
                this.lastDesiredVs = MathUtils.clamp(10 * deltaAltitude, -500, 500);
            }
        }
        else {
            this.lastDesiredVs = currentVs;
        }
        this.previousVelY = newVelY;
        return Math.asin(this.lastDesiredVs / UnitType.KNOT.convertTo(tas, UnitType.FPM)) * Avionics.Utils.RAD2DEG;
    }
    /**
     * Get the max bank for heading modes
     * @returns max bank in degrees for heading modes
     */
    getHeadingModeMaxBank() {
        var _a, _b;
        return (_b = (_a = this.variableBankManager) === null || _a === void 0 ? void 0 : _a.getHeadingModeMaxBank()) !== null && _b !== void 0 ? _b : 25;
    }
}
/** The AP can command up to these bank angles */
BoeingAPConfig.bankAngleTable = [
    [15, 0],
    [30, 150],
    [30, 300],
    [19, 450],
];
BoeingAPConfig.dVsNominal = 200; // Rate, at which altitudes shall be captured [ft/min/s], 200 translate to 0.104g, 100 would be 0.052g

/**
 * Boeing autopilot.
 */
class BoeingAutopilot extends Autopilot {
    /**
     * Creates an instance of the WT21Autopilot.
     * @param bus The event bus.
     * @param flightPlanner This autopilot's associated flight planner.
     * @param config This autopilot's configuration.
     * @param stateManager This autopilot's state manager.
     * @param messageService The message transmitter to send CDU messages
     */
    constructor(bus, flightPlanner, config, stateManager, messageService) {
        super(bus, flightPlanner, config, stateManager);
        this.stateManager = stateManager;
        this.messageService = messageService;
        this.externalAutopilotInstalled = Subject.create(false);
        this.lateralArmedModeSubject = Subject.create(APLateralModes.NONE);
        this.altArmedSubject = Subject.create(false);
        this.lateralNavSource = Subject.create(NavigationSource.NONE);
        this.verticalNavSource = Subject.create(NavigationSource.NONE);
        this.goAroundActive = Subject.create(false);
        this.subs = this.bus.getSubscriber();
        this.ra = ConsumerSubject.create(this.subs.on('ra_radio_alt_1').whenChangedBy(1), 0);
        this.vnavState = ConsumerSubject.create(this.subs.on('vnav_state'), VNavState.Enabled_Inactive);
        this.onGround = ConsumerSubject.create(this.subs.on('on_ground'), !!SimVar.GetSimVarValue('SIM ON GROUND', SimVarValueType.Bool));
        this.fmsOperatingPhase = ConsumerValue.create(this.subs.on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
        this.flapsPosition = ConsumerValue.create(this.subs.on('flap_computer_interpolated_position'), 100);
        this.ias = ConsumerValue.create(this.subs.on('ias').withPrecision(1), -1);
        this.mcpSpeedIsMach = ConsumerValue.create(this.subs.on('ap_boeing_mcp_speed_is_mach'), false);
        this.vs = ConsumerValue.create(this.subs.on('vertical_speed').withPrecision(1), -1);
        this.altitude = ConsumerValue.create(this.subs.on('indicated_alt').withPrecision(1), -1);
        this.apSelectedSpeedManual = ConsumerSubject.create(this.subs.on('ap_selected_speed_is_manual').whenChanged(), true);
        this.atActiveMode = ConsumerValue.create(this.subs.on('boeing_at_mode_active'), BoeingAutothrottleModes.NONE);
        /** flap speed limit in cas, -1 if no limit */
        this.flapSpeedLimit = ConsumerValue.create(null, -1);
        this.apVerticalActive = APVerticalModes.NONE;
        this.iasWindowChangedAfterToga = false;
        /** ambient pressure in in.Hg */
        this.ambientPressure = ConsumerValue.create(null, 0);
        /** glideslope is deselected by the pilot */
        this.gsSelected = ConsumerSubject.create(this.subs.on('boeing_glideslope_selected'), true);
        this.ianFacValid = ComputedSubject.create(null, (v) => v !== null);
        this.ianGpAvailable = ConsumerValue.create(this.subs.on('boeing_ian_gp_available'), false);
        this.ianGpValid = ComputedSubject.create(null, (v) => v !== null);
        /** The FMS selected approach is LOC-based, or no approach is selected (therefore LOC is eligible) */
        this.fmsLocApproachSelected = ConsumerValue.create(this.subs.on('boeing_fms_loc_approach_selected'), false);
        this.qfeSelected = ConsumerValue.create(this.subs.on('boeing_qfe_approach_selected'), false);
        this.hudTogaRunway = ConsumerSubject.create(this.subs.on('boeing_hud_takeoff_runway_set'), null);
        this.maxApproachFlaps = 0;
        this.autolandCapability = MappedSubject.create(([ra, lateralActive, verticalActive]) => this.getAutolandCapability(ra, lateralActive, verticalActive), this.ra, this.apValues.lateralActive, this.apValues.verticalActive);
        this.publisher = this.bus.getPublisher();
        this.fmaData = ObjectSubject.create({
            verticalActive: APVerticalModes.NONE,
            verticalArmed: APVerticalModes.NONE,
            verticalDegraded: false,
            lateralActive: APLateralModes.NONE,
            lateralArmed: APLateralModes.NONE,
            lateralDegraded: false
        });
        // Sync external LVars
        MappedSubject.create(this.apValues.lateralActive, this.apValues.lateralArmed, this.apValues.verticalActive, this.apValues.verticalArmed, this.vnavState).sub(([lateralActive, lateralArmed, verticalActive, verticalArmed]) => this.updateExternalLVars(lateralActive, lateralArmed, verticalActive, verticalArmed));
        this.fmaData.sub(() => {
            // dirty debounce, need better ObjectSubject
            if (this.fmaUpdateDebounce) {
                return;
            }
            this.fmaUpdateDebounce = setTimeout(() => {
                this.fmaUpdateDebounce = undefined;
                this.publisher.pub('fma_data', this.fmaData.get(), true);
            }, 0);
        }, true);
        this.lateralNavSource.sub((source) => this.publisher.pub('lateral_nav_source', source, true, true));
        this.verticalNavSource.sub((source) => this.publisher.pub('vertical_nav_source', source, true, true));
        this.ambientPressure.setConsumer(this.bus.getSubscriber().on('ambient_pressure_inhg'));
        this.apValues.verticalActive.sub(this.onApVerticalMode.bind(this));
        this.apValues.selectedIas.sub(this.onSpeedWindowChanged.bind(this));
        this.flapSpeedLimit.setConsumer(this.bus.getSubscriber().on('flap_computer_limit_speed'));
        this.subs.on('boeing_ian_fac_deviation').handle((v) => this.ianFacValid.set(v));
        this.subs.on('boeing_ian_gp_deviation').handle((v) => this.ianGpValid.set(v));
        this.gsSelected.sub(this.onGsSelectionChanged.bind(this));
        this.hudTogaRunway.sub(this.updateHudToga.bind(this));
        this.stateManager.apMasterOn.sub(this.updateHudToga.bind(this));
        this.stateManager.isFlightDirectorOn.sub(this.updateHudToga.bind(this));
        this.stateManager.isFlightDirectorCoPilotOn.sub(this.updateHudToga.bind(this));
        this.apValues.lateralActive.sub(this.updateHudToga.bind(this));
    }
    /** @inheritdoc */
    onBeforeUpdate() {
        this.updateManualSpeedCrossover();
    }
    /** @inheritdoc */
    onAfterUpdate() {
        this.updateFma();
        this.updateAutomaticGoAroundDetection();
    }
    /** @inheritdoc */
    onInitialized() {
        this.bus.pub('vnav_set_state', true);
        SimVar.SetSimVarValue('L:XMLVAR_SpeedIsManuallySet', SimVarValueType.Bool, true);
        this.monitorAdditionalEvents();
    }
    /** @inheritdoc */
    setLateralActive(mode, clearArmed = true) {
        const { lateralActive, lateralArmed } = this.apValues;
        this.checkRollModeActive();
        if (lateralArmed.get() === mode && clearArmed) {
            lateralArmed.set(APLateralModes.NONE);
        }
        if (mode !== lateralActive.get()) {
            const currentMode = this.lateralModes.get(lateralActive.get());
            if (this.apValues.apApproachModeOn.get()) {
                switch (lateralActive.get()) {
                    case APLateralModes.LOC:
                    case APLateralModes.GPSS:
                    case APLateralModes.FMS_LOC:
                        if (mode !== APLateralModes.LOC && mode !== APLateralModes.FMS_LOC) {
                            this.apValues.apApproachModeOn.set(false);
                        }
                }
            }
            currentMode === null || currentMode === void 0 ? void 0 : currentMode.deactivate();
            lateralActive.set(mode);
        }
    }
    /** @inheritdoc */
    approachPressed(set) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const approachMode = this.apValues.apApproachModeOn.get();
        const lateralArmed = this.apValues.lateralArmed.get();
        const lateralActive = this.apValues.lateralActive.get();
        if ((set === undefined || set === false) && approachMode === true) {
            if (lateralArmed === APLateralModes.LOC) {
                this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GS);
                (_a = this.lateralModes.get(APLateralModes.LOC)) === null || _a === void 0 ? void 0 : _a.deactivate();
            }
            else if (lateralArmed === APLateralModes.FMS_LOC) {
                this.deactivateArmedOrActiveVerticalMode(APVerticalModes.GP);
                (_b = this.lateralModes.get(APLateralModes.FMS_LOC)) === null || _b === void 0 ? void 0 : _b.deactivate();
            }
            else if (lateralActive === APLateralModes.LOC || lateralActive === APLateralModes.FMS_LOC) {
                (_c = this.lateralModes.get(lateralActive)) === null || _c === void 0 ? void 0 : _c.deactivate();
            }
            this.apValues.apApproachModeOn.set(false);
            return;
        }
        if (set === undefined || set === true) {
            if (!this.checkApproachValid()) {
                return;
            }
            const armableType = this.getArmableApproachType();
            if (armableType !== APLateralModes.NONE) {
                // arm lateral approach mode
                if (((_d = this.lateralModes.get(armableType)) === null || _d === void 0 ? void 0 : _d.state) === DirectorState.Inactive) {
                    (_e = this.lateralModes.get(armableType)) === null || _e === void 0 ? void 0 : _e.arm();
                }
                // arm vertical approach mode
                switch (armableType) {
                    case APLateralModes.LOC:
                        if (this.gsSelected.get()) {
                            if (((_f = this.verticalModes.get(APVerticalModes.GS)) === null || _f === void 0 ? void 0 : _f.state) === DirectorState.Inactive) {
                                (_g = this.verticalModes.get(APVerticalModes.GS)) === null || _g === void 0 ? void 0 : _g.arm();
                            }
                            this.apValues.apApproachModeOn.set(true);
                            return;
                        }
                    // fallthrough
                    case APLateralModes.BC:
                    case APLateralModes.FMS_LOC:
                        if (((_h = this.verticalModes.get(APVerticalModes.GP)) === null || _h === void 0 ? void 0 : _h.state) === DirectorState.Inactive) {
                            (_j = this.verticalModes.get(APVerticalModes.GP)) === null || _j === void 0 ? void 0 : _j.arm();
                        }
                        this.apValues.apApproachModeOn.set(true);
                        return;
                }
            }
        }
    }
    /**
     * Check if the current approach mode is valid, and send a message to the CDU if not
     * @returns true if approach is valid and arming may be attempted
     */
    checkApproachValid() {
        if (!this.gsSelected.get() && !this.ianGpAvailable.get()) {
            if (this.qfeSelected.get()) {
                this.messageService.sendMessage(BoeingFmcErrorKeys.FmcAppModeUavailQfe);
            }
            else {
                this.messageService.sendMessage(BoeingFmcErrorKeys.FmcAppModeUavailGp);
            }
            return false;
        }
        return true;
    }
    /** @inheritdoc */
    getArmableApproachType() {
        if (this.fmsLocApproachSelected.get()) {
            return APLateralModes.FMS_LOC;
        }
        else {
            const gotGlideSlope = this.gsSelected.get() && this.apValues.nav3HasGs.get();
            const gotGlidePath = !this.gsSelected.get() && this.ianGpValid.get();
            if (gotGlideSlope || gotGlidePath) {
                return APLateralModes.LOC;
            }
        }
        // FIXME APLateralModes.BC
        return APLateralModes.NONE;
    }
    /** @inheritdoc */
    lateralPressed(data) {
        // send FAC instead of LOC if LOC approach not selected
        if (data.mode === APLateralModes.LOC && this.fmsLocApproachSelected.get()) {
            data.mode = APLateralModes.FMS_LOC;
        }
        super.lateralPressed(data);
    }
    /** @inheritdoc */
    verticalPressed(data) {
        // Turn FDs on when TOGA is pressed while IAS > 80 and flaps out of up
        // Note, this intentionally does not turn the FD switches on... the pilot must cycle them if they want FDs off again
        if (this.ias.get() > 80 && this.flapsPosition.get() > 1 && (data.mode === APVerticalModes.TO || data.mode === APVerticalModes.GA)) {
            this.stateManager.setFlightDirector(true, false);
        }
        super.verticalPressed(data);
    }
    /** @inheritdoc */
    monitorAdditionalEvents() {
        const sub = this.bus.getSubscriber();
        const speedIsMachSub = ConsumerSubject.create(sub.on('ap_selected_speed_is_mach'), false);
        // Whenever we switch between mach and ias hold, we need to set the value to which we are switching to be equal to
        // the value we are switching from.
        speedIsMachSub.sub(isMach => {
            if (isMach) {
                SimVar.SetSimVarValue('K:AP_MACH_VAR_SET', SimVarValueType.Number, Math.round(Simplane.getKiasToMach(this.apValues.selectedIas.get()) * 100));
            }
            else {
                SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', SimVarValueType.Number, Math.round(Simplane.getMachToKias(this.apValues.selectedMach.get())));
            }
        });
        this.apValues.apApproachModeOn.sub(v => {
            var _a, _b;
            if (!v) {
                const verticalActive = this.apValues.verticalActive.get();
                const verticalArmed = this.verticalApproachArmed;
                if (verticalActive === APVerticalModes.GP || verticalArmed === APVerticalModes.GP) {
                    (_a = this.verticalModes.get(APVerticalModes.GP)) === null || _a === void 0 ? void 0 : _a.deactivate();
                }
                else if (verticalActive === APVerticalModes.GS || verticalArmed === APVerticalModes.GS) {
                    (_b = this.verticalModes.get(APVerticalModes.GS)) === null || _b === void 0 ? void 0 : _b.deactivate();
                }
            }
        });
        this.fmaData.sub(this.updateNavigationSources.bind(this));
        this.ianFacValid.sub(this.updateNavigationSources.bind(this));
        this.ianGpValid.sub(this.updateNavigationSources.bind(this));
        this.apValues.capturedAltitude.sub((a) => this.publisher.pub('ap_boeing_captured_altitude', a, true));
        this.autolandCapability.sub(this.onAutolandCapabilityChanged.bind(this));
        // Handle Boeing FCU Events
        const stateManager = this.stateManager;
        stateManager.altInterventionPressed.on(this.onAltInterventionPressed.bind(this));
        stateManager.spdInterventionPressed.on(this.onSpeedInterventionPressed.bind(this));
        stateManager.spdMachTogglePressed.on(this.onSpeedMachTogglePressed.bind(this));
        stateManager.autothrottleTogaPressed.on(this.onAutothrottleTogaPressed.bind(this));
        stateManager.autothrottleClbConPressed.on(this.onAutothrottleClbConPressed.bind(this));
        stateManager.autothrottleEngagePressed.on(this.onAutothrottleEngagePressed.bind(this));
        stateManager.autothrottleSpeedPressed.on(this.onAutothrottleSpdPressed.bind(this));
        stateManager.autothrottleThrPressed.on(this.onAutothrottleThrPressed.bind(this));
        this.stateManager.apMasterOn.sub(apOn => {
            if (apOn && this.ra.get() < 50) {
                SimVar.SetSimVarValue('K:AUTOPILOT_OFF', 'number', 0);
            }
        });
        this.onGround.sub(onGround => {
            var _a;
            if (onGround) {
                if (this.apValues.lateralArmed.get() === APLateralModes.ROLLOUT) {
                    (_a = this.lateralModes.get(APLateralModes.ROLLOUT)) === null || _a === void 0 ? void 0 : _a.activate();
                }
                else {
                    SimVar.SetSimVarValue('K:AUTOPILOT_OFF', 'number', 0);
                }
            }
        });
    }
    /**
     * Overridable method for setting the selected speed values for the A/P to follow.
     * The Boeing is setup to always get AP speeds from the Speed Manager events.
     */
    monitorApSpeedValues() {
        const speed = this.bus.getSubscriber();
        speed.on('fms_speed_autopilot_target_ias').withPrecision(0).handle((ias) => {
            this.apValues.selectedIas.set(ias);
        });
        speed.on('fms_speed_autopilot_target_mach').withPrecision(3).handle((mach) => {
            this.apValues.selectedMach.set(mach);
        });
        speed.on('fms_speed_autopilot_target_is_mach').whenChanged().handle((inMach) => {
            this.apValues.isSelectedSpeedInMach.set(inMach);
        });
    }
    /**
     * Handler when the Alt Intervention Knob Button is pressed on the FCU.
     */
    onAltInterventionPressed() {
        // during climb or descent with altitude constraints, each push deletes the next waypoint constraint
        // between the airplane altitude and the altitude window
        var _a;
        // during climb with no altitude constraints, and the altitude window set above the FMC cruise altitude,
        // the cruise altitude is changed to the altitude window value
        // during cruise:
        // -with the altitude window set above or below FMC cruise altitude, the FMC cruise altitude resets to the altitude window altitude
        // -when in VNAV PTH or VNAV ALT pitch mode, the airplane begins a climb or descent toward the altitude window altitude
        // -within 50 NM of the top-of-descent (T/D) point, with the altitude window set below cruise altitude, the airplane
        // initiates the descend now (DES NOW) feature
        (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.onAltInterventionPressed();
    }
    /**
     * Handler when the Speed Intervention Knob Button is pressed on the FCU.
     */
    onSpeedInterventionPressed() {
        var _a, _b;
        const apSelectedSpeedManual = this.apSelectedSpeedManual.get();
        const vnavMode = (_b = (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.boeingVNavMode.get()) !== null && _b !== void 0 ? _b : BoeingVNavModes.NONE;
        if (vnavMode !== BoeingVNavModes.NONE && vnavMode !== BoeingVNavModes.ARMED) {
            SimVar.SetSimVarValue('L:XMLVAR_SpeedIsManuallySet', SimVarValueType.Bool, !apSelectedSpeedManual);
            if (!apSelectedSpeedManual) {
                this.setSpeedWindow(this.ias.get());
            }
        }
    }
    /**
     * Handle when the SPD/MACH toggle button is pressed
     */
    onSpeedMachTogglePressed() {
        if (!this.apSelectedSpeedManual.get()) {
            return;
        }
        if (this.mcpSpeedIsMach.get()) {
            this.setMcpSpeedIsMach(false);
        }
        else {
            // cannot switch to mach unless the value is at least mach 0.4
            const mach = MathUtils.round(AeroMath.casToMach(UnitType.MPS.convertFrom(this.apValues.selectedIas.get(), UnitType.KNOT), UnitType.HPA.convertFrom(this.ambientPressure.get(), UnitType.IN_HG)), 0.01);
            if (mach >= 0.4) {
                this.setMcpSpeedIsMach(true);
            }
        }
    }
    /** Handler when the TOGA Button is pressed. */
    onAutothrottleTogaPressed() {
        this.publisher.pub('boeing_at_control_toga_button_pressed', undefined, false, false);
    }
    /** Handler when the A/T CLB/CON Button is pressed on the FCU. */
    onAutothrottleClbConPressed() {
        this.publisher.pub('boeing_at_control_clbcon_button_pressed', undefined, false, false);
    }
    /** Handler when the A/T Engage Button is pressed on the FCU. */
    onAutothrottleEngagePressed() {
        this.publisher.pub('boeing_at_control_engage_button_pressed', undefined, false, false);
    }
    /** Handler when the A/T SPD Button is pressed on the FCU. */
    onAutothrottleSpdPressed() {
        this.publisher.pub('boeing_at_control_spd_button_pressed', undefined, false, false);
    }
    /** Handler when the A/T THR Button is pressed on the FCU. */
    onAutothrottleThrPressed() {
        this.publisher.pub('boeing_at_control_thr_button_pressed', undefined, false, false);
    }
    /**
     * Handle changes in ap vertical mode
     * @param newVerticalMode New vertical mode
     */
    onApVerticalMode(newVerticalMode) {
        const wasToga = this.apVerticalActive === APVerticalModes.TO || this.apVerticalActive === APVerticalModes.GA;
        const needSpeedAdjust = newVerticalMode === APVerticalModes.VS || newVerticalMode === APVerticalModes.FPA
            || newVerticalMode === APVerticalModes.CAP || newVerticalMode === APVerticalModes.ALT;
        if (wasToga && needSpeedAdjust && !this.iasWindowChangedAfterToga) {
            // we need to bump the speed target from V2 (during takeoff), to a new suitable speed
            // setSpeedWindow takes care of making sure the max is flap placard -5 when flaps are not up
            this.setSpeedWindow(250);
        }
        this.apVerticalActive = newVerticalMode;
    }
    /**
     * Handle changes to the speed window speed
     */
    onSpeedWindowChanged() {
        const isToga = this.apValues.verticalActive.get() === APVerticalModes.TO || this.apValues.verticalActive.get() === APVerticalModes.GA;
        if (isToga) {
            this.iasWindowChangedAfterToga = true;
        }
    }
    /**
     * Set the speed window to a CAS, with automatic conversion to mach when required.
     * The maximum manual speed is limited to Vmo/Mmo - 11 knots, or flap placard speed - 5 knots.
     * @param cas Speed in knots
     */
    setSpeedWindow(cas) {
        var _a, _b, _c, _d, _e, _f;
        const vmoLimit = ((_b = (_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.getVmo()) !== null && _b !== void 0 ? _b : Infinity) - 11;
        const mmo = (_d = (_c = this.vnavManager) === null || _c === void 0 ? void 0 : _c.getMmo()) !== null && _d !== void 0 ? _d : Infinity;
        const hpa = UnitType.HPA.convertFrom(this.ambientPressure.get(), UnitType.IN_HG);
        const mmoCasLimit = UnitType.KNOT.convertFrom(AeroMath.machToCas(mmo, hpa), UnitType.MPS) - 11;
        let target = cas;
        const maneuvering = (_f = (_e = this.vnavManager) === null || _e === void 0 ? void 0 : _e.getManeuveringSpeed()) !== null && _f !== void 0 ? _f : target;
        if (target < maneuvering) {
            target = maneuvering;
        }
        if (target > vmoLimit) {
            target = vmoLimit;
        }
        if (target > mmoCasLimit) {
            target = mmoCasLimit;
        }
        const flapSpeedLimit = this.flapSpeedLimit.get();
        if (flapSpeedLimit > 0 && target > (flapSpeedLimit - 5)) {
            target = flapSpeedLimit - 5;
        }
        const machTarget = AeroMath.casToMach(UnitType.MPS.convertFrom(target, UnitType.KNOT), hpa);
        const targetIsMach = mmoCasLimit < vmoLimit;
        !targetIsMach && SimVar.SetSimVarValue('K:AP_SPD_VAR_SET', SimVarValueType.Knots, Math.round(target));
        targetIsMach && SimVar.SetSimVarValue('K:AP_MACH_VAR_SET', SimVarValueType.Number, Math.round(machTarget * 100));
        this.setMcpSpeedIsMach(targetIsMach);
    }
    /**
     * Handle changes in glideslope on/off selection
     * @param selected True if G/S is selected ON
     */
    onGsSelectionChanged(selected) {
        var _a;
        // deactivate GS mode if it's deselected
        if (!selected && (this.verticalApproachArmed === APVerticalModes.GS || this.apValues.verticalActive.get() === APVerticalModes.GS)) {
            (_a = this.verticalModes.get(APVerticalModes.GS)) === null || _a === void 0 ? void 0 : _a.deactivate();
        }
    }
    /**
     * Updates external AP LVars, for MCP display
     *
     * @param lateralActive the lateral active mode
     * @param lateralArmed the lateral armed mode
     * @param verticalActive the vertical active mode
     * @param verticalArmed the vertical armed mode
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    updateExternalLVars(lateralActive, lateralArmed, verticalActive, verticalArmed) {
        // Vertical
        var _a;
        const vnavActive = ((_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.state) === VNavState.Enabled_Active;
        SimVar.SetSimVarValue('L:AP_VNAV_ARMED', SimVarValueType.Bool, vnavActive).then();
        const vsActive = verticalActive === APVerticalModes.VS || verticalActive === APVerticalModes.FPA;
        SimVar.SetSimVarValue('L:AP_VS_ACTIVE', SimVarValueType.Bool, vsActive).then();
        const flcActive = verticalActive === APVerticalModes.FLC && !vnavActive;
        SimVar.SetSimVarValue('L:AP_FLCH_ACTIVE', SimVarValueType.Bool, flcActive).then();
        // TODO this is wrong, ALT HOLD is a separate mode
        const altHoldActive = verticalActive === APVerticalModes.ALT && !vnavActive;
        SimVar.SetSimVarValue('L:AP_ALT_HOLD_ACTIVE', SimVarValueType.Bool, altHoldActive).then();
        const appActive = this.apValues.apApproachModeOn.get();
        SimVar.SetSimVarValue('L:AP_APR_ARMED', SimVarValueType.Bool, appActive).then();
        // Lateral
        const lnavArmed = lateralActive === APLateralModes.GPSS || lateralArmed === APLateralModes.GPSS;
        SimVar.SetSimVarValue('L:AP_LNAV_ARMED', SimVarValueType.Bool, lnavArmed).then();
        const headingOrTrackSelectActive = lateralActive === APLateralModes.HEADING || lateralActive === APLateralModes.TRACK;
        SimVar.SetSimVarValue('L:AP_HEADING_SELECT_ACTIVE', SimVarValueType.Bool, headingOrTrackSelectActive).then();
        const headingOrTrackHoldActive = lateralActive === APLateralModes.HEADING_HOLD || lateralActive === APLateralModes.TRACK_HOLD;
        SimVar.SetSimVarValue('L:AP_HEADING_LOCK_ACTIVE', SimVarValueType.Bool, headingOrTrackHoldActive).then();
        const locActive = lateralActive === APLateralModes.LOC || lateralArmed === APLateralModes.LOC;
        SimVar.SetSimVarValue('L:AP_LOC_ARMED', SimVarValueType.Bool, locActive).then();
        // TODO HDG SEL ?
        // Autothrottle
        const clbConActive = false;
        SimVar.SetSimVarValue('L:AP_CLBCON_ACTIVE', SimVarValueType.Bool, clbConActive).then();
    }
    /**
     * Gets the current autoland capability.
     * @param ra The current radio altitude in feet.
     * @param lateralActive The activated lateral mode.
     * @param verticalActive The activated vertical mode.
     * @returns current autoland capability
     */
    getAutolandCapability(ra, lateralActive, verticalActive) {
        if ((ra < 1500 &&
            (lateralActive === APLateralModes.LOC || lateralActive === APLateralModes.ROLLOUT) &&
            (verticalActive === APVerticalModes.GS || verticalActive === APVerticalModes.FLARE))) {
            return AutolandCapability.FailOperational;
        }
        return AutolandCapability.None;
    }
    /**
     * Handles when the autoland capability changes.
     * @param v The current Autoland Capability.
     */
    onAutolandCapabilityChanged(v) {
        var _a, _b, _c, _d;
        this.publisher.pub('autoland_capability', v, true);
        if (v !== AutolandCapability.None) {
            if (this.apValues.verticalArmed.get() !== APVerticalModes.FLARE) {
                (_a = this.verticalModes.get(APVerticalModes.FLARE)) === null || _a === void 0 ? void 0 : _a.arm();
            }
            if (this.apValues.lateralArmed.get() !== APLateralModes.ROLLOUT) {
                (_b = this.lateralModes.get(APLateralModes.ROLLOUT)) === null || _b === void 0 ? void 0 : _b.arm();
            }
        }
        else {
            if (this.apValues.verticalArmed.get() === APVerticalModes.FLARE) {
                (_c = this.verticalModes.get(APVerticalModes.FLARE)) === null || _c === void 0 ? void 0 : _c.deactivate();
            }
            if (this.apValues.lateralArmed.get() === APLateralModes.ROLLOUT) {
                (_d = this.lateralModes.get(APLateralModes.ROLLOUT)) === null || _d === void 0 ? void 0 : _d.deactivate();
            }
        }
    }
    /**
     * Checks and sets the proper armed altitude mode.
     */
    manageAltitudeCapture() {
        var _a, _b, _c;
        let altCapType = APAltitudeModes.NONE;
        let armAltCap = false;
        switch (this.apValues.verticalActive.get()) {
            case APVerticalModes.VS:
            case APVerticalModes.FPA:
            case APVerticalModes.FLC:
            case APVerticalModes.PITCH:
            case APVerticalModes.TO:
            case APVerticalModes.GA:
                if (this.inClimb && this.apValues.selectedAltitude.get() > this.currentAltitude) {
                    altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                else if (!this.inClimb && this.apValues.selectedAltitude.get() < this.currentAltitude) {
                    altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
                    armAltCap = true;
                }
                break;
            case APVerticalModes.PATH: {
                if (!this.inClimb) {
                    altCapType = this.vnavCaptureType === VNavAltCaptureType.VNAV ? APAltitudeModes.ALTV : APAltitudeModes.ALTS;
                }
                break;
            }
            case APVerticalModes.CAP:
                altCapType = this.verticalAltitudeArmed;
                break;
        }
        if (this.verticalAltitudeArmed !== altCapType) {
            this.verticalAltitudeArmed = altCapType;
        }
        if (armAltCap && (!this.altCapArmed || ((_a = this.verticalModes.get(APVerticalModes.CAP)) === null || _a === void 0 ? void 0 : _a.state) === DirectorState.Inactive)) {
            (_b = this.verticalModes.get(APVerticalModes.CAP)) === null || _b === void 0 ? void 0 : _b.arm();
        }
        else if (!armAltCap && this.altCapArmed) {
            (_c = this.verticalModes.get(APVerticalModes.CAP)) === null || _c === void 0 ? void 0 : _c.deactivate();
            this.altCapArmed = false;
        }
    }
    /**
     * Handles input from the State Manager when the TOGA button is pressed
     * (K event AUTO_THROTTLE_TO_GA)
     */
    togaPressed() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const onGround = this.onGround.get();
        if (onGround) {
            const ias = this.ias.get();
            if (ias >= 80) {
                const lnavArmedOrActive = this.apValues.lateralActive.get() === APLateralModes.GPSS || this.apValues.lateralArmed.get() === APLateralModes.GPSS;
                if (lnavArmedOrActive) {
                    this.lateralPressed({ mode: APLateralModes.GPSS, set: false });
                }
                const vnavArmedOrActive = ((_a = this.vnavManager) === null || _a === void 0 ? void 0 : _a.state) === VNavState.Enabled_Active;
                if (vnavArmedOrActive) {
                    this.publisher.pub('boeingvnav_off', undefined);
                }
            }
        }
        else {
            const agl = this.ra.get();
            const lateralActive = this.apValues.lateralActive.get();
            const verticalActive = this.apValues.verticalActive.get();
            const afterLiftOff = this.fmsOperatingPhase.get() >= FmsOperatingPhase.TAKEOFF;
            const flapsOutOfUp = this.flapsPosition.get() > 1;
            const onApproach = this.fmsOperatingPhase.get() === FmsOperatingPhase.APPROACH;
            const gsOrGPCaptured = verticalActive === APVerticalModes.GS || verticalActive === APVerticalModes.GP;
            const goAroundActive = this.goAroundActive.get();
            const lateralInHeadingSelOrHold = lateralActive === APLateralModes.HEADING || lateralActive === APLateralModes.HEADING_HOLD;
            const verticalInTOGA = verticalActive === APVerticalModes.TO || verticalActive === APVerticalModes.GA;
            if (onApproach && !goAroundActive && (flapsOutOfUp || gsOrGPCaptured)) {
                // IF (on approach [phase == Approach] && (flaps out || GS/GP captured)):
                this.disarmAfdsModes();
                (_b = this.lateralModes.get(APLateralModes.TO)) === null || _b === void 0 ? void 0 : _b.activate();
                (_c = this.verticalModes.get(APVerticalModes.TO)) === null || _c === void 0 ? void 0 : _c.activate();
                this.armLnav();
                this.goAroundActive.set(true);
            }
            else if (goAroundActive && lateralInHeadingSelOrHold && verticalInTOGA) {
                // IF Second push (go-around active [phase == Approach] && flaps out && HDG SEL/HOLD lateral active && TOGA vertical active):
                (_d = this.lateralModes.get(APLateralModes.TO)) === null || _d === void 0 ? void 0 : _d.activate();
                (_e = this.verticalModes.get(APVerticalModes.TO)) === null || _e === void 0 ? void 0 : _e.activate();
            }
            else if (afterLiftOff) {
                // IF (after lift off && takeoff thrust limit):
                this.disarmAfdsModes();
                if (agl > 50 && agl < 400) {
                    (_f = this.lateralModes.get(APLateralModes.TO)) === null || _f === void 0 ? void 0 : _f.activate();
                }
                else if (agl > 400) {
                    (_g = this.lateralModes.get(APLateralModes.TO)) === null || _g === void 0 ? void 0 : _g.activate();
                    (_h = this.verticalModes.get(APVerticalModes.TO)) === null || _h === void 0 ? void 0 : _h.activate();
                }
                if (flapsOutOfUp) {
                    // IF (after lift off && flaps out):
                    this.armLnav();
                }
            }
        }
        this.iasWindowChangedAfterToga = false;
    }
    /**
     * Disarms all AFDS modes
     */
    disarmAfdsModes() {
        var _a, _b;
        const lateralArmed = this.apValues.lateralArmed.get();
        if (lateralArmed !== APLateralModes.NONE) {
            (_a = this.lateralModes.get(lateralArmed)) === null || _a === void 0 ? void 0 : _a.deactivate();
            this.apValues.lateralArmed.set(APLateralModes.NONE);
        }
        const verticalArmed = this.apValues.verticalArmed.get();
        if (verticalArmed !== APVerticalModes.NONE) {
            (_b = this.verticalModes.get(verticalArmed)) === null || _b === void 0 ? void 0 : _b.deactivate();
            this.apValues.verticalArmed.set(APVerticalModes.NONE);
        }
    }
    /**
     * Arms LNAV
     */
    armLnav() {
        this.publisher.pub('cdi_select', { type: NavSourceType.Gps, index: 0 }, true);
        this.lateralPressed({ mode: APLateralModes.NAV, set: true });
    }
    /**
     * Publishes data for the FMA.
     * @param clear Is to clear the FMA
     */
    updateFma(clear = false) {
        const fmaTemp = this.fmaData;
        if (!this.vnavManager) {
            return;
        }
        const boeingVNavMode = this.vnavManager.boeingVNavMode.get();
        const vnavActive = this.vnavManager.isVnavActive();
        // the FLARE FMA is removed as soon as the main gears touch down, but the director remains to drive the nose wheel down,
        // as seen in videos of the real plane and specified in the FCOM
        const hideVerticalActive = this.apValues.verticalActive.get() === APVerticalModes.FLARE && this.onGround.get();
        const verticalActive = (clear || hideVerticalActive) ? APVerticalModes.NONE : (vnavActive ? boeingVNavMode : this.apValues.verticalActive.get());
        fmaTemp.set('verticalActive', verticalActive);
        fmaTemp.set('verticalArmed', clear ? APVerticalModes.NONE :
            this.verticalApproachArmed !== APVerticalModes.NONE ? this.verticalApproachArmed :
                boeingVNavMode === BoeingVNavModes.ARMED ? BoeingVNavModes.ARMED :
                    this.apValues.verticalArmed.get());
        fmaTemp.set('lateralActive', (clear ? APLateralModes.NONE : this.apValues.lateralActive.get()));
        fmaTemp.set('lateralArmed', (clear ? APLateralModes.NONE : this.apValues.lateralArmed.get()));
        // FIXME get state from FBW
        const envelopeProtectionActive = false;
        fmaTemp.set('verticalDegraded', verticalActive !== APVerticalModes.NONE && envelopeProtectionActive);
    }
    /**
     * Updates the automatic go-around detection
     */
    updateAutomaticGoAroundDetection() {
        const goAroundActive = this.goAroundActive.get();
        if (this.fmsOperatingPhase.get() !== FmsOperatingPhase.APPROACH) {
            this.goAroundActive.set(false);
            return;
        }
        // Determine the flaps angle to use as a threshold for the "landing flaps retracted" condition
        let retractedFlapsAngle = Number.MAX_SAFE_INTEGER;
        if (this.maxApproachFlaps >= 25) {
            retractedFlapsAngle = 21.8;
        }
        else if (this.maxApproachFlaps >= 20) {
            retractedFlapsAngle = 11.8;
        }
        const flapsAngle = this.flapsPosition.get();
        if (goAroundActive) {
            // Reset GA when flaps angle goes back above the threshold for the "landing flaps retracted" condition
            if (flapsAngle > retractedFlapsAngle) {
                this.goAroundActive.set(false);
            }
            return;
        }
        else {
            this.maxApproachFlaps = Math.max(this.maxApproachFlaps, flapsAngle);
        }
        const mcpAltitude = this.apValues.selectedAltitude.get();
        const currentAltitude = this.altitude.get();
        const rateOfClimb = this.vs.get();
        if (mcpAltitude > currentAltitude && rateOfClimb > 600 && flapsAngle < retractedFlapsAngle) {
            this.goAroundActive.set(true);
        }
    }
    /** Update the kcas/mach crossover points for manual speed */
    updateManualSpeedCrossover() {
        // FMS speeds are all handled by FmsSpeedManager
        if (!this.apSelectedSpeedManual.get()) {
            return;
        }
        const climbing = this.vs.get() > 100;
        const descending = this.vs.get() < -100;
        const pressure = UnitType.HPA.convertFrom(this.ambientPressure.get(), UnitType.IN_HG);
        // During climb automatically change to mach at 0.84 mach.
        if (climbing && !this.mcpSpeedIsMach.get()
            && MathUtils.round(AeroMath.casToMach(UnitType.MPS.convertFrom(this.apValues.selectedIas.get(), UnitType.KNOT), pressure), 0.01) >= 0.84) {
            this.setMcpSpeedIsMach(true);
        }
        // During descent automatically change to kcas at 310 knots.
        if (descending && this.mcpSpeedIsMach.get()
            && UnitType.KNOT.convertFrom(AeroMath.machToCas(this.apValues.selectedMach.get(), pressure), UnitType.MPS) >= 310) {
            this.setMcpSpeedIsMach(false);
        }
    }
    /**
     * Set the MCP speed window to mach or cas
     * @param isMach true if the window should be set to mach
     */
    setMcpSpeedIsMach(isMach) {
        // set Lvar for the MCP (reflects manual speed target only)
        SimVar.SetSimVarValue('L:XMLVAR_AirSpeedIsInMach', SimVarValueType.Bool, isMach);
        // set AP state... blocked by FmsSpeedManager key handling if it's controlling speed
        if (isMach) {
            SimVar.SetSimVarValue('K:AP_MANAGED_SPEED_IN_MACH_ON', SimVarValueType.Bool, true);
        }
        else {
            SimVar.SetSimVarValue('K:AP_MANAGED_SPEED_IN_MACH_OFF', SimVarValueType.Bool, true);
        }
    }
    /**
     * Update the TO/GA and HUD TO/GA mode state
     */
    updateHudToga() {
        var _a;
        if (this.hudTogaRunway.get() !== null && this.apValues.lateralActive.get() === APLateralModes.TO) {
            this.setLateralActive(APLateralModes.TO_LOC, false);
            (_a = this.lateralModes.get(APLateralModes.TO_LOC)) === null || _a === void 0 ? void 0 : _a.activate();
        }
        // HUD TO/GA never disarms unless AP and FD are disengaged or we get airborne and another mode takes over
        const apAndFdsOff = !this.stateManager.apMasterOn.get() && !this.stateManager.isFlightDirectorOn.get() && !this.stateManager.isFlightDirectorCoPilotOn.get();
        if (apAndFdsOff && this.apValues.lateralActive.get() === APLateralModes.TO_LOC) {
            this.setLateralActive(APLateralModes.NONE);
        }
    }
    /** Updates the active navigation sources */
    updateNavigationSources() {
        const fma = this.fmaData.get();
        const latActive = fma.lateralActive;
        const latArmed = fma.lateralArmed;
        const vertActive = fma.verticalActive;
        const lnavActiveOrArmed = latActive === APLateralModes.GPSS || latArmed === APLateralModes.GPSS;
        const npsRequested = lnavActiveOrArmed || BoeingVNavUtils.isModeVnav(vertActive);
        const facRequested = latActive === APLateralModes.FMS_LOC || (this.ianFacValid.get() && latActive !== APLateralModes.GPSS);
        if (latActive === APLateralModes.LOC || latActive === APLateralModes.BC || latActive === APLateralModes.TO_LOC) {
            this.lateralNavSource.set(NavigationSource.ILS);
        }
        else if (facRequested) {
            this.lateralNavSource.set(NavigationSource.IAN);
        }
        else if (npsRequested) {
            this.lateralNavSource.set(NavigationSource.NPS);
        }
        else {
            this.lateralNavSource.set(NavigationSource.NONE);
        }
        const gpRequested = vertActive === APVerticalModes.GP || (this.ianGpValid.get() && !BoeingVNavUtils.isModeVnav(vertActive));
        if (vertActive === APVerticalModes.GS) {
            this.verticalNavSource.set(NavigationSource.ILS);
        }
        else if (gpRequested) {
            this.verticalNavSource.set(NavigationSource.IAN);
        }
        else if (npsRequested) {
            this.verticalNavSource.set(NavigationSource.NPS);
        }
        else {
            this.verticalNavSource.set(NavigationSource.NONE);
        }
    }
    /**
     * Get the default lateral mode
     * @returns default lateral mode
     */
    getDefaultLateralMode() {
        if (this.onGround.get()) {
            return APLateralModes.TO;
        }
        else if (SimVar.GetSimVarValue('L:XMLVAR_TRK_MODE_ACTIVE', SimVarValueType.Bool)) {
            return APLateralModes.TRACK_HOLD;
        }
        else {
            return APLateralModes.HEADING_HOLD;
        }
    }
    /**
     * Get the default vertical mode
     * @returns default vertical mode
     */
    getDefaultVerticalMode() {
        if (this.onGround.get()) {
            if (this.apValues.lateralActive.get() === APLateralModes.ROLLOUT) {
                return APVerticalModes.NONE;
            }
            else {
                return APVerticalModes.TO;
            }
        }
        else if (SimVar.GetSimVarValue('L:XMLVAR_FPA_MODE_ACTIVE', SimVarValueType.Bool)) {
            return APVerticalModes.FPA;
        }
        else {
            return APVerticalModes.VS;
        }
    }
}
BoeingAutopilot.ALT_SELECT_OPTIONS = {
    supportMetric: true,
    minValue: UnitType.FOOT.createNumber(0),
    maxValue: UnitType.FOOT.createNumber(43100),
    inputIncrLargeThreshold: 999,
    incrSmall: UnitType.FOOT.createNumber(100),
    incrLarge: UnitType.FOOT.createNumber(1000),
    incrSmallMetric: UnitType.METER.createNumber(50),
    incrLargeMetric: UnitType.METER.createNumber(500),
    accelInputCountThreshold: 11,
    accelResetOnDirectionChange: true
};
// TODO rebase and setup default TO mode to TO_LOC when hud toga selected

/** The Boeing FADEC LVars. */
const BoeingFadecLVars = {
    FADEC_IDLE_N1: 'L:WT_FADEC_IDLE_N1',
    FADEC_IDLE_N2: 'L:WT_FADEC_IDLE_N2',
    FADEC_REF_N1: 'L:WT_FADEC_REF_N1',
    FADEC_TGT_N1: 'L:WT_FADEC_TGT_N1',
    FADEC_REF_TPR: 'L:WT_FADEC_REF_TPR',
    FADEC_TGT_TPR: 'L:WT_FADEC_TGT_TPR',
    FADEC_CLB_N1: 'L:WT_FADEC_CLB_N1',
    FADEC_CRU_N1: 'L:WT_FADEC_CRU_N1',
    FADEC_N1_RED: 'L:WT_FADEC_N1_RED',
    FADEC_N1_AMBER: 'L:WT_FADEC_N1_AMBER',
    FADEC_N2_RED: 'L:WT_FADEC_N2_RED',
    FADEC_N2_AMBER: 'L:WT_FADEC_N2_AMBER',
    FADEC_EGT_START_LIMIT: 'L:WT_FADEC_EGT_START_LIMIT',
    FADEC_EGT_AMBER: 'L:WT_FADEC_EGT_AMBER',
    FADEC_EGT_RED: 'L:WT_FADEC_EGT_RED',
    FADEC_OIL_TEMP_LOW_RED: 'L:WT_FADEC_OIL_TEMP_LOW_RED',
    FADEC_OIL_TEMP_LOW_AMBER: 'L:WT_FADEC_OIL_TEMP_LOW_AMBER',
    FADEC_OIL_TEMP_HIGH_AMBER: 'L:WT_FADEC_OIL_TEMP_HIGH_AMBER',
    FADEC_ENG_START_STATE: 'L:WT_FADEC_ENG_START_STATE',
};
/** Utils for working with BoeingFadecLVars. */
class BoeingFadecLVarsUtils {
    /**
     * Creates an object of cached LVar strings, first indexed by engine index, then by LVar name.
     * @param engineCount The engine count.
     * @returns The cached LVars object.
     */
    static createLVars(engineCount) {
        const engineIndexedLVars = {};
        for (let i = 1; i <= engineCount; i++) {
            engineIndexedLVars[i] = BoeingFadecLVarsUtils.createCachedLVarsForEngine(i);
        }
        return engineIndexedLVars;
    }
    /**
     * Creates cached LVar strings object for single engine index.
     * @param engineIndex The engine index.
     * @returns The cached LVar strings object.
     */
    static createCachedLVarsForEngine(engineIndex) {
        const lVars = {};
        for (const [key, value] of Object.entries(BoeingFadecLVars)) {
            lVars[key] = `${value}_${engineIndex}`;
        }
        return lVars;
    }
}

/* eslint-disable @typescript-eslint/no-unused-vars */
/**
 * FADEC modes for the Boeings.
 */
var BoeingFadecModes;
(function (BoeingFadecModes) {
    /** Engine not running. */
    BoeingFadecModes["STOP"] = "STOP";
    /** Engine start. */
    BoeingFadecModes["START"] = "START";
    /** Max Takeoff thrust. */
    BoeingFadecModes["NORMAL"] = "NORMAL";
    /** TO-1 Derated Takeoff thrust. */
    BoeingFadecModes["ENGINE_OUT"] = "ENGINE_OUT";
    /** Takeoff thrust scale while on the ground. */
    BoeingFadecModes["GROUND"] = "GROUND";
    /** Reverse thrust. */
    BoeingFadecModes["TR"] = "T/R";
    /** Default undefined state. */
    BoeingFadecModes["UNDEF"] = "UNDEF";
})(BoeingFadecModes || (BoeingFadecModes = {}));
/**
 * The possible boeing engine start states.
 */
var BoeingEngineStartState;
(function (BoeingEngineStartState) {
    // Leave this as the default number values so it can be set to an LVar.
    BoeingEngineStartState[BoeingEngineStartState["STOPPED"] = 0] = "STOPPED";
    BoeingEngineStartState[BoeingEngineStartState["AUTOSTART"] = 1] = "AUTOSTART";
    BoeingEngineStartState[BoeingEngineStartState["RUNNING"] = 2] = "RUNNING";
})(BoeingEngineStartState || (BoeingEngineStartState = {}));
/**
 * A Boeing FADEC.
 */
class BoeingFadec extends JetFadec {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param engineData Data provider for the engines
     * @param performanceMath Pref math for Boeings.
     * @param thrustManager The Thrust Mode Manager.
     * @param calculateTpr Whether to calculate and publish TPR values in addition to N1 values.
     * @param fuelValveIndexOffset The offset for the fuel system valve switch sim var (defaults to 0).
     */
    constructor(bus, engineData, performanceMath, thrustManager, calculateTpr, fuelValveIndexOffset = 0) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        super(bus, [
            {
                name: BoeingFadecModes.STOP,
                /** @inheritdoc */
                accept: (index) => {
                    const { startState } = this.boeingEngineStates[index];
                    return startState === BoeingEngineStartState.STOPPED;
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index) => {
                    var _a, _b;
                    const referenceN1 = this.getN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
                    this.setReferenceN1(index, referenceN1);
                    this.setTargetN1(index, (_b = (_a = this.idleN1[index]) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : -1);
                    return 0;
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            },
            {
                name: BoeingFadecModes.START,
                /** @inheritdoc */
                accept: (index) => {
                    const { startState } = this.boeingEngineStates[index];
                    return startState === BoeingEngineStartState.AUTOSTART;
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index) => {
                    var _a, _b;
                    const referenceN1 = this.getN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
                    this.setReferenceN1(index, referenceN1);
                    this.setTargetN1(index, (_b = (_a = this.idleN1[index]) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : -1);
                    return 0;
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            },
            {
                name: BoeingFadecModes.TR,
                // Moving the throttle lever between 0 and the reverser lockout detent engages reverse idle mode.
                // If the airplane is not on the ground or the engines are not running, nothing happens. Otherwise, thrust
                // reverser deployment is commanded. The FADEC commands reverse idle until the lever is moved past the
                // reverser lockout detent.
                /** @inheritdoc */
                accept: (index, throttleLeverPos) => {
                    return throttleLeverPos < 0;
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index, throttleLeverPos, throttle, thrust, n1, n1Corrected) => {
                    // TODO: FADEC is supposed to set N1 target based on airspeed.
                    const referenceN1 = this.getN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
                    this.setReferenceN1(index, referenceN1);
                    this.setTargetN1(index, -1);
                    if (this.isOnGround.get()
                        && this.boeingEngineStates[index].startState === BoeingEngineStartState.RUNNING) {
                        if (throttleLeverPos < BoeingFadec.TR_LOCKOUT_DETENT - BoeingFadec.THROTTLE_LEVER_EPSILON) {
                            return BoeingFadec.REVERSE_IDLE_THROTTLE
                                + (throttleLeverPos - BoeingFadec.TR_LOCKOUT_DETENT) / BoeingFadec.TR_LEVER_RANGE * BoeingFadec.REVERSE_IDLE_THROTTLE_RANGE;
                        }
                        else {
                            return BoeingFadec.REVERSE_IDLE_THROTTLE;
                        }
                    }
                    else {
                        return 0;
                    }
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            },
            {
                name: BoeingFadecModes.GROUND,
                /** @inheritdoc */
                accept: () => {
                    return this.isOnGround.get();
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index, throttleLeverPos) => {
                    return this.computeDesiredThrottleForGroundAndNormal(index, throttleLeverPos);
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            },
            {
                name: BoeingFadecModes.NORMAL,
                /** @inheritdoc */
                accept: (index, throttleLeverPos) => {
                    return throttleLeverPos >= 0;
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index, throttleLeverPos) => {
                    return this.computeDesiredThrottleForGroundAndNormal(index, throttleLeverPos);
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            },
            {
                // Default case: should theoretically never fall into this.
                name: BoeingFadecModes.UNDEF,
                /** @inheritdoc */
                accept: () => {
                    return true;
                },
                /** @inheritdoc */
                computeDesiredThrottle: (index, throttleLeverPos) => {
                    return throttleLeverPos;
                },
                /** @inheritdoc */
                getVisibleThrottlePos: (index, throttleLeverPos) => {
                    return BoeingFadec.getThrottleAnimPos(throttleLeverPos);
                }
            }
        ], Array.from({ length: engineData.engineCount }).map((_, i) => ({ index: i + 1, leverPosTopic: `v_throttle_lever_pos_${i + 1}`, visiblePosSimVar: `L:XMLVAR_ThrottlePosition_${i + 1}` })), undefined, 
        // Arbitrarily high max desired throttle, mainly just because we don't actually want it limited on the high end in the Boeings
        150);
        this.engineData = engineData;
        this.performanceMath = performanceMath;
        this.thrustManager = thrustManager;
        this.calculateTpr = calculateTpr;
        // private readonly ignitionSetting = LongitudeUserSettings.getManager(this.bus).getSetting('engineIgnitorsSetOn');
        this.ignitionSetting = true;
        this.totalAirTemp = ConsumerValue.create(null, 0);
        this.ambientAirTemp = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.mach = ConsumerValue.create(null, 15);
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.indicatedAlt = ConsumerValue.create(null, 0);
        this.selectedAlt = ConsumerValue.create(null, 0);
        this.fmaData = ConsumerSubject.create(null, null);
        this.apIsToGa = this.fmaData.map(data => {
            if (data === null) {
                return false;
            }
            return data.verticalActive === APVerticalModes.TO || data.verticalActive === APVerticalModes.GA;
        });
        // private readonly autothrottleMode = ConsumerValue.create<string>(null, BoeingAutothrottleModes.NONE);
        this.apInClimbMode = false;
        this.clbTimeRemaining = 0;
        this.boeingEngineStates = {};
        this.maxClbN1Values = {};
        this.maxCruN1Values = {};
        this.referenceN1Values = {};
        this.targetN1Values = {};
        this.referenceTprValues = {};
        this.targetTprValues = {};
        this.engineLimits = {};
        this.isEngineOut = Subject.create(false);
        this.availableEngines = Subject.create(0);
        this.idleN1 = {};
        this.idleN2 = {};
        this.antiIceBoost = {};
        this.fadecLVars = BoeingFadecLVarsUtils.createLVars(this.engineData.engineCount);
        this.isFlightStarted = false;
        this.isThrottleLeverManagerInit = false;
        this.lastUpdateSimTime = 0;
        this.takeoffDeratePercentage = this.thrustManager.activePerfPlan.takeoffThrustMode.map((thrustMode) => {
            const maxN1 = this.getAmberLineMaxN1FromThrustReferenceMode(thrustMode);
            const derateN1 = this.getN1FromThrustReferenceMode(thrustMode);
            return this.engineData.getTakeoffDeratePercentage(derateN1, maxN1);
        });
        for (let n = 1; n <= engineData.engineCount; n++) {
            BoeingFadec.ENGINE_SIMVARS[n] = BoeingFadec.getEngineSimVars(n, fuelValveIndexOffset);
            this.boeingEngineStates[n] = {
                isEngFuelSwitchOn: false,
                isEngStarterSwitchOn: false,
                startState: BoeingEngineStartState.STOPPED,
                stoppingTime: 0,
                n2: 0,
                isAntiIceOn: false,
                maxClbN1: -1,
                maxCruN1: -1,
                isRescueIgnitionOn: false,
                rescueIgnitionExtraTime: 0,
                n2AmberTime: 0,
                oilTempLowHysteresis: false,
            };
            this.maxClbN1Values[n] = Subject.create(0);
            this.maxCruN1Values[n] = Subject.create(0);
            this.referenceN1Values[n] = Subject.create(0);
            this.targetN1Values[n] = Subject.create(0);
            this.referenceTprValues[n] = Subject.create(0);
            this.targetTprValues[n] = Subject.create(0);
            this.idleN1[n] = Subject.create(this.engineData.IDLE_N1);
            this.idleN2[n] = Subject.create(this.engineData.IDLE_N2);
            this.antiIceBoost[n] = 0;
            this.engineLimits[n] = {
                n1RedLine: Subject.create(0),
                n1AmberLine: Subject.create(0),
                n2RedLine: Subject.create(0),
                n2AmberLine: Subject.create(0),
                egtStartLimitLine: Subject.create(0),
                egtAmberLine: Subject.create(0),
                egtRedLine: Subject.create(0),
                oilTempLowRedLine: Subject.create(0)
            };
        }
        KeyEventManager.getManager(this.bus).then(manager => {
            this.keyEventManager = manager;
            manager.interceptKey('TURBINE_IGNITION_SWITCH_TOGGLE', false);
            manager.interceptKey('TURBINE_IGNITION_SWITCH_SET1', false);
            manager.interceptKey('TURBINE_IGNITION_SWITCH_SET2', false);
        });
        this.throttleLeverManager = new ThrottleLeverManager(bus, this.onThrottleLeverManagerInit.bind(this), this.onThrottleLeverPosRequested.bind(this));
        const sub = bus.getSubscriber();
        // Set up key intercepts
        sub.on('key_intercept').handle(this.onKeyIntercepted.bind(this));
        // Set up data subs.
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.indicatedAlt.setConsumer(sub.on('adc_indicated_alt_1'));
        this.selectedAlt.setConsumer(sub.on('ap_altitude_selected_3'));
        this.fmaData.setConsumer(sub.on('fma_data'));
        // this.autothrottleMode.setConsumer(sub.on('g3000_at_mode_active'));
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            const lVars = this.fadecLVars[n];
            // Publish N1 values.
            (_a = this.maxClbN1Values[n]) === null || _a === void 0 ? void 0 : _a.sub(n1 => SimVar.SetSimVarValue(lVars.FADEC_CLB_N1, SimVarValueType.Percent, n1));
            (_b = this.maxCruN1Values[n]) === null || _b === void 0 ? void 0 : _b.sub(n1 => SimVar.SetSimVarValue(lVars.FADEC_CRU_N1, SimVarValueType.Percent, n1));
            (_c = this.idleN1[n]) === null || _c === void 0 ? void 0 : _c.sub(n1 => SimVar.SetSimVarValue(lVars.FADEC_IDLE_N1, SimVarValueType.Percent, n1), true);
            (_d = this.idleN2[n]) === null || _d === void 0 ? void 0 : _d.sub(n2 => SimVar.SetSimVarValue(lVars.FADEC_IDLE_N2, SimVarValueType.Percent, n2), true);
            (_e = this.referenceN1Values[n]) === null || _e === void 0 ? void 0 : _e.sub(n1 => SimVar.SetSimVarValue(lVars.FADEC_REF_N1, SimVarValueType.Percent, n1));
            (_f = this.targetN1Values[n]) === null || _f === void 0 ? void 0 : _f.sub(n1 => SimVar.SetSimVarValue(lVars.FADEC_TGT_N1, SimVarValueType.Percent, n1));
            // Publish TPR values.
            if (this.calculateTpr) {
                (_g = this.referenceTprValues[n]) === null || _g === void 0 ? void 0 : _g.sub(tpr => SimVar.SetSimVarValue(lVars.FADEC_REF_TPR, SimVarValueType.Percent, tpr));
                (_h = this.targetTprValues[n]) === null || _h === void 0 ? void 0 : _h.sub(tpr => SimVar.SetSimVarValue(lVars.FADEC_TGT_TPR, SimVarValueType.Percent, tpr));
            }
            // Publish engine limit values.
            const limits = this.engineLimits[n];
            limits.n1RedLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_N1_RED, SimVarValueType.Percent, v));
            limits.n1AmberLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_N1_AMBER, SimVarValueType.Percent, v));
            limits.n2RedLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_N2_RED, SimVarValueType.Percent, v));
            limits.n2AmberLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_N2_AMBER, SimVarValueType.Percent, v));
            limits.egtStartLimitLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_EGT_START_LIMIT, SimVarValueType.Celsius, v));
            limits.egtAmberLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_EGT_AMBER, SimVarValueType.Celsius, v));
            limits.egtRedLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_EGT_RED, SimVarValueType.Celsius, v));
            limits.oilTempLowRedLine.sub(v => SimVar.SetSimVarValue(lVars.FADEC_OIL_TEMP_LOW_RED, SimVarValueType.Celsius, v));
            SimVar.SetSimVarValue(lVars.FADEC_OIL_TEMP_LOW_AMBER, SimVarValueType.Celsius, BoeingFadec.OIL_TEMP_LOW_AMBER);
            SimVar.SetSimVarValue(lVars.FADEC_OIL_TEMP_HIGH_AMBER, SimVarValueType.Celsius, BoeingFadec.OIL_TEMP_HIGH_AMBER);
            // Created here so it's not creating garbage every update
            const WT_Virtual_Throttle_Lever_Pos_n = `L:WT_Virtual_Throttle_Lever_Pos_${n}`;
            // Publish virtual throttle lever positions for the benefit of modelbehaviors.
            sub.on(`v_throttle_lever_pos_${n}`).whenChanged().handle(BoeingFadec.publishThrottleLeverPosSimVar.bind(undefined, WT_Virtual_Throttle_Lever_Pos_n));
            // sub.on(`ai_n1_boost_${n}`).handle(v => this.antiIceBoost[n] = v);
            // sub.on(`ai_idle_n1_min_{n}`).handle(v => this.idleN1[n] = v);
        }
        this.availableEngines.sub((engines) => this.bus.getPublisher().pub('fadec_available_engines', engines));
        this.isEngineOut.sub((out) => this.bus.getPublisher().pub('fadec_engine_out', out));
        this.takeoffDeratePercentage.sub((deratePercentage) => this.bus.getPublisher()
            .pub('fadec_takeoff_derate_percentage', deratePercentage, true, true));
        this.pressureAlt.setConsumer(sub.on('pressure_alt').withPrecision(1));
        this.totalAirTemp.setConsumer(sub.on('ram_air_temp_c').withPrecision(1));
        this.ambientAirTemp.setConsumer(sub.on('ambient_temp_c').withPrecision(1));
        this.mach.setConsumer(sub.on('mach_number').withPrecision(3));
    }
    /** Handles throttle lever manager init callback. */
    onThrottleLeverManagerInit() {
        this.isThrottleLeverManagerInit = true;
        this.tryStart();
    }
    /** Called when flight is started, or when instrument is reloaded after flight start. */
    onFlightStart() {
        this.isFlightStarted = true;
        this.tryStart();
    }
    /** Will start fadec if conditions are met. */
    tryStart() {
        if (this.isFlightStarted && this.isThrottleLeverManagerInit) {
            this.start(BoeingFadec.UPDATE_FREQ);
        }
    }
    /**
     * Computes desired throttle fround ground and normal fadec modes.
     * @param index the throttle index.
     * @param throttleLeverPos the throttle lever position.
     * @returns the desired throttle.
     */
    computeDesiredThrottleForGroundAndNormal(index, throttleLeverPos) {
        var _a, _b, _c;
        const maxN1 = this.getAmberLineMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
        const maximumRatedN1 = Math.min(maxN1 * 1.05, this.engineData.RED_LINE_N1);
        const referenceN1 = this.getN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
        const targetN1 = BoeingFadec.calcTargetN1(maximumRatedN1, throttleLeverPos, (_b = (_a = this.idleN1[index]) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : -1, (_c = this.antiIceBoost[index]) !== null && _c !== void 0 ? _c : 0);
        this.setReferenceN1(index, referenceN1);
        this.setTargetN1(index, targetN1);
        return this.adjustThrottleForN1(targetN1, index, throttleLeverPos);
    }
    /**
     * Responds to when a throttle lever position is requested.
     * @param index The index of the throttle lever, 1-based
     * @param currentPos The current position of the throttle lever, from -1 to +1.
     * @param newPos The requested new position, from -1 to +1.
     * @param keyEvent The key event that triggered the request.
     * @returns The actual throttle lever position to set.
     */
    onThrottleLeverPosRequested(index, currentPos, newPos, keyEvent) {
        if (this.engineStates[index] === undefined) {
            return newPos;
        }
        if (this.onThrottleLeverKeyEvent && keyEvent !== undefined) {
            newPos = this.onThrottleLeverKeyEvent(index, currentPos, newPos, keyEvent);
        }
        // The reverse thrust lever cannot be raised unless the forward thrust lever is at idle. However, in the sim it's
        // not really possible to violate this condition since everything is on a single continuous axis. Therefore we will
        // not worry about this check.
        // The reverse thrust lever cannot be raised farther than the reverser lockout detent until the reversers are
        // partially deployed. We don't model reverser deployment, so we will just use the same check that FADEC does to
        // determine whether reversers can be deployed: plane is on the ground and engine is running.
        if (newPos >= BoeingFadec.TR_LOCKOUT_DETENT) {
            return newPos;
        }
        if (this.isOnGround.get()
            && this.boeingEngineStates[index].startState === BoeingEngineStartState.RUNNING) {
            return newPos;
        }
        else {
            return BoeingFadec.TR_LOCKOUT_DETENT;
        }
    }
    /**
     * Responds to when a key event is intercepted.
     * @param data The data for the intercepted key event.
     */
    onKeyIntercepted(data) {
        // TODO?
    }
    /** @inheritdoc */
    onUpdate(realDeltaTime) {
        super.onUpdate(realDeltaTime);
        const simTime = this.simTime.get();
        const simDeltaTime = Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        this.updateBoeingEngineStates(simDeltaTime);
        for (let i = 1; i <= this.engineData.engineCount; i++) {
            this.updateEngineIgnitors(i, simDeltaTime);
        }
        this.updateEngineLimits(simDeltaTime);
    }
    /**
     * Updates boeing engine states.
     * @param simDeltaTime The number of milliseconds passed in sim time.
     */
    updateBoeingEngineStates(simDeltaTime) {
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            this.updateBoeingEngineState(n, simDeltaTime);
        }
        const availableEngines = Object.values(this.boeingEngineStates).reduce((onCount, engineState) => {
            return engineState.startState === BoeingEngineStartState.RUNNING
                ? onCount + 1
                : onCount;
        }, 0);
        this.isEngineOut.set(availableEngines < this.engineData.engineCount);
        this.availableEngines.set(availableEngines);
    }
    /**
     * Updates this FADEC's Longitude-specific state for a given engine.
     * @param index The index of the engine to update, 1-based
     * @param simDeltaTime The number of milliseconds passed in sim time.
     */
    updateBoeingEngineState(index, simDeltaTime) {
        var _a;
        const simVars = BoeingFadec.ENGINE_SIMVARS[index];
        const lVars = this.fadecLVars[index];
        const boeingEngineState = this.boeingEngineStates[index];
        if (simVars === undefined || boeingEngineState === undefined) {
            return;
        }
        boeingEngineState.isEngFuelSwitchOn = SimVar.GetSimVarValue(simVars.engFuelSwitch, SimVarValueType.Bool) !== 0;
        boeingEngineState.isEngStarterSwitchOn = SimVar.GetSimVarValue(simVars.engStarterSwitch, SimVarValueType.Bool) !== 0;
        boeingEngineState.startState = this.getEngineStartState(index, simDeltaTime);
        SimVar.SetSimVarValue(lVars.FADEC_ENG_START_STATE, SimVarValueType.Number, boeingEngineState.startState);
        boeingEngineState.n2 = SimVar.GetSimVarValue(simVars.n2, SimVarValueType.Percent);
        boeingEngineState.isAntiIceOn = SimVar.GetSimVarValue(simVars.antiIce, SimVarValueType.Bool) !== 0;
        (_a = this.idleN1[index]) === null || _a === void 0 ? void 0 : _a.set(this.performanceMath.calculateIdleCorrectedN1(this.totalAirTemp.get(), this.mach.get()));
        // if (boeingEngineState.isStarted) {
        //   boeingEngineState.maxClbN1 = BoeingFadec.lookupN1(this.perfPlanProxy.climbThrustMode.get());
        //   boeingEngineState.maxCruN1 = BoeingFadec.lookupN1(AirborneThrustMode.CRZ);
        // } else {
        //   boeingEngineState.maxClbN1 = -1;
        //   boeingEngineState.maxCruN1 = -1;
        // }
        // this.maxClbN1Values[index].set(boeingEngineState.maxClbN1);
        // this.maxCruN1Values[index].set(boeingEngineState.maxCruN1);
    }
    /**
     * Gets the current engine start state for an engine.
     * @param index The engine index.
     * @param simDeltaTime The number of milliseconds passed in sim time.
     * @returns the current engine start state.
     */
    getEngineStartState(index, simDeltaTime) {
        const state = this.boeingEngineStates[index];
        const { isEngStarterSwitchOn, isEngFuelSwitchOn, n2 } = state;
        const currentMode = state.startState;
        const idleN2 = this.idleN2[index].get();
        // 5 is arbitrary, just so we don't get stuck in autostart
        const idleN2StartLimit = idleN2 - 5;
        if (currentMode === BoeingEngineStartState.STOPPED) {
            if (isEngStarterSwitchOn && isEngFuelSwitchOn) {
                return BoeingEngineStartState.AUTOSTART;
            }
            if (isEngFuelSwitchOn && n2 > idleN2StartLimit) {
                return BoeingEngineStartState.RUNNING;
            }
        }
        if (currentMode === BoeingEngineStartState.AUTOSTART) {
            if (isEngFuelSwitchOn && n2 > idleN2StartLimit) {
                return BoeingEngineStartState.RUNNING;
            }
            if (!isEngFuelSwitchOn) {
                return BoeingEngineStartState.STOPPED;
            }
        }
        if (currentMode === BoeingEngineStartState.RUNNING) {
            if (!isEngFuelSwitchOn) {
                return BoeingEngineStartState.STOPPED;
            }
        }
        return currentMode;
    }
    /**
     * Updates the state of the ignitors for a given engine. If the engine is set to RUN, ignition will be set to ON if
     * the engine ignition user setting is ON, or AUTO if the engine ignition user setting is NORM. If the engine is set
     * to STOP, ignition will be set to OFF.
     * @param index The index of the engine.
     * @param simDeltaTime The number of milliseconds passed in sim time.
     */
    updateEngineIgnitors(index, simDeltaTime) {
        var _a;
        const simVars = BoeingFadec.ENGINE_SIMVARS[index];
        const engineState = this.boeingEngineStates[index];
        if (simVars === undefined || engineState === undefined) {
            return;
        }
        const ignitionState = SimVar.GetSimVarValue(simVars.ignitionSwitch, SimVarValueType.Number);
        let desiredIgnitionState;
        let isRescueIgnitionOn = false;
        if (engineState.isEngFuelSwitchOn) {
            if (this.ignitionSetting) {
                desiredIgnitionState = 2;
            }
            else {
                if (engineState.isEngStarterSwitchOn) {
                    desiredIgnitionState = 1;
                }
                else {
                    // Check if the engine is not combusting when it should be, and if so force the ignitors on.
                    const isCombusting = SimVar.GetSimVarValue(simVars.combustion, SimVarValueType.Bool) !== 0;
                    const requireRescue = !isCombusting && engineState.n2 >= this.engineData.IDLE_N2;
                    if (requireRescue || (engineState.isRescueIgnitionOn && engineState.rescueIgnitionExtraTime < BoeingFadec.RESCUE_IGNITION_HYSTERESIS)) {
                        desiredIgnitionState = 2;
                        isRescueIgnitionOn = true;
                        if (!requireRescue) {
                            engineState.rescueIgnitionExtraTime += simDeltaTime;
                        }
                    }
                    else {
                        desiredIgnitionState = 1;
                    }
                }
            }
        }
        else {
            desiredIgnitionState = 0;
        }
        engineState.isRescueIgnitionOn = isRescueIgnitionOn;
        if (!isRescueIgnitionOn) {
            engineState.rescueIgnitionExtraTime = 0;
        }
        if (ignitionState !== desiredIgnitionState) {
            (_a = this.keyEventManager) === null || _a === void 0 ? void 0 : _a.triggerKey(simVars.setIgnitionSwitchKey, true, desiredIgnitionState);
        }
    }
    /**
     * Updates engine limit values (N1, N2, EGT, oil temperature).
     * @param simDeltaTime The number of milliseconds passed in sim time.
     */
    updateEngineLimits(simDeltaTime) {
        // const toTimeLimit = (this.isEngineOut.get()) ? BoeingFadec.TO_TIME_LIMIT_SINGLE : BoeingFadec.TO_TIME_LIMIT_MULTI;
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            const simVars = BoeingFadec.ENGINE_SIMVARS[n];
            const engineState = this.engineStates[n];
            const boeingEngineState = this.boeingEngineStates[n];
            const mode = this.lastModes[n - 1];
            const limits = this.engineLimits[n];
            if (simVars === undefined || engineState === undefined || boeingEngineState === undefined || limits === undefined) {
                return;
            }
            // const isToThrust = mode !== null
            //   ? (mode.name === BoeingFadecModes.TO || mode.name === BoeingFadecModes.APR) && engineState.throttleLeverPos >= BoeingFadec.TO_DETENT
            //   : false;
            // if (isToThrust) {
            //   boeingEngineState.toThrustTime = Math.min(BoeingFadec.TO_TIME_LIMIT_SINGLE, boeingEngineState.toThrustTime + dt);
            // } else {
            //   boeingEngineState.toThrustTime = Math.max(0, boeingEngineState.toThrustTime - dt);
            // }
            const n1RedLine = this.engineData.RED_LINE_N1;
            const n1AmberLine = this.getAmberLineMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
            const n2AmberLine = BoeingFadec.N2_AMBER_TO;
            const egtStartLimitLine = this.engineData.START_LIMIT_EGT;
            const egtAmberLine = this.engineData.CONTINUOUS_LIMIT_EGT;
            const egtRedLine = this.engineData.RED_LINE_EGT;
            // let n1RedLine: number;
            // let n2AmberLine: number;
            // let ittRunRedLine: number;
            // if (!isToThrust || boeingEngineState.toThrustTime > toTimeLimit) {
            //   n1RedLine = BoeingFadec.N1_RED;
            //   n2AmberLine = BoeingFadec.N2_AMBER;
            //   ittRunRedLine = BoeingFadec.ITT_RED_RUN;
            // } else {
            //   n1RedLine = BoeingFadec.N1_RED_TO;
            //   n2AmberLine = BoeingFadec.N2_AMBER_TO;
            //   ittRunRedLine = BoeingFadec.ITT_RED_RUN_TO;
            // }
            if (boeingEngineState.n2 >= n2AmberLine) {
                boeingEngineState.n2AmberTime = Math.min(BoeingFadec.N2_AMBER_TIME_LIMIT, boeingEngineState.n2AmberTime + simDeltaTime);
            }
            else {
                boeingEngineState.n2AmberTime = Math.max(0, boeingEngineState.n2AmberTime - simDeltaTime);
            }
            let n2RedLine;
            if (boeingEngineState.n2AmberTime > BoeingFadec.N2_AMBER_TIME_LIMIT) {
                n2RedLine = n2AmberLine;
            }
            else {
                n2RedLine = this.engineData.RED_LINE_N2;
            }
            const oilTemp = SimVar.GetSimVarValue(simVars.oilTemp, SimVarValueType.Celsius);
            boeingEngineState.oilTempLowHysteresis = oilTemp >= BoeingFadec.OIL_TEMP_LOW_RED_CLB
                || (boeingEngineState.oilTempLowHysteresis && oilTemp >= BoeingFadec.OIL_TEMP_LOW_RED_IDLE);
            let oilTempLowRedLine;
            if (boeingEngineState.startState === BoeingEngineStartState.RUNNING) {
                if (mode === null || Math.abs(engineState.throttleLeverPos) < 0.01) {
                    oilTempLowRedLine = BoeingFadec.OIL_TEMP_LOW_RED;
                }
                else {
                    if (!boeingEngineState.oilTempLowHysteresis
                        && (mode.name === BoeingFadecModes.NORMAL || mode.name === BoeingFadecModes.GROUND)
                        && engineState.throttleLeverPos >= BoeingFadec.TO_DETENT - 0.05) {
                        oilTempLowRedLine = BoeingFadec.OIL_TEMP_LOW_RED_CLB;
                    }
                    else {
                        oilTempLowRedLine = BoeingFadec.OIL_TEMP_LOW_RED_IDLE;
                    }
                }
            }
            else {
                oilTempLowRedLine = BoeingFadec.OIL_TEMP_LOW_RED;
            }
            limits.n1RedLine.set(n1RedLine);
            limits.n1AmberLine.set(n1AmberLine);
            limits.n2RedLine.set(n2RedLine);
            limits.n2AmberLine.set(n2AmberLine);
            limits.egtStartLimitLine.set(egtStartLimitLine);
            limits.egtAmberLine.set(egtAmberLine);
            limits.egtRedLine.set(egtRedLine);
            limits.oilTempLowRedLine.set(oilTempLowRedLine);
        }
    }
    /**
     * Publishes a virtual throttle lever position to a SimVar.
     * @param simVar The name of the SimVar to publish to.
     * @param position The position to publish, in the range -1 to 1.
     */
    static publishThrottleLeverPosSimVar(simVar, position) {
        SimVar.SetSimVarValue(simVar, SimVarValueType.Percent, position * 100);
    }
    /**
     * Looks up the max N1 value from a table based on the current outside (static) air temperature and pressure altitude at
     * the airplane's position.
     * @param isEngineOut Whether an engine is out.
     * @param alt The Pressure Altitude AMSL in FT.
     * @param temp The Total Air Temp in C.
     * @returns The max N1 value, in percent, defined by the specified table for the current outside air temperature and
     * pressure altitude at the airplane's position.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    lookupAirborneMaxN1(isEngineOut = false, alt, temp) {
        // ALLOW 5% boost for Max N1
        return MathUtils.round(1.05 * this.engineData.getMaxConN1(alt, temp), 0.1);
    }
    /**
     * Looks up the max N1 value from a table based on the current outside (static) air temperature and pressure altitude at
     * the airplane's position.
     * @param isEngineOut Whether an engine is out.
     * @param alt The Pressure Altitude AMSL in FT.
     * @param temp The Total Air Temp in C.
     * @returns The max N1 value, in percent, defined by the specified table for the current outside air temperature and
     * pressure altitude at the airplane's position.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    lookupGroundedMaxN1(isEngineOut = false, alt, temp) {
        // ALLOW 5% boost for Max N1
        return MathUtils.round(1.05 * this.engineData.getToMaxN1(alt, temp), 0.1);
    }
    /**
     * Calculates the CLB or CRU target N1 setting.
     * @param maxN1 The current maximum CLB or CRU N1 target, in percent.
     * @param throttleLeverPos The current throttle lever position.
     * @param idleN1 The current idle N1.
     * @param aiN1 The amount of A/I N1 correction.
     * @returns The CLB or CRU target N1 setting, in percent.
     */
    static calcTargetN1(maxN1, throttleLeverPos, idleN1, aiN1) {
        const throttlePercentage = MathUtils.clamp(throttleLeverPos, 0, 1);
        return MathUtils.round(idleN1 + (throttlePercentage * (maxN1 - idleN1)) + aiN1, 0.1);
    }
    /**
     * Adjusts an engine throttle setting to target a specific N1 setting.
     * @param targetN1 The target N1 value, in percent.
     * @param index The engine index.
     * @param throttleLeverPos The throttle lever position.
     * @returns The adjusted engine throttle setting.
     */
    adjustThrottleForN1(targetN1, index, throttleLeverPos) {
        if (BoeingFadec.ENGINE_SIMVARS[index] === undefined) {
            return -1;
        }
        const targetUncorrectedN1 = this.performanceMath.uncorrectN1(this.ambientAirTemp.get(), this.mach.get(), targetN1);
        // The sim is hardcoded to command 100 N1 uncorrected when throttle is 100
        // (We can go over that by requesting throttle over 100)
        const simFullThrottleN1Uncorrected = 100;
        const rawThrottleTarget = MathUtils.lerp(targetUncorrectedN1, this.engineData.IDLE_N1, simFullThrottleN1Uncorrected, 0, 1);
        const throttlePct = MathUtils.clamp(rawThrottleTarget, 0, 2);
        // Leave here for FADEC debugging
        // if (index === 1) {
        //   SimVar.SetSimVarValue('L:wt-update-gauge-n1-tgt-corrected', SimVarValueType.Percent, targetN1);
        //   SimVar.SetSimVarValue('L:wt-update-gauge-n1-tgt-uncorrected', SimVarValueType.Percent, targetUncorrectedN1);
        //   SimVar.SetSimVarValue('L:wt-update-gauge-n1-commanded-simvar', SimVarValueType.Percent, SimVar.GetSimVarValue('TURB ENG THROTTLE COMMANDED N1:1', SimVarValueType.Percent));
        //   SimVar.SetSimVarValue('L:wt-update-gauge-n1-corrected-actual-simvar', SimVarValueType.Percent, SimVar.GetSimVarValue('TURB ENG CORRECTED N1:1', SimVarValueType.Percent));
        //   SimVar.SetSimVarValue('L:wt-update-gauge-n1-actual-simvar', SimVarValueType.Percent, SimVar.GetSimVarValue('TURB ENG N1:1', SimVarValueType.Percent));
        //   SimVar.SetSimVarValue('L:wt-update-gauge-idleN1Corrected', SimVarValueType.Percent, this.idleN1[1]?.get());
        //   SimVar.SetSimVarValue('L:wt-update-gauge-throttleRawPct', SimVarValueType.Percent, rawThrottleTarget);
        //   SimVar.SetSimVarValue('L:wt-update-gauge-throttlePct', SimVarValueType.Percent, throttlePct);
        //   SimVar.SetSimVarValue('L:wt-update-gauge-throttle-lever-position-simvar', SimVarValueType.Percent, SimVar.GetSimVarValue('GENERAL ENG THROTTLE LEVER POSITION:1', SimVarValueType.Percent));
        //   SimVar.SetSimVarValue('L:wt-update-gauge-throttleLeverPos', SimVarValueType.Percent, throttleLeverPos);
        // }
        return throttlePct;
    }
    /**
     * Gets the animation position value for a given throttle lever position.
     * @param throttleLeverPos A throttle lever position, in the range -1 to 1.
     * @returns The animation position value for the specified throttle lever position.
     */
    static getThrottleAnimPos(throttleLeverPos) {
        return MathUtils.clamp(throttleLeverPos * (throttleLeverPos < 0 ? 2 : 1), 0, 1);
    }
    /**
     * Gets an object containing SimVar names related to an engine.
     * @param index The index of the engine.
     * @param fuelValveIndexOffset The offset for the fuel system valve switch sim var.
     * @returns An object containing SimVar names related to the specified engine.
     */
    static getEngineSimVars(index, fuelValveIndexOffset = 0) {
        return {
            engFuelSwitch: `FUELSYSTEM VALVE SWITCH:${index + fuelValveIndexOffset}`,
            engStarterSwitch: `GENERAL ENG STARTER:${index}`,
            egt: `ENG EXHAUST GAS TEMPERATURE:${index}`,
            lowIdleN1: `TURB ENG LOW IDLE:${index}`,
            n2: `TURB ENG CORRECTED N2:${index}`,
            oilTemp: `ENG OIL TEMPERATURE:${index}`,
            antiIce: `ENG ANTI ICE:${index}`,
            ignitionSwitch: `TURB ENG IGNITION SWITCH EX1:${index}`,
            combustion: `GENERAL ENG COMBUSTION:${index}`,
            inletTemp: `TURB ENG INLET TEMPERATURE:${index}`,
            setIgnitionSwitchKey: `TURBINE_IGNITION_SWITCH_SET${index}`
        };
    }
    /**
     * Checks if an engine is at idle thrust
     * @param index Engine index 1..n
     * @returns true if thrust is at idle
     */
    isThrustAtIdle(index) {
        var _a, _b;
        return this.engineStates[index].n1Corrected <= ((_b = (_a = this.idleN1[index]) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : this.engineData.IDLE_N1) + 2;
    }
    /**
     * Checks if an engine is at a specified corrected N1
     * @param index Engine index 1..n
     * @param thrustCn1 Correct N1% target
     * @returns true if thrust is at target
     */
    isThrustAtTarget(index, thrustCn1) {
        return Math.abs(this.engineStates[index].n1Corrected - thrustCn1) < 1;
    }
    /**
     * Gets the N1 value from the performance tables based on selected Thrust Reference Mode.
     * TODO Use Derate stuff?
     * @param mode The selected thrust mode (null value returns TO N1).
     * @returns the Max N1 Value.
     */
    getN1FromThrustReferenceMode(mode) {
        var _a, _b, _c;
        switch (mode) {
            case TakeoffThrustMode.TO:
                return this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.TO1:
                return this.engineData.getTo1N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.TO2:
                return this.engineData.getTo2N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.DTO:
                return this.engineData.getToMaxN1(this.pressureAlt.get(), (_a = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _a !== void 0 ? _a : this.totalAirTemp.get());
            case TakeoffThrustMode.DTO1:
                return this.engineData.getTo1N1(this.pressureAlt.get(), (_b = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _b !== void 0 ? _b : this.totalAirTemp.get());
            case TakeoffThrustMode.DTO2:
                return this.engineData.getTo2N1(this.pressureAlt.get(), (_c = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _c !== void 0 ? _c : this.totalAirTemp.get());
            case ClimbThrustMode.CLB:
                return this.engineData.getClbMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case ClimbThrustMode.CLB1:
                return this.engineData.getClb1N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case ClimbThrustMode.CLB2:
                return this.engineData.getClb2N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CRZ:
                return this.engineData.getCruiseMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CON:
                return this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.GA:
                return this.engineData.getGaMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            default:
                return this.isOnGround.get() ? this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get())
                    : this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
        }
    }
    /**
     * Gets the Max N1 (amber line) value from the performance tables based on selected Thrust Reference Mode.
     * Ignore Derates.
     * @param mode The selected thrust mode (null value returns TO N1).
     * @returns the Max N1 amber line Value.
     */
    getAmberLineMaxN1FromThrustReferenceMode(mode) {
        switch (mode) {
            case TakeoffThrustMode.TO:
            case TakeoffThrustMode.TO1:
            case TakeoffThrustMode.TO2:
            case TakeoffThrustMode.DTO:
            case TakeoffThrustMode.DTO1:
            case TakeoffThrustMode.DTO2:
                return this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case ClimbThrustMode.CLB:
            case ClimbThrustMode.CLB1:
            case ClimbThrustMode.CLB2:
                return this.engineData.getClbMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CRZ:
                return this.engineData.getCruiseMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CON:
                return this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.GA:
                return this.engineData.getGaMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            default:
                return this.isOnGround.get()
                    ? this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get())
                    : this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
        }
    }
    /**
     * Sets the reference N1 Value for an engine.
     * @param engineIndex The engine index.
     * @param n1 The N1 value.
     */
    setReferenceN1(engineIndex, n1) {
        var _a, _b;
        (_a = this.referenceN1Values[engineIndex]) === null || _a === void 0 ? void 0 : _a.set(n1);
        if (this.calculateTpr) {
            (_b = this.referenceTprValues[engineIndex]) === null || _b === void 0 ? void 0 : _b.set(this.engineData.getTprFromN1(n1, this.totalAirTemp.get(), this.pressureAlt.get()));
        }
    }
    /**
     * Sets the target N1 Value for an engine.
     * @param engineIndex The engine index.
     * @param n1 The N1 value.
     */
    setTargetN1(engineIndex, n1) {
        var _a, _b;
        (_a = this.targetN1Values[engineIndex]) === null || _a === void 0 ? void 0 : _a.set(n1);
        if (this.calculateTpr) {
            (_b = this.targetTprValues[engineIndex]) === null || _b === void 0 ? void 0 : _b.set(this.engineData.getTprFromN1(n1, this.totalAirTemp.get(), this.pressureAlt.get()));
        }
    }
}
BoeingFadec.UPDATE_FREQ = 60; // hertz
BoeingFadec.THROTTLE_LEVER_EPSILON = 1 / 16384;
BoeingFadec.TO_DETENT = 0.95;
BoeingFadec.TR_LOCKOUT_DETENT = -0.025;
BoeingFadec.TR_LEVER_RANGE = BoeingFadec.TR_LOCKOUT_DETENT + 1;
BoeingFadec.REVERSE_IDLE_THROTTLE = -0.001; // engine throttle setting for reverse idle.
BoeingFadec.REVERSE_IDLE_THROTTLE_RANGE = BoeingFadec.REVERSE_IDLE_THROTTLE + 1;
/** The amount of time, in milliseconds, rescue ignition is kept active after combustion has been successfully restarted. */
BoeingFadec.RESCUE_IGNITION_HYSTERESIS = 10000;
/** The maximum time allowed in the N2 amber range, in milliseconds. */
BoeingFadec.N2_AMBER_TIME_LIMIT = 20000;
/** The amber-line N2 value, as a percent, for takeoff thrust. */
BoeingFadec.N2_AMBER_TO = 98.63;
/**
 * The low red-line oil temperature value, in degrees Celsius, when the engine is not running or when the engine is
 * running with the throttles at idle.
 */
BoeingFadec.OIL_TEMP_LOW_RED = -40;
/** The low red-line oil temperature value, in degrees Celsius, when the engine is running with the throttles above idle. */
BoeingFadec.OIL_TEMP_LOW_RED_IDLE = 5;
/**
 * The low red-line oil temperature value, in degrees Celsius, when the engine is running with the throttles at or
 * above CLB thrust.
 */
BoeingFadec.OIL_TEMP_LOW_RED_CLB = 15;
/** The low amber-line oil temperature value, in degrees Celsius. */
BoeingFadec.OIL_TEMP_LOW_AMBER = 15;
/** The high amber-line oil temperature value, in degrees Celsius. */
BoeingFadec.OIL_TEMP_HIGH_AMBER = 138;
BoeingFadec.ENGINE_SIMVARS = {};

/**
 * A Boeing autothrottle system.
 */
class BoeingAutothrottle {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param fadec The FADEC.
     * @param aoaDataProvider A provider of angle of attack data.
     * @param speedProvider A provider of speed data for the airframe.
     * @param performanceProvider A provider of vertical path performance data.
     * @param thrustManager The Thrust Mode Manager.
     * @param powerSimvar The simvar to use to retreive the power status of the autothrottle.
     * @param apValues The autopilot values
     * @param options Aircraft-specific options for the autothrottle.
     */
    constructor(bus, fadec, aoaDataProvider, speedProvider, performanceProvider, thrustManager, powerSimvar, apValues, options) {
        this.bus = bus;
        this.fadec = fadec;
        this.aoaDataProvider = aoaDataProvider;
        this.speedProvider = speedProvider;
        this.performanceProvider = performanceProvider;
        this.thrustManager = thrustManager;
        this.powerSimvar = powerSimvar;
        this.apValues = apValues;
        this.publisher = this.bus.getPublisher();
        this.isPowered = false;
        this.isAvionicsPowered = false;
        this.simTime = ConsumerSubject.create(null, 0);
        this.fcuArmSwitchState = ConsumerSubject.create(null, false);
        this.status = Subject.create(BoeingAutothrottleStatus.Off);
        this.armedMode = Subject.create(BoeingAutothrottleModes.NONE);
        this.activeMode = Subject.create(BoeingAutothrottleModes.NONE);
        this.thrModeLight = Subject.create(false);
        this.spdModeLight = this.activeMode.map((v) => v === BoeingAutothrottleModes.SPD);
        this.servosActiveCommand = Subject.create(false);
        this.canServoActivate = {};
        this.overrideTime = Subject.create(0);
        this.servoOverride = MappedSubject.create(([overrideTime, simTime]) => overrideTime > 0 && simTime < overrideTime + BoeingAutothrottle.SERVO_OVERRIDE_TIME, this.overrideTime, this.simTime);
        this.servoActive = {};
        this.underspeedProtActiveCommand = Subject.create(false);
        this.canUnderspeedProtActivate = Subject.create(false);
        this.underspeedProtActive = MappedSubject.create(([command, canActivate]) => command && canActivate, this.underspeedProtActiveCommand, this.canUnderspeedProtActivate);
        this.holdDuration = 0;
        this.isRetardPrimed = false;
        this.retardActivateDuration = 0;
        this.isRetardFailed = Subject.create(false);
        this.landingTimeFilter = new ExpSmoother(200 / Math.LN2);
        this.lastLandingFilterTime = 0;
        this.autoGroundDisengagePrimedDuration = 0;
        this.isOnGround = ConsumerSubject.create(null, false);
        this.radarAlt = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.pressureAlt = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        this.totalAirTemp = Subject.create(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);
        /** Airplane gross weight in lbs */
        this.grossWeight = ConsumerValue.create(null, 0);
        this.ambientPressure = ConsumerSubject.create(null, 29.92);
        /** Ambient temp in °C */
        this.ambientTemp = ConsumerSubject.create(null, 15);
        /** ISA temp in °C */
        this.isaTemp = ConsumerSubject.create(null, 15);
        /** Delta from ISA temp in °C */
        this.isaDelta = MappedSubject.create(([oat, isaTemp]) => oat - isaTemp, this.ambientTemp, this.isaTemp);
        this.enginesAvailable = ConsumerValue.create(null, 0);
        this.indicatedAlt = ConsumerValue.create(null, 0);
        this.selectedAlt = ConsumerValue.create(null, 0);
        this.gs = ConsumerValue.create(null, 0);
        this.ias = ConsumerSubject.create(null, 0);
        this.mach = ConsumerValue.create(null, 0);
        this.apVerticalMode = Subject.create(APVerticalModes.NONE);
        this.lastApVerticalMode = APVerticalModes.NONE;
        this.fmsOperatingPhase = ConsumerValue.create(null, FmsOperatingPhase.PREFLIGHT);
        this.isApVerticalModeFlc = MappedSubject.create((([apVerticalMode]) => {
            return apVerticalMode === APVerticalModes.FLC;
        }), this.apVerticalMode);
        this.isApVerticalModeTo = MappedSubject.create((([apVerticalMode]) => {
            return apVerticalMode === APVerticalModes.TO;
        }), this.apVerticalMode);
        this.isApVerticalModeGa = MappedSubject.create((([apVerticalMode]) => {
            return apVerticalMode === APVerticalModes.GA;
        }), this.apVerticalMode);
        this.thrustMode = MappedSubject.create((([activeThrustMode]) => {
            switch (activeThrustMode) {
                case ClimbThrustMode.CLB:
                case ClimbThrustMode.CLB1:
                case ClimbThrustMode.CLB2:
                    return 'climb';
                case TakeoffThrustMode.DTO:
                case TakeoffThrustMode.DTO1:
                case TakeoffThrustMode.DTO2:
                case TakeoffThrustMode.TO:
                case TakeoffThrustMode.TO1:
                case TakeoffThrustMode.TO2:
                    return 'takeoff';
                case AirborneThrustMode.CON:
                    return 'con';
                case AirborneThrustMode.CRZ:
                    return 'crz';
                case AirborneThrustMode.GA:
                    return 'ga';
            }
        }), this.thrustManager.activeThrustMode);
        this.atIasTarget = ConsumerSubject.create(null, 0);
        this.atMachTarget = ConsumerSubject.create(null, 0);
        this.atTargetIsMach = ConsumerSubject.create(null, false);
        /** The autothrottle target speed in Kcas, converted from mach if the target is a mach number */
        this.atTargetCas = MappedSubject.create(([casTarget, machTarget, isMach, ambientPressure]) => isMach
            ? UnitType.KNOT.convertFrom(AeroMath.machToCas(machTarget, UnitType.HPA.convertFrom(ambientPressure, UnitType.IN_HG)), UnitType.MPS)
            : casTarget, this.atIasTarget, this.atMachTarget, this.atTargetIsMach, this.ambientPressure, this.ambientPressure);
        this.vnavPathSpeedMin = ConsumerSubject.create(null, 0);
        this.belowSpeedTarget = MappedSubject.create(([targetCas, ias], wasBelowSpeedTarget) => {
            return targetCas > 0 && ias < (targetCas - (wasBelowSpeedTarget ? 0 : BoeingAutothrottle.TARGET_SPEED_HYSTERESIS));
        }, this.atTargetCas, this.ias.map((ias) => Math.round(ias)));
        this.fadecMode = {};
        this.fadecClbN1 = {};
        this.fadecTgtN1 = {};
        this.engineN1 = {};
        this.engineOut = ConsumerValue.create(null, false);
        this.gearNosePosition = ConsumerSubject.create(null, 0);
        this.gearLeftPosition = ConsumerSubject.create(null, 0);
        this.gearRightPosition = ConsumerSubject.create(null, 0);
        /** throttle lever position in range -1 to +1 */
        this.throttleLeverPosition = {};
        this.boeingVNavMode = ConsumerSubject.create(null, BoeingVNavModes.NONE);
        /** Index of the current flap position used to calculate the flap speed limit */
        this.flapIndex = ConsumerSubject.create(null, 0);
        /* flap position as shown in flight deck, interpolated between positions */
        this.flapPosition = ConsumerSubject.create(null, 0);
        /** Vfe in kcas, or -1 if none */
        this.flapSpeedLimit = ConsumerSubject.create(null, -1);
        this.flapsInLandingPos = this.flapPosition.map((p) => p >= 20);
        this.airframeMaxIas = Subject.create(Infinity);
        this.airframeMaxMach = Infinity;
        this.configurationIas = MappedSubject.create(([vfe, gearNose, gearLeft, gearRight]) => {
            const maxGear = Math.max(gearNose, gearLeft, gearRight);
            const vle = maxGear > 0 ? this.speedProvider.getGearLimitSpeed() : Infinity;
            return Math.min(vfe > 0 ? vfe : Infinity, vle);
        }, this.flapSpeedLimit, this.gearNosePosition, this.gearLeftPosition, this.gearRightPosition);
        this.activeTargetIas = MappedSubject.create(([mode, targetSpeedIsMach, iasTarget]) => mode === BoeingAutothrottleModes.SPD && !targetSpeedIsMach ? iasTarget : -1, this.activeMode, this.atTargetIsMach, this.atIasTarget);
        this.activeTargetMach = MappedSubject.create(([mode, targetSpeedIsMach, machTarget]) => mode === BoeingAutothrottleModes.SPD && targetSpeedIsMach ? machTarget : -1, this.activeMode, this.atTargetIsMach, this.atMachTarget);
        this.spoilersDeployed = Subject.create(false);
        this.maxThrottlePos = MappedSubject.create(
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        ([spoilers, mode]) => {
            if (mode === BoeingAutothrottleModes.TO) {
                return 1;
            }
            else {
                // return spoilers ? HydraulicSpoilerSystem.AUTOSTOW_MAX_THROTTLE - 0.025 : 0.949;
                return 1;
            }
        }, this.spoilersDeployed, this.activeMode);
        this.iasLookahead = new Lookahead(BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_LOOKAHEAD, BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_INPUT_TAU, BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_TREND_TAU);
        this.isLandingPhaseArmed = false;
        this.isLandingPhase = false;
        this.onGroundTime = 0;
        this.landingPhaseTime = 0;
        this.fmaData = ObjectSubject.create({
            status: BoeingAutothrottleStatus.Off,
            armedMode: BoeingAutothrottleModes.NONE,
            activeMode: BoeingAutothrottleModes.NONE,
            isActiveModeFail: false,
            targetIas: null,
            targetMach: null
        });
        this.needPublishFmaData = false;
        /** TODO */
        this.forceDisconnectData = {};
        this.holdData = {};
        this.isAlive = true;
        this.isInit = false;
        this.speedTargetChanged = MappedSubject.create(this.atIasTarget, this.atMachTarget, this.atTargetIsMach);
        this.speedBelowLowSpeedLimit1SecondTimer = new DebounceTimer();
        this.speedBelowLowSpeedLimit1Second = false;
        this.options = {
            autoActivateOnArm: (options === null || options === void 0 ? void 0 : options.autoActivateOnArm) ? true : false,
        };
        this.engineData = fadec.engineData;
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            const canServoActivate = Subject.create(false);
            this.canServoActivate[n] = canServoActivate;
            const servoActive = MappedSubject.create(([command, canActivate, override]) => command && canActivate && !override, this.servosActiveCommand, canServoActivate, this.servoOverride);
            this.servoActive[n] = servoActive;
            this.fadecMode[n] = ConsumerSubject.create(null, BoeingFadecModes.STOP);
            this.forceDisconnectData[n] = {
                servoActive: servoActive,
                lastInputTime: undefined,
                lastSetInputPos: undefined,
                cumulativeDisplacement: 0,
            };
            this.holdData[n] = {
                firstManualInput: undefined,
                leversActive: true,
            };
        }
        this.isAnyFadecModeUnsupported = MappedSubject.create(modes => {
            for (let i = 0; i < modes.length; i++) {
                if (BoeingAutothrottle.UNSUPPORTED_FADEC_MODES.includes(modes[i])) {
                    return true;
                }
            }
            return false;
        }, ...Object.values(this.fadecMode));
        this.isAnyFadecModeReverse = MappedSubject.create(modes => {
            for (let i = 0; i < modes.length; i++) {
                if (modes[i] === BoeingFadecModes.TR) {
                    return true;
                }
            }
            return false;
        }, ...Object.values(this.fadecMode));
        this.autothrottle = new JetAutothrottle(bus, 1, Array.from({ length: this.engineData.engineCount }, (_, i) => ({
            index: i + 1,
            isVirtual: true,
            idlePosition: 0,
            maxThrustPosition: 1,
        })), BoeingAutothrottle.OPTIONS, fadec.throttleLeverManager);
        // TODO Register CAS Errors if any
        // this.casManager.register...
        // this.casAlertTransporters.push(
        //   CasAlertTransporter.create(this.bus, BoeingAutothrottleCrewAlertIDs.AtRetardFail, AnnunciationType.Caution).pause()
        //     .bind(this.isRetardFailed, failed => failed),
        //   CasAlertTransporter.create(this.bus, BoeingAutothrottleCrewAlertIDs.AtHoldFail, AnnunciationType.Warning).pause()
        //     .bind(this.activeMode, mode => mode === BoeingAutothrottleModes.HOLD_FAIL)
        // );
        KeyEventManager.getManager(bus).then(manager => {
            this.keyEventManager = manager;
            manager.interceptKey('AUTO_THROTTLE_ARM', false);
            manager.interceptKey('AUTO_THROTTLE_DISCONNECT', false);
            bus.getSubscriber().on('key_intercept').handle(data => {
                switch (data.key) {
                    case 'AUTO_THROTTLE_ARM':
                        SimVar.SetSimVarValue('L:AS01B_AUTO_THROTTLE_ARM_STATE', SimVarValueType.Bool, !this.fcuArmSwitchState.get());
                        break;
                    case 'AUTO_THROTTLE_DISCONNECT':
                        if (this.isAvionicsPowered) {
                            // Pressing disconnect button while the autothrottle is active should put the autothrottle into the
                            // disconnect state. Pressing the button while the autothrottle is disconnected should cancel the
                            // disconnect state. Pressing the button under any other conditions should do nothing.
                            switch (this.status.get()) {
                                case BoeingAutothrottleStatus.On:
                                    this.deactivate(true);
                                    break;
                                case BoeingAutothrottleStatus.Disconnected:
                                    this.deactivate(false);
                                    break;
                            }
                        }
                        break;
                }
            });
        });
    }
    /**
     * Initializes this autothrottle.
     * @throws Error if this autothrottle has been destroyed.
     */
    init() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!this.isAlive) {
            throw new Error('FmsSpeedManager: cannot initialize a dead manager');
        }
        if (this.isInit) {
            return;
        }
        this.airframeMaxMach = this.speedProvider.getMmo();
        // Publish status.
        this.status.sub(status => {
            this.publisher.pub('boeing_at_status', status, true, true);
            this.fmaData.set('status', status);
            SimVar.SetSimVarValue('L:WT_Boeing_Autothrottle_Status', SimVarValueType.Number, BoeingAutothrottle.STATUS_SIMVAR_ENUM_MAP[status]);
        }, true);
        // publish SPD and THR status for 747
        this.spdModeLight.sub((v) => SimVar.SetSimVarValue('L:AP_SPD_ACTIVE', SimVarValueType.Bool, v), true);
        this.thrModeLight.sub((v) => SimVar.SetSimVarValue('L:AP_THR_ACTIVE', SimVarValueType.Bool, v), true);
        this.activeMode.sub((v) => v !== BoeingAutothrottleModes.CLIMB && this.thrModeLight.set(false));
        // Initialize mode topic.
        this.publisher.pub('boeing_at_mode_active', this.activeMode.get(), true, true);
        // Respond to armed mode changes.
        this.armedMode.sub(mode => {
            this.publisher.pub('boeing_at_mode_armed', mode, true, true);
            this.fmaData.set('armedMode', mode);
        });
        // Respond to active mode changes.
        this.activeMode.sub(mode => {
            this.publisher.pub('boeing_at_mode_active', mode, true, true);
            this.onActiveModeChanged(mode);
        });
        // Respond to maximum throttle position changes.
        this.maxThrottlePos.sub(pos => { this.autothrottle.setMaxThrottlePos(pos); }, true);
        // Because we start in an power-off state, initialize the failed topic to true.
        // this.publisher.pub('longitude_at_failed', true, true, true);
        // Resume CAS alert transporters.
        // this.casAlertTransporters.forEach(transporter => { transporter.resume(); });
        // Respond to servo activation changes.
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            (_a = this.servoActive[n]) === null || _a === void 0 ? void 0 : _a.sub((active) => this.autothrottle.setServoActive(n, active), true);
        }
        // Respond to underspeed protection activation changes.
        this.underspeedProtActive.sub(active => { this.autothrottle.setUnderspeedProtActive(active); }, true);
        // Set up data subs.
        // TODO: Fix for AvionicsStatusEvents
        // const sub = this.bus.getSubscriber<
        //   ClockEvents & AdcEvents & AdcSystemEvents & RadarAltimeterSystemEvents & APEvents & FmaDataEvents
        //   & EngineEvents & ControlSurfacesEvents & BoeingFadecEvents & VirtualThrottleLeverEvents & HEvent
        //   & AvionicsStatusEvents
        // >();
        const sub = this.bus.getSubscriber();
        // this.avionicsGlobalPowerSub = sub.on('avionics_global_power').handle(event => {
        //   if (event.current === true) {
        //     this.isAvionicsPowered = true;
        //   } else {
        //     this.isAvionicsPowered = false;
        //     this.deactivate(false);
        //     this.reset();
        //   }
        // });
        this.fcuArmSwitchState.setConsumer(sub.on('ap_boeing_autothrottle_armed'));
        this.isAvionicsPowered = true;
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        const radarAltSub = this.radarAltSub = sub.on('ra_radio_alt_1').handle(alt => { this.radarAlt.set(alt); }, true);
        this.radarAltimeterStateSub = sub.on('ra_state_1').handle(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                radarAltSub.resume(true);
            }
            else {
                radarAltSub.pause();
                this.radarAlt.set(NaN);
            }
        });
        const pressureAltSub = this.pressureAltSub = sub.on('adc_pressure_alt_1').handle(alt => { this.pressureAlt.set(Math.round(alt)); }, true);
        this.adcStateSub = sub.on('adc_state_1').handle(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                pressureAltSub.resume(true);
            }
            else {
                pressureAltSub.pause();
                this.pressureAlt.set(NaN);
            }
        });
        const tatSub = this.tatSub = sub.on('ram_air_temp_c').handle(tat => { this.totalAirTemp.set(Math.round(tat)); }, true);
        this.adcStateSub = sub.on('adc_state_1').handle(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                tatSub.resume(true);
            }
            else {
                tatSub.pause();
                this.totalAirTemp.set(NaN);
            }
        });
        // We use ADC1 data because the autopilot currently always uses ADC1.
        this.indicatedAlt.setConsumer(sub.on('adc_indicated_alt_1'));
        this.selectedAlt.setConsumer(sub.on('ap_altitude_selected_3'));
        this.ambientPressure.setConsumer(sub.on('ambient_pressure_inhg').withPrecision(2));
        this.ambientTemp.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        this.isaTemp.setConsumer(sub.on('isa_temp_c').withPrecision(0));
        this.grossWeight.setConsumer(sub.on('total_weight').withPrecision(-3));
        this.enginesAvailable.setConsumer(sub.on('fadec_available_engines'));
        this.gs.setConsumer(sub.on('ground_speed'));
        this.ias.setConsumer(sub.on('adc_ias_1'));
        this.mach.setConsumer(sub.on('adc_mach_number_1'));
        this.fmsOperatingPhase.setConsumer(sub.on('fms_operating_phase'));
        this.atIasTarget.setConsumer(sub.on('fms_speed_autopilot_target_ias'));
        this.atMachTarget.setConsumer(sub.on('fms_speed_autopilot_target_mach'));
        this.atTargetIsMach.setConsumer(sub.on('fms_speed_autopilot_target_is_mach'));
        this.vnavPathSpeedMin.setConsumer(sub.on('vnav_boeing_band_speed_min'));
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            (_b = this.fadecMode[n]) === null || _b === void 0 ? void 0 : _b.setConsumer(sub.on(`fadec_mode_${n}`));
            (_c = this.fadecClbN1[n]) === null || _c === void 0 ? void 0 : _c.setConsumer(sub.on(`fadec_clb_n1_${n}`));
            (_d = this.fadecTgtN1[n]) === null || _d === void 0 ? void 0 : _d.setConsumer(sub.on(`fadec_target_n1_${n}`));
            (_e = this.engineN1[n]) === null || _e === void 0 ? void 0 : _e.setConsumer(sub.on(`n1_${n}`));
            (_f = this.throttleLeverPosition[n]) === null || _f === void 0 ? void 0 : _f.setConsumer(sub.on(`v_throttle_lever_pos_${n}`));
        }
        this.engineOut.setConsumer(sub.on('fadec_engine_out'));
        this.flapIndex.setConsumer(sub.on('flap_computer_limit_index'));
        this.flapPosition.setConsumer(sub.on('flap_computer_interpolated_position'));
        this.flapSpeedLimit.setConsumer(sub.on('flap_computer_limit_speed'));
        this.gearNosePosition.setConsumer(sub.on('gear_position_0').withPrecision(1));
        this.gearLeftPosition.setConsumer(sub.on('gear_position_1').withPrecision(1));
        this.gearRightPosition.setConsumer(sub.on('gear_position_2').withPrecision(1));
        // Update servo activation criteria.
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.fadecMode[n].pipe(this.canServoActivate[n], (mode) => !BoeingAutothrottle.UNSUPPORTED_FADEC_MODES.includes(mode));
        }
        // Set speed targets.
        this.speedTargetChanged.sub(this.onSpeedTargetChanged.bind(this));
        // Publish active speed targets.
        this.activeTargetIas.sub(ias => {
            this.publisher.pub('boeing_at_target_ias', ias, true, true);
            this.fmaData.set('targetIas', ias < 0 ? null : ias);
        }, true);
        this.activeTargetMach.sub(mach => {
            this.publisher.pub('boeing_at_target_mach', mach, true, true);
            this.fmaData.set('targetMach', mach < 0 ? null : mach);
        }, true);
        // Schedule FMA data publish.
        this.fmaData.sub(() => { this.needPublishFmaData = true; });
        this.needPublishFmaData = true;
        // Set up throttle key event handlers.
        this.fadec.onThrottleLeverKeyEvent = this.handleThrottleLeverInput.bind(this);
        this.hEventSub = sub.on('hEvent').handle(hEvent => {
            // Inc/Dec H events are sent via modelbehaviors to notify us when a throttle INC/DEC key event has been
            // intercepted and turned into a SET event.
            switch (hEvent) {
                case 'WT_B78_Throttle_1_Inc':
                case 'WT_B78_Throttle_1_Dec':
                    this.handleThrottleLeverIncDec(1);
                    break;
                case 'WT_B78_Throttle_2_Inc':
                case 'WT_B78_Throttle_2_Dec':
                    this.handleThrottleLeverIncDec(2);
                    break;
            }
        });
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            (_g = this.servoActive[n]) === null || _g === void 0 ? void 0 : _g.sub(active => {
                const forceDisconnectData = this.forceDisconnectData[n];
                if (forceDisconnectData !== undefined && !active) {
                    forceDisconnectData.lastInputTime = undefined;
                    forceDisconnectData.lastSetInputPos = undefined;
                    forceDisconnectData.cumulativeDisplacement = 0;
                }
            }, true);
        }
        // Start autothrottle and update loop.
        this.autothrottle.setOverpowerProtActive(true);
        this.autothrottle.start(BoeingAutothrottle.UPDATE_FREQ);
        sub.on('fma_data').handle(this.onApFmaDataChanged.bind(this));
        this.boeingVNavMode.setConsumer(sub.on('vnav_boeing_vnav_mode'));
        this.servoOverride.sub(override => {
            !override && this.overrideTime.set(0);
        });
        this.fcuArmSwitchState.sub(armed => {
            if (!armed) {
                this.deactivate(false);
                this.reset();
            }
        });
        // TOGA button
        sub.on('boeing_at_control_toga_button_pressed').handle(this.onTogaPressed.bind(this));
        // 787 CLB/CON button
        sub.on('boeing_at_control_clbcon_button_pressed').handle(() => {
            // Only the TOGA switches can activate A/T below 400 feet
            if (this.radarAlt.get() < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
                return;
            }
            this.onClbConButtonPressed();
        });
        // 787 A/T button
        sub.on('boeing_at_control_engage_button_pressed').handle(() => {
            // Only the TOGA switches can activate A/T below 400 feet
            if (this.radarAlt.get() < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
                return;
            }
            this.arm();
            if (this.status.get() === BoeingAutothrottleStatus.Armed) {
                this.activate();
            }
        });
        // 747 SPD button
        sub.on('boeing_at_control_spd_button_pressed').handle(() => {
            // Only the TOGA switches can activate A/T below 400 feet
            if (this.radarAlt.get() < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
                return;
            }
            const pitchMode = this.apVerticalMode.get();
            if (pitchMode === APVerticalModes.FLC || pitchMode === APVerticalModes.TO || pitchMode === APVerticalModes.GA || BoeingVNavUtils.isModeVnav(pitchMode)) {
                return;
            }
            if (this.status.get() === BoeingAutothrottleStatus.On) {
                this.activeMode.set(BoeingAutothrottleModes.SPD);
            }
            else {
                this.arm();
                if (this.status.get() === BoeingAutothrottleStatus.Armed) {
                    this.activate(BoeingAutothrottleModes.SPD);
                }
            }
        });
        // 747 THR button
        sub.on('boeing_at_control_thr_button_pressed').handle(() => {
            // Only the TOGA switches can activate A/T below 400 feet
            if (this.radarAlt.get() < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
                return;
            }
            if (this.onClbConButtonPressed()) {
                // thrust limit was changed so we're done
                return;
            }
            const pitchMode = this.apVerticalMode.get();
            const landingMode = pitchMode === APVerticalModes.GS || pitchMode === APVerticalModes.GP || pitchMode === APVerticalModes.FLARE;
            switch (this.thrustManager.activeThrustMode.get()) {
                case ClimbThrustMode.CLB:
                case ClimbThrustMode.CLB1:
                case ClimbThrustMode.CLB2:
                case AirborneThrustMode.CRZ:
                case AirborneThrustMode.CON:
                    if (pitchMode !== APVerticalModes.ALT && pitchMode !== APVerticalModes.VS) {
                        return;
                    }
                    break;
                case AirborneThrustMode.GA:
                    if (!landingMode && !(this.flapsInLandingPos.get() && (pitchMode === APVerticalModes.ALT || pitchMode === APVerticalModes.VS))) {
                        return;
                    }
                    break;
            }
            if (this.status.get() === BoeingAutothrottleStatus.On) {
                this.activeMode.set(BoeingAutothrottleModes.CLIMB);
                this.thrModeLight.set(true);
            }
            else {
                this.arm();
                if (this.status.get() === BoeingAutothrottleStatus.Armed) {
                    this.activate(BoeingAutothrottleModes.CLIMB);
                    this.thrModeLight.set(this.status.get() === BoeingAutothrottleStatus.On);
                }
            }
        });
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Attempts to reduce takeoff thrust to climb or continuous thrust limit
     * @returns true if thrust limit was reduced
     */
    onClbConButtonPressed() {
        const gsOrGpCaptured = this.apVerticalMode.get() === APVerticalModes.GS || this.apVerticalMode.get() === APVerticalModes.GP;
        // the 747 FCOM details this flaps + pitch mode condition... we assume the 787 is the same
        if (this.thrustMode.get() === 'takeoff' || (this.thrustMode.get() === 'ga' && !this.flapsInLandingPos.get() && !gsOrGpCaptured)) {
            const newThrustLimit = this.engineOut.get() ? AirborneThrustMode.CON : this.thrustManager.getArmedClimbThrustMode();
            this.thrustManager.changeThrustMode(newThrustLimit);
            return true;
        }
        return false;
    }
    /**
     * Handles when the speed target changes in any way in order to set the proper fms or manual speed or mach.
     */
    onSpeedTargetChanged() {
        this.autothrottle.setSelectedIas(this.atIasTarget.get());
        this.autothrottle.setSelectedMach(this.atMachTarget.get());
        this.autothrottle.setSelectedSpeedIsMach(this.atTargetIsMach.get());
    }
    /**
     * Handles throttle input key events.
     * @param index The index of the throttle.
     * @param currentPos The current position of the throttle lever, in the range -1 to +1.
     * @param newPos The requested new position of the throttle lever, in the range -1 to +1.
     * @param keyEvent The key event.
     * @returns The desired throttle lever position to set, in the range -1 to +1.
     */
    handleThrottleLeverInput(index, currentPos, newPos, keyEvent) {
        var _a;
        const data = this.forceDisconnectData[index];
        if (data === undefined) {
            return -1;
        }
        if (!data.servoActive.get()) {
            const holdData = this.holdData[index];
            if (holdData) {
                if (holdData.firstManualInput === undefined) {
                    holdData.firstManualInput = newPos;
                }
                // Require a minimum amount of lever input in HOLD mode before the levers are controlled manually.
                // This ensures noisy hardware doesn't erroneously change the thrust lever position.
                holdData.leversActive || (holdData.leversActive = Math.abs(holdData.firstManualInput - newPos) >= BoeingAutothrottle.HOLD_THROTTLE_LEVER_ACTIVATION_THRESHOLD);
                const activeMode = this.activeMode.get();
                const holdModeActive = activeMode === BoeingAutothrottleModes.DESCENT_HOLD || activeMode === BoeingAutothrottleModes.TAKEOFF_HOLD;
                if (holdModeActive && !holdData.leversActive) {
                    return currentPos;
                }
            }
            return newPos;
        }
        const time = Date.now();
        if (data.cumulativeDisplacement === undefined || data.lastInputTime === undefined) {
            data.cumulativeDisplacement = 0;
        }
        else {
            const dt = time - data.lastInputTime;
            data.cumulativeDisplacement *= Math.exp(-dt / BoeingAutothrottle.FORCE_DC_DISPLACEMENT_DECAY_TAU);
        }
        if (keyEvent.search('SET') >= 0) {
            // SET event -> need to handle potential noisy hardware throttles that continuously send key events. (Note also
            // that modelbehaviors will intercept most throttle key events and turn them into SET events.)
            // The amount we add to cumulative displacement will be equal to the difference between the requested position of
            // the current SET event and the last SET event. For noisy hardware, their set events should be distributed
            // randomly around a constant value if the throttle is not in motion, so over time the cumulative displacement
            // tends toward 0.
            if (data.lastInputTime === undefined || time - data.lastInputTime > 200) {
                data.lastSetInputPos = undefined;
            }
            const deltaPos = newPos - ((_a = data.lastSetInputPos) !== null && _a !== void 0 ? _a : newPos);
            data.cumulativeDisplacement += deltaPos;
            data.lastSetInputPos = newPos;
        }
        else {
            // INC, DEC, or event that targets a constant throttle position -> no need to handle noisy hardware since they
            // shouldn't be sending these types of events.
            data.cumulativeDisplacement += BoeingAutothrottle.FORCE_DC_INC_DEC_DISPLACEMENT;
        }
        // OVERRIDE: Allow the user to override the A/T for 10 seconds before resuming A/T servos.
        if (Math.abs(data.cumulativeDisplacement) > BoeingAutothrottle.FORCE_OVERRIDE_DISPLACEMENT_THRESHOLD) {
            this.override();
        }
        data.lastInputTime = time;
        return currentPos;
    }
    /**
     * Handles throttle lever increase/decrease events.
     * @param index The index of the throttle.
     */
    handleThrottleLeverIncDec(index) {
        const data = this.forceDisconnectData[index];
        if (data === undefined) {
            return;
        }
        if (!data.servoActive.get()) {
            return;
        }
        const time = Date.now();
        if (data.cumulativeDisplacement === undefined || data.lastInputTime === undefined) {
            data.cumulativeDisplacement = 0;
        }
        else {
            const dt = time - data.lastInputTime;
            data.cumulativeDisplacement *= Math.exp(-dt / BoeingAutothrottle.FORCE_DC_DISPLACEMENT_DECAY_TAU);
        }
        data.cumulativeDisplacement += BoeingAutothrottle.FORCE_DC_INC_DEC_DISPLACEMENT;
        // OVERRIDE: Allow the user to override the A/T for 10 seconds before resuming A/T servos.
        if (Math.abs(data.cumulativeDisplacement) > BoeingAutothrottle.FORCE_OVERRIDE_DISPLACEMENT_THRESHOLD) {
            this.override();
        }
    }
    /**
     * Attempts to arm this autothrottle.
     */
    arm() {
        const status = this.status.get();
        if ((status !== BoeingAutothrottleStatus.Off && status !== BoeingAutothrottleStatus.Disconnected) || !this.canArm()) {
            return;
        }
        this.armedMode.set(BoeingAutothrottleModes.NONE);
        this.activeMode.set(BoeingAutothrottleModes.NONE);
        this.status.set(BoeingAutothrottleStatus.Armed);
        // auto-activation of A/T mode when VNAV or FLCH active..
        // Only the TOGA switches can activate A/T below 400 feet
        const atCanActivate = this.radarAlt.get() >= BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE;
        const apVerticalMode = this.apVerticalMode.get();
        const apVnavOrFlch = BoeingVNavUtils.isModeVnav(apVerticalMode) || apVerticalMode === APVerticalModes.FLC;
        if (this.options.autoActivateOnArm && atCanActivate && apVnavOrFlch) {
            if (this.status.get() === BoeingAutothrottleStatus.Armed) {
                this.activate();
            }
        }
    }
    /**
     * Attempts to activate this autothrottle.
     * @param mode The mode to activate. Defaults to {@link BoeingAutothrottleModes.NONE}.
     */
    activate(mode = BoeingAutothrottleModes.NONE) {
        if (this.status.get() === BoeingAutothrottleStatus.On || !this.canActivate()) {
            return;
        }
        this.armedMode.set(BoeingAutothrottleModes.NONE);
        this.activeMode.set(mode);
        this.status.set(BoeingAutothrottleStatus.On);
    }
    /**
     * Attempts to set an A/T override state.
     */
    override() {
        this.overrideTime.set(this.simTime.get());
    }
    /**
     * Attempts to deactivate this autothrottle. If the autothrottle is already deactivated, then this method has no
     * effect other than to change the status from disconnected to off if the `disconnect` argument is `false`.
     * @param disconnect Whether the autothrottle should enter the disconnect state when deactivated.
     */
    deactivate(disconnect) {
        if (this.status.get() === BoeingAutothrottleStatus.Off) {
            return;
        }
        this.armedMode.set(BoeingAutothrottleModes.NONE);
        this.activeMode.set(BoeingAutothrottleModes.NONE);
        this.status.set(disconnect ? BoeingAutothrottleStatus.Disconnected : BoeingAutothrottleStatus.Off);
    }
    /**
     * Resets all aspects of this autothrottle's state that are not tied to a specific operating status or mode.
     */
    reset() {
        this.iasLookahead.reset();
        this.speedBelowLowSpeedLimit1SecondTimer.clear();
        this.isLandingPhaseArmed = false;
        this.isLandingPhase = false;
        this.onGroundTime = 0;
        this.landingPhaseTime = 0;
    }
    /** Initialise hold modes on entry */
    initialiseHoldMode() {
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            const holdData = this.holdData[n];
            if (holdData) {
                holdData.firstManualInput = undefined;
                holdData.leversActive = false;
            }
        }
    }
    /**
     * Responds to changes in this autothrottle's active mode.
     * @param mode The active mode.
     */
    onActiveModeChanged(mode) {
        let areServosActive = false;
        this.holdDuration = 0;
        this.retardActivateDuration = 0;
        switch (mode) {
            case BoeingAutothrottleModes.NONE:
                this.isRetardPrimed = false;
            // eslint-disable-next-line no-fallthrough
            case BoeingAutothrottleModes.TAKEOFF_HOLD:
            case BoeingAutothrottleModes.DESCENT_HOLD:
                this.initialiseHoldMode();
            // fallthrough
            case BoeingAutothrottleModes.HOLD_FAIL:
                this.autoGroundDisengagePrimedDuration = 0;
                this.isRetardFailed.set(false);
                this.autothrottle.setTargetMode(AutothrottleTargetMode.None);
                break;
            case BoeingAutothrottleModes.CLIMB:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getClimbN1());
                break;
            case BoeingAutothrottleModes.IDLE:
                areServosActive = true;
                this.isRetardPrimed = false;
                this.isRetardFailed.set(false);
                this.autothrottle.setTargetMode(AutothrottleTargetMode.ThrottlePos);
                this.autothrottle.setSelectedThrottlePos(0);
                break;
            case BoeingAutothrottleModes.TO:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getTakeoffN1());
                break;
            case BoeingAutothrottleModes.GA:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getGoAroundN1());
                break;
            case BoeingAutothrottleModes.GA_THR:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getGoAroundThrN1());
                break;
            case BoeingAutothrottleModes.DESCENT_THR:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getDescentThrN1());
                break;
            case BoeingAutothrottleModes.CON:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Power);
                this.setAutothrottleSelectedPower(this.getMaxConN1());
                break;
            case BoeingAutothrottleModes.SPD:
                areServosActive = true;
                this.autothrottle.setTargetMode(AutothrottleTargetMode.Speed);
                break;
            case BoeingAutothrottleModes.RETARD:
                areServosActive = true;
                this.isRetardPrimed = false;
                this.isRetardFailed.set(false);
                this.autothrottle.setTargetMode(AutothrottleTargetMode.ThrottlePos);
                this.autothrottle.setSelectedThrottlePos(0);
                break;
        }
        this.servosActiveCommand.set(areServosActive);
        this.fmaData.set('activeMode', mode);
        this.fmaData.set('isActiveModeFail', mode === BoeingAutothrottleModes.HOLD_FAIL);
    }
    /**
     * Updates this autothrottle.
     */
    update() {
        var _a;
        const isPowered = SimVar.GetSimVarValue(this.powerSimvar, SimVarValueType.Bool) !== 0;
        if (isPowered !== this.isPowered) {
            this.isPowered = isPowered;
            if (!isPowered) {
                this.deactivate(this.isAvionicsPowered);
                this.reset();
            }
            // this.publisher.pub('longitude_at_failed', !this.isPowered, true, true);
            // this.publisher.pub(this.isPowered ? 'cas_deactivate_alert' : 'cas_activate_alert', {
            //   key: { uuid: BoeingAutothrottleCrewAlertIDs.AtFail },
            //   priority: AnnunciationType.Advisory
            // }, true, false);
        }
        this.airframeMaxIas.set(this.speedProvider.getVmo());
        this.updateAutothrottleMaxPower();
        (_a = this.lastUpdateSimTime) !== null && _a !== void 0 ? _a : (this.lastUpdateSimTime = this.simTime.get());
        const simTime = this.simTime.get();
        const dt = Math.max(simTime - this.lastUpdateSimTime, 0);
        if (this.isPowered && this.isAvionicsPowered && this.fcuArmSwitchState.get() === true) {
            this.updateSpeedLookahead();
            this.updateLandingPhase();
            this.updateLowSpeedAutoActivation();
            const status = this.status.get();
            // this.spoilersDeployed.set(SimVar.GetSimVarValue(SpoilerControlSystemSimVars.SpoilersInput, SimVarValueType.Percent) > 0.025);
            switch (status) {
                case BoeingAutothrottleStatus.Armed:
                    if (!this.canArm()) {
                        this.deactivate(false);
                    }
                    else {
                        this.updateArmed();
                    }
                    break;
                case BoeingAutothrottleStatus.On:
                    if (!this.canArm()) {
                        // If autothrottle deactivates because of reverse thrust, do not enter disconnected state.
                        this.deactivate(!this.isAnyFadecModeReverse.get());
                    }
                    else {
                        switch (this.activeMode.get()) {
                            case BoeingAutothrottleModes.NONE:
                                this.updateNoneMode();
                                break;
                            case BoeingAutothrottleModes.TAKEOFF_HOLD:
                                this.updateHoldTakeoffMode();
                                break;
                            case BoeingAutothrottleModes.DESCENT_HOLD:
                                this.updateHoldDescentMode();
                                break;
                            case BoeingAutothrottleModes.HOLD_FAIL:
                                this.updateHoldFailMode(dt);
                                break;
                            case BoeingAutothrottleModes.TO:
                                this.updateToMode();
                                break;
                            case BoeingAutothrottleModes.CLIMB:
                                this.updateClimbMode(dt);
                                break;
                            case BoeingAutothrottleModes.CON:
                                this.updateConMode(dt);
                                break;
                            case BoeingAutothrottleModes.IDLE:
                                this.updateIdleMode(dt);
                                break;
                            case BoeingAutothrottleModes.GA:
                                this.updateGoAroundMode(dt);
                                break;
                            case BoeingAutothrottleModes.GA_THR:
                                this.updateGoAroundThrMode(dt);
                                break;
                            case BoeingAutothrottleModes.DESCENT_THR:
                                this.updateDescentThrMode(dt);
                                break;
                            case BoeingAutothrottleModes.SPD:
                                this.updateSpeedMode(dt);
                                break;
                            case BoeingAutothrottleModes.RETARD:
                                this.updateRetardMode(dt);
                                break;
                        }
                    }
                    break;
                default:
                    this.updateOff();
            }
        }
        if (this.needPublishFmaData) {
            this.needPublishFmaData = false;
            this.publisher.pub('boeing_at_fma_data', this.fmaData.get(), true, true);
        }
        this.lastUpdateSimTime = simTime;
    }
    /**
     * Updates this autothrottle's IAS and mach speed lookahead values.
     */
    updateSpeedLookahead() {
        var _a;
        const simTime = this.simTime.get();
        const dt = simTime - ((_a = this.lastUpdateSimTime) !== null && _a !== void 0 ? _a : simTime);
        this.iasLookahead.next(this.ias.get(), dt);
    }
    /**
     * Updates whether this autothrottle is in the landing phase.
     */
    updateLandingPhase() {
        var _a;
        const simTime = this.simTime.get();
        const dt = Math.max(0, simTime - ((_a = this.lastUpdateSimTime) !== null && _a !== void 0 ? _a : simTime));
        const radarAlt = this.radarAlt.get();
        if (this.isOnGround.get()) {
            this.onGroundTime += dt;
        }
        else {
            this.onGroundTime = 0;
        }
        if (this.isLandingPhase) {
            this.landingPhaseTime += dt;
            this.isLandingPhase
                = this.landingPhaseTime < BoeingAutothrottle.LANDING_PHASE_MAX_TIME
                    && !isNaN(radarAlt) && radarAlt < BoeingAutothrottle.LANDING_PHASE_MAX_RADAR_ALT;
        }
        else if (this.isLandingPhaseArmed) {
            if (isNaN(radarAlt) || this.onGroundTime >= BoeingAutothrottle.LANDING_PHASE_MAX_GROUND_TIME) {
                this.isLandingPhaseArmed = false;
            }
            else if (radarAlt < BoeingAutothrottle.LANDING_PHASE_RADAR_ALT_THRESHOLD) {
                this.isLandingPhaseArmed = false;
                this.isLandingPhase = true;
            }
        }
        else {
            this.isLandingPhaseArmed
                = this.onGroundTime < BoeingAutothrottle.LANDING_PHASE_MAX_GROUND_TIME
                    && !isNaN(radarAlt) && radarAlt >= BoeingAutothrottle.LANDING_PHASE_RADAR_ALT_THRESHOLD;
        }
        if (!this.isLandingPhase) {
            this.landingPhaseTime = 0;
        }
    }
    /**
     * Checks whether this autothrottle can enter the armed state.
     * @returns Whether this autothrottle can enter the armed state.
     */
    canArm() {
        return this.fcuArmSwitchState.get() === true
            && this.isPowered
            && this.isAvionicsPowered
            && !this.isAnyFadecModeUnsupported.get();
    }
    /**
     * Checks whether this autothrottle can enter the active state
     * @returns Whether this autothrottle can enter the active state.
     */
    canActivate() {
        // - above 50 knots A/T inhibited below 400 feet (i.e. if A/T is not active by 50 knots, can't be until reaching 400 feet)
        if (this.gs.get() > BoeingAutothrottle.TO_ARM_MAX_SPEED && this.radarAlt.get() < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
            return false;
        }
        return true;
    }
    /**
     * Updates this autothrottle when in the off or disconnected state.
     */
    updateOff() {
        if (this.status.get() === BoeingAutothrottleStatus.Off && this.canArm()) {
            this.arm();
        }
    }
    /**
     * Updates this autothrottle when in the armed state.
     */
    updateArmed() {
        // let canActivate = false;
        // let modeToActivate: BoeingAutothrottleModes | undefined;
        // if (this.isOnGround.get()) {
        //   this.armedMode.set(BoeingAutothrottleModes.TO);
        //   // const isToGaActive = apFmaData?.verticalActive === APVerticalModes.GA || apFmaData?.verticalActive === APVerticalModes.TO;
        //   // const gs = this.gs.get();
        //   canActivate = this.isToGaActive.get() && this.gs.get() <= BoeingAutothrottle.TO_ARM_MAX_SPEED;
        //   // canActivate = Object.values(this.throttleLeverPosition).every(
        //   //   (p) => p.get() >= BoeingAutothrottle.THROTTLE_LEVER_ACTIVATE_THRESHOLD
        //   // );
        //   modeToActivate = BoeingAutothrottleModes.TO;
        // } else {
        //   canActivate = true;
        //   if (this.armedMode.get() === BoeingAutothrottleModes.TO) {
        //     // We were armed for TO/HOLD mode, but never actually activated HOLD mode before leaving the ground, so we will
        //     // enter HOLD FAIL mode.
        //     modeToActivate = BoeingAutothrottleModes.HOLD_FAIL;
        //   }
        // }
        // if (canActivate) {
        //   this.activate(modeToActivate);
        // }
    }
    /**
     * Updates auto-activation of the A/T to protect against low speed.
     */
    updateLowSpeedAutoActivation() {
        // auto-activation is inhibited if the A/T is off or already active, or we're not airborne
        if (!this.canArm() || this.activeMode.get() !== BoeingAutothrottleModes.NONE || this.isOnGround.get()) {
            return;
        }
        // firstly consider if we're "near" the stick shaker speed
        // The threshold for stick shaker = top of red band on the PFD, higher of 3 knots or 3% above 1g stall speed by regulation
        // If we auto-activate, the speed target shall be higher of IAS/MACH window, or min maneuvering speed = top of amber band on the PFD:
        // - 1.3g to stick shaker below 20k ft
        // - 1.3g to low speed buffet above 20k ft
        // FIXME anti-ice with flaps not up should increase stick shaker
        const stallSpeed = this.aoaDataProvider.estimateIasFromNormAoa(1.0);
        const stickShakerSpeed = Math.ceil(Math.max(stallSpeed + BoeingAutothrottle.STICK_SHAKER_MINIMUM_OFFSET, BoeingAutothrottle.STICK_SHAKER_MINIMUM_PROPORTION * stallSpeed));
        if (stickShakerSpeed > this.ias.get()) {
            // This will later automatically select an appropriate A/T mode depending on A/P pitch mode.
            // The selected mode may not necessarily help with a stall e.g. HOLD mode will not increase thrust.
            this.activate(BoeingAutothrottleModes.SPD);
            return;
        }
        // finally consider if speed is "less than an FMC calculated value for one second" in one of the specific pitch modes
        const pitchMode = this.apVerticalMode.get();
        switch (pitchMode) {
            case APVerticalModes.ALT:
            case APVerticalModes.CAP:
            case APVerticalModes.VS:
            case APVerticalModes.FPA:
            case APVerticalModes.GS:
            case APVerticalModes.GP:
            case BoeingVNavModes.ALT:
            case BoeingVNavModes.PATH_DESCENT:
            case BoeingVNavModes.PATH_IDLE:
            case BoeingVNavModes.PATH_LEVEL:
                break;
            default:
                // no protection in any other modes
                return;
        }
        // calculate the "FMC calculated value"
        const minSpeed = Math.round(this.aoaDataProvider.estimateIasFromNormAoa(BoeingAutothrottle.UNDERSPEED_PROTECTION_AOA));
        const ias = this.iasLookahead.last(true);
        if (isNaN(minSpeed) || ias === null) {
            return;
        }
        if (ias < minSpeed) {
            if (!this.speedBelowLowSpeedLimit1Second && !this.speedBelowLowSpeedLimit1SecondTimer.isPending()) {
                this.speedBelowLowSpeedLimit1SecondTimer.schedule(() => this.speedBelowLowSpeedLimit1Second = true, 1000);
            }
        }
        else {
            if (this.speedBelowLowSpeedLimit1SecondTimer.isPending()) {
                this.speedBelowLowSpeedLimit1SecondTimer.clear();
            }
            this.speedBelowLowSpeedLimit1Second = false;
        }
        // FIXME this should be based on baro alt and the airport alt
        const below400OnTakeoff = this.radarAlt.get() < 400 && this.fmsOperatingPhase.get() === FmsOperatingPhase.TAKEOFF;
        const below100OnApproach = this.radarAlt.get() < 100 && this.fmsOperatingPhase.get() === FmsOperatingPhase.APPROACH;
        if (this.speedBelowLowSpeedLimit1Second && this.isThrustBelowRefLimit() && !(below400OnTakeoff || below100OnApproach)) {
            // This will later automatically select an appropriate A/T mode depending on A/P pitch mode.
            // The selected mode may not necessarily help with a stall e.g. HOLD mode will not increase thrust.
            this.activate(BoeingAutothrottleModes.SPD);
        }
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is NONE.
     */
    updateNoneMode() {
        const radarAltitude = this.radarAlt.get();
        if (this.isOnGround.get() || (!isNaN(radarAltitude) && radarAltitude < BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE)) {
            this.activeMode.set(BoeingAutothrottleModes.TAKEOFF_HOLD);
        }
        else {
            this.selectTargetingMode();
        }
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is HOLD.
     */
    updateHoldTakeoffMode() {
        // TODO MORE?
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is HOLD.
     */
    updateHoldDescentMode() {
        // TODO MORE?
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is HOLD FAIL.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateHoldFailMode(dt) {
        this.tryAutoGroundDisengage(dt);
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is TO.
     */
    updateToMode() {
        this.setAutothrottleSelectedPower(this.getTakeoffN1());
        const radarAltitude = this.radarAlt.get();
        this.tryPrimeRetard(radarAltitude);
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is CLIMB.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateClimbMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        this.setAutothrottleSelectedPower(this.getClimbN1());
        const radarAltitude = this.radarAlt.get();
        this.tryPrimeRetard(radarAltitude);
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is CON.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateConMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        this.setAutothrottleSelectedPower(this.getMaxConN1());
        const radarAltitude = this.radarAlt.get();
        this.tryPrimeRetard(radarAltitude);
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is IDLE.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateIdleMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        const radarAltitude = this.radarAlt.get();
        this.tryPrimeRetard(radarAltitude);
        if (!this.tryActivateRetard(radarAltitude)) {
            this.selectTargetingMode();
        }
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is GA.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateGoAroundMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        this.setAutothrottleSelectedPower(this.getGoAroundN1());
        this.selectTargetingMode();
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is GA_THR
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateGoAroundThrMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        this.setAutothrottleSelectedPower(this.getGoAroundThrN1());
        this.selectTargetingMode();
    }
    /**
     * Sets the auto throttle using the given target N1 corrected value.
     * @param targetN1Corrected The target N1 corrected value.
     */
    setAutothrottleSelectedPower(targetN1Corrected) {
        this.autothrottle.setSelectedPower(this.performanceProvider.uncorrectN1(this.ambientTemp.get(), this.mach.get(), targetN1Corrected));
    }
    /**
     * Sets the auto throttle max N1 corrected value.
     */
    updateAutothrottleMaxPower() {
        const maxN1FromThrustRefMode = this.getMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
        this.autothrottle.setMaxPower(this.performanceProvider.uncorrectN1(this.ambientTemp.get(), this.mach.get(), maxN1FromThrustRefMode));
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is DESCENT_THR
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateDescentThrMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        const targetThrust = this.getDescentThrN1();
        if (!this.tryActivateDescentHold(targetThrust)) {
            this.setAutothrottleSelectedPower(targetThrust);
            this.selectTargetingMode();
        }
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is SPEED.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateSpeedMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        const radarAltitude = this.radarAlt.get();
        this.tryPrimeRetard(radarAltitude);
        if (!this.tryActivateRetard(radarAltitude)) {
            this.selectTargetingMode();
        }
    }
    /**
     * Updates this autothrottle when in the on state and the active mode is RETARD.
     * @param dt The elapsed time, in milliseconds, since the last update.
     */
    updateRetardMode(dt) {
        if (this.tryAutoGroundDisengage(dt)) {
            return;
        }
        if (this.isRetardFailed.get()) {
            return;
        }
        this.retardActivateDuration += dt;
        if (this.retardActivateDuration > BoeingAutothrottle.RETARD_OVERTIME_THRESHOLD) {
            this.isRetardFailed.set(true);
        }
    }
    /**
     * Handles when the AP Vertical Mode is changed.
     * @param data The BoeingFmaData Object.
     */
    onApFmaDataChanged(data) {
        const oldMode = this.apVerticalMode.get();
        const newMode = data.verticalActive;
        const isArmed = this.status.get() === BoeingAutothrottleStatus.Armed;
        if (isArmed) {
            if (!BoeingVNavUtils.isModeVnav(oldMode) && BoeingVNavUtils.isModeVnav(newMode)) {
                this.activate();
            }
            else if (newMode === APVerticalModes.FLC || newMode === APVerticalModes.VS) {
                this.activate();
            }
        }
        this.apVerticalMode.set(newMode);
    }
    // TODO ref thrust limit locked in GA when flaps are in landing config or gs/gp captured
    /**
     * Handle when TOGA is pressed.
     */
    onTogaPressed() {
        if (this.isPowered && this.isAvionicsPowered) {
            if (this.status.get() !== BoeingAutothrottleStatus.On) {
                this.arm();
            }
            const status = this.status.get();
            if (status !== BoeingAutothrottleStatus.Armed && status !== BoeingAutothrottleStatus.On) {
                return;
            }
            const onGround = this.isOnGround.get();
            const takeoffOrEarlier = this.fmsOperatingPhase.get() <= FmsOperatingPhase.TAKEOFF;
            const afterLiftOff = takeoffOrEarlier && !onGround;
            const flapsUp = this.flapSpeedLimit.get() < 0;
            const onDescentOrApproach = this.fmsOperatingPhase.get() === FmsOperatingPhase.DESCENT || this.fmsOperatingPhase.get() === FmsOperatingPhase.APPROACH;
            const gsOrGpCaptured = this.apVerticalMode.get() === APVerticalModes.GS || this.apVerticalMode.get() === APVerticalModes.GP;
            let activateMode;
            if (onGround) {
                if (this.gs.get() < BoeingAutothrottle.TO_ARM_MAX_SPEED) {
                    activateMode = BoeingAutothrottleModes.TO;
                }
            }
            else if (afterLiftOff) {
                // prior to 400 feet, if A/T is not active, it cannot be activated
                if (status === BoeingAutothrottleStatus.On || this.radarAlt.get() > BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE) {
                    activateMode = BoeingAutothrottleModes.TO;
                    this.bus.getPublisher().pub('thrust_control_remove_derates', true, false, false);
                }
            }
            else if (onDescentOrApproach && (!flapsUp || gsOrGpCaptured) && !onGround) {
                activateMode = this.activeMode.get() === BoeingAutothrottleModes.GA_THR ? BoeingAutothrottleModes.GA : BoeingAutothrottleModes.GA_THR;
            }
            if (activateMode === undefined) {
                return;
            }
            if (this.status.get() === BoeingAutothrottleStatus.On) {
                this.activeMode.set(activateMode);
            }
            else {
                this.activate(activateMode);
            }
        }
    }
    /**
     * Selects an appropriate speed/power/throttle position-targeting mode (CLIMB, DESC, SPD, or TO) for the current
     * situation.
     *
     * TO mode is selected if the autopilot/flight director is also in TO mode. CLIMB or DESCENT modes is selected if
     * the autopilot/flight director is in FLC mode and the pre-selected altitude is above or below the airplane's
     * current indicated altitude, respectively. SPD mode is selected in all other situations.
     *
     * Boeing Notes: The Boeing A/T will go from armed (inactive) to active on the following events:
     * - Is armed and A/T button is pressed
     * - Is armed and vertical mode is activated via the FCU panel to FLCH, ALT, VS, APR, VNAV)
     * - Is armed on TOGA pressed
     * - Otherwise the A/T does not automatically activate if not already on.
     *
     * @returns The selected speed/power/throttle position-targeting mode (CLIMB, DESC, SPD, or TO).
     */
    selectTargetingMode() {
        const verticalMode = this.apVerticalMode.get();
        const vnavMode = this.boeingVNavMode.get();
        const isActive = this.status.get() === BoeingAutothrottleStatus.On;
        if (!isActive) {
            this.activeMode.set(BoeingAutothrottleModes.NONE);
            return BoeingAutothrottleModes.NONE;
        }
        const activeMode = this.activeMode.get();
        if (activeMode === BoeingAutothrottleModes.TO) {
            const ias = this.ias.get();
            if (ias > BoeingAutothrottle.TO_HOLD_ENGAGE_SPEED && this.isOnGround.get()) {
                // At 80kts GS engage HOLD MODE from TO MODE.
                this.activeMode.set(BoeingAutothrottleModes.TAKEOFF_HOLD);
            }
            else if (this.thrustMode.get() !== 'takeoff') {
                // Once the thrust manager sets a mode other than takeoff, while in takeoff, activate CLIMB mode.
                this.activeMode.set(BoeingAutothrottleModes.CLIMB);
            }
        }
        else if (activeMode === BoeingAutothrottleModes.TAKEOFF_HOLD) {
            // Once the thrust manager sets a mode other than takeoff, while in takeoff hold, activate CLIMB mode.
            if (this.thrustMode.get() !== 'takeoff') {
                this.activeMode.set(BoeingAutothrottleModes.CLIMB);
            }
            else if (vnavMode !== BoeingVNavModes.ARMED && vnavMode !== BoeingVNavModes.NONE) {
                // back to THR REF when VNAV engages at 400 feet if armed
                this.activeMode.set(BoeingAutothrottleModes.TO);
            }
        }
        else if (this.apValues.verticalActive.get() === APVerticalModes.CAP) {
            this.activeMode.set(BoeingAutothrottleModes.SPD);
        }
        else if (vnavMode !== BoeingVNavModes.ARMED && vnavMode !== BoeingVNavModes.NONE) {
            switch (vnavMode) {
                case BoeingVNavModes.ALT:
                    this.activeMode.set(BoeingAutothrottleModes.SPD);
                    break;
                case BoeingVNavModes.PATH_LEVEL:
                    this.activeMode.set(BoeingAutothrottleModes.SPD);
                    break;
                case BoeingVNavModes.PATH_IDLE:
                    if (!this.belowSpeedTarget.get()) {
                        // if we were previously in another mode force IDLE first, else consider HOLD
                        if (this.lastApVerticalMode === BoeingVNavModes.PATH_IDLE && (activeMode === BoeingAutothrottleModes.DESCENT_HOLD || this.isThrustAtIdle())) {
                            this.activeMode.set(BoeingAutothrottleModes.DESCENT_HOLD);
                        }
                        else {
                            this.activeMode.set(BoeingAutothrottleModes.IDLE);
                        }
                    }
                    else {
                        this.activeMode.set(BoeingAutothrottleModes.SPD);
                    }
                    break;
                case BoeingVNavModes.PATH_DESCENT:
                    this.activeMode.set(BoeingAutothrottleModes.SPD);
                    break;
                case BoeingVNavModes.SPD_CLIMB:
                    this.activeMode.set(BoeingAutothrottleModes.CLIMB);
                    break;
                case BoeingVNavModes.SPD_DESCENT:
                    // if we were previously in another mode force IDLE first, else consider HOLD
                    if (this.lastApVerticalMode === BoeingVNavModes.PATH_IDLE && (activeMode === BoeingAutothrottleModes.DESCENT_HOLD || this.isThrustAtIdle())) {
                        this.activeMode.set(BoeingAutothrottleModes.DESCENT_HOLD);
                    }
                    else {
                        this.activeMode.set(BoeingAutothrottleModes.IDLE);
                    }
                    break;
                case BoeingVNavModes.THR_DESCENT:
                    if (activeMode === BoeingAutothrottleModes.DESCENT_HOLD) {
                        this.activeMode.set(BoeingAutothrottleModes.DESCENT_HOLD);
                    }
                    else {
                        this.activeMode.set(BoeingAutothrottleModes.DESCENT_THR);
                    }
                    break;
            }
        }
        else if (this.isApVerticalModeFlc.get()) {
            if (this.indicatedAlt.get() < this.selectedAlt.get()) {
                this.activeMode.set(BoeingAutothrottleModes.CLIMB);
            }
            else {
                this.activeMode.set(BoeingAutothrottleModes.IDLE);
            }
        }
        else if (activeMode === BoeingAutothrottleModes.GA || activeMode === BoeingAutothrottleModes.GA_THR) {
            if (verticalMode === APVerticalModes.ALT || verticalMode === APVerticalModes.CAP) {
                this.activeMode.set(BoeingAutothrottleModes.SPD);
            }
            else if (this.thrustMode.get() !== 'ga') {
                this.activeMode.set(BoeingAutothrottleModes.CLIMB);
            }
        }
        else if (verticalMode === APVerticalModes.TO || verticalMode === APVerticalModes.GA || this.thrModeLight.get()) {
            this.activeMode.set(BoeingAutothrottleModes.CLIMB);
        }
        else {
            this.activeMode.set(BoeingAutothrottleModes.SPD);
        }
        this.lastApVerticalMode = verticalMode;
        return this.activeMode.get();
    }
    /**
     * Check if all engines are at idle thrust
     * @returns true when all engines are at idle thrust
     */
    isThrustAtIdle() {
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            if (!this.fadec.isThrustAtIdle(n)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Check if all engines are at a specified thrust
     * @param targetCn1 Target thrust level as corrected N1%
     * @returns true when all engines are at idle thrust
     */
    isThrustAtTarget(targetCn1) {
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            if (!this.fadec.isThrustAtTarget(n, targetCn1)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Check if any engines is targeting below the reference thrust limit
     * @returns true when any engine target is below the reference thrust limit
     */
    isThrustBelowRefLimit() {
        var _a, _b;
        const refLimit = this.getMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
        for (let n = 1; n <= this.engineData.engineCount; n++) {
            if (((_b = (_a = this.throttleLeverPosition[n]) === null || _a === void 0 ? void 0 : _a.get()) !== null && _b !== void 0 ? _b : Infinity) < refLimit) {
                return true;
            }
        }
        return false;
    }
    /**
     * Attempts to prime RETARD mode. RETARD mode can be primed if the airplane's altitude is greater than or equal to 50
     * feet AGL.
     * @param radarAltitude The airplane's current radar altitude, in feet.
     * @returns Whether RETARD mode was successfully primed.
     */
    tryPrimeRetard(radarAltitude) {
        const isRadarAltInvalid = isNaN(radarAltitude);
        if (isRadarAltInvalid) {
            this.isRetardPrimed = false;
        }
        else {
            this.isRetardPrimed || (this.isRetardPrimed = radarAltitude >= BoeingAutothrottle.RETARD_THRESHOLD_ALTITUDE);
        }
        this.isRetardFailed.set(isRadarAltInvalid);
        return this.isRetardPrimed;
    }
    /**
     * Attempts to activate RETARD mode. RETARD mode can be activated if it is primed and the airplane's altitude is less
     * than 50 feet AGL.
     * @param radarAltitude The airplane's current radar altitude, in feet.
     * @returns Whether RETARD mode was successfully activated.
     */
    tryActivateRetard(radarAltitude) {
        if (this.isRetardPrimed && !isNaN(radarAltitude) && radarAltitude < BoeingAutothrottle.RETARD_THRESHOLD_ALTITUDE) {
            const time = Date.now();
            const dt = time - this.lastLandingFilterTime;
            this.lastLandingFilterTime = time;
            const vs = SimVar.GetSimVarValue('VELOCITY WORLD Y', SimVarValueType.FPM) / 60;
            const timeToLand = this.landingTimeFilter.next(this.radarAlt.get() / -vs, dt);
            if (timeToLand < BoeingAutothrottle.RETARD_ACTIVATE_THRESHOLD) {
                this.activeMode.set(BoeingAutothrottleModes.RETARD);
                return true;
            }
        }
        this.landingTimeFilter.reset();
        return false;
    }
    /**
     * Attempts to automatically disengage the autothrottle after the airplane has been on the ground for five seconds.
     * @param dt The elapsed time, in milliseconds, since the last update.
     * @returns Whether the autothrottle was disengaged.
     */
    tryAutoGroundDisengage(dt) {
        if (this.isOnGround.get() && this.isApVerticalModeTo.get() === false) {
            this.autoGroundDisengagePrimedDuration += dt;
            if (this.autoGroundDisengagePrimedDuration >= BoeingAutothrottle.AUTO_GROUND_DISENGAGE_DELAY) {
                this.deactivate(false);
                return true;
            }
        }
        else {
            this.autoGroundDisengagePrimedDuration = 0;
        }
        return false;
    }
    /**
     * Try to activate the descent hold mode when at the desired thrust
     * @param targetThrust Target thrust if not idle, otherwise idle is assumed
     * @returns True if hold mode was activated
     */
    tryActivateDescentHold(targetThrust) {
        if (targetThrust) {
            if (this.isThrustAtTarget(targetThrust)) {
                this.activeMode.set(BoeingAutothrottleModes.DESCENT_HOLD);
                return true;
            }
        }
        else if (this.isThrustAtIdle()) {
            this.activeMode.set(BoeingAutothrottleModes.DESCENT_HOLD);
            return true;
        }
        return false;
    }
    /**
     * Gets the Target Takeoff N1 value from the performance tables based on selected climb program.
     * @returns the Target Takeoff N1 Value.
     */
    getTakeoffN1() {
        return this.getMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
    }
    /**
     * Gets the Target Climb N1 value from the performance tables based on selected climb program.
     * @returns the Target Climb N1 Value.
     */
    getClimbN1() {
        return this.getMaxN1FromThrustReferenceMode(this.thrustManager.activeThrustMode.get());
    }
    /**
     * Gets the Target Go-Around N1 value from the performance tables based on selected climb program.
     * @returns the Target Go-Around N1 Value.
     */
    getGoAroundN1() {
        return this.engineData.getGaMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
    }
    /**
     * Gets the Target Max Continuious N1 value from the performance tables based on selected climb program.
     * @returns the Target Max Continuious N1 Value.
     */
    getMaxConN1() {
        return this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
    }
    /**
     * Computes the thrust required for a minimum climb rate up to the GA thrust limit
     * @returns The required thrust, or the GA thrust limit if lower
     */
    getGoAroundThrN1() {
        const limit = this.engineData.getGaMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
        const tas = UnitType.KNOT.convertFrom(AeroMath.casToTasIsa(UnitType.KNOT.convertTo(this.atTargetCas.get(), UnitType.MPS), UnitType.FOOT.convertTo(this.pressureAlt.get(), UnitType.METER), this.isaDelta.get()), UnitType.MPS);
        const cn1Target = this.performanceProvider.calculateCorrectedN1ForVerticalSpeed(BoeingAutothrottle.GO_AROUND_CLIMB_RATE * 1.1, tas, this.grossWeight.get(), this.enginesAvailable.get(), this.pressureAlt.get(), this.isaDelta.get(), this.flapIndex.get());
        return Math.min(limit, cn1Target);
    }
    /**
     * Computes the thrust required for an early descent at -1250 fpm
     * @returns The required thrust
     */
    getDescentThrN1() {
        const limit = this.getClimbN1();
        const tas = UnitType.KNOT.convertFrom(AeroMath.casToTasIsa(UnitType.KNOT.convertTo(this.atTargetCas.get(), UnitType.MPS), UnitType.FOOT.convertTo(this.pressureAlt.get(), UnitType.METER), this.isaDelta.get()), UnitType.MPS);
        const cn1Target = this.performanceProvider.calculateCorrectedN1ForVerticalSpeed(BoeingAutothrottle.EARLY_DESCENT_RATE, tas, this.grossWeight.get(), this.enginesAvailable.get(), this.pressureAlt.get(), this.isaDelta.get(), 0);
        return Math.min(limit, cn1Target);
    }
    /**
     * Gets the Max N1 value from the performance tables based on selected Thrust Reference Mode.
     * @param mode The selected thrust mode (null value returns TO N1).
     * @returns the Max N1 Value.
     */
    getMaxN1FromThrustReferenceMode(mode) {
        var _a, _b, _c;
        switch (mode) {
            case TakeoffThrustMode.TO:
                return this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.TO1:
                return this.engineData.getTo1N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.TO2:
                return this.engineData.getTo2N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case TakeoffThrustMode.DTO:
                return this.engineData.getToMaxN1(this.pressureAlt.get(), (_a = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _a !== void 0 ? _a : this.totalAirTemp.get());
            case TakeoffThrustMode.DTO1:
                return this.engineData.getTo1N1(this.pressureAlt.get(), (_b = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _b !== void 0 ? _b : this.totalAirTemp.get());
            case TakeoffThrustMode.DTO2:
                return this.engineData.getTo2N1(this.pressureAlt.get(), (_c = this.thrustManager.activePerfPlan.takeoffAssumedTemp.get()) !== null && _c !== void 0 ? _c : this.totalAirTemp.get());
            case ClimbThrustMode.CLB:
                return this.engineData.getClbMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case ClimbThrustMode.CLB1:
                return this.engineData.getClb1N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case ClimbThrustMode.CLB2:
                return this.engineData.getClb2N1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CRZ:
                return this.engineData.getCruiseMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.CON:
                return this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
            case AirborneThrustMode.GA:
                return this.engineData.getGaMaxN1(this.pressureAlt.get(), this.totalAirTemp.get());
            default:
                return this.isOnGround.get() ? this.engineData.getToMaxN1(this.pressureAlt.get(), this.totalAirTemp.get())
                    : this.engineData.getMaxConN1(this.pressureAlt.get(), this.totalAirTemp.get());
        }
    }
    /**
     * Destroys this autothrottle.
     */
    destroy() {
        var _a, _b, _c, _d, _e, _f, _g;
        this.isAlive = false;
        this.autothrottle.destroy();
        // this.casAlertTransporters.forEach(transporter => { transporter.destroy(); });
        this.isOnGround.destroy();
        this.indicatedAlt.destroy();
        this.selectedAlt.destroy();
        this.ambientPressure.destroy();
        this.ambientTemp.destroy();
        this.isaTemp.destroy();
        this.grossWeight.destroy();
        this.enginesAvailable.destroy();
        this.fmsOperatingPhase.destroy();
        this.atIasTarget.destroy();
        this.atMachTarget.destroy();
        this.atTargetIsMach.destroy();
        this.vnavPathSpeedMin.destroy();
        Object.values(this.fadecMode).forEach((m) => m.destroy());
        Object.values(this.fadecClbN1).forEach((m) => m.destroy());
        Object.values(this.fadecTgtN1).forEach((m) => m.destroy());
        Object.values(this.engineN1).forEach((m) => m.destroy());
        this.engineOut.destroy();
        Object.values(this.throttleLeverPosition).forEach((m) => m.destroy());
        this.flapIndex.destroy();
        this.flapPosition.destroy();
        this.flapSpeedLimit.destroy();
        this.gearNosePosition.destroy();
        this.gearLeftPosition.destroy();
        this.gearRightPosition.destroy();
        (_a = this.avionicsGlobalPowerSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.radarAltSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.radarAltimeterStateSub) === null || _c === void 0 ? void 0 : _c.destroy();
        (_d = this.pressureAltSub) === null || _d === void 0 ? void 0 : _d.destroy();
        (_e = this.adcStateSub) === null || _e === void 0 ? void 0 : _e.destroy();
        (_f = this.hEventSub) === null || _f === void 0 ? void 0 : _f.destroy();
        (_g = this.updateSub) === null || _g === void 0 ? void 0 : _g.destroy();
    }
}
BoeingAutothrottle.UPDATE_FREQ = 60; // hertz
BoeingAutothrottle.OPTIONS = {
    servoSpeed: 0.2,
    speedSmoothingConstant: 4 / Math.LN2,
    speedSmoothingVelocityConstant: 4 / Math.LN2,
    speedLookahead: 2,
    selectedSpeedAccelTarget: iasError => {
        const sign = iasError < 0 ? -1 : 1;
        return sign * MathUtils.lerp(iasError * sign, 0.5, 30, 0, 3, true, true);
    },
    accelSmoothingConstant: 1 / Math.LN2,
    accelTargetSmoothingConstant: 0.5 / Math.LN2,
    powerSmoothingConstant: 1 / Math.LN2,
    powerLookahead: 0,
    powerTargetSmoothingConstant: 1 / Math.LN2,
    hysteresis: 0.005,
    speedTargetPid: {
        kP: 5,
        kI: 0,
        kD: 15,
        maxOut: 50,
        minOut: -50
    },
    powerTargetPid: {
        kP: 0.01,
        kI: 0,
        kD: 0.015,
        maxOut: 0.2,
        minOut: -0.2
    },
    speedTargetChangeThreshold: 5,
    overspeedChangeThreshold: 5,
    underspeedChangeThreshold: 5
};
/** FADEC modes that prevent autothrottle arming and activation. */
BoeingAutothrottle.UNSUPPORTED_FADEC_MODES = [
    BoeingFadecModes.STOP,
    BoeingFadecModes.START,
    BoeingFadecModes.UNDEF,
    BoeingFadecModes.TR
];
/** The minimum throttle lever position required to activate HOLD mode from an armed state. */
BoeingAutothrottle.THROTTLE_LEVER_ACTIVATE_THRESHOLD = 0.95;
/** The minimum throttle lever change required to activate the levers in HOLD mode. */
BoeingAutothrottle.HOLD_THROTTLE_LEVER_ACTIVATION_THRESHOLD = 0.02;
BoeingAutothrottle.HOLD_THRESHOLD_ALTITUDE = 400; // feet AGL
BoeingAutothrottle.HOLD_MAX_DURATION = 90000; // milliseconds
/** the maximum radio height at which retard can activate */
BoeingAutothrottle.RETARD_THRESHOLD_ALTITUDE = 50; // feet AGL
BoeingAutothrottle.RETARD_OVERTIME_THRESHOLD = 30000; // milliseconds
/** seconds to landing (0 feet RA) at which retard activates */
BoeingAutothrottle.RETARD_ACTIVATE_THRESHOLD = 2.2;
BoeingAutothrottle.AUTO_GROUND_DISENGAGE_DELAY = 5000; // milliseconds
BoeingAutothrottle.TO_ARM_MAX_SPEED = 50; // knots GS
BoeingAutothrottle.TO_HOLD_ENGAGE_SPEED = 80; // knots GS
/** hysteresis for considering the speed to be on path in knots */
BoeingAutothrottle.TARGET_SPEED_HYSTERESIS = 3;
/** The minimum offset above 1g stall speed at which the stick shaker activates in knots, 3 knots is specified by regulation */
BoeingAutothrottle.STICK_SHAKER_MINIMUM_OFFSET = 3;
/** The minimum proportion of 1g stall speed at which the stick shaker activates, 3% is specified by regulation*/
BoeingAutothrottle.STICK_SHAKER_MINIMUM_PROPORTION = 1.03;
/** The underspeed protection angle of attack limit. */
BoeingAutothrottle.UNDERSPEED_PROTECTION_AOA = 0.9;
BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_LOOKAHEAD = 10000; // milliseconds
BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_INPUT_TAU = 2000; // milliseconds
BoeingAutothrottle.ENVELOPE_SPEED_PROTECTION_TREND_TAU = 1000; // milliseconds
/** The maximum amount of time landing phase can be active, in milliseconds. */
BoeingAutothrottle.LANDING_PHASE_MAX_TIME = 90000;
/** The maximum amount of time the airplane can be on the ground before landing phase cannot be active, in milliseconds. */
BoeingAutothrottle.LANDING_PHASE_MAX_GROUND_TIME = 30000;
/** The maximum allowed radar altitude, in feet, while landing phase is active . */
BoeingAutothrottle.LANDING_PHASE_MAX_RADAR_ALT = 500;
/** The radar altitude, in feet, at which crossing from above to below activates landing phase. */
BoeingAutothrottle.LANDING_PHASE_RADAR_ALT_THRESHOLD = 400;
/** The minimum climb rate required in GA THR mode (first press of TOGA during approach) */
BoeingAutothrottle.GO_AROUND_CLIMB_RATE = 2000;
/** The descent rate required in for early descent */
BoeingAutothrottle.EARLY_DESCENT_RATE = -1250;
/**
 * The decay time constant for cumulative throttle lever position displacement used to determine if the autothrottle
 * should be disconnected due to user force override.
 */
BoeingAutothrottle.FORCE_DC_DISPLACEMENT_DECAY_TAU = 500 / Math.LN2;
/** The throttle lever position displacement credit to assign to increase/decrease throttle key events. */
BoeingAutothrottle.FORCE_DC_INC_DEC_DISPLACEMENT = 0.02;
/** The amount of cumulative throttle lever position displacement required to override the autothrottle. */
BoeingAutothrottle.FORCE_OVERRIDE_DISPLACEMENT_THRESHOLD = 0.2;
/** The amount of time a manual override will disable the servos (in ms). */
BoeingAutothrottle.SERVO_OVERRIDE_TIME = 10000;
BoeingAutothrottle.STATUS_SIMVAR_ENUM_MAP = {
    [BoeingAutothrottleStatus.Off]: 0,
    [BoeingAutothrottleStatus.Disconnected]: 1,
    [BoeingAutothrottleStatus.Armed]: 2,
    [BoeingAutothrottleStatus.On]: 3
};

/**
 * Manager of Boeing Thrust Reference Modes
 */
class BoeingThrustModeManager {
    /**
     * Construct a Thrust Mode Manager.
     * @param bus The Event Bus.
     * @param activePerfPlan The Perf Plan.
     */
    constructor(bus, activePerfPlan) {
        this.bus = bus;
        this.activePerfPlan = activePerfPlan;
        this.fmsOperatingPhase = ConsumerSubject.create(null, FmsOperatingPhase.PREFLIGHT);
        this.fadecPublisher = this.bus.getPublisher();
        this.activeThrustMode = Subject.create(TakeoffThrustMode.TO);
        this.activeThrustMode.sub(mode => {
            this.thrustModeChanged(mode);
        }, true);
        this.activePerfPlan.takeoffThrustMode.sub(v => {
            const operatingPhase = this.fmsOperatingPhase.get();
            if (operatingPhase === FmsOperatingPhase.TAKEOFF || operatingPhase === FmsOperatingPhase.PREFLIGHT) {
                this.changeThrustMode(v);
            }
        });
        this.activePerfPlan.climbThrustMode.sub(v => {
            const operatingPhase = this.fmsOperatingPhase.get();
            if (operatingPhase === FmsOperatingPhase.CLIMB) {
                this.changeThrustMode(v);
            }
        });
        this.activePerfPlan.takeoffAssumedTemp.sub(v => {
            this.fadecPublisher.pub('fadec_assumed_temp', v, true, true);
        });
        this.fmsOperatingPhase.setConsumer(this.bus.getSubscriber().on('fms_operating_phase'));
        this.fmsOperatingPhase.sub(this.fmsOperatingPhaseChanged.bind(this), true);
        const subs = this.bus.getSubscriber();
        subs.on('thrust_control_activate_mode').handle((mode) => this.changeThrustMode(mode));
        subs.on('thrust_control_remove_derates').handle(() => this.removeThrustDerates());
    }
    /**
     * Changes the Thrust Reference Mode based on Fms Operating Phase changes.
     * @param phase The new FmsOperatingPhase.
     */
    fmsOperatingPhaseChanged(phase) {
        switch (phase) {
            case FmsOperatingPhase.PREFLIGHT:
            case FmsOperatingPhase.TAKEOFF:
                this.changeThrustMode(this.activePerfPlan.takeoffThrustMode.get());
                break;
            case FmsOperatingPhase.CLIMB:
                this.changeThrustMode(this.getArmedClimbThrustMode());
                break;
            case FmsOperatingPhase.CRUISE:
            case FmsOperatingPhase.DESCENT:
                this.changeThrustMode(AirborneThrustMode.CRZ);
                break;
            case FmsOperatingPhase.APPROACH:
            case FmsOperatingPhase.COMPLETE:
                this.changeThrustMode(AirborneThrustMode.GA);
                break;
        }
    }
    /**
     * Changes the Thrust Reference Mode in the Perf Plan.
     * @param mode The ThrustMode to set as active.
     */
    changeThrustMode(mode) {
        this.activeThrustMode.set(mode);
    }
    /**
     * Gets the currently armed/selected climb thrust mode.
     * @returns the current armed mode
     */
    getArmedClimbThrustMode() {
        return this.activePerfPlan.climbThrustMode.get();
    }
    /**
     * Publish changes to the current thrust mode via event bus <BoeingFadecEvents>.
     * @param mode The ThrustMode to publish as active.
     */
    thrustModeChanged(mode) {
        this.fadecPublisher.pub('fadec_thrust_mode', mode, true, true);
    }
    /**
     * Removes thrust derates from the active perf plan and sets the correct non-derated thrust immediatly.
     */
    removeThrustDerates() {
        this.activePerfPlan.climbThrustMode.set(ClimbThrustMode.CLB);
        this.activePerfPlan.takeoffThrustMode.set(TakeoffThrustMode.TO);
        switch (this.activeThrustMode.get()) {
            case TakeoffThrustMode.TO1:
            case TakeoffThrustMode.TO2:
            case TakeoffThrustMode.DTO:
            case TakeoffThrustMode.DTO1:
            case TakeoffThrustMode.DTO2:
                this.changeThrustMode(TakeoffThrustMode.TO);
                break;
            case ClimbThrustMode.CLB1:
            case ClimbThrustMode.CLB2:
                this.changeThrustMode(ClimbThrustMode.CLB);
                break;
        }
    }
}

var FmcCrewAlertIDs;
(function (FmcCrewAlertIDs) {
    FmcCrewAlertIDs["FmcMessage"] = "78-fmc-message";
})(FmcCrewAlertIDs || (FmcCrewAlertIDs = {}));

/**
 * A default implementation of {@link AoaDataProvider}.
 */
class DefaultAoaDataProvider {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param aoaIndex The index of the AoA computer that is the source of this provider's data.
     * @param adcIndex The index of the ADC that is the source of this provider's data.
     */
    constructor(bus, aoaIndex, adcIndex) {
        this.bus = bus;
        this._aoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.aoa = this._aoa;
        this._normAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.normAoa = this._normAoa;
        this._stallAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.stallAoa = this._stallAoa;
        this._zeroLiftAoa = ConsumerSubject.create(null, 0);
        /** @inheritdoc */
        this.zeroLiftAoa = this._zeroLiftAoa;
        this.ias = ConsumerValue.create(null, 0);
        this._isOnGround = ConsumerSubject.create(null, false);
        /** @inheritdoc */
        this.isOnGround = this._isOnGround;
        this.aoaCoefSmoother = new ExpSmoother(DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU);
        this._normAoaIasCoef = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef = this._normAoaIasCoef;
        this._normAoaIasCoef1g = Subject.create(null);
        /** @inheritdoc */
        this.normAoaIasCoef1g = this._normAoaIasCoef1g;
        this._isDataFailed = Subject.create(false);
        /** @inheritdoc */
        this.isDataFailed = this._isDataFailed;
        this.loadFactorSource = ConsumerValue.create(null, 1);
        this.loadFactorSmoother = new ExpSmoother(DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU);
        this.loadFactor = 1;
        this.aoaSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.adcSystemState = ConsumerSubject.create(null, { previous: undefined, current: undefined });
        this.isAdcDataFailed = false;
        this.isInit = false;
        this.isAlive = true;
        this.isPaused = false;
        this.aoaIndex = SubscribableUtils.toSubscribable(aoaIndex, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
    }
    /**
     * Initializes this data provider. Once initialized, this data provider will continuously update its data until
     * paused or destroyed.
     * @param paused Whether to initialize this data provider as paused. If `true`, this data provider will provide an
     * initial set of data but will not update the provided data until it is resumed. Defaults to `false`.
     * @throws Error if this data provider is dead.
     */
    init(paused = false) {
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot initialize a dead provider');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.isPaused = paused;
        const sub = this.bus.getSubscriber();
        this._isOnGround.setConsumer(sub.on('on_ground'));
        this.aoaIndexSub = this.aoaIndex.sub(index => {
            this._aoa.setConsumer(sub.on(`aoa_aoa_${index}`));
            this._normAoa.setConsumer(sub.on(`aoa_norm_aoa_${index}`));
            this._stallAoa.setConsumer(sub.on(`aoa_stall_aoa_${index}`));
            this._zeroLiftAoa.setConsumer(sub.on(`aoa_zero_lift_aoa_${index}`));
            this.loadFactorSource.setConsumer(sub.on(`aoa_load_factor_${index}`));
            this.aoaSystemState.setConsumer(sub.on(`aoa_state_${index}`));
        }, true);
        this.adcIndexSub = this.adcIndex.sub(index => {
            this.ias.setConsumer(sub.on(`adc_ias_${index}`));
            this.adcSystemState.setConsumer(sub.on(`adc_state_${index}`));
        }, true);
        this.aoaSystemState.sub(state => {
            if (state.current === undefined || state.current === AvionicsSystemState.On) {
                this._isDataFailed.set(false);
            }
            else {
                this._isDataFailed.set(true);
            }
        }, true);
        this.adcSystemState.sub(state => {
            this.isAdcDataFailed = !(state.current === undefined || state.current === AvionicsSystemState.On);
        }, true);
        this.clockSub = sub.on('realTime').handle(this.update.bind(this));
        if (paused) {
            this.pause();
        }
    }
    /** @inheritdoc */
    aoaToNormAoa(aoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return (aoa - zeroLiftAoa) / (this._stallAoa.get() - zeroLiftAoa);
    }
    /** @inheritdoc */
    normAoaToAoa(normAoa) {
        const zeroLiftAoa = this._zeroLiftAoa.get();
        return normAoa * (this._stallAoa.get() - zeroLiftAoa) + zeroLiftAoa;
    }
    /** @inheritdoc */
    estimateIasFromAoa(aoa, loadFactor) {
        return this.estimateIasFromNormAoa(this.aoaToNormAoa(aoa), loadFactor);
    }
    /** @inheritdoc */
    estimateIasFromNormAoa(normAoa, loadFactor) {
        var _a;
        const ratio = loadFactor === undefined ? 1 : loadFactor / this.loadFactor;
        return Math.sqrt(((_a = this._normAoaIasCoef.get()) !== null && _a !== void 0 ? _a : NaN) * ratio / normAoa);
    }
    /**
     * Resumes this data provider. Once resumed, this data provider will continuously update its data until paused or
     * destroyed.
     * @throws Error if this data provider is dead.
     */
    resume() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot resume a dead provider');
        }
        if (!this.isPaused) {
            return;
        }
        this.isPaused = false;
        this._aoa.resume();
        this._normAoa.resume();
        this._stallAoa.resume();
        this._zeroLiftAoa.resume();
        this.loadFactorSource.resume();
        this.ias.resume();
        this._isOnGround.resume();
        this.aoaSystemState.resume();
        this.adcSystemState.resume();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.resume(true);
    }
    /**
     * Pauses this data provider. Once paused, this data provider will not update its data until it is resumed.
     * @throws Error if this data provider is dead.
     */
    pause() {
        var _a;
        if (!this.isAlive) {
            throw new Error('DefaultAoaDataProvider: cannot pause a dead provider');
        }
        if (this.isPaused) {
            return;
        }
        this._aoa.pause();
        this._normAoa.pause();
        this._stallAoa.pause();
        this._zeroLiftAoa.pause();
        this.loadFactorSource.pause();
        this.ias.pause();
        this._isOnGround.pause();
        this.aoaSystemState.pause();
        this.adcSystemState.pause();
        (_a = this.clockSub) === null || _a === void 0 ? void 0 : _a.pause();
        this.lastUpdateTime = undefined;
        this.aoaCoefSmoother.reset();
        this.loadFactorSmoother.reset();
        this.isPaused = true;
    }
    /**
     * Updates this data provider.
     * @param time The current real (operating system) time, as a UNIX timestamp in milliseconds.
     */
    update(time) {
        if (this._isDataFailed.get() || this.isAdcDataFailed || this._isOnGround.get()) {
            this._normAoaIasCoef.set(null);
            this.loadFactor = 1;
            this.aoaCoefSmoother.reset();
            this.loadFactorSmoother.reset();
            this.lastUpdateTime = undefined;
            return;
        }
        const dt = this.lastUpdateTime === undefined ? 0 : Math.max(0, time - this.lastUpdateTime);
        this.lastUpdateTime = time;
        const normAoa = this._normAoa.get();
        const ias = this.ias.get();
        const iasSquared = ias * ias;
        const coef = normAoa * iasSquared;
        this._normAoaIasCoef.set(this.aoaCoefSmoother.next(coef, dt));
        this.loadFactor = this.loadFactorSmoother.next(this.loadFactorSource.get(), dt);
    }
    /**
     * Destroys this data provider. Once destroyed, this data provider will no longer update its provided data, and can
     * no longer be paused or resumed.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        this._aoa.destroy();
        this._normAoa.destroy();
        this._stallAoa.destroy();
        this._zeroLiftAoa.destroy();
        this.loadFactorSource.destroy();
        this.ias.destroy();
        this._isOnGround.destroy();
        this.aoaSystemState.destroy();
        this.adcSystemState.destroy();
        (_a = this.aoaIndexSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.adcIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.clockSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}
DefaultAoaDataProvider.AOA_COEF_SMOOTHING_TAU = 2000 / Math.LN2;
DefaultAoaDataProvider.LOAD_FACTOR_SMOOTHING_TAU = 2000 / Math.LN2;

/** Bitflags that describe which map waypoint types should be displayed. */
var MapWaypointsDisplay;
(function (MapWaypointsDisplay) {
    MapWaypointsDisplay[MapWaypointsDisplay["None"] = 0] = "None";
    MapWaypointsDisplay[MapWaypointsDisplay["NearestAirports"] = 1] = "NearestAirports";
    MapWaypointsDisplay[MapWaypointsDisplay["HiNavaids"] = 2] = "HiNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["LoNavaids"] = 4] = "LoNavaids";
    MapWaypointsDisplay[MapWaypointsDisplay["Intersections"] = 8] = "Intersections";
    MapWaypointsDisplay[MapWaypointsDisplay["TerminalWaypoints"] = 16] = "TerminalWaypoints";
    MapWaypointsDisplay[MapWaypointsDisplay["ETA"] = 32] = "ETA";
    MapWaypointsDisplay[MapWaypointsDisplay["Speed"] = 64] = "Speed";
    MapWaypointsDisplay[MapWaypointsDisplay["Altitude"] = 128] = "Altitude";
    MapWaypointsDisplay[MapWaypointsDisplay["Airports"] = 256] = "Airports";
    MapWaypointsDisplay[MapWaypointsDisplay["NDBs"] = 512] = "NDBs";
    MapWaypointsDisplay[MapWaypointsDisplay["MissedApproach"] = 1024] = "MissedApproach";
})(MapWaypointsDisplay || (MapWaypointsDisplay = {}));
/**
 * Priorities for map labels on Boeings maps.
 * Higher numbers are rendered oin top of lower numbers if drawn on same canvas.
 */
var BoeingMapLabelPriority;
(function (BoeingMapLabelPriority) {
    BoeingMapLabelPriority[BoeingMapLabelPriority["TopOfDescent"] = 9999] = "TopOfDescent";
    BoeingMapLabelPriority[BoeingMapLabelPriority["FlightPlan"] = 999] = "FlightPlan";
    BoeingMapLabelPriority[BoeingMapLabelPriority["AirportsRunways"] = 10] = "AirportsRunways";
    BoeingMapLabelPriority[BoeingMapLabelPriority["Bottom"] = 0] = "Bottom";
})(BoeingMapLabelPriority || (BoeingMapLabelPriority = {}));
/**
 * Priorities for map waypoint icons on Boeings maps.
 * Higher numbers are rendered oin top of lower numbers if drawn on same canvas.
 */
var BoeingMapWaypointIconPriority;
(function (BoeingMapWaypointIconPriority) {
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["TopOfDescent"] = 9999] = "TopOfDescent";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["FlightPlan"] = 999] = "FlightPlan";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["AirportsRunways"] = 10] = "AirportsRunways";
    BoeingMapWaypointIconPriority[BoeingMapWaypointIconPriority["Bottom"] = 0] = "Bottom";
})(BoeingMapWaypointIconPriority || (BoeingMapWaypointIconPriority = {}));
/** Features that a map format can support. */
var MapFormatFeatures;
(function (MapFormatFeatures) {
    MapFormatFeatures[MapFormatFeatures["None"] = 0] = "None";
    MapFormatFeatures[MapFormatFeatures["Weather"] = 1] = "Weather";
    MapFormatFeatures[MapFormatFeatures["Terrain"] = 2] = "Terrain";
    MapFormatFeatures[MapFormatFeatures["AltitudeArc"] = 4] = "AltitudeArc";
    MapFormatFeatures[MapFormatFeatures["PositionTrendVector"] = 8] = "PositionTrendVector";
})(MapFormatFeatures || (MapFormatFeatures = {}));
({
    rotationType: 'HdgOrTrkUp',
    ownAirplaneIconRotationType: MapOwnAirplaneIconOrientation.MapUp,
    features: MapFormatFeatures.Terrain | MapFormatFeatures.Weather | MapFormatFeatures.AltitudeArc | MapFormatFeatures.PositionTrendVector,
});
({
    rotationType: MapRotation.NorthUp,
    ownAirplaneIconRotationType: MapOwnAirplaneIconOrientation.HeadingUp,
    features: MapFormatFeatures.None,
});

/** A publisher that publishes Citation Longitude FADEC simvar events. */
class BoeingFadecPublisher extends SimVarPublisher {
    /**
     * Creates an instance of the CJ4FadecPublisher.
     * @param bus The event bus to use with this instance.
     * @param engineCount The number of engines on the plane
     */
    constructor(bus, engineCount) {
        const simvars = new Map();
        // eslint-disable-next-line jsdoc/require-jsdoc
        const indexedSimVars = {
            'fadec_idle_n1': { name: BoeingFadecLVars.FADEC_IDLE_N1, type: SimVarValueType.Percent },
            'fadec_idle_n2': { name: BoeingFadecLVars.FADEC_IDLE_N2, type: SimVarValueType.Percent },
            'fadec_ref_n1': { name: BoeingFadecLVars.FADEC_REF_N1, type: SimVarValueType.Percent },
            'fadec_target_n1': { name: BoeingFadecLVars.FADEC_TGT_N1, type: SimVarValueType.Percent },
            'fadec_ref_tpr': { name: BoeingFadecLVars.FADEC_REF_TPR, type: SimVarValueType.Percent },
            'fadec_target_tpr': { name: BoeingFadecLVars.FADEC_TGT_TPR, type: SimVarValueType.Percent },
            'fadec_clb_n1': { name: BoeingFadecLVars.FADEC_CLB_N1, type: SimVarValueType.Percent },
            'fadec_cru_n1': { name: BoeingFadecLVars.FADEC_CRU_N1, type: SimVarValueType.Percent },
            'fadec_n1_redline': { name: BoeingFadecLVars.FADEC_N1_RED, type: SimVarValueType.Percent },
            'fadec_n1_amberline': { name: BoeingFadecLVars.FADEC_N1_AMBER, type: SimVarValueType.Percent },
            'fadec_n2_redline': { name: BoeingFadecLVars.FADEC_N2_RED, type: SimVarValueType.Percent },
            'fadec_n2_amberline': { name: BoeingFadecLVars.FADEC_N2_AMBER, type: SimVarValueType.Percent },
            'fadec_egt_startline': { name: BoeingFadecLVars.FADEC_EGT_START_LIMIT, type: SimVarValueType.Celsius },
            'fadec_egt_amberline': { name: BoeingFadecLVars.FADEC_EGT_AMBER, type: SimVarValueType.Celsius },
            'fadec_egt_redline': { name: BoeingFadecLVars.FADEC_EGT_RED, type: SimVarValueType.Celsius },
            'fadec_oil_temp_low_redline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_LOW_RED, type: SimVarValueType.Celsius },
            'fadec_oil_temp_low_amberline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_LOW_AMBER, type: SimVarValueType.Celsius },
            'fadec_oil_temp_high_amberline': { name: BoeingFadecLVars.FADEC_OIL_TEMP_HIGH_AMBER, type: SimVarValueType.Celsius },
            'fadec_eng_start_state': { name: BoeingFadecLVars.FADEC_ENG_START_STATE, type: SimVarValueType.Number },
        };
        for (let i = 1; i <= engineCount; i++) {
            for (const [topic, simvar] of Object.entries(indexedSimVars)) {
                simvars.set(`${topic}_${i}`, {
                    name: `${simvar.name}_${i}`,
                    type: simvar.type,
                });
            }
        }
        super(simvars, bus);
    }
}

/**
 * FMS positioning system data modes.
 */
var FmsPositionMode;
(function (FmsPositionMode) {
    /** No position data is available. */
    FmsPositionMode["None"] = "None";
    /** Position data is sourced from GPS. */
    FmsPositionMode["Gps"] = "Gps";
    /** Position data is sourced from DME/DME. */
    FmsPositionMode["Dme"] = "Dme";
    /** Position data is sourced from HNS (hybrid inertial navigation). */
    FmsPositionMode["Hns"] = "Hns";
    /** Position data is sourced from dead reckoning. */
    FmsPositionMode["DeadReckoning"] = "DeadReckoning";
    /** Position data is sourced from dead reckoning and more than 20 minutes have elapsed since the last accurate position fix. */
    FmsPositionMode["DeadReckoningExpired"] = "DeadReckoningExpired";
})(FmsPositionMode || (FmsPositionMode = {}));
/**
 * A Boeing FMS geo-positioning system.
 */
class FmsPositionSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an FMS geo-positioning system.
     * @param index The index of the FMS geo-positioning system.
     * @param bus An instance of the event bus.
     * @param gpsReceiverIndex The index of the GPS receiver used by this system. No GPS data will be used if the index
     * is negative.
     * @param adcIndex The index of the ADC used by this system in dead reckoning mode to obtain airspeed data.
     * @param ahrsIndex The index of the AHRS used by this system in dead reckoning mode to obtain heading data.
     * @param hnsIndex The index of the HNS used by this system. No HNS data will be used if the index is negative.
     * Defaults to `-1`.
     * @param dmeIndex The index of the DME/DME navigation system used by this system. No DME/DME data will be used if
     * the index is negative. Defaults to `-1`.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsReceiverIndex, adcIndex, ahrsIndex, hnsIndex, dmeIndex, powerSource) {
        super(index, bus, `fms_pos_state_${index}`);
        this.initializationTime = 0;
        this.gnssDataSourceTopicMap = {
            [`fms_pos_gps-position_${this.index}`]: 'gps-position',
            [`fms_pos_ground_speed_${this.index}`]: 'ground_speed',
            [`fms_pos_track_deg_true_${this.index}`]: 'track_deg_true',
            [`fms_pos_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.modeTopic = `fms_pos_mode_${this.index}`;
        this.gpsIndexTopic = `fms_pos_gps_index_${this.index}`;
        this.hnsIndexTopic = `fms_pos_hns_index_${this.index}`;
        this.iruAnpTopic = `fms_pos_iru_anp_${this.index}`;
        this.gpsAnpTopic = `fms_pos_gps_anp_${this.index}`;
        this.radioAnpTopic = `fms_pos_radio_anp_${this.index}`;
        this.anpTopic = `fms_pos_anp_${this.index}`;
        this.verticalAnpTopic = `fms_pos_vertical_anp_${this.index}`;
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.simTime = ConsumerSubject.create(this.bus.getSubscriber().on('simTime'), 0);
        this.gpsStateSource = ConsumerSubject.create(null, GPSSystemState.Searching);
        this.gpsState = Subject.create(GPSSystemState.Searching);
        this.gpsPdop = ConsumerSubject.create(null, -1);
        this.gpsGroundSpeed = ConsumerSubject.create(null, -1);
        this.adcSystemState = ConsumerSubject.create(null, null);
        this.pressureAlt = ConsumerSubject.create(null, 0);
        this.pitch = 0;
        /** filtered pitch rate in degrees per second */
        this.pitchRate = Subject.create(0);
        this.verticalAnp = MappedSubject.create(([zp, pitchRate]) => MathUtils.round(MathUtils.clamp(2.6 * zp ** 3 * Math.pow(10, -12) + 49, 49, 169) + 6 * Math.abs(pitchRate)), this.pressureAlt, this.pitchRate);
        this.mode = FmsPositionMode.None;
        this.lastFixTime = undefined;
        this.gpsIndex = SubscribableUtils.toSubscribable(gpsReceiverIndex, true);
        this.hnsIndex = SubscribableUtils.toSubscribable(-1, true);
        this.dmeIndex = SubscribableUtils.toSubscribable(-1, true);
        this.adcIndex = SubscribableUtils.toSubscribable(adcIndex, true);
        this.ahrsIndex = SubscribableUtils.toSubscribable(ahrsIndex, true);
        this.publisher.pub(this.modeTopic, this.mode, false, true);
        this.publisher.pub(this.iruAnpTopic, -1, false, true);
        this.publisher.pub(this.gpsAnpTopic, -1, false, true);
        this.publisher.pub(this.radioAnpTopic, -1, false, true);
        this.publisher.pub(this.anpTopic, -1, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.gnssDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onGnssTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.gnssDataSourceTopicMap) {
                this.onGnssTopicSubscribed(topic);
            }
        });
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.gpsIndex.sub(index => this.publisher.pub(this.gpsIndexTopic, index, false, true), !paused, paused));
        this.dataSubs.push(this.hnsIndex.sub(index => this.publisher.pub(this.hnsIndexTopic, index, false, true), !paused, paused));
        const gpsStatePipe = this.gpsStateSource.pipe(this.gpsState, true);
        this.gpsIndex.sub(index => {
            if (index < 0) {
                this.gpsStateSource.setConsumer(null);
                gpsStatePipe.pause();
                this.gpsState.set(GPSSystemState.Searching);
            }
            else {
                this.gpsStateSource.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_state_changed_${index}`));
                gpsStatePipe.resume(true);
            }
        }, true);
        this.dataSubs.push(this.gpsPdop.sub(this.updateAnp.bind(this), !paused, paused));
        this.verticalAnpSub = this.verticalAnp.sub((verAnp) => this.publisher.pub(this.verticalAnpTopic, verAnp, false, true));
        this.dataSubs.push(this.dataSourceSubscriber.on('actual_pitch_deg').atFrequency(5).handle((pitch) => {
            this.pitchRate.set(0.8 * this.pitchRate.get() + 0.2 * 5 * (pitch - this.pitch));
            this.pitch = pitch;
        }));
        this.adcSystemState.sub(this.updateAdcSystemState.bind(this));
        this.dataSubs.push(this.gpsIndex.sub((index) => this.gpsPdop.setConsumer(this.dataSourceSubscriber.on(`gps_rec_gps_system_pdop_${index}`)), !paused, paused));
        this.gpsGroundSpeed.setConsumer(this.dataSourceSubscriber.on('ground_speed').withPrecision(0));
        this.dataSubs.push(this.adcIndex.sub((index) => this.pressureAlt.setConsumer(this.dataSourceSubscriber.on(`adc_pressure_alt_${index}`).withPrecision(-2)), !paused, paused));
        this.dataSubs.push(this.adcIndex.sub((index) => this.adcSystemState.setConsumer(this.dataSourceSubscriber.on(`adc_state_${index}`)), !paused, paused));
    }
    /**
     * Responds to when someone first subscribes to one of this system's GNSS-sourced data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onGnssTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.gnssDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.setMode(FmsPositionMode.None);
            this.lastFixTime = undefined;
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.updateMode();
        }
    }
    /**
     * Updates this system's data mode.
     */
    updateMode() {
        const gpsState = this.gpsState.get();
        if (gpsState === GPSSystemState.SolutionAcquired || gpsState === GPSSystemState.DiffSolutionAcquired) {
            this.setMode(FmsPositionMode.Gps);
            this.lastFixTime = this.simTime.get();
        }
        else if (this.lastFixTime !== undefined) {
            if (this.simTime.get() - this.lastFixTime > FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME) {
                this.setMode(FmsPositionMode.DeadReckoningExpired);
            }
            else {
                this.setMode(FmsPositionMode.DeadReckoning);
            }
        }
        else {
            this.setMode(FmsPositionMode.None);
        }
    }
    /**
     * Sets this system's data mode, and publishes the new value to the event bus if it differs from the current value.
     * @param mode The new data mode.
     */
    setMode(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this.publisher.pub(this.modeTopic, this.mode, false, true);
    }
    /** Update the ANP from data sources */
    updateAnp() {
        // The Boeing ANP includes navigation system error (aka position uncertainty),
        // but excludes Flight Technical Error (this is shown on the EFIS as a function of ANP and RNP),
        // and excludes path computation error as this is assumed negligable
        // https://www.boeing.com/commercial/aeromagazine/aero_16/navigation_story.html
        const pdop = this.gpsPdop.get();
        if (pdop >= 0) {
            const anp = FmsPositionSystem.ANP(pdop);
            this.publisher.pub(this.gpsAnpTopic, anp, false, true);
            this.publisher.pub(this.anpTopic, anp, false, true);
        }
        else {
            this.publisher.pub(this.gpsAnpTopic, pdop, false, true);
            this.publisher.pub(this.anpTopic, pdop, false, true);
        }
        // TODO IRU and radio position
    }
    /**
     * Updates the ADC derived values when the ADC system state changes
     * @param state ADC system state event
     */
    updateAdcSystemState(state) {
        var _a, _b;
        if ((state === null || state === void 0 ? void 0 : state.current) === AvionicsSystemState.On) {
            (_a = this.verticalAnpSub) === null || _a === void 0 ? void 0 : _a.resume(true);
        }
        else {
            (_b = this.verticalAnpSub) === null || _b === void 0 ? void 0 : _b.pause();
            this.publisher.pub(this.verticalAnpTopic, -1, false, true);
        }
    }
}
FmsPositionSystem.DEAD_RECKONING_EXPIRE_TIME = UnitType.MINUTE.convertTo(20, UnitType.MILLISECOND);
/** Calculates the ANP as the circle radius where the airplane position is estimated to be within 95% of the time.
 * Uses the statistic formula of estimating a 95% confidence interval with a (hypothetical) sample size of 1.
 * @param pdop The geometric dilution of precision computation (GDOP).
 * @returns The estimated ANP.
 */
FmsPositionSystem.ANP = (pdop) => {
    /** In meters. Used for calculating the ANP. Sets at 222 under the assumption that airplane cruises at 800 km/h,
     * hence if gps position is updated every second, the deviation would be 222 m/s.
     * Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR = 222;
    /** In meters. Used for calculating the ANP. Source: https://en.wikipedia.org/wiki/Error_analysis_for_the_Global_Positioning_System */
    const ESTIMATED_NUMERICAL_ERROR = 200;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL = 1.96;
    /** Used for calculating the ANP. Source: https://www.calculator.net/confidence-interval-calculator.html */
    const HYPOTHETICAL_SAMPLE_SIZE = 1;
    const STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS = () => {
        return Math.sqrt((pdop * STANDARD_DEVIATION_OF_USER_EQUIVALENT_RANGE_ERROR) ^ 2 + ESTIMATED_NUMERICAL_ERROR ^ 2);
    };
    const anpMeter = Z_FACTOR_OF_95_PERCENT_CONFIDENT_INTERVAL * STANDARD_DEVIATION_OF_ERROR_IN_ESTIMATED_RECEIVER_POS() / Math.sqrt(HYPOTHETICAL_SAMPLE_SIZE);
    return MathUtils.round(UnitType.NMILE.convertFrom(anpMeter, UnitType.METER), 0.01);
};

/**
 * A Boeing ADC system.
 */
class AdcSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an ADC system.
     * @param index The index of the ADC.
     * @param bus An instance of the event bus.
     * @param airspeedIndicatorIndex The index of the sim airspeed indicator from which this ADC derives its data.
     * @param altimeterIndex The index of the sim altimeter from which this ADC derives its data.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, airspeedIndicatorIndex, altimeterIndex, powerSource) {
        super(index, bus, `adc_state_${index}`);
        this.airspeedIndicatorIndex = airspeedIndicatorIndex;
        this.altimeterIndex = altimeterIndex;
        this.initializationTime = 15000;
        this.speedDataValidTopic = `adc_speed_data_valid_${this.index}`;
        this.altitudeDataValidTopic = `adc_altitude_data_valid_${this.index}`;
        this.dataSourceTopicMap = {
            [`adc_ias_${this.index}`]: `ias_${this.airspeedIndicatorIndex}`,
            [`adc_tas_${this.index}`]: `tas_${this.airspeedIndicatorIndex}`,
            [`adc_mach_to_kias_factor_${this.index}`]: `mach_to_kias_factor_${this.airspeedIndicatorIndex}`,
            [`adc_indicated_alt_${this.index}`]: `indicated_alt_${this.altimeterIndex}`,
            [`adc_altimeter_baro_setting_inhg_${this.index}`]: `altimeter_baro_setting_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_inhg_${this.index}`]: `altimeter_baro_preselect_inhg_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_mb_${this.index}`]: `altimeter_baro_preselect_mb_${this.altimeterIndex}`,
            [`adc_altimeter_baro_preselect_raw_${this.index}`]: `altimeter_baro_preselect_raw_${this.altimeterIndex}`,
            [`adc_altimeter_baro_is_std_${this.index}`]: `altimeter_baro_is_std_${this.altimeterIndex}`,
            [`adc_mach_number_${this.index}`]: 'mach_number',
            [`adc_pressure_alt_${this.index}`]: 'pressure_alt',
            [`adc_vertical_speed_${this.index}`]: 'vertical_speed',
            [`adc_ambient_density_${this.index}`]: 'ambient_density',
            [`adc_ambient_temp_c_${this.index}`]: 'ambient_temp_c',
            [`adc_ambient_pressure_inhg_${this.index}`]: 'ambient_pressure_inhg',
            [`adc_isa_temp_c_${this.index}`]: 'isa_temp_c',
            [`adc_ram_air_temp_c_${this.index}`]: 'ram_air_temp_c'
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.publisher.pub(this.speedDataValidTopic, true, false, true);
        this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing ADC data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.dataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.dataSourceTopicMap) {
                this.onTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state !== undefined && this.state !== AvionicsSystemState.On;
        this.dataSubs.push(this.dataSourceSubscriber.on(this.dataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, paused));
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.On) {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
            this.publisher.pub(this.speedDataValidTopic, true, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, true, false, true);
        }
        else {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
            this.publisher.pub(this.speedDataValidTopic, false, false, true);
            this.publisher.pub(this.altitudeDataValidTopic, false, false, true);
        }
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best ADC from a set of candidates based on the current states of all systems. System state
 * desiribility depends on whether it is providing valid airspeed and altitude data.
 */
class AdcSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the ADC systems from which to select.
     * @param systemPriorities The priorities for selecting individual ADC systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of ADC system indexes or a map of
     * ADC system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     * @param dataBias Whether to bias system desirability toward valid airspeed data, valid altitude data, or neither.
     * Defaults to `'none'`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities, dataBias) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isSpeedDataValid = Subject.create(false);
        this.isAltitudeDataValid = Subject.create(false);
        this.adcEntries = new Map();
        this.adcOrder = [];
        this.adcComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        switch (dataBias) {
            case 'airspeed':
                this.adcStateComparator = (a, b) => (Number(b[0]) * 1.5 + Number(b[1])) - (Number(a[0]) * 1.5 + Number(a[1]));
                break;
            case 'airspeed-only':
                this.adcStateComparator = (a, b) => Number(b[0]) - Number(a[0]);
                break;
            case 'altitude':
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1]) * 1.5) - (Number(a[0]) + Number(a[1]) * 1.5);
                break;
            case 'altitude-only':
                this.adcStateComparator = (a, b) => Number(b[1]) - Number(a[1]);
                break;
            default:
                this.adcStateComparator = (a, b) => (Number(b[0]) + Number(b[1])) - (Number(a[0]) + Number(a[1]));
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `adc_selector_selected_index_${index}`), true);
        this.isSpeedDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_speed_data_valid_${index}`), true);
        this.isAltitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `adc_selector_altitude_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.adcEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`adc_speed_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`adc_altitude_data_valid_${key}`), false),
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.adcEntries.set(key, entry);
                // When there is a change in an ADC state, we don't reselect immediately because the ADC could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.adcEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the ADC with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.adcEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.adcEntries.size === 1) {
            const entry = this.adcEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.adcOrder.length = 0;
            for (const index of this.adcEntries.keys()) {
                this.adcOrder.push(index);
            }
            this.adcOrder.sort(this.adcComparator);
            bestIndex = -1;
            for (let i = 0; i < this.adcOrder.length; i++) {
                const index = this.adcOrder[i];
                const state = this.adcEntries.get(index).state.get();
                if (!bestState || this.adcStateComparator(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isSpeedDataValid.set(bestState[0]);
            this.isAltitudeDataValid.set(bestState[1]);
        }
        else {
            this.isSpeedDataValid.set(false);
            this.isAltitudeDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.adcEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
}

/**
 * A Boeing angle of attack computer system.
 */
class AoaSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an angle of attack computer system.
     * @param index The index of the AoA computer.
     * @param bus An instance of the event bus.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `aoa_state_${index}`);
        this.initializationTime = 15000;
        this.simVarPublisher = new SimVarPublisher(new Map([
            [`aoa_load_factor_${this.index}`, { name: 'SEMIBODY LOADFACTOR Y', type: SimVarValueType.Number }]
        ]), this.bus);
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.isAoaSubbed = false;
        this.isStallAoaSubbed = false;
        this.isZeroLiftAoaSubbed = false;
        this.normAoaTopic = `aoa_norm_aoa_${this.index}`;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing angle of attack data on the event bus.
     */
    startDataPublish() {
        const topics = [
            `aoa_aoa_${this.index}`,
            `aoa_stall_aoa_${this.index}`,
            `aoa_zero_lift_aoa_${this.index}`,
            `aoa_norm_aoa_${this.index}`
        ];
        for (const topic of topics) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topics.includes(topic)) {
                this.onTopicSubscribed(topic);
            }
        });
        this.simVarPublisher.startPublish();
    }
    /**
     * Responds to when someone first subscribes to one of this system's data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onTopicSubscribed(topic) {
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        let shouldSubAoa = false;
        let shouldSubStallAoa = false;
        let shouldSubZeroLiftAoa = false;
        switch (topic) {
            case `aoa_aoa_${this.index}`:
                shouldSubAoa = true;
                break;
            case `aoa_stall_aoa_${this.index}`:
                shouldSubStallAoa = true;
                break;
            case `aoa_zero_lift_aoa_${this.index}`:
                shouldSubZeroLiftAoa = true;
                break;
            case `aoa_norm_aoa_${this.index}`:
                shouldSubAoa = true;
                shouldSubStallAoa = true;
                shouldSubZeroLiftAoa = true;
                break;
        }
        if (shouldSubAoa && !this.isAoaSubbed) {
            this.isAoaSubbed = true;
            const pubTopic = `aoa_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('aoa').handle(val => {
                this.aoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubStallAoa && !this.isStallAoaSubbed) {
            this.isStallAoaSubbed = true;
            const pubTopic = `aoa_stall_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('stall_aoa').handle(val => {
                this.stallAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
        if (shouldSubZeroLiftAoa && !this.isZeroLiftAoaSubbed) {
            this.isZeroLiftAoaSubbed = true;
            const pubTopic = `aoa_zero_lift_aoa_${this.index}`;
            this.dataSubs.push(this.dataSourceSubscriber.on('zero_lift_aoa').handle(val => {
                this.zeroLiftAoa = val;
                this.publisher.pub(pubTopic, val, false, true);
            }, paused));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            for (const sub of this.dataSubs) {
                sub.pause();
            }
        }
        else {
            for (const sub of this.dataSubs) {
                sub.resume(true);
            }
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.Failed
            || this._state === AvionicsSystemState.Off
            || this.aoa === undefined
            || this.stallAoa === undefined
            || this.zeroLiftAoa === undefined) {
            return;
        }
        this.publisher.pub(this.normAoaTopic, (this.aoa - this.zeroLiftAoa) / (this.stallAoa - this.zeroLiftAoa), false, true);
        this.simVarPublisher.onUpdate();
    }
}

/**
 * A publisher that publishes Boeing Game Units events.
 */
class BoeingGameUnitsPublisher extends GameVarPublisher {
    /**
     * Creates an instance of the BoeingGameUnitsPublisher.
     * @param bus The event bus to use with this instance.
     */
    constructor(bus) {
        super(BoeingGameUnitsPublisher.gamevars, bus);
    }
}
BoeingGameUnitsPublisher.gamevars = new Map([
    ['game_units_metric', { name: 'GAME UNIT IS METRIC', type: SimVarValueType.Bool }],
]);

var PresssureControllerMode;
(function (PresssureControllerMode) {
    PresssureControllerMode[PresssureControllerMode["None"] = 0] = "None";
    PresssureControllerMode[PresssureControllerMode["Takeoff"] = 1] = "Takeoff";
    PresssureControllerMode[PresssureControllerMode["Climb"] = 2] = "Climb";
    PresssureControllerMode[PresssureControllerMode["Descent"] = 3] = "Descent";
    PresssureControllerMode[PresssureControllerMode["Landing"] = 4] = "Landing";
})(PresssureControllerMode || (PresssureControllerMode = {}));
var PressurizationAlerts;
(function (PressurizationAlerts) {
    PressurizationAlerts["LandingAltitude"] = "press-landing-alt";
    PressurizationAlerts["CabinAltitude"] = "press-cabin-alt";
})(PressurizationAlerts || (PressurizationAlerts = {}));
/**
 * The Longitude pressurization system.
 */
class BoeingPressurizationSystem {
    /**
     * Creates an instance of the LongitudePressurizationSystem.
     * @param bus The event bus to use.
     * @param fms The FMS instance to use.
     * @param maxCabinAlt The maximum cabin altitude that is allowed, in feet.
     * @param defaultCruiseAlt The default cruise altitude, in feet.
     */
    constructor(bus, fms, maxCabinAlt, defaultCruiseAlt) {
        this.bus = bus;
        this.fms = fms;
        this.maxCabinAlt = maxCabinAlt;
        this.defaultCruiseAlt = defaultCruiseAlt;
        this.previousCabinAltitude = -1;
        this.mode = PresssureControllerMode.None;
        this.takeoffCabinPressure = 14.7;
        this.onGround = ConsumerValue.create(this.bus.getSubscriber().on('on_ground'), true);
        this.alt = ConsumerValue.create(this.bus.getSubscriber().on('indicated_alt'), 0);
        this.radioAlt = ConsumerValue.create(this.bus.getSubscriber().on('radio_alt'), 0);
        this.vs = ConsumerValue.create(this.bus.getSubscriber().on('vertical_speed'), 0);
        this.destinationFacility = Subject.create(undefined);
        this.approachDetails = Subject.create(undefined);
        this.cabinAltitude = Subject.create(0);
        this.cabinPressure = Subject.create(14.7);
        this.psiDelta = Subject.create(0);
        this.altitudeRate = Subject.create(0);
        this.landingAltitude = Subject.create(0);
        this.highAltMode = Subject.create(false);
        this.pressurizationAvailable = Subject.create(true);
        this.isManLanding = Subject.create(false);
        this.rateSmoother = new ExpSmoother(1500 / Math.LN2, 0);
        this.inputAccel = new InputAcceleration({ increment: 100, bigIncrement: 500 });
        this.fmsLandingAltitude = Subject.create(NaN);
        this.previousTimestamp = -1;
        this.hasPower = false;
        this.inAirTimestamp = -1;
        this.mostRecentClimbDescentPoint = 0;
        const sub = this.bus.getSubscriber();
        sub.on('simTime').handle(this.update.bind(this));
        sub.on('fplOriginDestChanged').handle(() => this.refreshDestination());
        sub.on('fplCopied').handle(() => this.refreshDestination());
        sub.on('active_approach_details_set').handle(v => this.approachDetails.set(v));
        sub.on('key_intercept').handle(this.onKeyIntercepted.bind(this));
        MappedSubject.create(this.onDestinationDetailsChanged.bind(this), this.destinationFacility, this.approachDetails);
        const pub = this.bus.getPublisher();
        this.cabinAltitude.sub(v => pub.pub('press_cabin_alt', v, true, true), true);
        this.psiDelta.sub(v => pub.pub('press_psid', v, true, true), true);
        this.altitudeRate.sub(v => pub.pub('press_rate', v, true, true), true);
        this.highAltMode.sub(v => pub.pub('press_high_alt_mode', v, true, true), true);
        this.landingAltitude.sub(v => pub.pub('press_landing_alt', v, true, true), true);
        this.landingAltitude.sub(v => SimVar.SetSimVarValue('L:WT_PRESS_LDG_ALT', SimVarValueType.Feet, v));
        this.isManLanding.sub(v => pub.pub('press_man_landing_mode', v, true, true), true);
    }
    /** @inheritdoc */
    init() {
        KeyEventManager.getManager(this.bus).then(km => {
            km.interceptKey('PRESSURIZATION_PRESSURE_ALT_INC', false);
            km.interceptKey('PRESSURIZATION_PRESSURE_ALT_DEC', false);
        });
        const casRegistrationManager = new CasRegistrationManager(this.bus);
        casRegistrationManager.register({ uuid: PressurizationAlerts.LandingAltitude, message: 'LANDING ALTITUDE' });
        casRegistrationManager.register({ uuid: PressurizationAlerts.CabinAltitude, message: 'CABIN ALTITUDE' });
        CasAlertTransporter.create(this.bus, PressurizationAlerts.CabinAltitude, AnnunciationType.Warning)
            .bind(MappedSubject.create(this.highAltMode, this.cabinAltitude), ([hiAlt, cabinAlt]) => {
            if (hiAlt) {
                return cabinAlt > 14000;
            }
            else {
                return cabinAlt > (this.maxCabinAlt + 2000);
            }
        });
        CasAlertTransporter.create(this.bus, PressurizationAlerts.LandingAltitude, AnnunciationType.Advisory)
            .bind(MappedSubject.create(this.fmsLandingAltitude, this.isManLanding), ([fmsAlt, isMan]) => !isFinite(fmsAlt) && !isMan);
    }
    /** @inheritdoc */
    onUpdate() {
        //NOOP
    }
    /**
     * Handles when a key is intercepted.
     * @param data The key that was intercepted.
     */
    onKeyIntercepted(data) {
        if (this.isManLanding.get()) {
            switch (data.key) {
                case 'PRESSURIZATION_PRESSURE_ALT_INC':
                    this.landingAltitude.set(MathUtils.clamp(this.landingAltitude.get() + this.inputAccel.doStep(), -2000, 14000));
                    break;
                case 'PRESSURIZATION_PRESSURE_ALT_DEC':
                    this.landingAltitude.set(MathUtils.clamp(this.landingAltitude.get() - this.inputAccel.doStep(), -2000, 14000));
                    break;
            }
        }
    }
    /**
     * Handles when the flight plan destination changes.
     */
    refreshDestination() {
        const planner = this.fms.flightPlanner;
        if (planner.hasFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX)) {
            const plan = planner.getFlightPlan(BoeingFms.ACT_RTE_PLAN_INDEX);
            const destIcao = plan.destinationAirport;
            if (destIcao !== undefined) {
                this.fms.facLoader.getFacility(FacilityType.Airport, destIcao).then(v => this.destinationFacility.set(v));
            }
            else {
                this.destinationFacility.set(undefined);
            }
        }
        else {
            this.destinationFacility.set(undefined);
        }
    }
    /**
     * Handles when the flight plan destination details are changed.
     * @param details The changed details.
     */
    onDestinationDetailsChanged(details) {
        const [facility, approachDetails] = details;
        if (facility !== undefined) {
            let hasRunway = false;
            if (approachDetails !== undefined) {
                const runway = RunwayUtils.matchOneWayRunwayFromDesignation(facility, approachDetails.approachRunway);
                if (runway !== undefined) {
                    this.fmsLandingAltitude.set(UnitType.METER.convertTo(runway.elevation, UnitType.FOOT));
                    hasRunway = true;
                }
            }
            if (!hasRunway) {
                const elevation = AirportUtils.getElevation(facility);
                this.fmsLandingAltitude.set(elevation !== undefined ? UnitType.METER.convertTo(elevation, UnitType.FOOT) : NaN);
            }
        }
        else {
            this.fmsLandingAltitude.set(NaN);
        }
    }
    /**
     * Updates the pressurization system.
     * @param timestamp The timestamp, in milliseconds simtime.
     */
    update(timestamp) {
        if (this.previousTimestamp === -1) {
            this.previousTimestamp = timestamp;
        }
        const deltaTime = NavMath.clamp(timestamp - this.previousTimestamp, 0, 10000);
        this.calcControllerMode(timestamp);
        const ambientPressure = SimVar.GetSimVarValue('AMBIENT PRESSURE', SimVarValueType.PSI);
        const hasPower = this.hasElectricalPower();
        if (this.hasPower !== hasPower) {
            this.handlePowerStateChanged(timestamp, hasPower, ambientPressure);
        }
        else if (this.hasPower && deltaTime !== 0) {
            this.updatePressurizationController(ambientPressure, deltaTime, timestamp);
        }
        this.previousTimestamp = timestamp;
    }
    /**
     * Gets the climb schedule in PSID.
     * @param timestamp The current sim timestamp.
     * @returns The target PSID for climb.
     */
    getClimbSchedule(timestamp) {
        var _a;
        let tocEta = this.fms.vnavData.tocEta.get();
        const altPsi = this.altitudeToPressure(this.alt.get());
        const maxAltPsi = this.altitudeToPressure(this.maxCabinAlt);
        const minPressureDiff = maxAltPsi - altPsi;
        if (tocEta !== null && this.inAirTimestamp > 0) {
            tocEta = tocEta + (timestamp - (timestamp % (1000 * 60 * 60 * 24))); //Add back beginning of day timestamp
            if (tocEta >= timestamp) {
                const targetPsi = MathUtils.lerp(timestamp, this.inAirTimestamp, tocEta, 0, maxAltPsi, true, true);
                return Math.max(targetPsi - altPsi, minPressureDiff);
            }
        }
        if (this.alt.get() <= 5000) {
            return 2.5;
        }
        const cruiseAlt = (_a = this.fms.activePerformancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : this.defaultCruiseAlt;
        return Math.max(MathUtils.lerp(this.alt.get(), 5000, cruiseAlt, 2.5, maxAltPsi - altPsi), minPressureDiff);
    }
    /**
     * Gets the descent schedule in PSID.
     * @returns The target PSID for descent.
     */
    getDescentSchedule() {
        var _a;
        const altPsi = this.altitudeToPressure(this.alt.get());
        const maxAltPsi = this.altitudeToPressure(this.maxCabinAlt);
        const cruiseAlt = (_a = this.fms.activePerformancePlan.cruiseAltitude.get()) !== null && _a !== void 0 ? _a : this.defaultCruiseAlt;
        const cruiseAltPsi = this.altitudeToPressure(cruiseAlt);
        const minPressureDiff = maxAltPsi - altPsi;
        const targetPsid = this.alt.get() <= 5000
            ? 3.1
            : MathUtils.lerp(this.alt.get(), 5000, cruiseAlt, 3.1, maxAltPsi - cruiseAltPsi);
        return Math.max(targetPsid, minPressureDiff);
    }
    /**
     * Updates the pressurization control portion of the system.
     * @param ambientPressure The current ambient pressure.
     * @param deltaTime The delta time, in milliseconds simtime.
     * @param timestamp The current sim time.
     */
    updatePressurizationController(ambientPressure, deltaTime, timestamp) {
        this.isManLanding.set(SimVar.GetSimVarValue('L:WT_PRESS_MAN_ALT_ON', SimVarValueType.Bool) === 1);
        if (!this.isManLanding.get()) {
            this.landingAltitude.set(isFinite(this.fmsLandingAltitude.get()) ? this.fmsLandingAltitude.get() : 2000);
        }
        const deltaPressure = this.cabinPressure.get() - ambientPressure;
        this.computeHighAltMode();
        this.pressurizationAvailable.set(this.hasAirFromAirSystems());
        if (this.mode === PresssureControllerMode.Climb || this.mode === PresssureControllerMode.Descent) {
            this.handleClimbAndDescentModes(deltaTime, deltaPressure, ambientPressure, timestamp);
        }
        else if (this.mode === PresssureControllerMode.Takeoff || this.mode === PresssureControllerMode.Landing) {
            this.handleGroundModes(deltaTime, ambientPressure);
        }
        const deltaAlt = this.cabinAltitude.get() - this.previousCabinAltitude;
        const rate = (deltaAlt / deltaTime) * 1000 * 60;
        const smoothedRate = this.rateSmoother.next(rate, deltaTime);
        this.altitudeRate.set(smoothedRate);
        this.psiDelta.set(this.cabinPressure.get() - ambientPressure);
        this.previousCabinAltitude = this.cabinAltitude.get();
    }
    /**
     * Handles when the power state of the system has changed.
     * @param timestamp The current sim time.
     * @param hasPower Whether or not the system has power.
     * @param ambientPressure The current ambient pressure.
     */
    handlePowerStateChanged(timestamp, hasPower, ambientPressure) {
        if (hasPower) {
            let targetPressure = ambientPressure;
            if (!this.onGround.get()) {
                targetPressure = Math.max(ambientPressure + this.getClimbSchedule(timestamp));
                if (this.radioAlt.get() > 150) {
                    this.inAirTimestamp = timestamp;
                }
                this.mostRecentClimbDescentPoint = this.alt.get();
            }
            this.cabinPressure.set(targetPressure);
            this.cabinAltitude.set(this.pressureToAltitude(this.cabinPressure.get()));
            this.takeoffCabinPressure = this.onGround.get() ? targetPressure : 14.7;
            this.psiDelta.set(this.cabinPressure.get() - targetPressure);
            this.previousCabinAltitude = this.cabinAltitude.get();
            this.altitudeRate.set(0);
            this.rateSmoother.reset();
        }
        this.hasPower = hasPower;
    }
    /**
     * Calculates the controller mode.
     * @param timestamp The current sim time.
     */
    calcControllerMode(timestamp) {
        if (this.inAirTimestamp === -1 && !this.onGround.get() && this.radioAlt.get() > 150) {
            this.inAirTimestamp = timestamp;
        }
        if (this.onGround.get() && this.inAirTimestamp > 0) {
            this.mode = PresssureControllerMode.Landing;
        }
        else if (this.onGround.get() && this.areThrottlesInTakeoff()) {
            this.mode = PresssureControllerMode.Takeoff;
            this.inAirTimestamp = -1;
        }
        else if (!this.onGround.get() && (this.mode === PresssureControllerMode.Takeoff || this.mode === PresssureControllerMode.Landing)) {
            this.mode = PresssureControllerMode.Climb;
        }
        else if (this.mode === PresssureControllerMode.Climb || this.mode === PresssureControllerMode.Descent) {
            this.computeClimbOrDescent();
        }
        else {
            this.mode = PresssureControllerMode.Climb;
        }
    }
    /**
     * Computes if the flight phase is climb or descent.
     */
    computeClimbOrDescent() {
        if (this.mode === PresssureControllerMode.Climb) {
            if (this.vs.get() > 0) {
                this.mostRecentClimbDescentPoint = this.alt.get();
            }
            else if (this.vs.get() < 0) {
                const distanceFromClimb = this.mostRecentClimbDescentPoint - this.alt.get();
                if (distanceFromClimb >= 500) {
                    this.mode = PresssureControllerMode.Descent;
                    this.mostRecentClimbDescentPoint = this.alt.get();
                }
            }
        }
        else if (this.mode === PresssureControllerMode.Descent) {
            if (this.vs.get() < 0) {
                this.mostRecentClimbDescentPoint = this.alt.get();
            }
            else if (this.vs.get() > 0) {
                const distanceFromDescent = this.alt.get() - this.mostRecentClimbDescentPoint;
                if (distanceFromDescent >= 500) {
                    this.mode = PresssureControllerMode.Climb;
                    this.mostRecentClimbDescentPoint = this.alt.get();
                }
            }
        }
    }
    /**
     * Computes if the controller is in high altitude mode.
     */
    computeHighAltMode() {
        this.highAltMode.set(this.pressureToAltitude(this.takeoffCabinPressure) >= this.maxCabinAlt || this.landingAltitude.get() > this.maxCabinAlt);
    }
    /**
     * Handles the pressure controller for climb and descent modes.
     * @param deltaTime The delta time, in milliseconds simtime.
     * @param deltaPressure The current computed delta pressure.
     * @param ambientPressure The current ambient pressure.
     * @param timestamp The current sim time.
     */
    handleClimbAndDescentModes(deltaTime, deltaPressure, ambientPressure, timestamp) {
        let maximumCabinPressure = this.takeoffCabinPressure;
        if (this.mode === PresssureControllerMode.Climb && this.pressureToAltitude(this.takeoffCabinPressure) >= this.maxCabinAlt && !this.onGround.get()) {
            maximumCabinPressure = this.altitudeToPressure(this.maxCabinAlt);
        }
        if (this.mode === PresssureControllerMode.Descent) {
            maximumCabinPressure = isFinite(this.fmsLandingAltitude.get()) ? this.altitudeToPressure(this.fmsLandingAltitude.get() - 200) : this.takeoffCabinPressure;
        }
        const ecsHasBleedAir = this.hasAirFromAirSystems();
        const psidTarget = this.mode === PresssureControllerMode.Climb
            ? this.getClimbSchedule(timestamp)
            : this.getDescentSchedule();
        let targetPressure = Math.min(ambientPressure + psidTarget, maximumCabinPressure);
        if (targetPressure > this.cabinPressure.get() && !ecsHasBleedAir) {
            return;
        }
        const targetAlt = this.pressureToAltitude(targetPressure);
        let deltaAlt = targetAlt - this.cabinAltitude.get();
        if (this.highAltMode.get()) {
            const maxDeltaAlt = (1000 / 60 / 1000) * deltaTime;
            deltaAlt = NavMath.clamp(deltaAlt, -maxDeltaAlt, maxDeltaAlt);
        }
        else {
            const maxDeltaAltUp = (750 / 60 / 1000) * deltaTime;
            const maxDeltaAltDown = (500 / 60 / 1000) * deltaTime;
            deltaAlt = NavMath.clamp(deltaAlt, -maxDeltaAltDown, maxDeltaAltUp);
        }
        targetPressure = Math.max(this.altitudeToPressure(this.cabinAltitude.get() + deltaAlt), ambientPressure);
        if (this.pressurizationAvailable.get() || targetPressure < this.cabinPressure.get()) {
            this.cabinPressure.set(targetPressure);
            this.cabinAltitude.set(this.pressureToAltitude(this.cabinPressure.get()));
        }
    }
    /**
     * Handles the ground controller modes.
     * @param deltaTime The delta time, in milliseconds simtime.
     * @param ambientPressure The current ambient pressure.
     */
    handleGroundModes(deltaTime, ambientPressure) {
        const takeoffAlt = this.pressureToAltitude(this.takeoffCabinPressure);
        const targetAlt = takeoffAlt - 15;
        let targetPressure = this.altitudeToPressure(targetAlt);
        if (this.mode === PresssureControllerMode.Landing) {
            targetPressure = ambientPressure;
            this.takeoffCabinPressure = ambientPressure;
        }
        const deltaP = this.cabinPressure.get() - ambientPressure;
        const fpmMax = deltaP > 0.3 ? 2000 : 500;
        const maxDeltaAlt = (fpmMax / 60 / 1000) * deltaTime;
        let deltaAlt = targetAlt - this.cabinAltitude.get();
        deltaAlt = NavMath.clamp(deltaAlt, -maxDeltaAlt, maxDeltaAlt);
        targetPressure = this.altitudeToPressure(this.cabinAltitude.get() + deltaAlt);
        this.cabinPressure.set(targetPressure);
        this.cabinAltitude.set(this.pressureToAltitude(this.cabinPressure.get()));
    }
    /**
     * Gets the ISA Standard Press from Altitude.
     * @param altitude The altitude in feet.
     * @returns The pressure in PSI
     */
    altitudeToPressure(altitude) {
        return AeroMath.isaPressure(UnitType.FOOT.convertTo(altitude, UnitType.METER)) * 0.0145037738;
    }
    /**
     * Takes a pressure in PSI and returns an altitude, in feet.
     * @param pressure The pressure, in PSI.
     * @returns The altitude, in feet.
     */
    pressureToAltitude(pressure) {
        pressure /= 0.0145037738;
        const stdPressure = 1013.25;
        pressure = Math.max(pressure, 0.01); //Protect against bad pressures during some init stages to avoid log(0)
        //MATT N: NOAA/Aviation pressure alt formula
        let pressureAltitude = 145442.15 * (1 - Math.pow(pressure / stdPressure, 0.190263));
        if (pressureAltitude >= 36089.24) {
            pressureAltitude = 36089.24 - 20805.8 * Math.log(4.47706 * (pressure / stdPressure));
        }
        return pressureAltitude;
    }
}
/** ISA temp at Sea Level in Kelvin  */
BoeingPressurizationSystem.SEA_LEVEL_TEMP = 288.15;
/** ISA pressure at Sea Level in Pascals  */
BoeingPressurizationSystem.SEA_LEVEL_PRESSURE = 101325;
/** Atmospheric Lapse Rate Constant (Kelvin per foot)  */
BoeingPressurizationSystem.TEMP_LAPSE_RATE = 0.0019812;

/**
 * Automatically selects the best GPS receiver from a set of candidates based on the current states of all receivers.
 * Receivers that have computed a 3D position solution with differential corrections are favored over those that have
 * computed a 3D solution without corrections, and either of these are favored over those that have not computed any
 * position solution.
 */
class GpsReceiverSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param enabledReceiverIndexes The indexes of the GPS receivers from which to select.
     * @param preferredReceiverIndex The index of this selector's preferred GPS receiver, or `-1` if there is no such
     * receiver. This selector is guaranteed to select the preferred GPS receiver if its state is at least as desirable
     * as the state of all other receivers from which to select. Defaults to `-1`.
     */
    constructor(bus, enabledReceiverIndexes, preferredReceiverIndex) {
        this.bus = bus;
        this._selectedIndex = Subject.create(-1);
        this.selectedIndex = this._selectedIndex;
        this.gpsStates = new Map();
        this.isAlive = true;
        this.isInit = false;
        this.enabledReceiverIndexes = 'isSubscribableSet' in enabledReceiverIndexes ? enabledReceiverIndexes : SetSubject.create(enabledReceiverIndexes);
        this.preferredReceiverIndex = SubscribableUtils.toSubscribable(preferredReceiverIndex !== null && preferredReceiverIndex !== void 0 ? preferredReceiverIndex : -1, true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best GPS receiver among
     * its candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('GpsReceiverSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const selectIndex = this.selectIndex.bind(this);
        this.enabledReceiverIndexesSub = this.enabledReceiverIndexes.sub((set, type, key) => {
            var _a;
            (_a = this.gpsStates.get(key)) === null || _a === void 0 ? void 0 : _a.destroy();
            if (type === SubscribableSetEventType.Added) {
                const gpsState = ConsumerSubject.create(sub.on(`gps_rec_gps_system_state_changed_${key}`), GPSSystemState.Acquiring);
                this.gpsStates.set(key, gpsState);
                gpsState.sub(selectIndex);
            }
            else {
                this.gpsStates.delete(key);
            }
            selectIndex();
        }, true);
        this.preferredReceiverIndexSub = this.preferredReceiverIndex.sub(selectIndex);
    }
    /**
     * Selects the index of the GPS receiver with the most desirable state.
     */
    selectIndex() {
        var _a, _b;
        if (this.gpsStates.size === 0) {
            this._selectedIndex.set(-1);
            return;
        }
        if (this.gpsStates.size === 1) {
            this._selectedIndex.set(this.gpsStates.keys().next().value);
            return;
        }
        let bestIndex = this._selectedIndex.get();
        let bestState = (_a = this.gpsStates.get(bestIndex)) === null || _a === void 0 ? void 0 : _a.get();
        for (const index of this.gpsStates.keys()) {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            const state = this.gpsStates.get(index).get();
            if (bestIndex < 0 || !bestState || GpsReceiverSelector.compareGpsState(state, bestState) < 0) {
                bestIndex = index;
                bestState = state;
            }
        }
        const preferredIndex = this.preferredReceiverIndex.get();
        if (preferredIndex >= 0) {
            const preferredIndexState = (_b = this.gpsStates.get(preferredIndex)) === null || _b === void 0 ? void 0 : _b.get();
            if (preferredIndexState !== undefined && GpsReceiverSelector.compareGpsState(preferredIndexState, bestState) <= 0) {
                bestIndex = preferredIndex;
            }
        }
        this._selectedIndex.set(bestIndex);
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b;
        this.isAlive = false;
        for (const state of this.gpsStates.values()) {
            state.destroy();
        }
        (_a = this.enabledReceiverIndexesSub) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.preferredReceiverIndexSub) === null || _b === void 0 ? void 0 : _b.destroy();
    }
    /**
     * Compares two GPS system states and returns a number whose sign indicates which one is more desirable.
     * @param a The first GPS system state to compare.
     * @param b The second GPS system state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareGpsState(a, b) {
        return GpsReceiverSelector.GPS_STATE_PRIORITIES[a] - GpsReceiverSelector.GPS_STATE_PRIORITIES[b];
    }
}
GpsReceiverSelector.GPS_STATE_PRIORITIES = {
    [GPSSystemState.DiffSolutionAcquired]: 0,
    [GPSSystemState.SolutionAcquired]: 1,
    [GPSSystemState.Acquiring]: 2,
    [GPSSystemState.Searching]: 2
};

/**
 * A Garmin GPS receiver system.
 */
class GpsReceiverSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of a GPS receiver system.
     * @param index The index of the GPS receiver.
     * @param bus An instance of the event bus.
     * @param gpsSatComputer This system's GPS computer system.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, gpsSatComputer, powerSource) {
        super(index, bus, `gps_rec_state_${index}`);
        this.gpsSatComputer = gpsSatComputer;
        this.initializationTime = 0;
        this.cachedDataSourceTopicMap = {
            [`gps_rec_gps_system_state_changed_${this.index}`]: `gps_system_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_sbas_state_changed_${this.index}`]: `gps_system_sbas_state_changed_${this.gpsSatComputer.index}`
        };
        this.uncachedDataSourceTopicMap = {
            [`gps_rec_gps_sat_state_changed_${this.index}`]: `gps_sat_state_changed_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_sat_pos_calculated_${this.index}`]: `gps_sat_pos_calculated_${this.gpsSatComputer.index}`
        };
        this.dopDataSourceTopicMap = {
            [`gps_rec_gps_system_pdop_${this.index}`]: `gps_system_pdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_hdop_${this.index}`]: `gps_system_hdop_${this.gpsSatComputer.index}`,
            [`gps_rec_gps_system_vdop_${this.index}`]: `gps_system_vdop_${this.gpsSatComputer.index}`
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.dataSubs = [];
        this.dopSources = [];
        this.sbasState = ConsumerSubject.create(null, GPSSystemSBASState.Disabled);
        gpsSatComputer.init();
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
        else if (gpsSatComputer.syncRole !== 'replica') {
            // If our power source is undefined, then the system is always considered to be in the on state. Therefore we
            // will force the GPS to immediately acquire and use all the satellites it can since a system that is always on
            // never needs to initialize.
            gpsSatComputer.acquireAndUseSatellites();
        }
        this.startDataPublish();
    }
    /**
     * Starts publishing data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.cachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.cachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, true);
            }));
        }
        for (const topic of Object.keys(this.uncachedDataSourceTopicMap)) {
            this.dataSubs.push(this.dataSourceSubscriber.on(this.uncachedDataSourceTopicMap[topic]).handle(val => {
                this.publisher.pub(topic, val, false, false);
            }));
        }
        // Garmin seems to halve DOP values when SBAS is active. It could be a trainer-specific behavior, but in the
        // absence of any other information, we will implement it here.
        this.sbasState.setConsumer(this.dataSourceSubscriber.on(`gps_system_sbas_state_changed_${this.gpsSatComputer.index}`));
        for (const topic of Object.keys(this.dopDataSourceTopicMap)) {
            const dopSource = ConsumerSubject.create(this.dataSourceSubscriber.on(this.dopDataSourceTopicMap[topic]), -1);
            this.dopSources.push(dopSource);
            const processedDop = MappedSubject.create(([dop, sbasState]) => dop <= 0 ? dop : dop * (sbasState === GPSSystemSBASState.Active ? 0.5 : 1), dopSource, this.sbasState);
            this.dataSubs.push(processedDop.sub(dop => {
                this.publisher.pub(topic, dop, false, false);
            }, true));
        }
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        // If this is the first time we are setting our state and the state is on, then we assume that the system was on at
        // flight load, in which case we will force the GPS to immediately acquire and use all the satellites it can so
        // that we don't force people to wait for satellite acquisition when loading onto the runway/in the air.
        if (previousState === undefined && currentState === AvionicsSystemState.On && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.acquireAndUseSatellites();
        }
        // Reset the GPS sat computer if the system is not operating and its receiver is not a replica (a replica receiver
        // will get the reset command from its primary).
        if ((currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) && this.gpsSatComputer.syncRole !== 'replica') {
            this.gpsSatComputer.reset();
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this._state === AvionicsSystemState.On || this._state === undefined) {
            this.gpsSatComputer.onUpdate();
        }
    }
}

/**
 * IRS operating modes.
 */
var IrsSystemOperatingMode;
(function (IrsSystemOperatingMode) {
    /** The IRS is not operating. */
    IrsSystemOperatingMode["Off"] = "Off";
    /** The IRS is in Standby mode. No data are available. */
    IrsSystemOperatingMode["Standby"] = "Standby";
    /** The IRS is performing a full alignment. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlign"] = "FullAlign";
    /** The IRS has completed a full alignment but is awaiting a position input. Attitude and heading data may be available. */
    IrsSystemOperatingMode["FullAlignPositionPending"] = "FullAlignPositionPending";
    /** The IRS is in Navigation mode. All data are available. */
    IrsSystemOperatingMode["Navigation"] = "Navigation";
    /** The IRS is performing a realignment. All data are available. */
    IrsSystemOperatingMode["Realign"] = "Realign";
    /** The IRS is performing an attitude alignment. No data are available. */
    IrsSystemOperatingMode["AttitudeAlign"] = "AttitudeAlign";
    /** The IRS is in Attitude mode. Attitude and heading data are available. */
    IrsSystemOperatingMode["Attitude"] = "Attitude";
})(IrsSystemOperatingMode || (IrsSystemOperatingMode = {}));
/**
 * IRS system operating mode setting commands.
 */
var IrsSystemOperatingModeSetting;
(function (IrsSystemOperatingModeSetting) {
    /** Forces the IRS into Off mode. */
    IrsSystemOperatingModeSetting["Off"] = "Off";
    /** Commands Navigation mode. The IRS will perform a full alignment (if required), then enter Navigation mode. */
    IrsSystemOperatingModeSetting["Navigation"] = "Navigation";
    /**
     * Arms IRS realignment. If the IRS is in Navigation mode, then the next time Navigation mode is selected and the
     * airplane is on the ground and not moving, it will attempt an realignment.
     */
    IrsSystemOperatingModeSetting["Align"] = "Align";
    /** Commands Attitude mode. The IRS will perform an attitude alignment (if required), then enter Attitude mode. */
    IrsSystemOperatingModeSetting["Attitude"] = "Attitude";
})(IrsSystemOperatingModeSetting || (IrsSystemOperatingModeSetting = {}));
/**
 * A Boeing inertial reference system (IRS). Provides attitude, heading, and inertial (position, velocity,
 * acceleration) data.
 */
class IrsSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of an IRS system.
     * @param index The index of the IRS.
     * @param bus An instance of the event bus.
     * @param attitudeIndicatorIndex The index of the sim attitude indicator from which this IRS derives its data.
     * @param directionIndicatorIndex The index of the sim direction indicator from which this IRS derives its data.
     * @param supportInFlightAlign Whether this IRS supports full alignment while in flight. In-flight full alignment
     * requires position input from GPS receivers.
     * @param operatingModeSetting The operating mode setting commanded for this IRS.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     * @param gpsReceiverIndexes The indexes of the GPS receiver systems from which the IRS receives position input data.
     * If no indexes are supplied, then the IRS will not automatically initialize its position from GPS and will require
     * manual position input during alignment.
     * @param attitudeAlignDuration The duration, in milliseconds, required for this IRS to complete attitude alignment.
     * Defaults to 30000 milliseconds.
     * @param fullAlignDuration The duration, in milliseconds, required for this IRS to complete a full alignment. If not
     * defined, full alignment duration will be simulated based on the airplane's current latitude.
     * @param realignDuration The duration, in milliseconds, required for this IRS to complete realignment. Defaults to
     * 30000 milliseconds.
     */
    constructor(index, bus, attitudeIndicatorIndex, directionIndicatorIndex, supportInFlightAlign, operatingModeSetting, powerSource, gpsReceiverIndexes, attitudeAlignDuration, fullAlignDuration, realignDuration) {
        var _a;
        super(index, bus, `irs_state_${index}`);
        this.attitudeIndicatorIndex = attitudeIndicatorIndex;
        this.directionIndicatorIndex = directionIndicatorIndex;
        this.supportInFlightAlign = supportInFlightAlign;
        this.operatingModeSetting = operatingModeSetting;
        this.powerSource = powerSource;
        this.initializationTime = 0;
        this.simulatedFullAlignDuration = Subject.create(0);
        this.operatingModeTopic = `irs_operating_mode_${this.index}`;
        this.headingDataValidTopic = `irs_heading_data_valid_${this.index}`;
        this.attitudeDataValidTopic = `irs_attitude_data_valid_${this.index}`;
        this.inertialDataValidTopic = `irs_inertial_data_valid_${this.index}`;
        this.positionDataValidTopic = `irs_position_data_valid_${this.index}`;
        this.acceptingPositionTopic = `irs_is_accepting_position_${this.index}`;
        this.requestingPositionTopic = `irs_is_requesting_position_${this.index}`;
        this.fullAlignTimeTopic = `irs_full_align_time_remaining_${this.index}`;
        this.attitudeAlignTimeTopic = `irs_att_align_time_remaining_${this.index}`;
        this.operatingMode = IrsSystemOperatingMode.Navigation;
        this.isHeadingDataValid = true;
        this.isAttitudeDataValid = true;
        this.isInertialDataValid = true;
        this.isInertialHeadingDataValid = true;
        this.isPositionDataValid = true;
        this.isPositionInit = Subject.create(true);
        // When true, the next time isAcceptingPosition becomes true, isPositionInit will automatically be set to true
        this.autoPositionInit = false;
        this.isAcceptingPosition = Subject.create(false);
        this.isRealignArmed = false;
        this.attitudeAlignTime = 0;
        this.fullAlignTime = 0;
        this.realignTime = 0;
        this.publishedFullAlignTimeRemaining = undefined;
        this.publishedAttitudeAlignTimeRemaining = undefined;
        this.lastUpdateSimTime = undefined;
        this.simTime = ConsumerValue.create(null, 0);
        this.isOnGround = ConsumerValue.create(null, false);
        this.speed = ConsumerValue.create(null, 0);
        this.position = ConsumerValue.create(null, new LatLongAlt(0, 0, 0));
        this.headingDataSourceTopicMap = {
            [`irs_hdg_deg_${this.index}`]: `hdg_deg_${this.directionIndicatorIndex}`,
            [`irs_hdg_deg_true_${this.index}`]: `hdg_deg_true_${this.directionIndicatorIndex}`
        };
        this.attitudeDataSourceTopicMap = {
            [`irs_delta_heading_rate_${this.index}`]: `delta_heading_rate_${this.attitudeIndicatorIndex}`,
            [`irs_pitch_deg_${this.index}`]: `pitch_deg_${this.attitudeIndicatorIndex}`,
            [`irs_roll_deg_${this.index}`]: `roll_deg_${this.attitudeIndicatorIndex}`,
            [`irs_turn_coordinator_ball_${this.index}`]: 'turn_coordinator_ball'
        };
        this.inertialDataSourceTopicMap = {
            [`irs_inertial_speed_${this.index}`]: 'inertial_speed',
            [`irs_inertial_vertical_speed_${this.index}`]: 'inertial_vertical_speed',
            [`irs_inertial_acceleration_${this.index}`]: 'inertial_acceleration',
            [`irs_inertial_track_acceleration_${this.index}`]: 'inertial_track_acceleration',
            [`irs_ground_speed_${this.index}`]: 'ground_speed'
        };
        this.inertialHeadingDataSourceTopicMap = {
            [`irs_track_deg_true_${this.index}`]: 'track_deg_true',
            [`irs_track_deg_magnetic_${this.index}`]: 'track_deg_magnetic'
        };
        this.positionDataSourceTopicMap = {
            [`irs_gps-position_${this.index}`]: 'gps-position',
        };
        this.dataSourceSubscriber = this.bus.getSubscriber();
        this.headingDataSubs = [];
        this.attitudeDataSubs = [];
        this.inertialDataSubs = [];
        this.inertialHeadingDataSubs = [];
        this.positionDataSubs = [];
        this.overrideAttitudeAlignDuration = SubscribableUtils.toSubscribable(attitudeAlignDuration, true);
        this.overrideFullAlignDuration = SubscribableUtils.toSubscribable(fullAlignDuration, true);
        this.overrideRealignDuration = SubscribableUtils.toSubscribable(realignDuration, true);
        this.attitudeAlignDuration = this.overrideAttitudeAlignDuration.map(duration => duration === undefined ? IrsSystem.ATTITUDE_ALIGN_DURATION : duration);
        this.fullAlignDuration = MappedSubject.create(([simulated, override, attitudeAlign]) => Math.max(override === undefined ? simulated : override, attitudeAlign), this.simulatedFullAlignDuration, this.overrideFullAlignDuration, this.attitudeAlignDuration);
        this.realignDuration = this.overrideRealignDuration.map(duration => duration === undefined ? IrsSystem.REALIGN_DURATION : duration);
        if (this.powerSource !== undefined) {
            this.connectToPower(this.powerSource);
        }
        // Initialize some cached topics.
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid);
        this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid);
        this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid);
        this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid);
        this.publishFullAlignTimeRemaining(null);
        this.publishAttitudeAlignTimeRemaining(null);
        // Set up automatic position initialization from GPS.
        const gpsReceiverIndexArray = Array.from(new Set(gpsReceiverIndexes)); // Ensure no duplicates
        if (gpsReceiverIndexArray.length > 0) {
            const gpsSub = bus.getSubscriber();
            this.isGpsAvailable = MappedSubject.create(states => states.includes(GPSSystemState.SolutionAcquired) || states.includes(GPSSystemState.DiffSolutionAcquired), ...gpsReceiverIndexArray.map(gpsReceiverIndex => ConsumerSubject.create(gpsSub.on(`gps_rec_gps_system_state_changed_${gpsReceiverIndex}`), GPSSystemState.Searching)));
            this.gpsPositionSub = this.isGpsAvailable.sub(isAvail => {
                if (isAvail) {
                    this.isPositionInit.set(true);
                }
            }, false, true);
        }
        const sub = bus.getSubscriber();
        this.simTime.setConsumer(sub.on('simTime'));
        this.isOnGround.setConsumer(sub.on('on_ground'));
        this.speed.setConsumer(sub.on('inertial_speed'));
        this.position.setConsumer(sub.on('gps-position'));
        this.setPositionSub = sub.on(`irs_set_position_${index}`).handle(() => {
            this.isPositionInit.set(true);
        }, true);
        this.autoSetPositionSub = sub.on('hEvent').handle(hEvent => {
            if (hEvent === 'WT_AUTO_SET_IRS_POS') {
                if (this.isAcceptingPosition.get()) {
                    this.isPositionInit.set(true);
                }
                else {
                    this.autoPositionInit = true;
                }
            }
        });
        this.isAcceptingPosition.sub(val => {
            var _a, _b;
            if (val) {
                this.setPositionSub.resume();
                (_a = this.gpsPositionSub) === null || _a === void 0 ? void 0 : _a.resume(true);
                if (this.autoPositionInit) {
                    this.isPositionInit.set(true);
                    this.autoPositionInit = false;
                }
            }
            else {
                this.setPositionSub.pause();
                (_b = this.gpsPositionSub) === null || _b === void 0 ? void 0 : _b.pause();
            }
            this.publisher.pub(this.acceptingPositionTopic, val);
        }, true);
        // Request manual position input when the system is accepting position inputs, has not received a position input
        // yet, and GPS position is not available.
        this.isRequestingPosition = MappedSubject.create(([isAccepting, isInit, isGpsAvail]) => isAccepting && !isInit && !isGpsAvail, this.isAcceptingPosition, this.isPositionInit, (_a = this.isGpsAvailable) !== null && _a !== void 0 ? _a : Subject.create(false));
        this.isPositionInit.sub(isInit => {
            SimVar.SetSimVarValue(`L:WT_IRS_POS_SET_${this.index}`, SimVarValueType.Bool, isInit);
        }, true);
        this.isRequestingPosition.sub(val => { this.publisher.pub(this.requestingPositionTopic, val); }, true);
        this.startDataPublish();
    }
    /**
     * Starts publishing IRS data on the event bus.
     */
    startDataPublish() {
        for (const topic of Object.keys(this.headingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.attitudeDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onAttitudeTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.inertialHeadingDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
        }
        for (const topic of Object.keys(this.positionDataSourceTopicMap)) {
            if (this.bus.getTopicSubscriberCount(topic) > 0) {
                this.onPositionTopicSubscribed(topic);
            }
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic in this.headingDataSourceTopicMap) {
                this.onHeadingTopicSubscribed(topic);
            }
            else if (topic in this.attitudeDataSourceTopicMap) {
                this.onAttitudeTopicSubscribed(topic);
            }
            else if (topic in this.inertialDataSourceTopicMap) {
                this.onInertialTopicSubscribed(topic);
            }
            else if (topic in this.inertialHeadingDataSourceTopicMap) {
                this.onInertialHeadingTopicSubscribed(topic);
            }
            else if (topic in this.positionDataSourceTopicMap) {
                this.onPositionTopicSubscribed(topic);
            }
        });
    }
    /**
     * Responds to when someone first subscribes to one of this system's heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onHeadingTopicSubscribed(topic) {
        this.headingDataSubs.push(this.dataSourceSubscriber.on(this.headingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's attitude data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onAttitudeTopicSubscribed(topic) {
        this.attitudeDataSubs.push(this.dataSourceSubscriber.on(this.attitudeDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isAttitudeDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialTopicSubscribed(topic) {
        this.inertialDataSubs.push(this.dataSourceSubscriber.on(this.inertialDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial/heading data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onInertialHeadingTopicSubscribed(topic) {
        this.inertialHeadingDataSubs.push(this.dataSourceSubscriber.on(this.inertialHeadingDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isHeadingDataValid || !this.isInertialDataValid));
    }
    /**
     * Responds to when someone first subscribes to one of this system's inertial data topics on the event bus.
     * @param topic The topic that was subscribed to.
     */
    onPositionTopicSubscribed(topic) {
        this.positionDataSubs.push(this.dataSourceSubscriber.on(this.positionDataSourceTopicMap[topic]).handle(val => {
            this.publisher.pub(topic, val, false, true);
        }, !this.isPositionDataValid));
    }
    /**
     * Publishes the time remaining for full alignment to complete.
     * @param time The time to publish, in seconds, or `null` if full alignment is not in process.
     */
    publishFullAlignTimeRemaining(time) {
        if (time === this.publishedFullAlignTimeRemaining) {
            return;
        }
        this.publishedFullAlignTimeRemaining = time;
        this.publisher.pub(this.fullAlignTimeTopic, time, false, true);
    }
    /**
     * Publishes the time remaining for attitude alignment to complete.
     * @param time The time to publish, in seconds, or `null` if attitude alignment is not in process.
     */
    publishAttitudeAlignTimeRemaining(time) {
        if (time === this.publishedAttitudeAlignTimeRemaining) {
            return;
        }
        this.publishedAttitudeAlignTimeRemaining = time;
        this.publisher.pub(this.attitudeAlignTimeTopic, time, false, true);
    }
    /** @inheritdoc */
    onPowerChanged(isPowered) {
        this.isPowered = isPowered;
        this.setState(isPowered ? AvionicsSystemState.On : AvionicsSystemState.Off);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onStateChanged(previousState, currentState) {
        if (currentState === AvionicsSystemState.Off) {
            this.setOperatingMode(IrsSystemOperatingMode.Off);
        }
    }
    /**
     * Sets this system's operating mode.
     * @param mode The operating mode to set.
     */
    setOperatingMode(mode) {
        if (this.operatingMode === mode) {
            return;
        }
        this.operatingMode = mode;
        let resetRealignTime = true;
        let disarmRealign = true;
        switch (mode) {
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                this.fullAlignTime = 0;
                this.attitudeAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.publishAttitudeAlignTimeRemaining(null);
            // fallthrough
            case IrsSystemOperatingMode.AttitudeAlign:
                this.fullAlignTime = 0;
                this.isAcceptingPosition.set(false);
                this.isPositionInit.set(false);
                this.publishFullAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.publishFullAlignTimeRemaining(0);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Navigation:
                disarmRealign = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
            case IrsSystemOperatingMode.Realign:
                this.isAcceptingPosition.set(true);
                resetRealignTime = false;
                this.publishFullAlignTimeRemaining(null);
                this.publishAttitudeAlignTimeRemaining(null);
                break;
        }
        if (resetRealignTime) {
            this.realignTime = 0;
        }
        if (disarmRealign) {
            this.isRealignArmed = false;
        }
        this.isRealignArmed = false;
        this.publisher.pub(this.operatingModeTopic, this.operatingMode);
        this.updateHeadingDataState();
        this.updateAttitudeDataState();
        this.updateInertialDataState();
        this.updateInertialHeadingDataState();
        this.updatePositionDataState();
    }
    /**
     * Updates the validity state of this system's heading data. If heading data is valid, this system will start
     * publishing heading data. If heading data is invalid, this system will stop publishing heading data.
     */
    updateHeadingDataState() {
        // TODO: Heading data requires manual heading input in Attitude mode if the IRS does not have an AHRU component.
        let isHeadingDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isHeadingDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isHeadingDataValid = false;
                break;
            default:
                isHeadingDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isHeadingDataValid !== this.isHeadingDataValid) {
            this.isHeadingDataValid = isHeadingDataValid;
            if (isHeadingDataValid) {
                for (const sub of this.headingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.headingDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.headingDataValidTopic, this.isHeadingDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's attitude data. If attitude data is valid, this system will start
     * publishing attitude data. If attitude data is invalid, this system will stop publishing attitude data.
     */
    updateAttitudeDataState() {
        let isAttitudeDataValid;
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Attitude:
            case IrsSystemOperatingMode.Navigation:
            case IrsSystemOperatingMode.Realign:
                isAttitudeDataValid = true;
                break;
            case IrsSystemOperatingMode.Off:
            case IrsSystemOperatingMode.Standby:
                isAttitudeDataValid = false;
                break;
            default:
                isAttitudeDataValid = this.attitudeAlignTime >= this.attitudeAlignDuration.get();
        }
        if (isAttitudeDataValid !== this.isAttitudeDataValid) {
            this.isAttitudeDataValid = isAttitudeDataValid;
            if (isAttitudeDataValid) {
                for (const sub of this.attitudeDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.attitudeDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.attitudeDataValidTopic, this.isAttitudeDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial data. If inertial data is valid, this system will start
     * publishing inertial data. If inertial data is invalid, this system will stop publishing inertial data.
     */
    updateInertialDataState() {
        const isInertialDataValid = this.operatingMode === IrsSystemOperatingMode.Navigation
            || this.operatingMode === IrsSystemOperatingMode.Realign;
        if (isInertialDataValid !== this.isInertialDataValid) {
            this.isInertialDataValid = isInertialDataValid;
            if (isInertialDataValid) {
                for (const sub of this.inertialDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.inertialDataValidTopic, this.isInertialDataValid, false, true);
        }
    }
    /**
     * Updates the validity state of this system's inertial/heading data. If inertial/heading data is valid, this system
     * will start publishing inertial/heading data. If inertial/heading data is invalid, this system will stop publishing
     * inertial/heading data.
     */
    updateInertialHeadingDataState() {
        const isInertialHeadingDataValid = this.isHeadingDataValid && this.isInertialDataValid;
        if (isInertialHeadingDataValid !== this.isInertialHeadingDataValid) {
            this.isInertialHeadingDataValid = isInertialHeadingDataValid;
            if (isInertialHeadingDataValid) {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.inertialHeadingDataSubs) {
                    sub.pause();
                }
            }
        }
    }
    /**
     * Updates the validity state of this system's position data. If position data is valid, this system will start
     * publishing position data. If position data is invalid, this system will stop publishing position data.
     */
    updatePositionDataState() {
        const isPositionDataValid = this.isInertialDataValid;
        if (isPositionDataValid !== this.isPositionDataValid) {
            this.isPositionDataValid = isPositionDataValid;
            if (isPositionDataValid) {
                for (const sub of this.positionDataSubs) {
                    sub.resume(true);
                }
            }
            else {
                for (const sub of this.positionDataSubs) {
                    sub.pause();
                }
            }
            this.publisher.pub(this.positionDataValidTopic, this.isPositionDataValid, false, true);
        }
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
        if (this.state === AvionicsSystemState.Off) {
            return;
        }
        const simTime = this.simTime.get();
        const dt = this.lastUpdateSimTime === undefined ? 0 : Math.max(0, simTime - this.lastUpdateSimTime);
        this.lastUpdateSimTime = simTime;
        this.updateSimulatedFullAlignDuration();
        const modeSetting = this.operatingModeSetting.get();
        switch (this.operatingMode) {
            case IrsSystemOperatingMode.Off:
                this.updateOff(modeSetting);
                break;
            case IrsSystemOperatingMode.Standby:
                this.updateStandby(modeSetting);
                break;
            case IrsSystemOperatingMode.FullAlign:
                this.updateFullAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.FullAlignPositionPending:
                this.updateFullAlignPositionPending(modeSetting);
                break;
            case IrsSystemOperatingMode.Navigation:
                this.updateNavigation(modeSetting);
                break;
            case IrsSystemOperatingMode.Realign:
                this.updateRealign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.AttitudeAlign:
                this.updateAttitudeAlign(modeSetting, dt);
                break;
            case IrsSystemOperatingMode.Attitude:
                this.updateAttitude(modeSetting);
                break;
        }
    }
    /**
     * Updates the simulated time required to complete a full alignment.
     */
    updateSimulatedFullAlignDuration() {
        // 5 min at equator, 17 min at 70 degrees latitude
        this.simulatedFullAlignDuration.set(MathUtils.lerp(Math.cos(this.position.get().lat * Avionics.Utils.DEG2RAD), 1, 0.342, 300e3, 1020e3, true, true));
    }
    /**
     * Attempts to start a new full or attitude alignment cycle.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @returns Whether a new alignment cycle was started.
     */
    tryStartFreshAlign(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isOnGround.get()) {
                    if (this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                        return true;
                    }
                }
                else if (this.supportInFlightAlign && this.isGpsAvailable && this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
                    this.setOperatingMode(IrsSystemOperatingMode.FullAlign);
                    return true;
                }
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                return true;
        }
        return false;
    }
    /**
     * Updates this system while it is in the Off operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateOff(modeSetting) {
        if (this.tryStartFreshAlign(modeSetting)) {
            return;
        }
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                break;
            default:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
        }
    }
    /**
     * Updates this system while it is in the Standby operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateStandby(modeSetting) {
        this.tryStartFreshAlign(modeSetting);
    }
    /**
     * Updates this system while it is in the FullAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateFullAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                if (this.attitudeAlignTime >= IrsSystem.ATTITUDE_ALIGN_DURATION) {
                    this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                }
                else {
                    this.setOperatingMode(IrsSystemOperatingMode.AttitudeAlign);
                }
                return;
        }
        let isInFlightAlign = false;
        if (this.isOnGround.get()) {
            this.isAcceptingPosition.set(true);
            if (this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
                this.fullAlignTime = 0;
            }
        }
        else if (!this.supportInFlightAlign || !this.isGpsAvailable || !this.isGpsAvailable.get()) { // In-flight alignment requires GPS position input
            this.setOperatingMode(IrsSystemOperatingMode.Standby);
            return;
        }
        else {
            this.isAcceptingPosition.set(false);
            isInFlightAlign = true;
        }
        this.attitudeAlignTime += dt;
        this.fullAlignTime += dt;
        const fullAlignDuration = this.fullAlignDuration.get();
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration
            && (!this.isAttitudeDataValid || !this.isHeadingDataValid)) {
            this.updateAttitudeDataState();
            this.updateHeadingDataState();
        }
        if (this.fullAlignTime >= fullAlignDuration) {
            if (this.isPositionInit.get() || isInFlightAlign) {
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            }
            else {
                this.setOperatingMode(IrsSystemOperatingMode.FullAlignPositionPending);
            }
        }
        else {
            if (this.attitudeAlignTime >= attitudeAlignDuration) {
                this.publishAttitudeAlignTimeRemaining(null);
            }
            else {
                this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
            }
            this.publishFullAlignTimeRemaining((fullAlignDuration - this.fullAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the FullAlignPositionPending operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateFullAlignPositionPending(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        if (this.isPositionInit.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the Navigation operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateNavigation(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.isAcceptingPosition.set(true);
                this.isRealignArmed = true;
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (this.isRealignArmed) {
                    // Realignment requires the airplane be on the ground and not moving.
                    if (this.isOnGround.get() && this.speed.get() <= IrsSystem.ALIGN_SPEED_THRESHOLD) {
                        this.setOperatingMode(IrsSystemOperatingMode.Realign);
                        return;
                    }
                    else {
                        this.isRealignArmed = false;
                    }
                }
                this.isAcceptingPosition.set(false);
                break;
        }
    }
    /**
     * Updates this system while it is in the Realign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateRealign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Navigation);
                return;
            case IrsSystemOperatingModeSetting.Attitude:
                this.setOperatingMode(IrsSystemOperatingMode.Attitude);
                return;
        }
        // Realignment requires the airplane be on the ground and not moving.
        if (!this.isOnGround.get() || this.speed.get() > IrsSystem.ALIGN_SPEED_THRESHOLD) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
            return;
        }
        this.realignTime += dt;
        if (this.realignTime >= this.realignDuration.get()) {
            this.setOperatingMode(IrsSystemOperatingMode.Navigation);
        }
    }
    /**
     * Updates this system while it is in the AttitudeAlign operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     * @param dt The elapsed simulation time, in milliseconds, since the last update.
     */
    updateAttitudeAlign(modeSetting, dt) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                return;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                return;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                return;
        }
        this.attitudeAlignTime += dt;
        const attitudeAlignDuration = this.attitudeAlignDuration.get();
        if (this.attitudeAlignTime >= attitudeAlignDuration) {
            this.setOperatingMode(IrsSystemOperatingMode.Attitude);
        }
        else {
            this.publishAttitudeAlignTimeRemaining((attitudeAlignDuration - this.attitudeAlignTime) / 1000);
        }
    }
    /**
     * Updates this system while it is in the Attitude operating mode.
     * @param modeSetting The current operating mode setting commanded for this system.
     */
    updateAttitude(modeSetting) {
        switch (modeSetting) {
            case IrsSystemOperatingModeSetting.Off:
                this.setOperatingMode(IrsSystemOperatingMode.Off);
                break;
            case IrsSystemOperatingModeSetting.Align:
                this.setOperatingMode(IrsSystemOperatingMode.Standby);
                break;
            case IrsSystemOperatingModeSetting.Navigation:
                if (!this.tryStartFreshAlign(modeSetting)) {
                    this.setOperatingMode(IrsSystemOperatingMode.Standby);
                }
                break;
        }
    }
}
IrsSystem.ATTITUDE_ALIGN_DURATION = 30000; // milliseconds
IrsSystem.REALIGN_DURATION = 30000; // milliseconds
IrsSystem.ALIGN_SPEED_THRESHOLD = 1; // meters per second

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/**
 * Automatically selects the best IRS from a set of candidates based on the current states of all systems. System state
 * desiribility is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class IrsSystemSelector {
    /**
     * Constructor.
     * @param index The index of this selector.
     * @param bus The event bus.
     * @param candidateSystemIndexes The indexes of the IRS systems from which to select.
     * @param systemPriorities The priorities for selecting individual IRS systems. If two systems have the same
     * desirability, then the one with the higher priority will be selected. If a system's priority is not defined, then
     * it will default to a value of `0`. The priorities can be specified as an array of IRS system indexes or a map of
     * IRS system indexes to the priorities for selecting those systems. If specified as an array of indexes, then each
     * system whose index appears in the array will be assigned a priority equal to
     * `array.length - array.indexOf(index)`.
     */
    constructor(index, bus, candidateSystemIndexes, systemPriorities) {
        this.index = index;
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        this.selectedIndex = Subject.create(-1);
        this.isAttitudeDataValid = Subject.create(false);
        this.isHeadingDataValid = Subject.create(false);
        this.isInertialDataValid = Subject.create(false);
        this.isInertialHeadingDataValid = Subject.create(false);
        this.isPositionDataValid = Subject.create(false);
        this.irsEntries = new Map();
        this.irsOrder = [];
        this.irsComparator = (a, b) => {
            var _a, _b;
            return ((_a = this.systemPriorities.getValue(b)) !== null && _a !== void 0 ? _a : 0) - ((_b = this.systemPriorities.getValue(a)) !== null && _b !== void 0 ? _b : 0);
        };
        this.needReselect = true;
        this.isAlive = true;
        this.isInit = false;
        this.candidateSystemIndexes = 'isSubscribableSet' in candidateSystemIndexes ? candidateSystemIndexes : SetSubject.create(candidateSystemIndexes);
        if (systemPriorities) {
            if ('isSubscribableMap' in systemPriorities) {
                this.systemPriorities = systemPriorities;
            }
            else if (systemPriorities instanceof Map) {
                this.systemPriorities = MapSubject.create(systemPriorities);
            }
            else {
                this.systemPriorities = MapSubject.create(systemPriorities.map((adcIndex, arrayIndex, array) => [adcIndex, array.length - arrayIndex]));
            }
        }
        else {
            this.systemPriorities = MapSubject.create();
        }
        // Set up publishing.
        this.selectedIndex.sub(this.publisher.pub.bind(this.publisher, `irs_selector_selected_index_${index}`), true);
        this.isAttitudeDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_attitude_data_valid_${index}`), true);
        this.isHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_heading_data_valid_${index}`), true);
        this.isInertialDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_data_valid_${index}`), true);
        this.isInertialHeadingDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_inertial_heading_data_valid_${index}`), true);
        this.isPositionDataValid.sub(this.publisher.pub.bind(this.publisher, `irs_selector_position_data_valid_${index}`), true);
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        const sub = this.bus.getSubscriber();
        const scheduleReselect = () => { this.needReselect = true; };
        this.candidateSystemIndexesSub = this.candidateSystemIndexes.sub((set, type, key) => {
            const existing = this.irsEntries.get(key);
            if (existing) {
                for (const subject of existing.subjects) {
                    subject.destroy();
                }
            }
            if (type === SubscribableSetEventType.Added) {
                const subjects = [
                    ConsumerSubject.create(sub.on(`irs_attitude_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_heading_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_inertial_data_valid_${key}`), false),
                    ConsumerSubject.create(sub.on(`irs_position_data_valid_${key}`), false)
                ];
                const entry = {
                    subjects,
                    state: MappedSubject.create(...subjects)
                };
                this.irsEntries.set(key, entry);
                // When there is a change in an IRS state, we don't reselect immediately because the IRS could be in an
                // intermediate transition state. Instead, we will schedule a reselect during the next update loop.
                entry.state.sub(scheduleReselect);
            }
            else {
                this.irsEntries.delete(key);
            }
            this.needReselect = true;
        }, true);
        this.systemPrioritiesSub = this.systemPriorities.sub(scheduleReselect);
        this.updateSub = sub.on('realTime').handle(this.update.bind(this));
    }
    /**
     * Updates this selector.
     */
    update() {
        if (this.needReselect) {
            this.selectIndex();
            this.needReselect = false;
        }
    }
    /**
     * Selects the index of the IRS with the most desirable state.
     */
    selectIndex() {
        let bestIndex;
        let bestState;
        if (this.irsEntries.size === 0) {
            bestIndex = -1;
            bestState = undefined;
        }
        else if (this.irsEntries.size === 1) {
            const entry = this.irsEntries.entries().next().value;
            bestIndex = entry[0];
            bestState = entry[1].state.get();
        }
        else {
            // Sort the systems in order of decreasing priority.
            this.irsOrder.length = 0;
            for (const index of this.irsEntries.keys()) {
                this.irsOrder.push(index);
            }
            this.irsOrder.sort(this.irsComparator);
            bestIndex = -1;
            for (let i = 0; i < this.irsOrder.length; i++) {
                const index = this.irsOrder[i];
                const state = this.irsEntries.get(index).state.get();
                if (!bestState || IrsSystemSelector.compareIrsState(state, bestState) < 0) {
                    bestIndex = index;
                    bestState = state;
                }
            }
        }
        this.selectedIndex.set(bestIndex);
        if (bestState) {
            this.isAttitudeDataValid.set(bestState[0]);
            this.isHeadingDataValid.set(bestState[1]);
            this.isInertialDataValid.set(bestState[2]);
            this.isInertialHeadingDataValid.set(bestState[1] && bestState[2]);
            this.isPositionDataValid.set(bestState[3]);
        }
        else {
            this.isAttitudeDataValid.set(false);
            this.isHeadingDataValid.set(false);
            this.isInertialDataValid.set(false);
            this.isInertialHeadingDataValid.set(false);
            this.isPositionDataValid.set(false);
        }
    }
    /**
     * Destroys this selector.
     */
    destroy() {
        var _a, _b, _c;
        this.isAlive = false;
        (_a = this.updateSub) === null || _a === void 0 ? void 0 : _a.destroy();
        for (const entry of this.irsEntries.values()) {
            for (const subject of entry.subjects) {
                subject.destroy();
            }
        }
        (_b = this.candidateSystemIndexesSub) === null || _b === void 0 ? void 0 : _b.destroy();
        (_c = this.systemPrioritiesSub) === null || _c === void 0 ? void 0 : _c.destroy();
    }
    /**
     * Compares two IRS states and returns a number whose sign indicates which one is more desirable.
     * @param a The first IRS state to compare.
     * @param b The second IRS state to compare.
     * @returns A negative number of state `a` is more desirable than `b`, a positive number if state `b` is more
     * desirable than `a`, or zero if the two states are equally desirable.
     */
    static compareIrsState(a, b) {
        // The data validity flags within the state array are ordered such that a false flag cannot precede a true flag,
        // so we can exploit this fact.
        return b.lastIndexOf(true) - a.lastIndexOf(true);
    }
}

/**
 * The GMU44 magnetometer system.
 */
class MagnetometerSystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the MagnetometerSystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param powerSource The {@link ElectricalEvents} topic or electricity logic element to which to connect the
     * system's power.
     */
    constructor(index, bus, powerSource) {
        super(index, bus, `magnetometer_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.initializationTime = 5000;
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
}

/**
 * The Radio Altimeter system.
 */
class RASystem extends BasicAvionicsSystem {
    /**
     * Creates an instance of the RASystem.
     * @param index The index of the system.
     * @param bus The instance of the event bus for the system to use.
     * @param radioAltOffset The radio altimeter offset.
     * @param powerSource The power source.
     */
    constructor(index, bus, radioAltOffset, powerSource) {
        super(index, bus, `ra_state_${index}`);
        this.index = index;
        this.bus = bus;
        this.radioAltOffset = radioAltOffset;
        this.powerSource = powerSource;
        this.initializationTime = 7000;
        const radioAltTopic = `ra_radio_alt_${this.index}`;
        if (this.bus.getTopicSubscriberCount(radioAltTopic) > 0) {
            this.onRadioAltTopicSubscribed();
        }
        this.bus.getSubscriber().on('event_bus_topic_first_sub').handle(topic => {
            if (topic === radioAltTopic) {
                this.onRadioAltTopicSubscribed();
            }
        });
        if (powerSource !== undefined) {
            this.connectToPower(powerSource);
        }
    }
    /**
     * Responds to when someone first subscribes to this system's radar altitude data topic on the event bus.
     */
    onRadioAltTopicSubscribed() {
        const topic = `ra_radio_alt_${this.index}`;
        const paused = this.state === AvionicsSystemState.Failed || this.state === AvionicsSystemState.Off;
        this.radioAltSub = this.bus.getSubscriber().on('radio_alt').atFrequency(3).handle(val => {
            this.publisher.pub(topic, val + this.radioAltOffset);
        }, paused);
    }
    /** @inheritdoc */
    onStateChanged(previousState, currentState) {
        var _a, _b;
        if (currentState === AvionicsSystemState.Failed || currentState === AvionicsSystemState.Off) {
            (_a = this.radioAltSub) === null || _a === void 0 ? void 0 : _a.pause();
        }
        else {
            (_b = this.radioAltSub) === null || _b === void 0 ? void 0 : _b.resume(true);
        }
    }
}

/** A class to publish events related to all IRS systems as a whole. */
class IrsSystemGroupStatusPublisher {
    /** @inheritDoc */
    constructor(bus, irsCount) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
        const sub = bus.getSubscriber();
        MappedSubject.create(modes => {
            for (let i = 0; i < modes.length; i++) {
                if (modes[i] !== IrsSystemOperatingMode.Navigation && modes[i] !== IrsSystemOperatingMode.Realign) {
                    return false;
                }
            }
            return true;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Off))).sub(allOperating => this.publisher.pub('all_irs_systems_operating', allOperating), true);
        const anIrsIsAcceptingPos = MappedSubject.create(irsSystemIsAcceptingPos => {
            for (let i = 0; i < irsSystemIsAcceptingPos.length; i++) {
                if (irsSystemIsAcceptingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_accepting_position_${index + 1}`), false)));
        const anIrsIsRequestingPos = MappedSubject.create(irsSystemIsRequestingPos => {
            for (let i = 0; i < irsSystemIsRequestingPos.length; i++) {
                if (irsSystemIsRequestingPos[i]) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_is_requesting_position_${index + 1}`), false)));
        anIrsIsAcceptingPos.sub(acceptingPos => this.publisher.pub('an_irs_is_accepting_pos', acceptingPos), true);
        anIrsIsRequestingPos.sub(requestingPos => this.publisher.pub('an_irs_is_requesting_pos', requestingPos), true);
        MappedSubject.create(([isAccepting, isRequesting]) => isAccepting || isRequesting, anIrsIsAcceptingPos, anIrsIsRequestingPos).sub(accOrReqPos => this.publisher.pub('an_irs_is_accepting_or_requesting_pos', accOrReqPos), true);
        const anIrsIsOperating = MappedSubject.create((irsOperatingMode) => {
            for (let i = 0; i < irsOperatingMode.length; i++) {
                if (irsOperatingMode[i] === IrsSystemOperatingMode.Navigation || irsOperatingMode[i] === IrsSystemOperatingMode.Realign) {
                    return true;
                }
            }
            return false;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_operating_mode_${index + 1}`), IrsSystemOperatingMode.Navigation)));
        anIrsIsOperating.sub(isAnyOperating => this.publisher.pub('an_irs_system_is_operating', isAnyOperating), true);
        const maxIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let maxSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (maxSeconds === null || remaining > maxSeconds) {
                        maxSeconds = remaining;
                    }
                }
            }
            return maxSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        maxIrsAlignSecondsRemaining.sub(maxRemaining => this.publisher.pub('max_irs_align_seconds_remaining', maxRemaining), true);
        const minIrsAlignSecondsRemaining = MappedSubject.create((irsFullAlignSecondsRemaining) => {
            let minSeconds = null;
            for (let i = 0; i < irsFullAlignSecondsRemaining.length; i++) {
                const remaining = irsFullAlignSecondsRemaining[i];
                if (remaining !== null) {
                    if (minSeconds === null || remaining < minSeconds) {
                        minSeconds = remaining;
                    }
                }
            }
            return minSeconds;
        }, ...ArrayUtils.create(irsCount, index => ConsumerSubject.create(sub.on(`irs_full_align_time_remaining_${index + 1}`), null)));
        minIrsAlignSecondsRemaining.sub(minRemaining => this.publisher.pub('min_irs_align_seconds_remaining', minRemaining), true);
        const anIrsIsAligning = maxIrsAlignSecondsRemaining.map(x => x !== null);
        anIrsIsAligning.sub(isAligning => this.publisher.pub('an_irs_is_aligning', isAligning), true);
    }
}

/* eslint-disable @typescript-eslint/no-non-null-assertion */
/** MessageService, copied from CJ4 mod, with modifications. */
class MessageService {
    constructor() {
        this.activeMsgs = new Map();
        this.receivers = new Map();
    }
    /**
     * Posts messages to the targets defined in the message definition
     * @param msgkey The message identifier
     * @param exitHandler An optional function that returns true when the msg should not be shown anymore.
     * If it is not passed in, you must clear the message manually by calling the clear function.
     * @param blinkHandler A function that returns a boolean indicating if the message should blink
     */
    post(msgkey, exitHandler, blinkHandler = () => false) {
        if (MessageDefinitions.definitions.has(msgkey)) {
            const opmsg = MessageDefinitions.definitions.get(msgkey);
            opmsg.msgDefs.forEach(def => {
                if (this.receivers.has(def.target)) {
                    this.receivers.get(def.target).process(msgkey, def.text, opmsg.level, opmsg.weight, def.target, blinkHandler);
                }
            });
            this.activeMsgs.set(msgkey, new MessageConditionChecks(exitHandler));
        }
    }
    /**
     * Clears a message from all targets
     * @param msgkey The message identifier
     */
    clear(msgkey) {
        if (this.activeMsgs.has(msgkey)) {
            this._clear(msgkey);
        }
    }
    /** Update function which calls the exitHandler function and clears messages that have to go */
    update() {
        this.activeMsgs.forEach((v, k) => {
            if (v.exitHandler && v.exitHandler() === true) {
                this._clear(k);
            }
        });
    }
    /** Tells receivers that a message has been cleared.
     * @param messageId The message id to clear. */
    _clear(messageId) {
        const opmsg = MessageDefinitions.definitions.get(messageId);
        opmsg.msgDefs.forEach(def => {
            if (this.receivers.has(def.target)) {
                this.receivers.get(def.target).clear(messageId);
            }
        });
        this.activeMsgs.delete(messageId);
    }
    /**
     * Registers a receiver implementation to the target display
     * @param target The target display
     * @param receiver The receiver
     */
    registerReceiver(target, receiver) {
        this.receivers.set(target, receiver);
    }
}
/** Just a wrapper */
class MessageConditionChecks {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(_exitHandler) {
        this._exitHandler = _exitHandler;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    get exitHandler() {
        return this._exitHandler;
    }
    // eslint-disable-next-line jsdoc/require-jsdoc
    set exitHandler(v) {
        this._exitHandler = v;
    }
}

// TODO auto-select CRS for proc navaids, vor approach, and some vor transitions... whatever that means
/** Selects and tunes VORs by the FMC. */
class BoeingVorManager {
    // eslint-disable-next-line jsdoc/require-jsdoc
    constructor(bus, flightPlanner, facLoader) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.facLoader = facLoader;
        this.blacklist = new Set();
        this.blacklistTimes = new Map();
        this.lnavDataCurrentLegIndex = ConsumerSubject.create(null, -1);
        this.ppos = new GeoPoint(0, 0);
        this.altitude = 0;
        this.horizonDistance = 10;
        this.vor1HasNav = ConsumerSubject.create(null, false);
        this.vor2HasNav = ConsumerSubject.create(null, false);
        this.tuningModeLeft = Subject.create(VorTuningMode.None);
        this.tuningModeRight = Subject.create(VorTuningMode.None);
        /** If the VOR was lost last time we checked, and it's still lost, we check for a new one */
        this.vorLostLastUpdate = true;
        this.procedureVor = null;
        this.routeVor = null;
        /** Current autotune selected VOR */
        this.selectedVor = null;
        /** Current mode if using the autotune selected VOR */
        this.selectedMode = VorTuningMode.None;
        this.facilities = ArraySubject.create([]);
        this.monitorEvents();
    }
    /**
     * Handle sequencing of LNAV legs, selecting new procedure and route VORs
     */
    async onLnavSequenced() {
        const legIndex = this.lnavDataCurrentLegIndex.get();
        if (legIndex < 0 || !this.flightPlanner.hasActiveFlightPlan()) {
            if (this.procedureVor !== null) {
                this.procedureVor = null;
                this.selectNewVor();
            }
            if (this.routeVor !== null) {
                this.routeVor = null;
                this.selectNewVor();
            }
            return;
        }
        const plan = this.flightPlanner.getActiveFlightPlan();
        const activeLeg = plan.tryGetLeg(legIndex);
        if (!activeLeg) {
            return;
        }
        const segment = plan.getSegmentFromLeg(activeLeg);
        this.procedureVor = null;
        // check approach, preferring procedure navaids at or past the current leg, but before as last resort
        if ((segment === null || segment === void 0 ? void 0 : segment.segmentType) === FlightPlanSegmentType.Approach) {
            const lastLeg = segment.offset + segment.legs.length;
            for (let i = segment.offset; i < lastLeg; i++) {
                const leg = plan.tryGetLeg(i);
                const facility = await this.tryGetVorFromLeg(leg, true);
                if (facility) {
                    this.procedureVor = facility;
                    if (i >= legIndex) {
                        break;
                    }
                }
            }
        }
        // check SID, preferring procedure navaids at or past the current leg, but before as last resort
        if ((segment === null || segment === void 0 ? void 0 : segment.segmentType) === FlightPlanSegmentType.Departure) {
            const lastLeg = segment.offset + segment.legs.length;
            for (let i = segment.offset; i < lastLeg; i++) {
                const leg = plan.tryGetLeg(i);
                const facility = await this.tryGetVorFromLeg(leg, true);
                if (facility) {
                    this.procedureVor = facility;
                    if (i >= legIndex) {
                        break;
                    }
                }
            }
        }
        this.routeVor = null;
        // check the current leg for a route vor
        const activeLegFacility = await this.tryGetVorFromLeg(activeLeg);
        if (activeLegFacility) {
            this.routeVor = activeLegFacility;
        }
        if (this.routeVor === null) {
            // check the previous leg for a route vor
            const leg = plan.tryGetLeg(legIndex - 1);
            const prevLegFacility = await this.tryGetVorFromLeg(leg);
            if (prevLegFacility) {
                this.routeVor = prevLegFacility;
            }
        }
        if (this.routeVor === null) {
            // finally, look down the f-pln 5 legs and check for a suitable route VOR
            for (let i = legIndex + 1; i <= legIndex + 5; i++) {
                const leg = plan.tryGetLeg(i);
                const facility = await this.tryGetVorFromLeg(leg);
                if (facility) {
                    this.routeVor = facility;
                    break;
                }
            }
        }
        if (this.selectedMode !== VorTuningMode.AutoTuned || this.isProcedureVorAvailable() || this.isRouteVorAvailable()) {
            this.selectNewVor();
        }
    }
    /**
     * Get the VOR facility associated with a flight plan leg if available
     * @param leg The leg to check
     * @param checkOrigin Check originIcao (i.e. recommended navaid) rather than the fixIcao
     * @returns A VorFacility or null if there isn't one
     */
    async tryGetVorFromLeg(leg, checkOrigin = false) {
        if (!leg) {
            return null;
        }
        const icao = checkOrigin ? leg.leg.originIcao : leg.leg.fixIcao;
        if (ICAO.isFacility(icao, FacilityType.VOR)) {
            const facility = await this.facLoader.getFacility(FacilityType.VOR, icao);
            if (facility && this.isAllowedFacility(facility)) {
                return facility;
            }
        }
        return null;
    }
    /**
     * Check if a VOR facility is of a type eligible for VOR autotuning
     * @param facility The VOR facility to check
     * @returns true if the facility is eligible for tuning
     */
    isAllowedFacility(facility) {
        return facility.vorClass !== VorClass.Unknown
            && (facility.type === VorType.VOR
                || facility.type === VorType.VORDME
                || facility.type === VorType.VORTAC);
    }
    /**
     * Check if a VOR facility is within a suitable range for VOR autotuning
     * @param facility The VOR facility to check
     * @param checkConeOfConfusion Whether to check the cone of confusion criteria
     * @returns true if the facility is within range
     */
    isInRange(facility, checkConeOfConfusion = true) {
        if (this.altitude > 18000 && (facility.vorClass === VorClass.LowAlt || facility.vorClass === VorClass.Terminal)) {
            return false;
        }
        if (this.altitude > 12000 && facility.vorClass === VorClass.Terminal) {
            return false;
        }
        const dist = UnitType.GA_RADIAN.convertTo(this.ppos.distance(facility.lat, facility.lon), UnitType.NMILE);
        switch (facility.vorClass) {
            case VorClass.HighAlt:
                // unfortunately MSFS db doesn't have FoM to determine range of 130 or 250
                if (dist > 130) {
                    return false;
                }
                break;
            case VorClass.LowAlt:
                if (dist > 70) {
                    return false;
                }
                break;
            default:
                if (dist > 40) {
                    return false;
                }
        }
        // Check we can see the navaid over the horizon, with a conservative adjustment for refraction
        // Note: the real thing also considers the navaid elevation, but that information is not available to us from the facility
        if (dist > Math.max(10, (7 / 6 * this.horizonDistance))) {
            return false;
        }
        if (!checkConeOfConfusion) {
            return true;
        }
        // cone of confusion is 30° up to infinite altitude
        const coneOfConfusionDist = UnitType.NMILE.convertFrom(this.altitude, UnitType.FOOT) * Math.tan(Math.PI / 6);
        return dist > coneOfConfusionDist;
    }
    /**
     * Check if a procedure VOR is available for tuning
     * @returns true if a procedure VOR is available
     */
    isProcedureVorAvailable() {
        return this.procedureVor !== null;
    }
    /**
     * Check if a route VOR is available for tuning
     * @returns true if a route VOR is available and in-range
     */
    isRouteVorAvailable() {
        return this.routeVor !== null && this.isInRange(this.routeVor, false);
    }
    /**
     * Selects and tunes a new VOR from those currently available for tuning
     * @param maximumDistance The maximum distance in nautical miles to consider.
     * If there are no candidates inside this range nothing is done.
     */
    selectNewVor(maximumDistance = Infinity) {
        if (this.procedureVor && this.isProcedureVorAvailable()) {
            this.selectVor(this.procedureVor, VorTuningMode.ProcedureTuned);
            return;
        }
        if (this.routeVor && this.isRouteVorAvailable()) {
            this.selectVor(this.routeVor, VorTuningMode.RouteTuned);
            return;
        }
        let bestDistance = Infinity;
        let bestCandidate = null;
        for (const facility of this.facilities.getArray()) {
            if (this.blacklist.has(facility.icao) || !this.isAllowedFacility(facility) || !this.isInRange(facility)) {
                continue;
            }
            const distance = this.ppos.distance(facility.lat, facility.lon);
            if (distance < bestDistance && distance <= maximumDistance) {
                bestDistance = distance;
                bestCandidate = facility;
            }
        }
        if (bestCandidate !== null) {
            this.selectVor(bestCandidate, VorTuningMode.AutoTuned);
        }
    }
    /**
     * Select a new VOR and tune it on available receivers
     * @param facility The VOR facility to tune
     * @param mode The tuning mode used to select the VOR
     */
    selectVor(facility, mode) {
        this.selectedVor = facility;
        this.selectedMode = mode;
        this.vorLostLastUpdate = false;
        if (this.tuningModeLeft.get() !== VorTuningMode.ManuallyTuned) {
            this.tuneVor(1);
        }
        if (this.tuningModeRight.get() !== VorTuningMode.ManuallyTuned) {
            this.tuneVor(2);
        }
    }
    /**
     * Tune the selected VOR on the given receiver
     * @param index The receiver to tune
     */
    tuneVor(index) {
        if (!this.selectedVor || this.selectedMode === VorTuningMode.None) {
            if (index === 1) {
                this.tuningModeLeft.set(VorTuningMode.None);
            }
            else {
                this.tuningModeRight.set(VorTuningMode.None);
            }
            return;
        }
        const currentFrequency = SimVar.GetSimVarValue(`NAV ACTIVE FREQUENCY:${index}`, 'mhz');
        // We only tune radios when required to avoid temporal loss of ident/radial/DME information
        if (!BoeingFmsUtils.vhfFrequenciesEqual(this.selectedVor.freqMHz, currentFrequency)) {
            SimVar.SetSimVarValue(`K:NAV${index}_RADIO_SET_HZ`, SimVarValueType.Number, this.selectedVor.freqMHz * 1000000);
        }
        index === 1 ? this.tuningModeLeft.set(this.selectedMode) : this.tuningModeRight.set(this.selectedMode);
    }
    /**
     * Check if the selected VORs are available, tuning new VORs when required
     */
    checkTunedVorStatus() {
        if (this.tuningModeLeft.get() === VorTuningMode.None || this.tuningModeRight.get() === VorTuningMode.None) {
            this.selectNewVor();
            return;
        }
        if (this.tuningModeLeft.get() === VorTuningMode.ManuallyTuned && this.tuningModeRight.get() === VorTuningMode.ManuallyTuned) {
            return;
        }
        // if a procedure or route VOR became available we should switch to it
        if (this.isProcedureVorAvailable() && this.selectedMode !== VorTuningMode.ProcedureTuned) {
            this.selectNewVor();
            return;
        }
        if (this.isRouteVorAvailable() && this.selectedMode !== VorTuningMode.RouteTuned) {
            this.selectNewVor();
            return;
        }
        let maximumDistance = Infinity;
        if (this.selectedVor !== null) {
            maximumDistance = UnitType.NMILE.convertFrom(this.ppos.distance(this.selectedVor.lat, this.selectedVor.lon), UnitType.GA_RADIAN)
                + BoeingVorManager.NEARBY_VOR_STICKY_DISTANCE;
        }
        // if the receiver is manually tuned we want to ignore for it for the purposes of determining our selected VOR as lost
        const vorReceived = (this.tuningModeLeft.get() === VorTuningMode.ManuallyTuned || this.vor1HasNav.get())
            && (this.tuningModeRight.get() === VorTuningMode.ManuallyTuned || this.vor2HasNav.get());
        if (!vorReceived && this.vorLostLastUpdate) {
            if (this.selectedVor) {
                this.blacklist.add(this.selectedVor.icao);
                maximumDistance = Infinity;
            }
        }
        else if (!vorReceived) {
            this.vorLostLastUpdate = true;
        }
        else {
            this.vorLostLastUpdate = false;
        }
        this.selectNewVor(maximumDistance);
    }
    /**
     * Handle manual FMC tuning event from CDU
     * @param index Index of the VOR receiver to tune, 1 for left or 2 for right
     * @param frequency Desired frequency in MHz or null to clear manual tuning mode and resume auto-tuning
     */
    onManualTune(index, frequency) {
        if (frequency === null) {
            this.tuneVor(index);
        }
        else {
            SimVar.SetSimVarValue(`K:NAV${index}_RADIO_SET_HZ`, SimVarValueType.Number, frequency * 1000000);
            index === 1 && this.tuningModeLeft.set(VorTuningMode.ManuallyTuned);
            index === 2 && this.tuningModeRight.set(VorTuningMode.ManuallyTuned);
        }
    }
    /**
     * Updates the blacklist, removing expired items
     */
    updateBlacklist() {
        var _a;
        for (const icao of this.blacklist.values()) {
            const blacklistedFor = (_a = this.blacklistTimes.get(icao)) !== null && _a !== void 0 ? _a : 0;
            if (blacklistedFor >= BoeingVorManager.BLACKLIST_TIMEOUT) {
                this.blacklist.delete(icao);
                this.blacklistTimes.delete(icao);
            }
            else {
                this.blacklistTimes.set(icao, blacklistedFor + 10);
            }
        }
    }
    /**
     * Connect event listeners to the bus to begin operation
     */
    monitorEvents() {
        const sub = this.bus.getSubscriber();
        sub.on('fms_pos_gps-position_1').handle(lla => { this.ppos.set(lla.lat, lla.long); });
        sub.on('indicated_alt').whenChangedBy(10).handle((z) => {
            this.altitude = z;
            const earthRadius = UnitType.GA_RADIAN.convertTo(1, UnitType.NMILE);
            const planeAltNm = Math.max(0, UnitType.FOOT.convertTo(this.altitude, UnitType.NMILE));
            this.horizonDistance = Math.sqrt(planeAltNm * (2 * earthRadius + planeAltNm));
        });
        this.lnavDataCurrentLegIndex.setConsumer(sub.on('lnav_tracked_leg_index'));
        this.lnavDataCurrentLegIndex.sub(this.onLnavSequenced.bind(this));
        sub.on('realTime').atFrequency(0.1).handle(this.updateBlacklist.bind(this));
        sub.on('realTime').atFrequency(0.1).handle(this.checkTunedVorStatus.bind(this));
        this.vor1HasNav.setConsumer(sub.on('nav_has_nav_1'));
        this.vor2HasNav.setConsumer(sub.on('nav_has_nav_2'));
        this.tuningModeLeft.sub((m) => this.bus.getPublisher().pub('vor_tuning_mode_left', m));
        this.tuningModeRight.sub((m) => this.bus.getPublisher().pub('vor_tuning_mode_right', m));
        sub.on('set_manual_vor_freq_left').handle((freq) => this.onManualTune(1, freq));
        sub.on('set_manual_vor_freq_right').handle((freq) => this.onManualTune(2, freq));
        NearestContext.onInitialized((instance) => {
            instance.vors.sub((index, type, item) => {
                switch (type) {
                    case SubscribableArrayEventType.Added:
                        this.facilities.insert(item, index);
                        break;
                    case SubscribableArrayEventType.Removed:
                        this.facilities.removeAt(index);
                        break;
                    case SubscribableArrayEventType.Cleared:
                        this.facilities.clear();
                        break;
                }
            });
        });
    }
}
/** VORs are blacklisted for this amount of time in seconds when tuned and not received */
BoeingVorManager.BLACKLIST_TIMEOUT = 600;
/**
 * If we have a nearby VOR tuned, new VORs would need to be closer than the current one by
 * this distance (in nautical miles) to be considered.
 */
BoeingVorManager.NEARBY_VOR_STICKY_DISTANCE = 5;

/**
 * A TCAS II implementation for the Boeing airplanes.
 */
class BoeingTCAS extends Tcas {
    constructor() {
        super(...arguments);
        this.settings = TrafficUserSettings.getManager(this.bus);
        /** All RAs are inhibited when airplane is on ground, or when airplane's radio altitude < 1100ft. */
        this.isRAsInhibited = MappedSubject.create(([radarAlt, isClimbing]) => {
            return radarAlt < (isClimbing ? 900 : 1100);
        }, this.ownAirplaneSubs.radarAltitude.map(radarAlt => Math.round(radarAlt.asUnit(UnitType.FOOT))), this.ownAirplaneSubs.verticalSpeed.map(verticalSpeed => verticalSpeed.number >= 0));
    }
    /** @inheritdoc */
    init() {
        super.init();
        this.settings.whenSettingChanged('trafficOperatingMode').handle(mode => {
            switch (mode) {
                case TcasOperatingModeSetting.Standby:
                    this.setOperatingMode(TcasOperatingMode.Standby);
                    break;
                case TcasOperatingModeSetting.TAOnly:
                    this.setOperatingMode(TcasOperatingMode.TAOnly);
                    break;
                case TcasOperatingModeSetting.TA_RA:
                    if (this.isRAsInhibited.get()) {
                        this.setOperatingMode(TcasOperatingMode.TAOnly);
                    }
                    else {
                        this.setOperatingMode(TcasOperatingMode.TA_RA);
                    }
                    break;
            }
        });
        this.isRAsInhibited.sub(isInhibited => {
            if (this.settings.getSetting('trafficOperatingMode').value === TcasOperatingModeSetting.TA_RA) {
                this.setOperatingMode(isInhibited ? TcasOperatingMode.TAOnly : TcasOperatingMode.TA_RA);
            }
        });
    }
    /** @inheritdoc */
    createSensitivity() {
        return new TcasIISensitivity();
    }
    /** @inheritdoc */
    createIntruderEntry(contact) {
        return new DefaultTcasIntruder(contact);
    }
    /** @inheritdoc */
    updateSensitivity() {
        this.sensitivity.updateLevel(this.ownAirplaneSubs.altitude.get(), this.ownAirplaneSubs.radarAltitude.get());
    }
}

/** Stores wind data associated with a flightplan */
class WindPlan {
    /**
     * Constructs a new WindPlan
     * @param options Options for the WindPlanner
     * @param numberOfLegs Number of legs to initialise the plan with (will be filled with empty data)
     */
    constructor(options, numberOfLegs = 0) {
        this.options = options;
        this.climbData = [];
        this.descentData = [];
        /** Maps global flight plan leg index to wind records */
        this.legWindData = [];
        /** Maps global flight plan leg index to temparture records */
        this.legTemperatureData = [];
        if (numberOfLegs > 0) {
            this.legWindData = Array.from({ length: numberOfLegs }, () => []);
        }
    }
    /**
     * Set wind for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during climb
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.climbData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature !== null;
            this.refreshTemperaturePropagation(this.climbData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfClimbAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.climbData, wind);
        return true;
    }
    /**
     * Deletes a climb wind record
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(altitude) {
        const deleteIndex = this.climbData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.climbData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the climb wind records for a flight plan
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures() {
        return this.climbData;
    }
    /**
     * Set wind for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(altitude, speed, direction) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.speed = speed;
            replaceRecord.direction = direction;
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.climbData.length >= ((_b = this.options.numberOfDescentAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed, direction, windPropagated: false, temperature: null, temperaturePropagated: true };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Set temperature for an altitude during descent
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setDescentTemperature(altitude, temperature = null) {
        var _a, _b;
        const replaceRecord = this.descentData.find((r) => r.altitude === altitude);
        if (replaceRecord) {
            replaceRecord.altitude = altitude;
            replaceRecord.temperature = temperature;
            replaceRecord.temperaturePropagated = temperature === null;
            this.refreshTemperaturePropagation(this.descentData);
            return true;
        }
        if (isFinite((_a = this.options.numberOfDescentAltitudes) !== null && _a !== void 0 ? _a : Infinity)) {
            if (this.descentData.length >= ((_b = this.options.numberOfClimbAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
                return false;
            }
        }
        const wind = { altitude, speed: null, direction: null, temperature, windPropagated: false, temperaturePropagated: temperature === null };
        this.insertClimbDescentRecord(this.descentData, wind);
        return true;
    }
    /**
     * Deletes a descent wind record
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWind(altitude) {
        const deleteIndex = this.descentData.findIndex((r) => r.altitude === altitude);
        if (deleteIndex >= 0) {
            this.descentData.splice(deleteIndex, 1);
        }
    }
    /**
     * Gets the descent wind records for a flight plan
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures() {
        return this.descentData;
    }
    /**
     * Deletes the record for a leg (when the leg is deleted from the flightplan)
     * @param globalLegIndex Index of leg in entire flight plan
     */
    deleteLeg(globalLegIndex) {
        // Does not removed propagated data from other legs... may need an option for this later with other FMS types
        if (this.legWindData[globalLegIndex]) {
            this.legWindData.splice(globalLegIndex, 1);
        }
        if (this.legTemperatureData[globalLegIndex]) {
            this.legTemperatureData.splice(globalLegIndex, 1);
        }
    }
    /**
     * Inserts a new flight plan leg and propagates data from existing legs
     * @param globalLegIndex Index of leg in entire flight plan
     */
    insertLegAndPropagate(globalLegIndex) {
        this.legWindData.splice(globalLegIndex, 0, []);
        const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : 0;
        const propagationData = this.legWindData[propagationIndex];
        if (propagationData) {
            const records = propagationData.map(({ altitude, direction, speed }) => ({ altitude, direction, speed, windPropagated: true }));
            this.legWindData.splice(globalLegIndex, 0, records);
        }
        else {
            this.legWindData.splice(globalLegIndex, 0, []);
        }
        const tempData = this.legTemperatureData[propagationIndex];
        if (tempData) {
            this.legTemperatureData.splice(globalLegIndex, 0, Object.assign(Object.assign({}, tempData), { temperaturePropagated: true }));
        }
    }
    /**
     * Check if all the available leg altitudes are already used
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed() {
        if (this.legWindData.length === 0 || this.options.numberOfLegAltitudes === undefined) {
            return false;
        }
        const windData = this.legWindData[0];
        return windData.length >= this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(globalLegIndex) {
        var _a, _b;
        return (_b = (_a = this.legWindData[globalLegIndex]) === null || _a === void 0 ? void 0 : _a.some((record) => record.windPropagated === false)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(globalLegIndex, altitude, speed, direction) {
        var _a, _b, _c, _d;
        const windData = this.legWindData[globalLegIndex];
        if (windData === undefined) {
            return false;
        }
        /** index of existing record for this altitude (same in all legs) */
        const existingRecordIndex = (_a = windData === null || windData === void 0 ? void 0 : windData.findIndex((v) => v.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (existingRecordIndex < 0 && isFinite((_b = this.options.numberOfLegAltitudes) !== null && _b !== void 0 ? _b : Infinity)) {
            if (((_c = windData === null || windData === void 0 ? void 0 : windData.length) !== null && _c !== void 0 ? _c : 0) >= ((_d = this.options.numberOfLegAltitudes) !== null && _d !== void 0 ? _d : Infinity)) {
                return false;
            }
        }
        if (existingRecordIndex >= 0 && windData) {
            const existingRecord = windData[existingRecordIndex];
            existingRecord.altitude = altitude;
            existingRecord.speed = speed;
            existingRecord.direction = direction;
            existingRecord.windPropagated = false;
            // propagate backward if needed
            if (this.findNextNonPropagatedLeg(globalLegIndex, altitude, -1) < 0) {
                this.propagateWind(0, globalLegIndex - 1, windData[existingRecordIndex], existingRecordIndex);
            }
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLeg(globalLegIndex, altitude);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateWind(globalLegIndex + 1, propagateTo, windData[existingRecordIndex], existingRecordIndex);
        }
        else {
            const newRecord = {
                altitude,
                speed,
                direction,
                windPropagated: true,
            };
            this.legWindData.forEach((r, index) => r.push(index === globalLegIndex ? Object.assign(Object.assign({}, newRecord), { windPropagated: speed === null }) : Object.assign({}, newRecord)));
        }
        return true;
    }
    /**
     * Delete an altitude from all leg wind records
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(altitude) {
        this.legWindData.forEach((leg) => {
            const idx = leg.findIndex((r) => r.altitude === altitude);
            if (idx >= 0) {
                leg.splice(idx, 1);
            }
        });
    }
    /**
     * Delete wind at a leg at a given altitude (does not delete this altitude globally)
     * @param globalLegIndex Flight plan leg index
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(globalLegIndex, altitude) {
        var _a;
        const leg = this.legWindData[globalLegIndex];
        const recordIndex = (_a = leg === null || leg === void 0 ? void 0 : leg.findIndex((r) => r.altitude === altitude)) !== null && _a !== void 0 ? _a : -1;
        if (recordIndex >= 0 && leg) {
            const propagationIndex = globalLegIndex > 0 ? globalLegIndex - 1 : globalLegIndex + 1;
            const propagationData = this.legWindData[propagationIndex][recordIndex];
            if (propagationData) {
                const record = leg[recordIndex];
                Object.assign(record, propagationData);
                record.windPropagated = true;
            }
            else {
                // we must be the only leg
                this.deleteLegAltitude(altitude);
            }
        }
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(globalLegIndex, altitude, temperature) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            const tempData = this.legTemperatureData[globalLegIndex];
            tempData.altitude = altitude;
            tempData.temperature = temperature;
            tempData.temperaturePropagated = temperature === null;
            // propagate forward
            const nextNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, 1);
            const propagateTo = nextNonPropagatedLeg < 0 ? this.legWindData.length - 1 : nextNonPropagatedLeg - 1;
            this.propagateTemperature(globalLegIndex + 1, propagateTo, tempData);
            // propagate backward if no non-propagated legs behind
            const prevNonPropagatedLeg = this.findNextNonPropagatedLegTemperature(globalLegIndex, altitude, -1);
            if (prevNonPropagatedLeg < 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
        }
        else {
            const tempData = { altitude, temperature, temperaturePropagated: temperature === null };
            this.legTemperatureData[globalLegIndex] = tempData;
            // no data exists, so we can propagate to all legs
            if (globalLegIndex > 0) {
                this.propagateTemperature(0, globalLegIndex - 1, tempData);
            }
            if (globalLegIndex < (this.legWindData.length - 1)) {
                this.propagateTemperature(globalLegIndex + 1, this.legWindData.length - 1, tempData);
            }
        }
        return true;
    }
    /**
     * Deletes a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(globalLegIndex) {
        if (this.legTemperatureData[globalLegIndex] !== undefined) {
            this.legTemperatureData[globalLegIndex].temperature = null;
            // TODO propagate from other leg
        }
    }
    /**
     * Gets a leg temperature record
     * @param globalLegIndex Global leg index in flight plan
     * @returns the leg temperature record if it exists, else undefined
     */
    getLegTemperature(globalLegIndex) {
        return this.legTemperatureData[globalLegIndex];
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from
     * @param recordIndex The index of the altitude record to propagate
     */
    propagateWind(fromIndex, toIndex, fromRecord, recordIndex) {
        for (let i = fromIndex; i <= toIndex; i++) {
            const record = this.legWindData[i][recordIndex];
            if (!record.windPropagated) {
                console.warn('Overwriting non-propagated wind record with propagated record at global leg', i);
                record.windPropagated = true;
            }
            record.altitude = fromRecord.altitude;
            record.direction = fromRecord.direction;
            record.speed = fromRecord.speed;
        }
    }
    /**
     * Propagate wind entries forward or backward from a leg
     * @param fromIndex First leg to propagate the fromRecord data into
     * @param toIndex Last leg to propagate the fromRecord data into
     * @param fromRecord Record to take the propagated data from.
     * @throws if parameters are incompatible with options
     */
    propagateTemperature(fromIndex, toIndex, fromRecord) {
        for (let i = fromIndex; i <= toIndex; i++) {
            if (this.legTemperatureData[i] === undefined) {
                this.legTemperatureData[i] = Object.assign(Object.assign({}, fromRecord), { temperaturePropagated: true });
            }
            else {
                const record = this.legTemperatureData[i];
                if (!record.temperaturePropagated) {
                    console.warn('Overwriting non-propagated temperature record with propagated record at global leg', i);
                    record.temperaturePropagated = true;
                }
                record.altitude = fromRecord.altitude;
                record.temperature = fromRecord.temperature;
            }
        }
    }
    /**
     * Find the next leg that doesn't have a propagated wind
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLeg(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legWindData.length : i >= 0); i += direction) {
            const legData = this.legWindData[i];
            if (legData.find((w) => w.altitude === altitude && !w.windPropagated)) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Find the next leg that doesn't have a propagated temperature
     * @param globalLegIndex Flight plan index to start searching (non-inclusive)
     * @param altitude Altitude
     * @param direction Direction to search, -1 for backward, +1 for forward
     * @returns the next leg without propagated wind, or -1 if none found
     */
    findNextNonPropagatedLegTemperature(globalLegIndex, altitude, direction = 1) {
        for (let i = globalLegIndex + direction; (direction > 0 ? i < this.legTemperatureData.length : i >= 0); i += direction) {
            const legData = this.legTemperatureData[i];
            if (!legData.temperaturePropagated) {
                return i;
            }
        }
        return -1;
    }
    /**
     * Get the wind records for a flight plan leg
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(globalLegIndex) {
        return this.legWindData[globalLegIndex];
    }
    /**
     * Get the number of legs in the plan
     * @returns the number of legs in the plan
     */
    get legLength() {
        return this.legWindData.length;
    }
    /**
     * Copy all data from another plan into this one
     * @param fromPlan the plan to copy from
     */
    copyFrom(fromPlan) {
        // TODO make this cheaper by re-using existing objects
        this.climbData = fromPlan.climbData.map((r) => (Object.assign({}, r)));
        this.descentData = fromPlan.descentData.map((r) => (Object.assign({}, r)));
        this.legWindData = fromPlan.legWindData.map((r) => r.map((v) => (Object.assign({}, v))));
        this.legTemperatureData = fromPlan.legTemperatureData.map((r) => (Object.assign({}, r)));
    }
    /**
     * Insert a climb or descent record into the array, taking care of temperature propagation and sorting
     * @param records climb or descent records
     * @param newRecord new record to insert
     */
    insertClimbDescentRecord(records, newRecord) {
        const insertAt = Math.max(0, records.findIndex((r) => r.altitude > newRecord.altitude));
        records.splice(insertAt, 0, newRecord);
        this.refreshTemperaturePropagation(records);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Refresh propagated temperature values for climb and descent from the non-propagated records
     * @param records Climb or Descent records
     */
    refreshTemperaturePropagation(records) {
        var _a;
        const anyNonPropagated = records.some((r) => r.temperaturePropagated === false);
        if (anyNonPropagated) {
            let previousAlt = null;
            let previousTemp = null;
            for (const record of records) {
                if ((_a = record.temperaturePropagated) !== null && _a !== void 0 ? _a : true) {
                    const nextHighestNonPropagated = records.find((r) => r.altitude > record.altitude && r.temperature !== null && r.temperaturePropagated === false);
                    if (nextHighestNonPropagated !== undefined && previousTemp !== null && previousAlt !== null && nextHighestNonPropagated.altitude !== previousAlt) {
                        // we have a temp above and below, interpolate isa delta between them
                        /** proportion of the higher ISA delta to take */
                        const k = (record.altitude - previousAlt) / (nextHighestNonPropagated.altitude - previousAlt);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + k * isaAbove + (1 - k) * isaBelow;
                    }
                    else if (nextHighestNonPropagated !== undefined) {
                        // we have a temp above but not below, use isaDelta directly
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const isaAbove = nextHighestNonPropagated.temperature - this.isaTemperatureFeet(nextHighestNonPropagated.altitude);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaAbove;
                    }
                    else if (previousTemp !== null && previousAlt !== null) {
                        // we have a temp below but not above, use isaDelta directly
                        const isaBelow = previousTemp - this.isaTemperatureFeet(previousAlt);
                        record.temperature = this.isaTemperatureFeet(record.altitude) + isaBelow;
                    }
                }
                else {
                    previousAlt = record.altitude;
                    previousTemp = record.temperature;
                }
            }
        }
        else {
            records.forEach((r) => r.temperature = this.isaTemperatureFeet(r.altitude));
        }
    }
}

/** Stores and manages wind plans */
class WindPlanner {
    /**
     * Constructs a WindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.plans = [];
        this.syncPublisher = this.bus.getPublisher();
        this.eventPublisher = this.bus.getPublisher();
        this.ignoreSync = false;
        const fpln = this.bus.getSubscriber();
        fpln.on('fplCreated').handle(this.onPlanCreated.bind(this));
        fpln.on('fplCopied').handle(this.onPlanCopied.bind(this));
        fpln.on('fplLoaded').handle(this.onPlanLoaded.bind(this));
        fpln.on('fplDeleted').handle(this.onPlanDeleted.bind(this));
        fpln.on('fplSegmentChange').handle(this.onSegmentChanged.bind(this));
        fpln.on('fplLegChange').handle(this.onLegChanged.bind(this));
        const sync = this.bus.getSubscriber();
        sync.on('windsync_climb_wind_deleted').handle(this.handleClimbWindDelete.bind(this));
        sync.on('windsync_climb_wind_set').handle(this.handleClimbWindSet.bind(this));
        sync.on('windsync_climb_temperature_set').handle(this.handleClimbTemperatureSet.bind(this));
        sync.on('windsync_descent_wind_deleted').handle(this.handleDescentWindDelete.bind(this));
        sync.on('windsync_descent_wind_set').handle(this.handleDescentWindSet.bind(this));
        sync.on('windsync_descent_temperature_set').handle(this.handleDescentTemperatureSet.bind(this));
        sync.on('windsync_leg_wind_deleted').handle(this.handleLegWindDelete.bind(this));
        sync.on('windsync_leg_altitude_deleted').handle(this.handleLegAltitudeDelete.bind(this));
        sync.on('windsync_leg_wind_set').handle(this.handleLegWindSet.bind(this));
        sync.on('windsync_leg_temperature_deleted').handle(this.handleLegTempDelete.bind(this));
        sync.on('windsync_leg_temperature_set').handle(this.handleLegTempSet.bind(this));
    }
    /**
     * Set wind for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbWindSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a climb wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteClimbWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleClimbWindDelete(ev);
    }
    /**
     * Handles climb wind delete events
     * @param ev the event
     */
    handleClimbWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteClimbWindAndTemperature(ev.altitude);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set temperature for an altitude during climb
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfClimbAltitudes)
     */
    setClimbTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_climb_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleClimbTemperatureSet(ev);
    }
    /**
     * Handles climb wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleClimbTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setClimbTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the climb wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the climb, or undefined if none exist
     */
    getClimbWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getClimbWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentWind(planIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentWindSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentWind(ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a descent wind and temperature record
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteDescentWindAndTemperature(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleDescentWindDelete(ev);
    }
    /**
     * Handles descent wind delete events
     * @param ev the event
     */
    handleDescentWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteDescentWind(ev.altitude);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Set wind for an altitude during descent
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfDescentAltitudes)
     */
    setDescentTemperature(planIndex, altitude, temperature) {
        const ev = {
            planIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_descent_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleDescentTemperatureSet(ev);
    }
    /**
     * Handles descent wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleDescentTemperatureSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setDescentTemperature(ev.altitude, ev.temperature);
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Gets the descent wind and temperature records for a flight plan
     * @param planIndex Flight Plan index
     * @returns An array of wind entries for the descent, or undefined if none exist
     */
    getDescentWindsAndTemperatures(planIndex) {
        var _a;
        return (_a = this.plans[planIndex]) === null || _a === void 0 ? void 0 : _a.getDescentWindsAndTemperatures();
    }
    /**
     * Set wind for an altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param speed Wind speed in knots
     * @param direction Wind direction in degrees true
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegWind(planIndex, globalLegIndex, altitude, speed, direction) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            speed,
            direction,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegWindSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegWindSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegWind(ev.globalLegIndex, ev.altitude, ev.speed, ev.direction);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg wind record
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     */
    deleteLegWind(planIndex, globalLegIndex, altitude) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_wind_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegWindDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegWindDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegWind(ev.globalLegIndex, ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Deletes all leg wind records for a given altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     */
    deleteLegAltitude(planIndex, altitude) {
        const ev = {
            planIndex,
            altitude,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_altitude_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegAltitudeDelete(ev);
    }
    /**
     * Handles leg wind delete events
     * @param ev the event
     */
    handleLegAltitudeDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegAltitude(ev.altitude);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the wind records for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns An array of wind entries (propagated or entered) for the leg, or undefined if none exist
     */
    getLegWinds(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegWinds(globalLegIndex);
    }
    /**
     * Set temperature for one altitude on a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param temperature Temperature in degrees C
     * @returns true if the operation suceeded, false if not e.g. if there are already too many altitudes (options.numberOfLegAltitudes)
     */
    setLegTemperature(planIndex, globalLegIndex, altitude, temperature = null) {
        const ev = {
            planIndex,
            globalLegIndex,
            altitude,
            temperature,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_set', ev, true, false);
        this.ignoreSync = false;
        return this.handleLegTempSet(ev);
    }
    /**
     * Handles leg wind set events
     * @param ev the event
     * @returns passes through return value (true if set suceeded)
     */
    handleLegTempSet(ev) {
        if (this.ignoreSync) {
            return false;
        }
        const plan = this.getPlan(ev.planIndex);
        const ret = plan.setLegTemperature(ev.globalLegIndex, ev.altitude, ev.temperature);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
        return ret;
    }
    /**
     * Deletes a leg temperature record,
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     */
    deleteLegTemperature(planIndex, globalLegIndex) {
        const ev = {
            planIndex,
            globalLegIndex,
        };
        this.ignoreSync = true;
        this.syncPublisher.pub('windsync_leg_temperature_deleted', ev, true, false);
        this.ignoreSync = false;
        this.handleLegTempDelete(ev);
    }
    /**
     * Handles leg temperature delete events
     * @param ev the event
     */
    handleLegTempDelete(ev) {
        if (this.ignoreSync) {
            return;
        }
        const plan = this.getPlan(ev.planIndex);
        plan.deleteLegTemperature(ev.globalLegIndex);
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: ev.planIndex });
    }
    /**
     * Get the temperature record for a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global index of the desired leg within the flight plan
     * @returns A temperature record if one exists, else undefined
     */
    getLegTemperature(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.getLegTemperature(globalLegIndex);
    }
    /**
     * Handles flight plan creation events
     * @param data Event Data
     */
    onPlanCreated(data) {
        this.plans[data.planIndex] = new WindPlan(this.options);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handle flight plan copy events by copying related wind data
     * @param data Event Data
     */
    onPlanCopied(data) {
        const targetPlan = this.plans[data.targetPlanIndex];
        const fromPlan = this.plans[data.planIndex];
        if (!targetPlan || !fromPlan) {
            console.error('WindPlanner: failed to copy plan!');
            return;
        }
        targetPlan.copyFrom(fromPlan);
        this.eventPublisher.pub('climb_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
        this.eventPublisher.pub('descent_wind_data_changed', { planIndex: data.planIndex });
    }
    /**
     * Handles flight plan load events
     * @param data Event Data
     */
    onPlanLoaded(data) {
        const flightPlan = this.flightPlanner.getFlightPlan(data.planIndex);
        if (!flightPlan) {
            this.plans[data.planIndex] = undefined;
            return;
        }
        this.plans[data.planIndex] = new WindPlan(this.options, flightPlan.length);
    }
    /**
     * Handles flight plan deletion events
     * @param data Event Data
     */
    onPlanDeleted(data) {
        this.plans[data.planIndex] = undefined;
    }
    /**
     * Handles flight plan segment change events
     * @param data Event Data
     */
    onSegmentChanged(data) {
        var _a, _b;
        const windPlan = this.plans[data.planIndex];
        if (!windPlan) {
            return;
        }
        switch (data.type) {
            case SegmentEventType.Removed:
                for (let i = 0; i < ((_b = (_a = data.segment) === null || _a === void 0 ? void 0 : _a.legs.length) !== null && _b !== void 0 ? _b : 0); i++) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    windPlan.deleteLeg(data.segment.offset);
                }
                break;
            case SegmentEventType.Changed:
            // fall through, airway changes don't matter to us
            case SegmentEventType.Added:
            case SegmentEventType.Inserted:
            default:
                // nothing we need to do for these as they don't add or remove legs
                return;
        }
    }
    /**
     * Handles flight plan leg change events
     * @param data Event Data
     */
    onLegChanged(data) {
        const globalLegIndex = WindPlanner.getGlobalLegIndex(this.flightPlanner.getFlightPlan(data.planIndex), data.segmentIndex, data.legIndex);
        const plan = this.plans[data.planIndex];
        if (!plan) {
            console.warn('onLegChanged, but the flightplan doesn\'t exist!');
            return;
        }
        switch (data.type) {
            case LegEventType.Added:
                plan.insertLegAndPropagate(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
            case LegEventType.Removed:
                plan.deleteLeg(globalLegIndex);
                this.eventPublisher.pub('leg_wind_data_changed', { planIndex: data.planIndex });
                break;
        }
    }
    /**
     * Get a flight plan or error if it doesn't exist
     * @param planIndex Flight Plan index
     * @throws if flight plan doesn't exist
     * @returns FlightPlan
     */
    getPlan(planIndex) {
        const plan = this.plans[planIndex];
        if (plan === undefined) {
            throw new Error(`WindPlanner: wind plan ${planIndex} does not exist!`);
        }
        return plan;
    }
    /**
     * Gets the global leg index from a segment and segment leg index, whether or not the leg exists.
     * @param lateralPlan The Lateral Flight Plan.
     * @param segmentIndex The Segment Index.
     * @param segmentLegIndex The Segment Leg Index.
     * @returns The global leg index.
     */
    static getGlobalLegIndex(lateralPlan, segmentIndex, segmentLegIndex) {
        if (segmentIndex < lateralPlan.segmentCount) {
            const segment = lateralPlan.getSegment(segmentIndex);
            return segment.offset + segmentLegIndex;
        }
        return -1;
    }
    /**
     * Check if all the available leg altitudes are already used
     * @param planIndex Flight Plan index
     * @returns true if they are all used, or false otherwise
     */
    areAllLegAltitudesUsed(planIndex) {
        const plan = this.getPlan(planIndex);
        return plan.areAllLegAltitudesUsed();
    }
    /**
     * Get the number of leg wind altitudes permitted
     * @returns the maximum number of leg wind altitudes, or undefined if no limit
     */
    getNumberOfLegAltitudes() {
        return this.options.numberOfLegAltitudes;
    }
    /**
     * Check if a leg has any non-propagated wind entries
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @returns true if there are wind entries that are not propagated
     */
    legHasNonPropagatedWind(planIndex, globalLegIndex) {
        const plan = this.getPlan(planIndex);
        return plan.legHasNonPropagatedWind(globalLegIndex);
    }
}

// TODO consider average wind entry instead of individual winds
/** Wind Planner that interpolates live wind data along the route for a Boeing FMS */
class InterpolatingWindPlanner extends WindPlanner {
    /**
     * Constructs an InterpolatingWindPlanner
     * @param bus Event bus instance
     * @param flightPlanner Flight Planner that managers the related flight plans
     * @param options Options to configure the Wind Planner
     */
    constructor(bus, flightPlanner, options) {
        super(bus, flightPlanner, options);
        this.bus = bus;
        this.flightPlanner = flightPlanner;
        this.options = options;
        this.vec2Cache = [Vec2Math.create(), Vec2Math.create(), Vec2Math.create()];
        this.filteredLiveWind = Vec2Math.create();
        /** sim wind direction in degrees true */
        this.liveWindDirection = ConsumerValue.create(null, 0);
        /** sim wind speed in knots */
        this.liveWindSpeed = ConsumerValue.create(null, 0);
        /** plane altitude in feet */
        this.planeAltitude = ConsumerValue.create(null, 0);
        /** plane is on the ground */
        this.onGround = ConsumerValue.create(null, true);
        /** static/outside air temperature in degrees celsius */
        this.staticAirTemperature = ConsumerValue.create(null, 0);
        this.filteredCache = [];
        const sub = this.bus.getSubscriber();
        this.liveWindDirection.setConsumer(sub.on('ambient_wind_direction').withPrecision(0));
        this.liveWindSpeed.setConsumer(sub.on('ambient_wind_velocity').withPrecision(0));
        this.planeAltitude.setConsumer(sub.on('indicated_alt').withPrecision(-2));
        this.onGround.setConsumer(sub.on('on_ground'));
        this.staticAirTemperature.setConsumer(sub.on('ambient_temp_c').withPrecision(0));
        sub.on('simTime').atFrequency(1).handle(this.updateLiveWind.bind(this));
    }
    /** Apply an IIR filter to the live wind */
    updateLiveWind() {
        Vec2Math.setFromPolar(this.liveWindSpeed.get(), UnitType.RADIAN.convertFrom(this.liveWindDirection.get(), UnitType.DEGREE), this.vec2Cache[0]);
        Vec2Math.multScalar(this.vec2Cache[0], 0.1, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 0.9, this.filteredLiveWind);
        Vec2Math.add(this.filteredLiveWind, this.vec2Cache[0], this.filteredLiveWind);
    }
    /**
     * Transform a cartesian wind vector to polar direction/speed
     * @param vector Cartesian wind vector or null if no vector
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    windVectorToDirectionSpeed(vector, out) {
        if (vector === null) {
            return null;
        }
        out[0] = NavMath.normalizeHeading(UnitType.RADIAN.convertTo(Vec2Math.theta(vector), UnitType.DEGREE));
        out[1] = Vec2Math.abs(vector);
        return out;
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO Does the Boeing use climb and/or descent wind if no leg winds?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.tryGetLeg(globalLegIndex);
        if (!fpLeg) {
            return null;
        }
        /** Stored in this.vec2Cache[0] */
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        /** proportion of live wind to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        Vec2Math.multScalar(forecastWind, 1 - k, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
        return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
    }
    /**
     * Get the wind interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedWindAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg, out) {
        const wind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, altitude, distanceAlongLeg, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get the wind at a given altitude on a given leg
     * @param windPlan The wind plan to use
     * @param globalLegIndex The global index of the desired leg
     * @param altitude Altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getLegWindAtAltitude(windPlan, globalLegIndex, altitude, out) {
        const legWinds = windPlan.getLegWinds(globalLegIndex);
        if (legWinds === undefined) {
            return null;
        }
        return this.getAltitudeInterpolatedWind(legWinds, altitude, out);
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind vector in knots
     */
    getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(climbWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = this.vec2Cache[0][0];
        out[1] = this.vec2Cache[0][1];
        return out;
    }
    /**
     * Get a climb wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedClimbWind(planIndex, altitude, liveWind, out) {
        const wind = this.getInterpolatedClimbWindCartesian(planIndex, altitude, liveWind, this.vec2Cache[0]);
        return this.windVectorToDirectionSpeed(wind, out);
    }
    /**
     * Get a descent wind interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveWind Whether to interpolate live wind data into the output
     * @param out Vector to write the output into
     * @returns Wind direction (° true)/speed (knots) or null if unavailable
     */
    getInterpolatedDescentWind(planIndex, altitude, liveWind, out) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const desWinds = windPlan.getDescentWindsAndTemperatures();
        if (this.getAltitudeInterpolatedWind(desWinds, altitude, this.vec2Cache[0]) === null) {
            return null;
        }
        if (liveWind) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            Vec2Math.multScalar(this.vec2Cache[0], 1 - k, this.vec2Cache[0]);
            Vec2Math.multScalar(this.filteredLiveWind, k, this.vec2Cache[1]);
            Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        }
        out[0] = UnitType.RADIAN.convertTo(Vec2Math.theta(this.vec2Cache[0]), UnitType.DEGREE);
        out[1] = Vec2Math.abs(this.vec2Cache[0]);
        return out;
    }
    /**
     * Get the wind at a given altitude from a WindRecord, interpolated when it lies between altitudes for which wind is defined
     * Caution: clobbers first 2 elements of this.vec2Cache
     * @param winds Wind records to use
     * @param altitude Desired altitude in feet MSL
     * @param out Vector to write the output into
     * @returns A vector of the wind magnitude in knots referenced to true north (stored in "out") or null if unavailable
     */
    getAltitudeInterpolatedWind(winds, altitude, out) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < winds.length; i++) {
            const wind = winds[i];
            if (wind.direction !== null && wind.speed !== null) {
                this.filteredCache[index++] = wind;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredWinds = this.filteredCache;
        if (filteredWinds.length < 1) {
            return null;
        }
        if (filteredWinds.length === 1 || altitude >= filteredWinds[0].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[0].speed, UnitType.RADIAN.convertFrom(filteredWinds[0].direction, UnitType.DEGREE), out);
        }
        if (altitude <= filteredWinds[filteredWinds.length - 1].altitude) {
            return Vec2Math.setFromPolar(filteredWinds[filteredWinds.length - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[filteredWinds.length - 1].direction, UnitType.DEGREE), out);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredWinds.length; i++) {
            if (filteredWinds[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper wind to take */
            const k = (altitude - filteredWinds[i].altitude) / (filteredWinds[i - 1].altitude - filteredWinds[i].altitude);
            const windUpper = Vec2Math.setFromPolar(filteredWinds[i - 1].speed, UnitType.RADIAN.convertFrom(filteredWinds[i - 1].direction, UnitType.DEGREE), this.vec2Cache[0]);
            const windLower = Vec2Math.setFromPolar(filteredWinds[i].speed, UnitType.RADIAN.convertFrom(filteredWinds[i].direction, UnitType.DEGREE), this.vec2Cache[1]);
            Vec2Math.multScalar(windUpper, k, this.vec2Cache[0]);
            Vec2Math.multScalar(windLower, 1 - k, this.vec2Cache[1]);
            return Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], out);
        }
        return null;
    }
    /**
     * Get the ISA delta temperature interpolated from live and forecast data along a flight plan leg
     * @param planIndex Flight Plan index
     * @param globalLegIndex Global leg index in flight plan
     * @param altitude Altitude in feet MSL
     * @param distanceAlongLeg Distance from the start of the leg in metres
     * @returns ISA temperature delta in °C or null if no data
     */
    getInterpolatedIsaDeltaAlongLeg(planIndex, globalLegIndex, altitude, distanceAlongLeg) {
        var _a, _b;
        const windPlan = this.plans[planIndex];
        if (!windPlan || !this.flightPlanner.hasFlightPlan(planIndex)) {
            return null;
        }
        // TODO use climb and/or descent temp if no leg temp?
        const flightPlan = this.flightPlanner.getFlightPlan(planIndex);
        const fpLeg = flightPlan.getLeg(globalLegIndex);
        const forecastWind = this.getLegWindAtAltitude(windPlan, globalLegIndex, altitude, this.vec2Cache[0]);
        const cumulativeDistance = (_a = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _a === void 0 ? void 0 : _a.cumulativeDistance;
        const legDistance = (_b = fpLeg === null || fpLeg === void 0 ? void 0 : fpLeg.calculated) === null || _b === void 0 ? void 0 : _b.distance;
        if (cumulativeDistance === undefined || legDistance === undefined || forecastWind === null) {
            return null;
        }
        const legTemp = windPlan.getLegTemperature(globalLegIndex);
        if (legTemp === undefined || legTemp.temperature === null) {
            return null;
        }
        /** proportion of live data to use */
        const k = this.getLiveDataProportion(cumulativeDistance - Math.max(0, legDistance - distanceAlongLeg));
        const isaTemp = this.isaTemperatureFeet(altitude);
        const interpolatedTemp = k * this.staticAirTemperature.get() + (1 - k) * legTemp.temperature;
        return interpolatedTemp - isaTemp;
    }
    /**
     * Get a climb ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedClimbIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const climbWinds = windPlan.getClimbWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(climbWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get a descent ISA temperature delta interpolated at an altitude
     * @param planIndex Flight Plan index
     * @param altitude Altitude in feet MSL
     * @param liveTemp Whether to interpolate live temperature data into the output
     * @returns ISA delta in °C, or null if unavailable
     */
    getInterpolatedDescentIsaDelta(planIndex, altitude, liveTemp) {
        const windPlan = this.plans[planIndex];
        if (!windPlan) {
            return null;
        }
        const descentWinds = windPlan.getDescentWindsAndTemperatures();
        let interpolatedIsaDelta = this.getAltitudeInterpolatedIsaDelta(descentWinds, altitude);
        if (interpolatedIsaDelta === null) {
            return null;
        }
        if (liveTemp) {
            const height = Math.abs(altitude - this.planeAltitude.get());
            const k = this.getLiveDataProportionHeight(height);
            const planeIsaDelta = this.staticAirTemperature.get() - this.isaTemperatureFeet(this.planeAltitude.get());
            interpolatedIsaDelta = k * planeIsaDelta + (1 - k) * interpolatedIsaDelta;
        }
        return interpolatedIsaDelta;
    }
    /**
     * Get the ISA temperature delta at a given altitude from a WindAndTemperatureRecord,
     * interpolated when it lies between altitudes for which temperature is defined
     * @param temps Wind/Temperature records to use
     * @param altitude Desired altitude in feet MSL
     * @returns An ISA delta in °C or null if unavailable
     */
    getAltitudeInterpolatedIsaDelta(temps, altitude) {
        /** valid winds sorted from highest to lowest */
        let index = 0;
        for (let i = 0; i < temps.length; i++) {
            const temp = temps[i];
            if (temp.temperature !== null) {
                this.filteredCache[index++] = temp;
            }
        }
        this.filteredCache.length = index;
        this.filteredCache.sort(InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT);
        const filteredTemps = this.filteredCache;
        if (filteredTemps.length < 1) {
            return null;
        }
        if (filteredTemps.length === 1 || altitude >= filteredTemps[0].altitude) {
            return filteredTemps[0].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        else if (altitude <= filteredTemps[filteredTemps.length - 1].altitude) {
            return filteredTemps[filteredTemps.length - 1].temperature - this.isaTemperatureFeet(filteredTemps[0].altitude);
        }
        // wind is somewhere between the lowest and highest altitudes we have data for
        for (let i = 1; i < filteredTemps.length; i++) {
            if (filteredTemps[i].altitude > altitude) {
                continue;
            }
            /** proportion of the upper temperature to take */
            const k = (altitude - filteredTemps[i].altitude) / (filteredTemps[i - 1].altitude - filteredTemps[i].altitude);
            // we have filtered out null temps above, but the linter isn't quite smart enough to figure that out
            const upperIsaDelta = filteredTemps[i - 1].temperature - this.isaTemperatureFeet(filteredTemps[i - 1].altitude);
            const lowerIsaDelta = filteredTemps[i].temperature - this.isaTemperatureFeet(filteredTemps[i].altitude);
            return k * upperIsaDelta + (1 - k) * lowerIsaDelta;
        }
        return null;
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a distance from the aircraft
     * @param distance distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportion(distance) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        if (distance < 277800) {
            return 1 - 1 / 3 * (distance / 277800) ** 2;
        }
        return 2 / 3 * (Math.E ** (-5 * ((distance - 277800) / 1852000)));
    }
    /**
     * Calculate the proportion of live wind that should be interpolated at a height from the aircraft
     * @param height vertical distance from the aircraft in metres
     * @returns the proportion of live wind to use [0, 1]
     */
    getLiveDataProportionHeight(height) {
        // the plane can't measure wind on the ground, so no live data in that case
        if (this.onGround.get()) {
            return 0;
        }
        // 243.045 = 6076.12 feet/NM / (17500 ft / 700 NM), the latter from FMS documentation
        return this.getLiveDataProportion(Math.abs(height) * 243.045);
    }
    /**
     * Get an ISA temperature for a given altitude
     * @param altitude altitude in feet
     * @returns ISA delta in °C
     */
    isaTemperatureFeet(altitude) {
        return AeroMath.isaTemperature(UnitType.METER.convertFrom(altitude, UnitType.FOOT));
    }
    /**
     * Calculate the wind speed for the ECON speed calculation.
     * Before takeoff, when planning the flight, this shall be taken from the wind plan.
     * Once flying at cruise flight level, ECON speed controls the AT so we want to base the calculation
     * on the actual live wind.
     * @param planIndex Flight Plan index
     * @param cruiseAltitude Planned cruise altitude
     * @param globalLegIndex Index of active leg
     * @param distanceAlongLeg Distance along the active leg
     * @param trueHeading Heading of the aircraft, degree
     * @returns Headwind component (knots)
     */
    getHeadwindForEconSpeedCalculation(planIndex, cruiseAltitude, globalLegIndex, distanceAlongLeg, trueHeading) {
        // Retrieve planned wind (first wind along leg, if unavailble climb wind).
        let planWind = this.getInterpolatedWindAlongLegCartesian(planIndex, globalLegIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, distanceAlongLeg, this.vec2Cache[2]);
        if (planWind === null) {
            planWind = this.getInterpolatedClimbWindCartesian(planIndex, cruiseAltitude !== null && cruiseAltitude !== void 0 ? cruiseAltitude : 0, true, this.vec2Cache[2]);
        }
        if (planWind === null) {
            planWind = this.vec2Cache[2];
            this.vec2Cache[2][0] = 0;
            this.vec2Cache[2][1] = 0;
        }
        // Blend gradually between planned wind and live wind using 100% live wind @(plane alt = cruiseAlt) 
        // and 100% planned wind @(alt deviates 500ft or more from cruise alt):
        const planWindProportion = Math.min(1, Math.abs(cruiseAltitude - this.planeAltitude.get()) / 500);
        Vec2Math.multScalar(planWind, planWindProportion, this.vec2Cache[0]);
        Vec2Math.multScalar(this.filteredLiveWind, 1 - planWindProportion, this.vec2Cache[1]);
        Vec2Math.add(this.vec2Cache[0], this.vec2Cache[1], this.vec2Cache[0]);
        // Create unit vector in heading direction:
        Vec2Math.setFromPolar(1, UnitType.RADIAN.convertFrom(trueHeading, UnitType.DEGREE), this.vec2Cache[1]);
        // The dot product returns the projected length of the wind vector onto the heading (unit) vector:
        return VecNMath.dot(this.vec2Cache[0], this.vec2Cache[1]);
    }
}
InterpolatingWindPlanner.WIND_RECORD_SORT_BY_ALT = (a, b) => b.altitude - a.altitude;

/**
 * Autopilot engage states.
 */
var APEngageState;
(function (APEngageState) {
    APEngageState[APEngageState["Off"] = 0] = "Off";
    APEngageState[APEngageState["Armed"] = 1] = "Armed";
    APEngageState[APEngageState["Engaged"] = 2] = "Engaged";
})(APEngageState || (APEngageState = {}));
/**
 * A Boeing 747-8 autopilot state manager.
 */
class B748APStateManager extends BoeingAPStateManager {
    constructor() {
        super(...arguments);
        this.apApproachModeArmed = ConsumerSubject.create(null, false);
        this.autolandCapability = ConsumerSubject.create(null, AutolandCapability.None);
        this.primaryApIndex = Subject.create(1);
        this.apEngageState = [1, 2, 3].map(index => MappedSubject.create(([apMasterStatus, apApproachModeArmed, autolandCapability, primaryApIndex]) => {
            if (!apMasterStatus) {
                return APEngageState.Off;
            }
            if (primaryApIndex === index || autolandCapability === AutolandCapability.FailOperational) {
                return APEngageState.Engaged;
            }
            return apApproachModeArmed ? APEngageState.Armed : APEngageState.Off;
        }, this.apMasterOn, this.apApproachModeArmed, this.autolandCapability, this.primaryApIndex));
    }
    /** @inheritdoc */
    onAPListenerRegistered() {
        super.onAPListenerRegistered();
        const sub = this.bus.getSubscriber();
        sub.on('b74_fpa_mode').whenChanged().handle(this.handleFpaModeChange.bind(this));
        sub.on('b74_trk_mode').whenChanged().handle(this.handleTrkModeChange.bind(this));
        this.apApproachModeArmed.setConsumer(sub.on('ap_boeing_approach_mode_armed'));
        this.autolandCapability.setConsumer(sub.on('autoland_capability'));
        for (let i = 0; i < this.apEngageState.length; i++) {
            this.apEngageState[i].sub(state => { SimVar.SetSimVarValue(`${B748APStateManager.AP_STATUS_SIMVAR}:${i + 1}`, SimVarValueType.Number, state); });
        }
    }
    /** @inheritdoc */
    setupKeyIntercepts(manager) {
        super.setupKeyIntercepts(manager);
        this.bus.getSubscriber().on('hEvent').handle(hEvent => {
            if (hEvent.startsWith(B748APStateManager.AP_ENGAGE_H_EVENT_PREFIX)) {
                manager.triggerKey('AUTOPILOT_ON', true);
                const index = parseInt(hEvent.substring(B748APStateManager.AP_ENGAGE_H_EVENT_PREFIX.length));
                this.primaryApIndex.set(isFinite(index) ? MathUtils.clamp(index, 1, 3) : 1);
            }
        });
    }
    /** @inheritdoc */
    onApMasterStatusEvent(key, commandedState, currentState) {
        super.onApMasterStatusEvent(key, commandedState, currentState);
        // If we get a key event to turn the autopilot on, we assume the user wants to engage autopilot 1 (left).
        if (commandedState) {
            this.primaryApIndex.set(1);
        }
    }
}
B748APStateManager.AP_STATUS_SIMVAR = 'L:B748_Autopilot_Status';
B748APStateManager.AP_ENGAGE_H_EVENT_PREFIX = 'B748_Autopilot_Engage_';

/** The B748Square component. */
class B748Square extends DisplayComponent {
    /** @inheritdoc */
    onAfterRender() {
        // TODO do stuff
    }
    /** @inheritdoc */
    render() {
        return (FSComponent.buildComponent("div", { class: `b748-square ${this.props.pfdOrMfd} ${this.props.pfdOrMfd}-${this.props.instrumentIndex}` }, this.props.children));
    }
}

/**
 * A help window message object
 */
class ScratchpadMessage {
    /**
     * Ctor
     *
     * @param onlyOnside whether this message is only sent to the onside CDU
     * @param body the body of the message, containing text
     */
    constructor(onlyOnside, body) {
        this.onlyOnside = onlyOnside;
        this.body = body;
    }
}

/**
 * Object associating {@link BoeingFmcErrorKeys} keys to scratchpad message strings,
 * or null if the plane does not have such a message.
 */
const DefinedScratchpadMessages = {
    [BoeingFmcErrorKeys.AppTuneInhibitedMcp]: new ScratchpadMessage(true, 'APP TUNE INHIBITED - MCP'),
    [BoeingFmcErrorKeys.DragRequired]: new ScratchpadMessage(false, 'DRAG REQUIRED - VNAV'),
    [BoeingFmcErrorKeys.FmcAppModeUavailGp]: new ScratchpadMessage(false, 'FMC APP MODE UNAVAIL-GP'),
    [BoeingFmcErrorKeys.FmcAppModeUavailQfe]: undefined,
    [BoeingFmcErrorKeys.FmcAppTuneDisagree]: new ScratchpadMessage(false, 'FMC APP/TUNE DISAGREE'),
    [BoeingFmcErrorKeys.InertialOriginDisagree]: new ScratchpadMessage(true, 'INERTIAL/ORIGIN DISAGREE'),
    [BoeingFmcErrorKeys.InvalidDelete]: new ScratchpadMessage(true, 'INVALID DELETE'),
    [BoeingFmcErrorKeys.GenericInvalidEntry]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.InvalidEntryRouteAirway]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.InvalidEntryRouteTermination]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.InvalidEntryWindDirSpdInitial]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.InvalidEntryBearingDistance]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.InvalidEntryAltitudeOrTime]: new ScratchpadMessage(true, 'INVALID ENTRY'),
    [BoeingFmcErrorKeys.NotInDataBase]: new ScratchpadMessage(true, 'NOT IN DATA BASE'),
    [BoeingFmcErrorKeys.ResetMcpAlt]: new ScratchpadMessage(false, 'RESET MCP ALT'),
    [BoeingFmcErrorKeys.RunwayNaForSid]: new ScratchpadMessage(true, 'RUNWAY N/A FOR SID'),
    [BoeingFmcErrorKeys.TakeoffFlapsDeleted]: new ScratchpadMessage(false, 'TAKEOFF FLAPS DELETED'),
    [BoeingFmcErrorKeys.TakeoffSpeedsDeleted]: new ScratchpadMessage(false, 'TAKEOFF SPEEDS DELETED'),
    [BoeingFmcErrorKeys.ThrustRequired]: new ScratchpadMessage(false, 'THRUST REQUIRED-VNAV'),
    [BoeingFmcErrorKeys.TakeoffDataUplink]: new ScratchpadMessage(// not used on 747-8
    false, 'TAKEOFF DATA UPLINK'),
};

/**
 * An interface for sending and clearing messages between the SDK and the plane specific messaging system.
 */
class B748MessageTransmitter {
    /**
     * Create an instance of the B787MessageTransmitter
     * @param bus The Event Bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.publisher = this.bus.getPublisher();
    }
    /**
     * Send a message topic to the aircraft specific messaging system.
     * @param messageTopic The Message Topic to send.
     */
    sendMessage(messageTopic) {
        const message = messageTopic !== BoeingFmcErrorKeys.Generic ? this.getMessage(messageTopic) : undefined;
        if (message !== undefined) {
            this.publisher.pub('post_message', { key: messageTopic, message, targetCdu: 'any' }, true);
        }
    }
    /**
     * Clear a message topic in the aircraft specific messaging system.
     * @param messageTopic The Message Topic to clear.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    clearMessage(messageTopic) {
        this.publisher.pub('clear_message', messageTopic, true);
    }
    /**
     * Gets the HelpWindowMessage from a topic for the B787.
     * @param messageTopic The message topic.
     * @returns The Help Window Message
     */
    getMessage(messageTopic) {
        return DefinedScratchpadMessages[messageTopic];
    }
}

/**
 * Class that calculates the stab trim values and min/max green zones for the 747
 */
class B748StabTrimCalculator extends BoeingStabTrimCalculator {
    /** @inheritdoc */
    static convertElevatorTrimAngleToGaugeRange(elevatorTrimAngle) {
        return MathUtils.lerp(elevatorTrimAngle, B748StabTrimCalculator.ELEVATOR_TRIM_RANGE[0], B748StabTrimCalculator.ELEVATOR_TRIM_RANGE[1], B748StabTrimCalculator.STAB_TRIM_GAUGE_RANGE[0], B748StabTrimCalculator.STAB_TRIM_GAUGE_RANGE[1]);
    }
    /** @inheritdoc */
    static normalizeStabTrimValue(stabTrimValue) {
        return MathUtils.lerp(stabTrimValue, B748StabTrimCalculator.STAB_TRIM_GAUGE_RANGE[0], B748StabTrimCalculator.STAB_TRIM_GAUGE_RANGE[1], 0, 1);
    }
    /** @inheritdoc */
    convertElevatorTrimAngleToGaugeRange(elevatorTrimAngle) {
        return B748StabTrimCalculator.convertElevatorTrimAngleToGaugeRange(elevatorTrimAngle);
    }
    /** @inheritdoc */
    roundCalcStabTrim(rawCalcTrim) {
        return MathUtils.round(rawCalcTrim, 0.1);
    }
    /** @inheritdoc */
    calculateGreenZone(calcStabTrim) {
        if (calcStabTrim === null) {
            return {
                min: B748StabTrimCalculator.middleBandMinValue,
                max: B748StabTrimCalculator.middleBandMaxValue,
            };
        }
        if (calcStabTrim < B748StabTrimCalculator.middleBandMinValue) {
            return {
                min: B748StabTrimCalculator.extendedNoseDownLimit,
                max: B748StabTrimCalculator.middleBandMaxValue,
            };
        }
        else if (calcStabTrim > B748StabTrimCalculator.extendedNoseUpTriggerLimit) {
            return {
                min: B748StabTrimCalculator.middleBandMinValue,
                max: B748StabTrimCalculator.extendedNoseUpLimit,
            };
        }
        else {
            return {
                min: B748StabTrimCalculator.middleBandMinValue,
                max: B748StabTrimCalculator.middleBandMaxValue,
            };
        }
    }
}
// Value from flight_model.cfg, recommended from https://www.pprune.org/tech-log/446606-747-400-other-boeing-aircraft-trim-question.html
B748StabTrimCalculator.ELEVATOR_TRIM_RANGE = [-9.5454, 15];
B748StabTrimCalculator.STAB_TRIM_GAUGE_RANGE = [0, 15];
// 6-10 is from 748 FCOM? Or maybe just from photos
B748StabTrimCalculator.middleBandMinValue = 6;
B748StabTrimCalculator.middleBandMaxValue = 10;
B748StabTrimCalculator.extendedNoseUpTriggerLimit = 9;
// 2 is min possible calc trim from the trim table in 63995815-01-TAKEOFF-DATA-747-400-V10.pdf (747-400)
B748StabTrimCalculator.extendedNoseDownLimit = 2;
// 12 was what the max green zone for extended NU segment looked like from photos
B748StabTrimCalculator.extendedNoseUpLimit = 12;

/* eslint-disable max-len */
/** B747/8i Stabilizer Trim Settings */
class B748StabTrimData {
    /** @inheritDoc */
    getStabTrimSetting(takeoffThrustMode, flapPos, weightKg, centerOfGravity) {
        return B748StabTrimData.stab_trim_settings_to.get(weightKg, centerOfGravity);
    }
}
/**
 * 747-400 Stabilizer Trim Settings for TO.
 * From "63995815-01-TAKEOFF-DATA-747-400-V10.pdf".
 * Replace if you find better info.
 * [ Stabilizer Trim Setting, Weight (kg), Center of Gravity ]
 */
B748StabTrimData.stab_trim_settings_to = new LerpLookupTable([
    [9.5, 400000, 9], [9, 400000, 13], [8, 400000, 17], [7, 400000, 21], [6, 400000, 25], [5, 400000, 29], [4, 400000, 33],
    [9.5, 380000, 9], [9, 380000, 13], [8, 380000, 17], [7, 380000, 21], [5.5, 380000, 25], [5, 380000, 29], [3.5, 380000, 33],
    [9.5, 360000, 9], [8.5, 360000, 13], [7.5, 360000, 17], [6.5, 360000, 21], [5.5, 360000, 25], [4.5, 360000, 29], [3.5, 360000, 33],
    [9.5, 340000, 9], [8.5, 340000, 13], [7.5, 340000, 17], [6.5, 340000, 21], [5.5, 340000, 25], [4.5, 340000, 29], [3.5, 340000, 33],
    [9.5, 320000, 9], [8.5, 320000, 13], [7.5, 320000, 17], [6.5, 320000, 21], [5.5, 320000, 25], [4, 320000, 29], [3, 320000, 33],
    [9, 300000, 9], [8, 300000, 13], [7, 300000, 17], [6, 300000, 21], [5, 300000, 25], [4, 300000, 29], [3, 300000, 33],
    [8.5, 280000, 9], [7.5, 280000, 13], [6.5, 280000, 17], [5.5, 280000, 21], [4.5, 280000, 25], [3.5, 280000, 29], [2.5, 280000, 33],
    [8, 260000, 9], [7, 260000, 13], [6, 260000, 17], [5, 260000, 21], [4, 260000, 25], [3, 260000, 29], [2, 260000, 33],
    [6, 240000, 13], [5, 240000, 17], [4.5, 240000, 21], [3.5, 240000, 25], [2.5, 240000, 29],
    [5, 220000, 13], [4, 220000, 17], [3.5, 220000, 21], [3, 220000, 25], [2, 220000, 29],
    [4, 200000, 13], [3.5, 200000, 17], [3, 200000, 21], [2.5, 200000, 25],
]);

/**
 * Possible Door status values in the B748
 */
var B74DoorStatus;
(function (B74DoorStatus) {
    B74DoorStatus[B74DoorStatus["BLANK"] = 0] = "BLANK";
    B74DoorStatus[B74DoorStatus["OPEN"] = 1] = "OPEN";
    B74DoorStatus[B74DoorStatus["MANUAL"] = 2] = "MANUAL";
    B74DoorStatus[B74DoorStatus["AUTO"] = 3] = "AUTO";
})(B74DoorStatus || (B74DoorStatus = {}));
/**
 * A class to emulate and publish Door status values.
 */
class B748DoorDataInstrument {
    /**
     * Constructor for B78DoorDataInstrument
     * @param bus The event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.doorPub = this.bus.getPublisher();
        this.doorPositionSub = this.bus.getSubscriber();
        this.brakeSub = this.bus.getSubscriber();
        this.engineSub = this.bus.getSubscriber();
        this.entry1LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_1l_position').whenChanged(), 0);
        this.entry1RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_1r_position').whenChanged(), 0);
        this.entry2LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_2l_position').whenChanged(), 0);
        this.entry2RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_2r_position').whenChanged(), 0);
        this.entry3LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_3l_position').whenChanged(), 0);
        this.entry3RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_3r_position').whenChanged(), 0);
        this.entry4LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_4l_position').whenChanged(), 0);
        this.entry4RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_4r_position').whenChanged(), 0);
        this.entry5LPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_5l_position').whenChanged(), 0);
        this.entry5RPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_5r_position').whenChanged(), 0);
        this.entryULPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_ul_position').whenChanged(), 0);
        this.entryURPosition = ConsumerSubject.create(this.doorPositionSub.on('entry_ur_position').whenChanged(), 0);
        this.fwdCargoPosition = ConsumerSubject.create(this.doorPositionSub.on('cargo_fwd_position').whenChanged(), 0);
        this.aftCargoPosition = ConsumerSubject.create(this.doorPositionSub.on('cargo_aft_position').whenChanged(), 0);
        this.doorsManual = MappedSubject.create(([parkingBrakeOn, leftN1, rightN1]) => {
            return parkingBrakeOn && leftN1 < 2 && rightN1 < 2;
        }, ConsumerSubject.create(this.brakeSub.on('parking_brake_set').whenChanged(), true), ConsumerSubject.create(this.engineSub.on('n1_1').whenChanged().withPrecision(1), 0), ConsumerSubject.create(this.engineSub.on('n1_2').whenChanged().withPrecision(1), 0));
        // inop
    }
    /** @inheritdoc */
    init() {
        this.entry1LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_1l_status', this.doorsManual.get()));
        this.entry1RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_1r_status', this.doorsManual.get()));
        this.entry2LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_2l_status', this.doorsManual.get()));
        this.entry2RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_2r_status', this.doorsManual.get()));
        this.entry3LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_3l_status', this.doorsManual.get()));
        this.entry3RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_3r_status', this.doorsManual.get()));
        this.entry4LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_4l_status', this.doorsManual.get()));
        this.entry4RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_4r_status', this.doorsManual.get()));
        this.entry5LPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_5l_status', this.doorsManual.get()));
        this.entry5RPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_5r_status', this.doorsManual.get()));
        this.entryULPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_ul_status', this.doorsManual.get()));
        this.entryURPosition.sub(v => this.updateEntryDoorStatus(v, 'entry_ur_status', this.doorsManual.get()));
        this.fwdCargoPosition.sub(this.updateFwdCargoStatus.bind(this));
        this.aftCargoPosition.sub(this.updateAftCargoStatus.bind(this));
        this.doorsManual.sub(v => {
            this.updateEntryDoorStatus(this.entry1LPosition.get(), 'entry_1l_status', v);
            this.updateEntryDoorStatus(this.entry1RPosition.get(), 'entry_1r_status', v);
            this.updateEntryDoorStatus(this.entry2LPosition.get(), 'entry_2l_status', v);
            this.updateEntryDoorStatus(this.entry2RPosition.get(), 'entry_2r_status', v);
            this.updateEntryDoorStatus(this.entry3LPosition.get(), 'entry_3l_status', v);
            this.updateEntryDoorStatus(this.entry3RPosition.get(), 'entry_3r_status', v);
            this.updateEntryDoorStatus(this.entry4LPosition.get(), 'entry_4l_status', v);
            this.updateEntryDoorStatus(this.entry4RPosition.get(), 'entry_4r_status', v);
            this.updateEntryDoorStatus(this.entry5LPosition.get(), 'entry_5l_status', v);
            this.updateEntryDoorStatus(this.entry5RPosition.get(), 'entry_5r_status', v);
            this.updateEntryDoorStatus(this.entryULPosition.get(), 'entry_ul_status', v);
            this.updateEntryDoorStatus(this.entryURPosition.get(), 'entry_ur_status', v);
        });
    }
    /** @inheritdoc */
    onUpdate() {
        // inop
    }
    /**
     * Publishes updated Entry door status to the bus
     * @param position the new door position
     * @param doorTopic the door event topic to publish
     * @param doorsManual whether doors should be set to manual (auto if false)
     */
    updateEntryDoorStatus(position, doorTopic, doorsManual) {
        this.doorPub.pub(doorTopic, position > 0 ? B74DoorStatus.OPEN : doorsManual ? B74DoorStatus.MANUAL : B74DoorStatus.AUTO, true, true);
    }
    /**
     * Publishes updated FwdCargo door status to the bus
     * @param position the new door position
     */
    updateFwdCargoStatus(position) {
        this.doorPub.pub('fwd_cargo_status', position > 0 ? B74DoorStatus.OPEN : B74DoorStatus.BLANK, true, true);
    }
    /**
     * Publishes updated AftCargo door status to the bus
     * @param position the new door position
     */
    updateAftCargoStatus(position) {
        this.doorPub.pub('aft_cargo_status', position > 0 ? B74DoorStatus.OPEN : B74DoorStatus.BLANK, true, true);
    }
}

/**
 * A publisher for Door Position information in the B748.
 */
class B748DoorPositionPublisher extends SimVarPublisher {
    /**
     * Create a B78DoorPositionPublisher.
     * @param bus The EventBus to publish to
     * @param pacer An optional pacer to use to control the rate of publishing
     */
    constructor(bus, pacer = undefined) {
        const simvars = new Map([
            ['entry_1l_position', { name: 'INTERACTIVE POINT OPEN:10', type: SimVarValueType.Number }],
            ['entry_1r_position', { name: 'INTERACTIVE POINT OPEN:11', type: SimVarValueType.Number }],
            ['entry_2l_position', { name: 'INTERACTIVE POINT OPEN:4', type: SimVarValueType.Number }],
            ['entry_2r_position', { name: 'INTERACTIVE POINT OPEN:5', type: SimVarValueType.Number }],
            ['entry_3l_position', { name: 'INTERACTIVE POINT OPEN:6', type: SimVarValueType.Number }],
            ['entry_3r_position', { name: 'INTERACTIVE POINT OPEN:7', type: SimVarValueType.Number }],
            ['entry_4l_position', { name: 'INTERACTIVE POINT OPEN:8', type: SimVarValueType.Number }],
            ['entry_4r_position', { name: 'INTERACTIVE POINT OPEN:9', type: SimVarValueType.Number }],
            ['entry_5l_position', { name: 'INTERACTIVE POINT OPEN:0', type: SimVarValueType.Number }],
            ['entry_5r_position', { name: 'INTERACTIVE POINT OPEN:1', type: SimVarValueType.Number }],
            ['entry_ul_position', { name: 'INTERACTIVE POINT OPEN:2', type: SimVarValueType.Number }],
            ['entry_ur_position', { name: 'INTERACTIVE POINT OPEN:3', type: SimVarValueType.Number }],
            ['cargo_fwd_position', { name: 'INTERACTIVE POINT OPEN:12', type: SimVarValueType.Number }],
            ['cargo_aft_position', { name: 'INTERACTIVE POINT OPEN:13', type: SimVarValueType.Number }],
        ]);
        super(simvars, bus, pacer);
    }
    /** @inheritdoc */
    onUpdate() {
        super.onUpdate();
    }
}

/**
 * The 748 cabin pressurization system.
 */
class B748PressurizationSystem extends BoeingPressurizationSystem {
    /**
     * Creates an instance of the B748PressurizationSystem.
     * @param bus An instance of the event bus.
     * @param fms An instance of the FMS.
     */
    constructor(bus, fms) {
        super(bus, fms, 8000, 39000);
        this.throttle1 = ConsumerValue.create(this.bus.getSubscriber().on('v_throttle_lever_pos_1'), 0);
        this.throttle2 = ConsumerValue.create(this.bus.getSubscriber().on('v_throttle_lever_pos_2'), 0);
        this.throttle3 = ConsumerValue.create(this.bus.getSubscriber().on('v_throttle_lever_pos_3'), 0);
        this.throttle4 = ConsumerValue.create(this.bus.getSubscriber().on('v_throttle_lever_pos_4'), 0);
        this.elec = ConsumerValue.create(this.bus.getSubscriber().on('elec_circuit_avionics_on'), false);
        this.ductPress1 = ConsumerSubject.create(this.bus.getSubscriber().on('boeing_air_duct_pressure_1'), 0);
        this.ductPress2 = ConsumerSubject.create(this.bus.getSubscriber().on('boeing_air_duct_pressure_2'), 0);
        this.ductPress3 = ConsumerSubject.create(this.bus.getSubscriber().on('boeing_air_duct_pressure_3'), 0);
        this.hasAir = MappedSubject.create(([d1, d2, d3]) => d1 > 0 || d2 > 0 || d3 > 0, this.ductPress1, this.ductPress2, this.ductPress3);
    }
    /** @inheritdoc */
    areThrottlesInTakeoff() {
        return this.throttle1.get() > 0.8 || this.throttle2.get() > 0.8 || this.throttle3.get() > 0.8 || this.throttle4.get() > 0.8;
    }
    /** @inheritdoc */
    hasElectricalPower() {
        return this.elec.get();
    }
    /** @inheritdoc */
    hasAirFromAirSystems() {
        return this.hasAir.get();
    }
}

/**
 * Boeing 747-8 MFD side selections.
 */
var MFD_SIDE_SELECT;
(function (MFD_SIDE_SELECT) {
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["LEFT"] = 0] = "LEFT";
    MFD_SIDE_SELECT[MFD_SIDE_SELECT["RIGHT"] = 1] = "RIGHT";
})(MFD_SIDE_SELECT || (MFD_SIDE_SELECT = {}));
/**
 * Boeing 747 transponder modes.
 */
var B74_XPDR_MODE;
(function (B74_XPDR_MODE) {
    B74_XPDR_MODE[B74_XPDR_MODE["STBY"] = 0] = "STBY";
    B74_XPDR_MODE[B74_XPDR_MODE["ON"] = 1] = "ON";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_Only"] = 2] = "TA_Only";
    B74_XPDR_MODE[B74_XPDR_MODE["TA_RA"] = 3] = "TA_RA";
})(B74_XPDR_MODE || (B74_XPDR_MODE = {}));
/**
 * Boeing 747-8 hydraulic pump states
 */
var B74_HYDRAULIC_PUMP_MODE;
(function (B74_HYDRAULIC_PUMP_MODE) {
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["OFF"] = 0] = "OFF";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUTO"] = 1] = "AUTO";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["ON"] = 2] = "ON";
    B74_HYDRAULIC_PUMP_MODE[B74_HYDRAULIC_PUMP_MODE["AUX"] = 3] = "AUX";
})(B74_HYDRAULIC_PUMP_MODE || (B74_HYDRAULIC_PUMP_MODE = {}));
/**
 * Boeing 747-8 TCAS Airspace selector modes
 */
var B74_TCAS_ATC_AIRSPACE_MODE;
(function (B74_TCAS_ATC_AIRSPACE_MODE) {
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["ABV"] = 0] = "ABV";
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["NORM"] = 1] = "NORM";
    B74_TCAS_ATC_AIRSPACE_MODE[B74_TCAS_ATC_AIRSPACE_MODE["BLW"] = 2] = "BLW";
})(B74_TCAS_ATC_AIRSPACE_MODE || (B74_TCAS_ATC_AIRSPACE_MODE = {}));
/**
 * Boeing 747-8 standby power knob states.
 */
var StandbyPowerKnobState;
(function (StandbyPowerKnobState) {
    StandbyPowerKnobState[StandbyPowerKnobState["Off"] = 0] = "Off";
    StandbyPowerKnobState[StandbyPowerKnobState["Auto"] = 1] = "Auto";
    StandbyPowerKnobState[StandbyPowerKnobState["Batt"] = 2] = "Batt";
})(StandbyPowerKnobState || (StandbyPowerKnobState = {}));
/**
 * Boeing 747-8 IRS knob states.
 */
var IrsKnobState;
(function (IrsKnobState) {
    IrsKnobState[IrsKnobState["Off"] = 0] = "Off";
    IrsKnobState[IrsKnobState["Align"] = 1] = "Align";
    IrsKnobState[IrsKnobState["Nav"] = 2] = "Nav";
    IrsKnobState[IrsKnobState["Att"] = 3] = "Att";
})(IrsKnobState || (IrsKnobState = {}));
/**
 * Boeing 747-8 IRS source select knob states.
 */
var IrsSourceKnobState;
(function (IrsSourceKnobState) {
    IrsSourceKnobState[IrsSourceKnobState["Left"] = 0] = "Left";
    IrsSourceKnobState[IrsSourceKnobState["Center"] = 1] = "Center";
    IrsSourceKnobState[IrsSourceKnobState["Right"] = 2] = "Right";
    IrsSourceKnobState[IrsSourceKnobState["Auto"] = 3] = "Auto";
})(IrsSourceKnobState || (IrsSourceKnobState = {}));
/**
 * Boeing 747-8 AIR DATA source select knob states.
 */
var AirDataSourceKnobState;
(function (AirDataSourceKnobState) {
    AirDataSourceKnobState[AirDataSourceKnobState["Left"] = 0] = "Left";
    AirDataSourceKnobState[AirDataSourceKnobState["Auto"] = 1] = "Auto";
    AirDataSourceKnobState[AirDataSourceKnobState["Right"] = 2] = "Right";
})(AirDataSourceKnobState || (AirDataSourceKnobState = {}));
/**
 * Boeing 747-8 wing/engine anti-ice switch states.
 */
var AntiIceSwitchState;
(function (AntiIceSwitchState) {
    AntiIceSwitchState[AntiIceSwitchState["Off"] = 0] = "Off";
    AntiIceSwitchState[AntiIceSwitchState["Auto"] = 1] = "Auto";
    AntiIceSwitchState[AntiIceSwitchState["On"] = 2] = "On";
})(AntiIceSwitchState || (AntiIceSwitchState = {}));
/**
 * A publisher for 748 Cockpit Variables or Events.
 */
class CockpitVarsPublisher extends SimVarPublisher {
    /**
     * Creates a new instance of CockpitVarsPublisher.
     * @param bus The event bus to which to publish.
     */
    constructor(bus) {
        super(new Map([
            ['b74_minimums_mode', { name: 'L:XMLVAR_Mins_Selector_Baro', type: SimVarValueType.Number }],
            ['pilot_transmitting', { name: 'PILOT TRANSMITTING', type: SimVarValueType.Bool }],
            ['b74_xpdr_mode', { name: 'L:XMLVAR_Transponder_Mode', type: SimVarValueType.Number }],
            ['b74_stby_power_mode', { name: 'L:XMLVAR_StandbyPower_Selector', type: SimVarValueType.Number }],
            ['b74_hyd_pump', { name: 'L:XMLVAR_HYDRAULICS_DEMAND_#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['mfd_side_select', { name: 'L:XMLVAR_MFD_Side_#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['mfd_nd_wx_terr_contrast_1', { name: 'L:WT_MFD_1_CONTRAST', type: SimVarValueType.Number }],
            ['mfd_nd_wx_terr_contrast_2', { name: 'L:WT_MFD_2_CONTRAST', type: SimVarValueType.Number }],
            ['baro_ref_hpa', { name: 'L:XMLVAR_Baro_Selector_HPA_#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_irs_knob_state', { name: 'L:B748_IRS_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3], defaultIndex: null }],
            ['b74_irs_source_knob_state', { name: 'L:B748_IRS_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b74_air_data_source_knob_state', { name: 'L:B748_Air_Data_Source_Knob_State:#index#', type: SimVarValueType.Number, indexed: [1, 2], defaultIndex: null }],
            ['b74_ext_pwr_switch_pressed', { name: 'L:EXT_PWR_COMMANDED:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_elec_bus_1_connection_on', { name: 'L:XMLVAR_Bus1ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_2_connection_on', { name: 'L:XMLVAR_Bus2ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_3_connection_on', { name: 'L:XMLVAR_Bus3ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_bus_4_connection_on', { name: 'L:XMLVAR_Bus4ToMain_Connected', type: SimVarValueType.Bool }],
            ['b74_elec_emer_lights', { name: 'L:XMLVAR_EMER_LIGHTS_ARMED', type: SimVarValueType.Number }],
            ['b74_batt_to_hotbatt_connection_on', { name: 'L:XMLVAR_BattToHotBatt_Connected', type: SimVarValueType.Bool }],
            ['b74_tcas_atc_airspace_mode', { name: 'L:XMLVAR_ATC_AIRSPACE_MODE_ABV_BLW', type: SimVarValueType.Number }],
            ['b74_bleed_air_switch', { name: 'L:WT_748_BLEED_ON:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_air_isln_closed', { name: 'L:WT_748_AIR_ISLN_CLOSED:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_pack_switch', { name: 'L:WT_748_PACK_ON:#index#', type: SimVarValueType.Bool, indexed: true, defaultIndex: null }],
            ['b74_apu_bleed_switch', { name: 'L:ELECTRICAL_APU_Bleed', type: SimVarValueType.Bool }],
            ['b74_trim_air_l_switch', { name: 'L:WT_748_TRIM_AIR_L', type: SimVarValueType.Bool }],
            ['b74_trim_air_r_switch', { name: 'L:WT_748_TRIM_AIR_R', type: SimVarValueType.Bool }],
            ['b74_lwr_recirc_switch', { name: 'L:WT_748_RECIRC_LWR', type: SimVarValueType.Bool }],
            ['b74_fltdeck_temp_target', { name: 'L:WT_748_FLT_DECK_TEMP', type: SimVarValueType.Number }],
            ['b74_cabin_master_temp_target', { name: 'L:WT_748_CABIN_TEMP', type: SimVarValueType.Number }],
            ['b74_aft_cargo_temp_target', { name: 'L:WT_748_CARGO_TEMP', type: SimVarValueType.Number }],
            ['b74_engine_anti_ice_switch_state', { name: 'L:B748_Engine_AntiIce_Switch_State:#index#', type: SimVarValueType.Number, indexed: [1, 2, 3, 4], defaultIndex: null }],
            ['b74_wing_anti_ice_switch_state', { name: 'L:B748_Wing_AntiIce_Switch_State', type: SimVarValueType.Number }],
            ['b74_windshield_deice', { name: 'L:XMLVAR_DeiceWindshield:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_yaw_damper_switch', { name: 'L:WT_748_Yaw_Damper:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_yaw_damper_failed', { name: 'L:WT_748_Yaw_Damper_Fail:#index#', type: SimVarValueType.Bool, indexed: [1, 2], defaultIndex: null }],
            ['b74_fuel_innerleft_xfeed_switch', { name: 'L:WT_748_FUEL_XFEED:2', type: SimVarValueType.Bool }],
            ['b74_fuel_innerright_xfeed_switch', { name: 'L:WT_748_FUEL_XFEED:3', type: SimVarValueType.Bool }],
            ['b74_fuel_main2_pump_aft_switch', { name: 'L:WT_748_FUEL_PUMP_2_AFT_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_main3_pump_aft_switch', { name: 'L:WT_748_FUEL_PUMP_3_AFT_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_outer_to_inner_xfer_switch', { name: 'L:WT_748_FUEL_MAIN_OUTER_TO_INNER_XFER_ON', type: SimVarValueType.Bool }],
            ['b74_fuel_reserve_xfer_switch', { name: 'L:WT_748_FUEL_MAIN_RESERVE_XFER_ON', type: SimVarValueType.Bool }],
        ]), bus);
    }
}

/**
 * Manages automatic setting of TCAS and transponder modes such that TCAS is set to standby if transponder mode is not
 * altitude reporting and transponder is set to altitude reporting if TCAS mode is not standby.
 */
class B748TCASTransponderManager {
    /**
     * Constructor.
     * @param bus The event bus.
     */
    constructor(bus) {
        this.bus = bus;
        this.settings = TrafficUserSettings.getManager(this.bus);
    }
    /**
     * Initializes this manager. Once initialized, the manager will automatically set transponder mode to altitude
     * reporting if TCAS is set to any mode other than standby, and set TCAS mode to standby if transponder is set to
     * any mode other than altitude reporting.
     */
    init() {
        const cockpitVarSub = this.bus.getSubscriber();
        cockpitVarSub.on('b74_xpdr_mode').whenChanged().handle(mode => {
            let setMode = TcasOperatingModeSetting.Standby;
            if (mode >= B74_XPDR_MODE.TA_Only) {
                setMode = (mode === B74_XPDR_MODE.TA_Only) ? TcasOperatingModeSetting.TAOnly : TcasOperatingModeSetting.TA_RA;
            }
            this.settings.getSetting('trafficOperatingMode').set(setMode);
        });
        cockpitVarSub.on('b74_tcas_atc_airspace_mode').whenChanged().handle(mode => {
            this.settings.getSetting('trafficShowAbove').set(mode === B74_TCAS_ATC_AIRSPACE_MODE.ABV);
            this.settings.getSetting('trafficShowBelow').set(mode === B74_TCAS_ATC_AIRSPACE_MODE.BLW);
        });
    }
}

/**
 * B747-8 GENX-2B67 Engine Data Utility Class.
 */
class B748EngineData {
    /**
     * Creates an instance of B787 Engine Data
     * @param bus The Event Bus.
     * @param performanceData An instance of the BoeingPerformanceDataProvider.
     */
    constructor(bus, performanceData) {
        this.performanceData = performanceData;
        this.engineCount = 4;
        // 23.2 is best guess, and matches engines.cfg
        this.IDLE_N1 = 23.2;
        // 102.9 is the highest N1 value found in perf tables.
        // (This is still a best guess as to what maximum rated thrust means, we know max rated is below redline, based on the FCOM)
        this.MAX_RATED_N1 = 102.9;
        // 106 from the GEnx cert docs.
        this.RED_LINE_N1 = 106;
        // 58 is best guess from looking at videos.
        this.IDLE_N2 = 58;
        // 118 is pulled from the GEnx cert docs.
        this.RED_LINE_N2 = 118;
        // 750 comes from the GEnx cert docs.
        this.START_LIMIT_EGT = 750;
        // 1005 comes from GEnx cert docs, EGT Max Continuous max temp C
        this.CONTINUOUS_LIMIT_EGT = 1005;
        // 1040 comes from GEnx cert docs, 30 sec max transient temp C
        // (we used the highest egt limit in that table)
        this.RED_LINE_EGT = 1040;
        this.mach = ConsumerValue.create(null, 0);
        this.sat = ConsumerValue.create(null, 0);
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.mach.setConsumer(bus.getSubscriber().on('mach_number').withPrecision(2));
        this.sat.setConsumer(bus.getSubscriber().on('ambient_temp_c').withPrecision(0));
        this.pressureAlt.setConsumer(bus.getSubscriber().on('pressure_alt').withPrecision(0));
    }
    /** @inheritdoc */
    getMaxConN1(pressureAltitude, tat) {
        return B748EngineData.max_con_n1.get(tat, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getMaxConTpr(pressureAltitude, tat) {
        return -1;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getToMaxTpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getToMaxN1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo1Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo1N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to1_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTo2Tpr(airportPressureAltitude, airportTemp) {
        return -1;
    }
    /** @inheritdoc */
    getTo2N1(airportPressureAltitude, airportTemp) {
        return B748EngineData.to2_n1_max.get(airportTemp, airportPressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClbMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClbMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.clb_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb1Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb1N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 5% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.05 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, mach);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getClb2Tpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getClb2N1(pressureAltitude, totalAirTemp) {
        const maxClb = this.getClbMaxN1(pressureAltitude, totalAirTemp);
        // 15% derate at/below 25,000' that tapers to 0 derate at 33,000'.
        const mach = this.mach.get();
        const thrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxClb, mach);
        const derate = thrustScalar * 0.15 * (1 - MathUtils.clamp((pressureAltitude - 25000) / 8000, 0, 1));
        const deratedThrustScalar = thrustScalar - derate;
        return this.performanceData.aircraftFlightModel.thrust_and_mach_on_n1_table.get(deratedThrustScalar, mach);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getGaMaxTpr(pressureAltitude, totalAirTemp) {
        return -1;
    }
    /** @inheritdoc */
    getGaMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.ga_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getCruiseMaxN1(pressureAltitude, totalAirTemp) {
        return B748EngineData.cru_n1_max.get(totalAirTemp, pressureAltitude);
    }
    /** @inheritdoc */
    getOptimumAltitude(aircraftWeight) {
        return Math.min(B748EngineData.alt_opt.get(aircraftWeight), 41000);
    }
    /** @inheritdoc */
    getMaximumAltitude(aircraftWeight) {
        const isa = BoeingAeroMath.calcIsaFromAltitude(this.pressureAlt.get());
        const isaTempC = UnitType.KELVIN.convertTo(isa[0], UnitType.CELSIUS);
        const isaDev = this.sat.get() - isaTempC;
        return Math.min(B748EngineData.alt_max.get(aircraftWeight, isaDev), 41000);
    }
    /** @inheritdoc */
    getLongRangeCruiseMach(aircraftWeight, pressureAltitude) {
        return B748EngineData.lrc_mach.get(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    getEconCruiseMach(aircraftWeight, pressureAltitude) {
        return 0.95 * this.getLongRangeCruiseMach(aircraftWeight, pressureAltitude);
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getTprFromN1(n1, tat, pressureAltitude) {
        return -1;
    }
    /** @inheritDoc */
    getTakeoffDeratePercentage(targetN1, maxN1) {
        const targetThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(targetN1, 0);
        const maxThrustScalar = this.performanceData.aircraftFlightModel.n1_and_mach_on_thrust_table.get(maxN1, 0);
        return (maxThrustScalar - targetThrustScalar) / maxThrustScalar * 100;
    }
}
B748EngineData.to_n1_max = new LerpLookupTable([
    [89.7, 70, -2000], [90.1, 70, -1000], [90.6, 70, 0], [90.6, 70, 1000], [90.6, 70, 2000], [90.5, 70, 3000], [90.4, 70, 4000], [90.4, 70, 5000], [90.3, 70, 6000],
    [90.3, 70, 7000], [89.7, 70, 8000], [89.2, 70, 9000], [88.5, 70, 10000],
    [92.5, 60, -2000], [93, 60, -1000], [93.4, 60, 0], [93.4, 60, 1000], [93.4, 60, 2000], [93.3, 60, 3000], [93.3, 60, 4000], [93.2, 60, 5000], [93.2, 60, 6000],
    [93.2, 60, 7000], [92.6, 60, 8000], [92, 60, 9000], [91.4, 60, 10000],
    [93.9, 55, -2000], [94.4, 55, -1000], [94.8, 55, 0], [94.8, 55, 1000], [94.8, 55, 2000], [94.7, 55, 3000], [94.6, 55, 4000], [94.6, 55, 5000], [94.6, 55, 6000],
    [94.5, 55, 7000], [94, 55, 8000], [93.4, 55, 9000], [92.8, 55, 10000],
    [95.2, 50, -2000], [95.7, 50, -1000], [96.2, 50, 0], [96.1, 50, 1000], [96.1, 50, 2000], [96, 50, 3000], [96, 50, 4000], [95.9, 50, 5000], [95.9, 50, 6000],
    [95.9, 50, 7000], [95.3, 50, 8000], [94.7, 50, 9000], [94.2, 50, 10000],
    [96.5, 45, -2000], [97, 45, -1000], [97.5, 45, 0], [97.4, 45, 1000], [97.3, 45, 2000], [97.3, 45, 3000], [97.3, 45, 4000], [97.2, 45, 5000], [97.2, 45, 6000],
    [97.2, 45, 7000], [96.6, 45, 8000], [96, 45, 9000], [95.5, 45, 10000],
    [97.5, 40, -2000], [98.2, 40, -1000], [98.9, 40, 0], [98.7, 40, 1000], [98.5, 40, 2000], [98.4, 40, 3000], [98.4, 40, 4000], [98.5, 40, 5000], [98.4, 40, 6000],
    [98.4, 40, 7000], [97.9, 40, 8000], [97.3, 40, 9000], [96.7, 40, 10000],
    [97.8, 35, -2000], [98.9, 35, -1000], [99.8, 35, 0], [99.7, 35, 1000], [99.7, 35, 2000], [99.5, 35, 3000], [99.3, 35, 4000], [99.3, 35, 5000], [99.2, 35, 6000],
    [99.3, 35, 7000], [98.8, 35, 8000], [98.4, 35, 9000], [98, 35, 10000],
    [97.2, 30, -2000], [98.8, 30, -1000], [100.4, 30, 0], [100.4, 30, 1000], [100.4, 30, 2000], [100.4, 30, 3000], [100.4, 30, 4000], [100.1, 30, 5000], [100, 30, 6000],
    [99.9, 30, 7000], [99.5, 30, 8000], [99.2, 30, 9000], [98.8, 30, 10000],
    [96.4, 25, -2000], [98, 25, -1000], [99.6, 25, 0], [100.1, 25, 1000], [100.7, 25, 2000], [101.1, 25, 3000], [101.1, 25, 4000], [101.1, 25, 5000], [101.7, 25, 6000],
    [101.3, 25, 7000], [100.3, 25, 8000], [99.9, 25, 9000], [99.5, 25, 10000],
    [95.6, 20, -2000], [97.2, 20, -1000], [98.8, 20, 0], [99.3, 20, 1000], [99.9, 20, 2000], [100.5, 20, 3000], [101.1, 20, 4000], [101.8, 20, 5000], [102.2, 20, 6000],
    [102.4, 20, 7000], [102.1, 20, 8000], [101.5, 20, 9000], [100.3, 20, 10000],
    [94.8, 15, -2000], [96.3, 15, -1000], [97.9, 15, 0], [98.4, 15, 1000], [99, 15, 2000], [99.6, 15, 3000], [100.2, 15, 4000], [101, 15, 5000], [101.7, 15, 6000],
    [102.5, 15, 7000], [102.5, 15, 8000], [102.2, 15, 9000], [101.2, 15, 10000],
    [93.9, 10, -2000], [95.5, 10, -1000], [97.1, 10, 0], [97.6, 10, 1000], [98.2, 10, 2000], [98.8, 10, 3000], [99.4, 10, 4000], [100.1, 10, 5000], [100.8, 10, 6000],
    [101.6, 10, 7000], [101.8, 10, 8000], [102, 10, 9000], [102.3, 10, 10000],
    [93.1, 5, -2000], [94.7, 5, -1000], [96.2, 5, 0], [96.7, 5, 1000], [97.3, 5, 2000], [97.9, 5, 3000], [98.5, 5, 4000], [99.2, 5, 5000], [99.9, 5, 6000], [100.7, 5, 7000],
    [100.9, 5, 8000], [101.2, 5, 9000], [101.4, 5, 10000],
    [92.3, 0, -2000], [93.8, 0, -1000], [95.3, 0, 0], [95.8, 0, 1000], [96.4, 0, 2000], [97, 0, 3000], [97.6, 0, 4000], [98.3, 0, 5000], [99.1, 0, 6000], [99.8, 0, 7000],
    [100, 0, 8000], [100.3, 0, 9000], [100.6, 0, 10000],
    [90.6, -10, -2000], [92.1, -10, -1000], [93.6, -10, 0], [94.1, -10, 1000], [94.6, -10, 2000], [95.2, -10, 3000], [95.9, -10, 4000], [96.6, -10, 5000], [97.3, -10, 6000],
    [98, -10, 7000], [98.3, -10, 8000], [98.5, -10, 9000], [98.8, -10, 10000],
    [88.8, -20, -2000], [90.3, -20, -1000], [91.8, -20, 0], [92.3, -20, 1000], [92.8, -20, 2000], [93.4, -20, 3000], [94.1, -20, 4000], [94.8, -20, 5000], [95.5, -20, 6000],
    [96.3, -20, 7000], [96.5, -20, 8000], [96.7, -20, 9000], [97, -20, 10000],
    [87, -30, -2000], [88.5, -30, -1000], [89.9, -30, 0], [90.4, -30, 1000], [91, -30, 2000], [91.6, -30, 3000], [92.3, -30, 4000], [93, -30, 5000], [93.7, -30, 6000],
    [94.4, -30, 7000], [94.7, -30, 8000], [94.9, -30, 9000], [95.2, -30, 10000],
    [85.2, -40, -2000], [86.7, -40, -1000], [88.1, -40, 0], [88.6, -40, 1000], [89.1, -40, 2000], [89.8, -40, 3000], [90.5, -40, 4000], [91.2, -40, 5000], [91.9, -40, 6000],
    [92.6, -40, 7000], [92.8, -40, 8000], [93.1, -40, 9000], [93.4, -40, 10000],
    [83.4, -50, -2000], [84.8, -50, -1000], [86.2, -50, 0], [86.7, -50, 1000], [87.3, -50, 2000], [87.9, -50, 3000], [88.6, -50, 4000], [89.3, -50, 5000], [90, -50, 6000],
    [90.7, -50, 7000], [91, -50, 8000], [91.2, -50, 9000], [91.5, -50, 10000]
]);
B748EngineData.to1_n1_max = new LerpLookupTable([
    [86, 70, -2000], [86.5, 70, -1000], [86.9, 70, 0], [86.9, 70, 1000], [86.8, 70, 2000], [86.8, 70, 3000], [86.7, 70, 4000],
    [86.6, 70, 5000], [86.6, 70, 6000], [86.6, 70, 7000], [86.1, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [88.7, 60, -2000], [89.1, 60, -1000], [89.6, 60, 0], [89.6, 60, 1000], [89.5, 60, 2000], [89.5, 60, 3000], [89.4, 60, 4000],
    [89.3, 60, 5000], [89.3, 60, 6000], [89.3, 60, 7000], [88.8, 60, 8000], [88.2, 60, 9000], [87.6, 60, 10000],
    [90, 55, -2000], [90.5, 55, -1000], [90.9, 55, 0], [90.9, 55, 1000], [90.9, 55, 2000], [90.8, 55, 3000], [90.7, 55, 4000],
    [90.7, 55, 5000], [90.7, 55, 6000], [90.6, 55, 7000], [90.1, 55, 8000], [89.5, 55, 9000], [89, 55, 10000],
    [91.3, 50, -2000], [91.8, 50, -1000], [92.2, 50, 0], [92.1, 50, 1000], [92.1, 50, 2000], [92.1, 50, 3000], [92, 50, 4000],
    [92, 50, 5000], [92, 50, 6000], [91.9, 50, 7000], [91.4, 50, 8000], [90.8, 50, 9000], [90.3, 50, 10000],
    [92.6, 45, -2000], [93.1, 45, -1000], [93.5, 45, 0], [93.4, 45, 1000], [93.4, 45, 2000], [93.3, 45, 3000], [93.3, 45, 4000],
    [93.2, 45, 5000], [93.2, 45, 6000], [93.2, 45, 7000], [92.7, 45, 8000], [92.1, 45, 9000], [91.5, 45, 10000],
    [93.5, 40, -2000], [94.3, 40, -1000], [94.9, 40, 0], [94.7, 40, 1000], [94.5, 40, 2000], [94.5, 40, 3000], [94.5, 40, 4000],
    [94.5, 40, 5000], [94.4, 40, 6000], [94.4, 40, 7000], [93.9, 40, 8000], [93.4, 40, 9000], [92.8, 40, 10000],
    [93.9, 35, -2000], [94.8, 35, -1000], [95.6, 35, 0], [95.5, 35, 1000], [95.5, 35, 2000], [95.3, 35, 3000], [95.2, 35, 4000],
    [95.1, 35, 5000], [95.1, 35, 6000], [95.1, 35, 7000], [94.8, 35, 8000], [94.4, 35, 9000], [94, 35, 10000],
    [93.3, 30, -2000], [94.7, 30, -1000], [96.1, 30, 0], [96, 30, 1000], [96, 30, 2000], [96, 30, 3000], [96, 30, 4000],
    [95.8, 30, 5000], [95.7, 30, 6000], [95.6, 30, 7000], [95.3, 30, 8000], [95, 30, 9000], [94.7, 30, 10000],
    [92.5, 25, -2000], [93.9, 25, -1000], [95.3, 25, 0], [95.7, 25, 1000], [96.2, 25, 2000], [96.5, 25, 3000],
    [96.6, 25, 4000], [96.6, 25, 5000], [97, 25, 6000], [96.7, 25, 7000], [95.9, 25, 8000], [95.5, 25, 9000], [95.2, 25, 10000],
    [91.7, 20, -2000], [93.1, 20, -1000], [94.5, 20, 0], [94.9, 20, 1000], [95.4, 20, 2000], [95.9, 20, 3000],
    [96.3, 20, 4000], [96.8, 20, 5000], [97, 20, 6000], [97.1, 20, 7000], [97, 20, 8000], [96.6, 20, 9000], [95.7, 20, 10000],
    [90.9, 15, -2000], [92.3, 15, -1000], [93.6, 15, 0], [94.1, 15, 1000], [94.6, 15, 2000], [95.1, 15, 3000],
    [95.5, 15, 4000], [96, 15, 5000], [96.4, 15, 6000], [96.9, 15, 7000], [96.9, 15, 8000], [96.7, 15, 9000], [96.1, 15, 10000],
    [90.1, 10, -2000], [91.5, 10, -1000], [92.8, 10, 0], [93.3, 10, 1000], [93.8, 10, 2000], [94.3, 10, 3000],
    [94.7, 10, 4000], [95.1, 10, 5000], [95.6, 10, 6000], [96, 10, 7000], [96.2, 10, 8000], [96.3, 10, 9000],
    [96.5, 10, 10000], [89.3, 5, -2000], [90.7, 5, -1000], [92, 5, 0], [92.5, 5, 1000], [93, 5, 2000], [93.4, 5, 3000],
    [93.8, 5, 4000], [94.3, 5, 5000], [94.7, 5, 6000], [95.2, 5, 7000], [95.3, 5, 8000], [95.5, 5, 9000], [95.6, 5, 10000],
    [88.5, 0, -2000], [89.9, 0, -1000], [91.2, 0, 0], [91.6, 0, 1000], [92.1, 0, 2000], [92.6, 0, 3000], [93, 0, 4000],
    [93.4, 0, 5000], [93.9, 0, 6000], [94.3, 0, 7000], [94.5, 0, 8000], [94.6, 0, 9000], [94.8, 0, 10000],
    [86.9, -10, -2000], [88.2, -10, -1000], [89.5, -10, 0], [89.9, -10, 1000], [90.4, -10, 2000], [90.9, -10, 3000],
    [91.3, -10, 4000], [91.8, -10, 5000], [92.2, -10, 6000], [92.6, -10, 7000], [92.8, -10, 8000], [92.9, -10, 9000], [93.1, -10, 10000],
    [85.2, -20, -2000], [86.5, -20, -1000], [87.8, -20, 0], [88.2, -20, 1000], [88.7, -20, 2000], [89.2, -20, 3000],
    [89.6, -20, 4000], [90, -20, 5000], [90.5, -20, 6000], [90.9, -20, 7000], [91.1, -20, 8000], [91.2, -20, 9000], [91.4, -20, 10000],
    [83.5, -30, -2000], [84.8, -30, -1000], [86, -30, 0], [86.4, -30, 1000], [86.9, -30, 2000], [87.4, -30, 3000],
    [87.9, -30, 4000], [88.3, -30, 5000], [88.7, -30, 6000], [89.2, -30, 7000], [89.3, -30, 8000], [89.5, -30, 9000], [89.6, -30, 10000],
    [81.8, -40, -2000], [83, -40, -1000], [84.2, -40, 0], [84.7, -40, 1000], [85.1, -40, 2000], [85.7, -40, 3000],
    [86.1, -40, 4000], [86.5, -40, 5000], [87, -40, 6000], [87.4, -40, 7000], [87.6, -40, 8000], [87.7, -40, 9000], [87.9, -40, 10000],
    [80, -50, -2000], [81.2, -50, -1000], [82.4, -50, 0], [82.9, -50, 1000], [83.4, -50, 2000], [83.9, -50, 3000],
    [84.3, -50, 4000], [84.7, -50, 5000], [85.2, -50, 6000], [85.6, -50, 7000], [85.7, -50, 8000], [85.9, -50, 9000], [86.1, -50, 10000]
]);
B748EngineData.to2_n1_max = new LerpLookupTable([
    [85.9, 70, -2000], [85.9, 70, -1000], [85.9, 70, 0], [85.9, 70, 1000], [85.9, 70, 2000], [85.9, 70, 3000], [85.9, 70, 4000],
    [85.9, 70, 5000], [85.9, 70, 6000], [85.9, 70, 7000], [85.9, 70, 8000], [85.9, 70, 9000], [86, 70, 10000],
    [84.7, 60, -2000], [85.1, 60, -1000], [85.5, 60, 0], [85.5, 60, 1000], [85.5, 60, 2000], [85.4, 60, 3000], [85.3, 60, 4000],
    [85.3, 60, 5000], [85.3, 60, 6000], [85.2, 60, 7000], [84.7, 60, 8000], [84.7, 60, 9000], [84.7, 60, 10000],
    [85.9, 55, -2000], [86.4, 55, -1000], [86.8, 55, 0], [86.7, 55, 1000], [86.7, 55, 2000], [86.7, 55, 3000], [86.6, 55, 4000],
    [86.5, 55, 5000], [86.5, 55, 6000], [86.5, 55, 7000], [86, 55, 8000], [85.5, 55, 9000], [84.9, 55, 10000],
    [87.1, 50, -2000], [87.6, 50, -1000], [88.1, 50, 0], [88, 50, 1000], [88, 50, 2000], [87.9, 50, 3000], [87.8, 50, 4000],
    [87.8, 50, 5000], [87.8, 50, 6000], [87.8, 50, 7000], [87.2, 50, 8000], [86.7, 50, 9000], [86.1, 50, 10000],
    [88.4, 45, -2000], [88.9, 45, -1000], [89.3, 45, 0], [89.2, 45, 1000], [89.1, 45, 2000], [89.1, 45, 3000], [89.1, 45, 4000],
    [89, 45, 5000], [89, 45, 6000], [89, 45, 7000], [88.5, 45, 8000], [87.9, 45, 9000], [87.4, 45, 10000],
    [89.3, 40, -2000], [90, 40, -1000], [90.6, 40, 0], [90.4, 40, 1000], [90.2, 40, 2000], [90.2, 40, 3000], [90.2, 40, 4000],
    [90.2, 40, 5000], [90.1, 40, 6000], [90.2, 40, 7000], [89.7, 40, 8000], [89.1, 40, 9000], [88.6, 40, 10000],
    [89.6, 35, -2000], [90.5, 35, -1000], [91.2, 35, 0], [91.2, 35, 1000], [91.2, 35, 2000], [91, 35, 3000], [90.9, 35, 4000],
    [90.8, 35, 5000], [90.8, 35, 6000], [90.8, 35, 7000], [90.5, 35, 8000], [90.1, 35, 9000], [89.8, 35, 10000],
    [89.1, 30, -2000], [90.4, 30, -1000], [91.7, 30, 0], [91.7, 30, 1000], [91.7, 30, 2000], [91.7, 30, 3000],
    [91.7, 30, 4000], [91.4, 30, 5000], [91.4, 30, 6000], [91.3, 30, 7000], [91, 30, 8000], [90.7, 30, 9000], [90.4, 30, 10000],
    [88.3, 25, -2000], [89.6, 25, -1000], [90.9, 25, 0], [91.4, 25, 1000], [91.9, 25, 2000], [92.1, 25, 3000],
    [92.2, 25, 4000], [92.2, 25, 5000], [92.6, 25, 6000], [92.4, 25, 7000], [91.5, 25, 8000], [91.2, 25, 9000], [90.9, 25, 10000],
    [87.6, 20, -2000], [88.9, 20, -1000], [90.2, 20, 0], [90.6, 20, 1000], [91.1, 20, 2000], [91.6, 20, 3000],
    [91.9, 20, 4000], [92.4, 20, 5000], [92.5, 20, 6000], [92.7, 20, 7000], [92.5, 20, 8000], [92.2, 20, 9000], [91.4, 20, 10000],
    [86.8, 15, -2000], [88.1, 15, -1000], [89.4, 15, 0], [89.8, 15, 1000], [90.3, 15, 2000], [90.8, 15, 3000],
    [91.1, 15, 4000], [91.6, 15, 5000], [92, 15, 6000], [92.4, 15, 7000], [92.4, 15, 8000], [92.3, 15, 9000], [91.7, 15, 10000],
    [86.1, 10, -2000], [87.4, 10, -1000], [88.6, 10, 0], [89.1, 10, 1000], [89.5, 10, 2000], [90, 10, 3000],
    [90.4, 10, 4000], [90.8, 10, 5000], [91.2, 10, 6000], [91.6, 10, 7000], [91.7, 10, 8000], [91.8, 10, 9000], [92, 10, 10000],
    [85.3, 5, -2000], [86.6, 5, -1000], [87.8, 5, 0], [88.3, 5, 1000], [88.8, 5, 2000], [89.2, 5, 3000], [89.6, 5, 4000],
    [90, 5, 5000], [90.4, 5, 6000], [90.8, 5, 7000], [90.9, 5, 8000], [91, 5, 9000], [91.2, 5, 10000],
    [84.5, 0, -2000], [85.8, 0, -1000], [87, 0, 0], [87.5, 0, 1000], [87.9, 0, 2000], [88.4, 0, 3000],
    [88.8, 0, 4000], [89.2, 0, 5000], [89.6, 0, 6000], [90, 0, 7000], [90.1, 0, 8000], [90.2, 0, 9000], [90.4, 0, 10000],
    [83, -10, -2000], [84.2, -10, -1000], [85.4, -10, 0], [85.9, -10, 1000], [86.3, -10, 2000], [86.8, -10, 3000],
    [87.1, -10, 4000], [87.6, -10, 5000], [88, -10, 6000], [88.4, -10, 7000], [88.5, -10, 8000], [88.6, -10, 9000], [88.8, -10, 10000],
    [81.4, -20, -2000], [82.6, -20, -1000], [83.8, -20, 0], [84.2, -20, 1000], [84.7, -20, 2000], [85.1, -20, 3000],
    [85.5, -20, 4000], [85.9, -20, 5000], [86.3, -20, 6000], [86.7, -20, 7000], [86.8, -20, 8000], [87, -20, 9000], [87.1, -20, 10000],
    [79.8, -30, -2000], [81, -30, -1000], [82.1, -30, 0], [82.5, -30, 1000], [83, -30, 2000], [83.5, -30, 3000],
    [83.9, -30, 4000], [84.3, -30, 5000], [84.6, -30, 6000], [85, -30, 7000], [85.2, -30, 8000], [85.3, -30, 9000], [85.5, -30, 10000],
    [78.1, -40, -2000], [79.3, -40, -1000], [80.4, -40, 0], [80.8, -40, 1000], [81.3, -40, 2000], [81.8, -40, 3000],
    [82.2, -40, 4000], [82.6, -40, 5000], [83, -40, 6000], [83.4, -40, 7000], [83.5, -40, 8000], [83.6, -40, 9000], [83.8, -40, 10000],
    [76.4, -50, -2000], [77.6, -50, -1000], [78.7, -50, 0], [79.1, -50, 1000], [79.6, -50, 2000], [80.1, -50, 3000],
    [80.5, -50, 4000], [80.8, -50, 5000], [81.2, -50, 6000], [81.6, -50, 7000], [81.7, -50, 8000], [81.9, -50, 9000], [82, -50, 10000]
]);
B748EngineData.ga_n1_max = new LerpLookupTable([
    [85.9, 74, 0], [86.7, 74, 1000], [87.5, 74, 2000], [88.3, 74, 3000], [88.7, 74, 4000], [89.1, 74, 5000],
    [89.4, 74, 6000], [89.8, 74, 7000], [89.9, 74, 8000], [89.6, 74, 9000], [89, 74, 10000],
    [87.9, 64, 0], [88.8, 64, 1000], [89.7, 64, 2000], [90.7, 64, 3000], [91.2, 64, 4000], [91.7, 64, 5000],
    [92.1, 64, 6000], [92.5, 64, 7000], [92.7, 64, 8000], [92.4, 64, 9000], [91.8, 64, 10000],
    [88.8, 59, 0], [89.8, 59, 1000], [90.8, 59, 2000], [91.8, 59, 3000], [92.4, 59, 4000], [93, 59, 5000],
    [93.4, 59, 6000], [93.9, 59, 7000], [94.1, 59, 8000], [93.8, 59, 9000], [93.2, 59, 10000],
    [90.2, 54, 0], [90.9, 54, 1000], [91.9, 54, 2000], [92.9, 54, 3000], [93.6, 54, 4000], [94.2, 54, 5000],
    [94.6, 54, 6000], [95.1, 54, 7000], [95.4, 54, 8000], [95.1, 54, 9000], [94.5, 54, 10000],
    [91.5, 49, 0], [92.3, 49, 1000], [93.2, 49, 2000], [94.2, 49, 3000], [94.8, 49, 4000], [95.3, 49, 5000],
    [95.9, 49, 6000], [96.4, 49, 7000], [96.7, 49, 8000], [96.4, 49, 9000], [95.8, 49, 10000],
    [92.8, 44, 0], [93.6, 44, 1000], [94.5, 44, 2000], [95.4, 44, 3000], [96, 44, 4000], [96.6, 44, 5000],
    [97.1, 44, 6000], [97.6, 44, 7000], [98, 44, 8000], [97.7, 44, 9000], [97.1, 44, 10000],
    [94.2, 39, 0], [94.9, 39, 1000], [95.8, 39, 2000], [96.8, 39, 3000], [97.2, 39, 4000], [97.7, 39, 5000],
    [98.3, 39, 6000], [99, 39, 7000], [99, 39, 8000], [98.8, 39, 9000], [98.3, 39, 10000],
    [94.8, 34, 0], [95.7, 34, 1000], [96.6, 34, 2000], [97.6, 34, 3000], [98.2, 34, 4000], [98.7, 34, 5000],
    [99.2, 34, 6000], [99.7, 34, 7000], [99.9, 34, 8000], [99.5, 34, 9000], [99.2, 34, 10000],
    [94.1, 29, 0], [95.5, 29, 1000], [97, 29, 2000], [98.1, 29, 3000], [98.7, 29, 4000], [99.2, 29, 5000],
    [100.3, 29, 6000], [100.8, 29, 7000], [100.7, 29, 8000], [100.3, 29, 9000], [99.9, 29, 10000],
    [93.3, 24, 0], [94.7, 24, 1000], [96.2, 24, 2000], [97.7, 24, 3000], [98.9, 24, 4000], [100.1, 24, 5000],
    [100.9, 24, 6000], [101.7, 24, 7000], [102.2, 24, 8000], [101.6, 24, 9000], [100.7, 24, 10000],
    [92.5, 19, 0], [93.9, 19, 1000], [95.4, 19, 2000], [96.8, 19, 3000], [98, 19, 4000], [99.3, 19, 5000],
    [100.7, 19, 6000], [102.4, 19, 7000], [102.9, 19, 8000], [102.4, 19, 9000], [101.6, 19, 10000],
    [91.7, 14, 0], [93.1, 14, 1000], [94.5, 14, 2000], [96, 14, 3000], [97.2, 14, 4000], [98.5, 14, 5000],
    [99.8, 14, 6000], [101.5, 14, 7000], [102.5, 14, 8000], [102.5, 14, 9000], [102.5, 14, 10000],
    [90.8, 8, 0], [92.1, 8, 1000], [93.5, 8, 2000], [95, 8, 3000], [96.2, 8, 4000], [97.4, 8, 5000], [98.8, 8, 6000],
    [100.4, 8, 7000], [101.4, 8, 8000], [101.4, 8, 9000], [101.5, 8, 10000],
    [90, 3, 0], [91.3, 3, 1000], [92.7, 3, 2000], [94.2, 3, 3000], [95.3, 3, 4000], [96.6, 3, 5000], [97.9, 3, 6000],
    [99.6, 3, 7000], [100.5, 3, 8000], [100.5, 3, 9000], [100.7, 3, 10000],
    [88.3, -7, 0], [89.6, -7, 1000], [91, -7, 2000], [92.4, -7, 3000], [93.6, -7, 4000], [94.9, -7, 5000],
    [96.2, -7, 6000], [97.8, -7, 7000], [98.8, -7, 8000], [98.8, -7, 9000], [98.9, -7, 10000],
    [86.6, -17, 0], [87.9, -17, 1000], [89.3, -17, 2000], [90.7, -17, 3000], [91.9, -17, 4000],
    [93.2, -17, 5000], [94.5, -17, 6000], [96.1, -17, 7000], [97, -17, 8000], [97, -17, 9000], [97.1, -17, 10000],
    [84.9, -27, 0], [86.2, -27, 1000], [87.6, -27, 2000], [89, -27, 3000], [90.2, -27, 4000], [91.4, -27, 5000],
    [92.7, -27, 6000], [94.3, -27, 7000], [95.2, -27, 8000], [95.2, -27, 9000], [95.3, -27, 10000],
    [83.2, -37, 0], [84.4, -37, 1000], [85.8, -37, 2000], [87.2, -37, 3000], [88.5, -37, 4000], [89.7, -37, 5000],
    [90.9, -37, 6000], [92.5, -37, 7000], [93.4, -37, 8000], [93.4, -37, 9000], [93.5, -37, 10000],
    [81.4, -47, 0], [82.7, -47, 1000], [84, -47, 2000], [85.5, -47, 3000], [86.7, -47, 4000], [87.9, -47, 5000],
    [89.1, -47, 6000], [90.6, -47, 7000], [91.5, -47, 8000], [91.6, -47, 9000], [91.7, -47, 10000]
]);
B748EngineData.clb_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.cru_n1_max = new LerpLookupTable([
    [91, 60, 0], [91.6, 60, 5000], [92.9, 60, 10000], [94.1, 60, 15000], [96.1, 60, 20000], [97.6, 60, 25000], [99.8, 60, 30000], [101.2, 60, 35000],
    [101.5, 60, 40000], [100.7, 60, 45000], [92.8, 50, 0], [93.2, 50, 5000], [93.8, 50, 10000], [93.1, 50, 15000], [94.7, 50, 20000], [96.2, 50, 25000],
    [98.3, 50, 30000], [99.7, 50, 35000], [100, 50, 40000], [99.2, 50, 45000], [94.2, 40, 0], [95, 40, 5000], [95.4, 40, 10000], [94.8, 40, 15000], [95, 40, 20000],
    [94.9, 40, 25000], [96.7, 40, 30000], [98.2, 40, 35000], [98.4, 40, 40000], [97.7, 40, 45000], [92.7, 30, 0], [95.5, 30, 5000], [97, 30, 10000], [96.4, 30, 15000],
    [96.6, 30, 20000], [96.5, 30, 25000], [95.2, 30, 30000], [96.6, 30, 35000], [96.8, 30, 40000], [96.1, 30, 45000], [91.2, 20, 0], [93.9, 20, 5000], [96.6, 20, 10000],
    [97.9, 20, 15000], [98.2, 20, 20000], [98, 20, 25000], [96.9, 20, 30000], [95.5, 20, 35000], [95.2, 20, 40000], [94.5, 20, 45000], [90.4, 15, 0], [93.1, 15, 5000],
    [95.8, 15, 10000], [97.3, 15, 15000], [99, 15, 20000], [98.9, 15, 25000], [97.8, 15, 30000], [96.5, 15, 35000], [95.9, 15, 40000], [95.2, 15, 45000], [89.6, 10, 0],
    [92.3, 10, 5000], [95, 10, 10000], [96.5, 10, 15000], [98.7, 10, 20000], [99.7, 10, 25000], [98.7, 10, 30000], [97.6, 10, 35000], [97, 10, 40000], [96.3, 10, 45000],
    [88.8, 5, 0], [91.5, 5, 5000], [94.1, 5, 10000], [95.6, 5, 15000], [97.9, 5, 20000], [99.6, 5, 25000], [99.7, 5, 30000], [98.6, 5, 35000], [98, 5, 40000], [97.3, 5, 45000],
    [88, 0, 0], [90.7, 0, 5000], [93.3, 0, 10000], [94.8, 0, 15000], [97, 0, 20000], [98.7, 0, 25000], [100.8, 0, 30000], [99.6, 0, 35000], [99, 0, 40000], [98.3, 0, 45000],
    [87.2, -5, 0], [89.8, -5, 5000], [92.4, -5, 10000], [93.9, -5, 15000], [96.1, -5, 20000], [97.8, -5, 25000], [101.1, -5, 30000], [100.8, -5, 35000], [100, -5, 40000],
    [99.3, -5, 45000], [86.4, -10, 0], [89, -10, 5000], [91.5, -10, 10000], [93, -10, 15000], [95.2, -10, 20000], [96.8, -10, 25000], [100.2, -10, 30000], [101.4, -10, 35000],
    [100.9, -10, 40000], [100.3, -10, 45000], [85.5, -15, 0], [88.1, -15, 5000], [90.7, -15, 10000], [92.1, -15, 15000], [94.3, -15, 20000], [95.9, -15, 25000],
    [99.2, -15, 30000], [101, -15, 35000], [100.9, -15, 40000], [100.8, -15, 45000], [84.7, -20, 0], [87.3, -20, 5000], [89.8, -20, 10000], [91.2, -20, 15000], [93.4, -20, 20000],
    [95, -20, 25000], [98.3, -20, 30000], [100, -20, 35000], [99.9, -20, 40000], [99.9, -20, 45000], [83.9, -25, 0], [86.4, -25, 5000], [88.9, -25, 10000], [90.3, -25, 15000],
    [92.4, -25, 20000], [94, -25, 25000], [97.3, -25, 30000], [99, -25, 35000], [98.9, -25, 40000], [98.9, -25, 45000], [83, -30, 0], [85.5, -30, 5000], [88, -30, 10000],
    [89.4, -30, 15000], [91.5, -30, 20000], [93.1, -30, 25000], [96.3, -30, 30000], [98, -30, 35000], [97.9, -30, 40000], [97.9, -30, 45000], [82.2, -35, 0], [84.7, -35, 5000],
    [87.1, -35, 10000], [88.5, -35, 15000], [90.6, -35, 20000], [92.1, -35, 25000], [95.3, -35, 30000], [97, -35, 35000], [96.9, -35, 40000], [96.8, -35, 45000], [81.3, -40, 0],
    [83.8, -40, 5000], [86.2, -40, 10000], [87.5, -40, 15000], [89.6, -40, 20000], [91.2, -40, 25000], [94.3, -40, 30000], [96, -40, 35000], [95.9, -40, 40000], [95.8, -40, 45000]
]);
B748EngineData.max_con_n1 = new LerpLookupTable([
    [95.8, 30, 5000], [97.2, 30, 10000], [96.7, 30, 16000], [96.8, 30, 20000], [97.3, 30, 25000], [95, 30, 29000], [94.4, 30, 33000], [93.3, 30, 37000],
    [95.4, 20, 5000], [97.7, 20, 10000], [97.9, 20, 16000], [98.4, 20, 20000], [97.3, 20, 25000], [96.8, 20, 29000], [95.4, 20, 33000], [95.8, 20, 37000],
    [93.4, 10, 5000], [96.7, 10, 10000], [98.4, 10, 16000], [99.2, 10, 20000], [99, 10, 25000], [97.8, 10, 29000], [97.3, 10, 33000], [98.1, 10, 37000],
    [92.1, 0, 5000], [95, 0, 10000], [98.1, 0, 16000], [99.4, 0, 20000], [100, 0, 25000], [100.9, 0, 29000], [99.4, 0, 33000], [99.2, 0, 37000],
    [90.4, -10, 5000], [93.3, -10, 10000], [96.3, -10, 16000], [98.5, -10, 20000], [100.2, -10, 25000], [100.8, -10, 29000], [101, -10, 33000], [100.9, -10, 37000],
    [88.6, -20, 5000], [91.5, -20, 10000], [94.5, -20, 16000], [96.6, -20, 20000], [99.2, -20, 25000], [100.1, -20, 29000], [100.1, -20, 33000], [99.8, -20, 37000],
    [87.8, -30, 5000], [90.6, -30, 10000], [93.5, -30, 16000], [95.6, -30, 20000], [97.3, -30, 25000], [98.1, -30, 29000], [98.2, -30, 33000], [97.9, -30, 37000],
    [87.8, -40, 5000], [90.6, -40, 10000], [93.5, -40, 16000], [95.6, -40, 20000], [96.3, -40, 25000], [96, -40, 29000], [96.1, -40, 33000], [95.9, -40, 37000],
    [87.8, -50, 5000], [90.6, -50, 10000], [93.5, -50, 16000], [95.6, -50, 20000], [95.3, -50, 25000], [95, -50, 29000], [94.9, -50, 33000], [93.8, -50, 37000]
]);
B748EngineData.lrc_mach = new LerpLookupTable([
    // At weight 1014300/460t:
    [0.852, 1014300, 25000], [0.86, 1014300, 27000], [0.86, 1014300, 29000], [0.859, 1014300, 31000], [0.857, 1014300, 33000], [0.853, 1014300, 35000],
    [0.847, 1014300, 37000], [0.839, 1014300, 39000], [0.832, 1014300, 41000], [0.824, 1014300, 43000],
    // At weight 970200/440t:
    [0.845, 970200, 25000], [0.858, 970200, 27000], [0.86, 970200, 29000], [0.859, 970200, 31000], [0.857, 970200, 33000], [0.853, 970200, 35000],
    [0.848, 970200, 37000], [0.840, 970200, 39000], [0.833, 970200, 41000], [0.827, 970200, 43000],
    // At weight 926100/420t:
    [0.836, 926100, 25000], [0.852, 926100, 27000], [0.86, 926100, 29000], [0.86, 926100, 31000], [0.859, 926100, 33000], [0.857, 926100, 35000],
    [0.852, 926100, 37000], [0.846, 926100, 39000], [0.841, 926100, 41000], [0.837, 926100, 43000],
    // At weight 882000/400t:
    [0.827, 882000, 25000], [0.843, 882000, 27000], [0.858, 882000, 29000], [0.86, 882000, 31000], [0.859, 882000, 33000], [0.854, 882000, 35000],
    [0.854, 882000, 37000], [0.848, 882000, 39000], [0.844, 882000, 41000], [0.840, 882000, 43000],
    // At weight 837900/380t:
    [0.817, 837900, 25000], [0.834, 837900, 27000], [0.85, 837900, 29000], [0.859, 837900, 31000], [0.86, 837900, 33000], [0.859, 837900, 35000],
    [0.856, 837900, 37000], [0.853, 837900, 39000], [0.849, 837900, 41000], [0.841, 837900, 43000],
    // At weight 793800/360t:
    [0.805, 793800, 25000], [0.824, 793800, 27000], [0.84, 793800, 29000], [0.856, 793800, 31000], [0.86, 793800, 33000], [0.859, 793800, 35000],
    [0.856, 793800, 37000], [0.853, 793800, 39000], [0.849, 793800, 41000], [0.841, 793800, 43000],
    // At weight 749700/340t:
    [0.792, 749700, 25000], [0.812, 749700, 27000], [0.83, 749700, 29000], [0.846, 749700, 31000], [0.859, 749700, 33000], [0.86, 749700, 35000],
    [0.859, 749700, 37000], [0.849, 749700, 39000], [0.845, 749700, 41000], [0.841, 749700, 43000],
    // At weight 705600/320t:
    [0.776, 705600, 25000], [0.798, 705600, 27000], [0.818, 705600, 29000], [0.836, 705600, 31000], [0.852, 705600, 33000], [0.86, 705600, 35000],
    [0.859, 705600, 37000], [0.858, 705600, 39000], [0.854, 705600, 41000], [0.847, 705600, 43000],
    // At weight 661500/300t:
    [0.758, 661500, 25000], [0.782, 661500, 27000], [0.804, 661500, 29000], [0.823, 661500, 31000], [0.841, 661500, 33000], [0.857, 661500, 35000],
    [0.86, 661500, 37000], [0.859, 661500, 39000], [0.854, 661500, 41000], [0.849, 661500, 43000],
    // At weight 617400/280t:
    [0.737, 617400, 25000], [0.763, 617400, 27000], [0.787, 617400, 29000], [0.809, 617400, 31000], [0.828, 617400, 33000], [0.845, 617400, 35000],
    [0.859, 617400, 37000], [0.86, 617400, 39000], [0.859, 617400, 41000], [0.850, 617400, 43000],
    // At weight 529200/240t:
    [0.686, 529200, 25000], [0.716, 529200, 27000], [0.744, 529200, 29000], [0.771, 529200, 31000], [0.795, 529200, 33000], [0.816, 529200, 35000],
    [0.835, 529200, 37000], [0.852, 529200, 39000], [0.86, 529200, 41000], [0.859, 529200, 43000],
    // At weight 441000/200t:
    [0.626, 441000, 25000], [0.654, 441000, 27000], [0.684, 441000, 29000], [0.715, 441000, 31000], [0.744, 441000, 33000], [0.772, 441000, 35000],
    [0.797, 441000, 37000], [0.818, 441000, 39000], [0.837, 441000, 41000], [0.853, 441000, 43000]
]);
/** Output: Opt Altitude in Ft; Term 1: Weight in LBS */
B748EngineData.alt_opt = new LerpLookupTable([
    [29000, 1014125.2],
    [30000, 970032.8],
    [31000, 925940.4],
    [32100, 881848],
    [33200, 837755.6],
    [34300, 793663.2],
    [35500, 749570.8],
    [36800, 705478.4],
    [38100, 661386],
    [39600, 617293.6],
    [41100, 573201.2],
    [42800, 529108.8],
    [43100, 485016.4],
    [43100, 440924]
]);
/** Output: Max Altitude in Ft; Term 1: Weight in LBS; Term 2: ISA Tem Deviation in C */
B748EngineData.alt_max = new LerpLookupTable([
    [32500, 1014125.2, -100], [32500, 1014125.2, 10], [31300, 1014125.2, 15], [29600, 1014125.2, 20],
    [33700, 970032.8, -100], [33700, 970032.8, 10], [32800, 970032.8, 15], [31000, 970032.8, 20],
    [34800, 925940.4, -100], [34800, 925940.4, 10], [34100, 925940.4, 15], [32500, 925940.4, 20],
    [35800, 881848, -100], [35800, 881848, 10], [35500, 881848, 15], [33900, 881848, 20],
    [36800, 837755.6, -100], [36800, 837755.6, 10], [36600, 837755.6, 15], [35500, 837755.6, 20],
    [38000, 793663.2, -100], [38000, 793663.2, 10], [37700, 793663.2, 15], [36700, 793663.2, 20],
    [39200, 749570.8, -100], [39200, 749570.8, 10], [38800, 749570.8, 15], [37800, 749570.8, 20],
    [40400, 705478.4, -100], [40400, 705478.4, 10], [40000, 705478.4, 15], [38900, 705478.4, 20],
    [41700, 661386, -100], [41700, 661386, 10], [41200, 661386, 15], [40100, 661386, 20],
    [43100, 617293.6, -100], [43100, 617293.6, 10], [42400, 617293.6, 15], [41300, 617293.6, 20],
    [43100, 573201.2, -100], [43100, 573201.2, 10], [43100, 573201.2, 15], [42600, 573201.2, 20],
    [43100, 529108.8, -100], [43100, 529108.8, 10], [43100, 529108.8, 15], [43100, 529108.8, 20],
    [43100, 485016.4, -100], [43100, 485016.4, 10], [43100, 485016.4, 15], [43100, 485016.4, 20],
    [43100, 440924, -100], [43100, 440924, 10], [43100, 440924, 15], [43100, 440924, 20]
]);

/** B747-8i Performance Math Utility Class. */
class B748PerformanceMath extends BoeingPerformanceDataProvider {
    /** @inheritDoc */
    get operatingEmptyWeight() {
        return 467160; // 211,900 kg
    }
    /** @inheritDoc */
    get maxZeroFuelWeight() {
        return 651000; // 295,288 kg
    }
    /** @inheritDoc */
    get maxGrossWeight() {
        return 975000; // 442,252 kg
    }
    /** @inheritDoc */
    get maxReserveFuel() {
        return Number.MAX_SAFE_INTEGER; // TODO Replace with actual value
    }
    /** @inheritDoc */
    get fuelFreezeTemp() {
        return -37;
    }
    /** @inheritDoc */
    get minCenterOfGravity() {
        return 11;
    }
    /** @inheritDoc */
    get maxCenterOfGravity() {
        return 33;
    }
    /** @inheritdoc */
    getAircraftFlightModel() {
        return {
            wing_span: 224.57,
            wing_area: 5960,
            //From the lift_coef_aoa_table: the value at aoa_0.
            cl_cd: [[0.23, 0.018], [0.2764, 0.0533], [0.4554, 0.0644], [0.5659, 0.0778], [0.7648, 0.0994], [0.8747, 0.1144], [1.0926, 0.1237]],
            induced_drag_scalar: 1,
            oswald_efficiency_factor: 0.75,
            inlet_area: 60,
            low_idle_n1: 23.2,
            mach_influence_on_n1: 10,
            static_thrust: 66500,
            ThrustSpecificFuelConsumption: 0.27,
            n1_and_mach_on_thrust_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.45], [0, 0, 0.9],
                [0.053978, 20, 0], [0.034816, 20, 0.45], [0.080724, 20, 0.9],
                [0.072647, 25, 0], [0.042137, 25, 0.45], [0.153968, 25, 0.9],
                [0.092571, 30, 0], [0.055766, 30, 0.45], [0.352444, 30, 0.9],
                [0.114397, 35, 0], [0.087857, 35, 0.45], [0.382598, 35, 0.9],
                [0.133584, 40, 0], [0.129235, 40, 0.45], [0.401433, 40, 0.9],
                [0.163657, 45, 0], [0.179995, 45, 0.45], [0.424077, 45, 0.9],
                [0.201611, 50, 0], [0.227881, 50, 0.45], [0.453427, 50, 0.9],
                [0.247145, 55, 0], [0.284959, 55, 0.45], [0.489514, 55, 0.9],
                [0.306598, 60, 0], [0.357671, 60, 0.45], [0.526682, 60, 0.9],
                [0.404374, 65, 0], [0.458374, 65, 0.45], [0.565243, 65, 0.9],
                [0.472288, 70, 0], [0.53715, 70, 0.45], [0.610145, 70, 0.9],
                [0.543975, 75, 0], [0.608862, 75, 0.45], [0.67375, 75, 0.9],
                [0.628349, 80, 0], [0.697486, 80, 0.45], [0.766623, 80, 0.9],
                [0.735036, 85, 0], [0.796225, 85, 0.45], [0.857414, 85, 0.9],
                [0.837808, 90, 0], [0.906299, 90, 0.45], [0.97479, 90, 0.9],
                [0.956614, 95, 0], [1.020258, 95, 0.45], [1.083902, 95, 0.9],
                [1.090953, 100, 0], [1.156054, 100, 0.45], [1.221156, 100, 0.9],
                [1.234866, 105, 0], [1.296368, 105, 0.45], [1.35787, 105, 0.9],
                [1.325555, 110, 0], [1.380287, 110, 0.45], [1.43502, 110, 0.9]
            ]),
            thrust_and_mach_on_n1_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.45], [0, 0, 0.9],
                [20, 0.053978, 0], [20, 0.034816, 0.45], [20, 0.080724, 0.9],
                [25, 0.072647, 0], [25, 0.042137, 0.45], [25, 0.153968, 0.9],
                [30, 0.092571, 0], [30, 0.055766, 0.45], [30, 0.352444, 0.9],
                [35, 0.114397, 0], [35, 0.087857, 0.45], [35, 0.382598, 0.9],
                [40, 0.133584, 0], [40, 0.129235, 0.45], [40, 0.401433, 0.9],
                [45, 0.163657, 0], [45, 0.179995, 0.45], [45, 0.424077, 0.9],
                [50, 0.201611, 0], [50, 0.227881, 0.45], [50, 0.453427, 0.9],
                [55, 0.247145, 0], [55, 0.284959, 0.45], [55, 0.489514, 0.9],
                [60, 0.306598, 0], [60, 0.357671, 0.45], [60, 0.526682, 0.9],
                [65, 0.404374, 0], [65, 0.458374, 0.45], [65, 0.565243, 0.9],
                [70, 0.472288, 0], [70, 0.53715, 0.45], [70, 0.610145, 0.9],
                [75, 0.543975, 0], [75, 0.608862, 0.45], [75, 0.67375, 0.9],
                [80, 0.628349, 0], [80, 0.697486, 0.45], [80, 0.766623, 0.9],
                [85, 0.735036, 0], [85, 0.796225, 0.45], [85, 0.857414, 0.9],
                [90, 0.837808, 0], [90, 0.906299, 0.45], [90, 0.97479, 0.9],
                [95, 0.956614, 0], [95, 1.020258, 0.45], [95, 1.083902, 0.9],
                [100, 1.090953, 0], [100, 1.156054, 0.45], [100, 1.221156, 0.9],
                [105, 1.234866, 0], [105, 1.296368, 0.45], [105, 1.35787, 0.9],
                [110, 1.325555, 0], [110, 1.380287, 0.45], [110, 1.43502, 0.9]
            ]),
            corrected_airflow_table: new LerpLookupTable([
                [0, 0, 0], [0, 0, 0.9],
                [4.29, 20, 0], [14.081, 20, 0.9],
                [22, 85, 0], [24, 85, 0.9],
                [25, 90, 0], [25, 90, 0.9],
                [27, 95, 0], [27, 95, 0.9],
                [28, 100, 0], [28, 100, 0.9],
                [29, 105, 0], [29, 105, 0.9],
                [30, 110, 0], [30, 110, 0.9]
            ])
        };
    }
}

/** Boeing Speed Data */
class B748SpeedData {
    /**
     * Construct an instance of the 748 speed provider
     * @param bus Event bus
     */
    constructor(bus) {
        this.bus = bus;
        this.pressureAlt = ConsumerValue.create(null, 0);
        this.pressureAlt.setConsumer(this.bus.getSubscriber().on('pressure_alt'));
    }
    /** @inheritdoc */
    getFlapManeuverSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.flap_maneuver_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVrefSpeed(flapPos, weight, pressureAlt) {
        if (flapPos === 25 || flapPos === 30) {
            // the flap maneuver speeds for 25 and 30 are vref
            return this.getFlapManeuverSpeed(flapPos, weight, pressureAlt);
        }
        throw new Error('25 and 30 are the only valid 748 VREF flap positions');
    }
    /** @inheritdoc */
    getHoldingSpeed(flapPos, weight, pressureAlt) {
        return B748SpeedData.holding_speeds.get(weight, flapPos, pressureAlt);
    }
    /** @inheritdoc */
    getVmo() {
        return B748SpeedData.vmo;
    }
    /** @inheritdoc */
    getMmo() {
        return B748SpeedData.mmo;
    }
    /** @inheritdoc */
    getGearLimitSpeed() {
        return B748SpeedData.vle;
    }
}
/** Maximum Speed Limit Mach Number */
B748SpeedData.mmo = 0.9;
/** Maximum Speed Limit KCAS */
B748SpeedData.vmo = 365;
/** Landing Gear Placard Speed KIAS */
B748SpeedData.vle = 270;
/** Flap Maneuver Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.flap_maneuver_speeds = new LerpLookupTable([
    [266, 1014126, 0, 0], [244, 1014126, 1, 0], [224, 1014126, 5, 0], [204, 1014126, 10, 0], [194, 1014126, 20, 0], [191, 1014126, 25, 0], [187, 1014126, 30, 0],
    [260, 970034, 0, 0], [240, 970034, 1, 0], [220, 970034, 5, 0], [201, 970034, 10, 0], [190, 970034, 20, 0], [187, 970034, 25, 0], [183, 970034, 30, 0],
    [256, 925942, 0, 0], [236, 925942, 1, 0], [216, 925942, 5, 0], [198, 925942, 10, 0], [186, 925942, 20, 0], [182, 925942, 25, 0], [178, 925942, 30, 0],
    [252, 881849, 0, 0], [232, 881849, 1, 0], [212, 881849, 5, 0], [195, 881849, 10, 0], [181, 881849, 20, 0], [177, 881849, 25, 0], [173, 881849, 30, 0],
    [247, 837757, 0, 0], [227, 837757, 1, 0], [207, 837757, 5, 0], [192, 837757, 10, 0], [177, 837757, 20, 0], [172, 837757, 25, 0], [169, 837757, 30, 0],
    [243, 793664, 0, 0], [223, 793664, 1, 0], [202, 793664, 5, 0], [190, 793664, 10, 0], [174, 793664, 20, 0], [167, 793664, 25, 0], [164, 793664, 30, 0],
    [239, 749572, 0, 0], [219, 749572, 1, 0], [199, 749572, 5, 0], [186, 749572, 10, 0], [172, 749572, 20, 0], [163, 749572, 25, 0], [160, 749572, 30, 0],
    [234, 705479, 0, 0], [214, 705479, 1, 0], [194, 705479, 5, 0], [180, 705479, 10, 0], [166, 705479, 20, 0], [158, 705479, 25, 0], [155, 705479, 30, 0],
    [229, 661387, 0, 0], [209, 661387, 1, 0], [189, 661387, 5, 0], [174, 661387, 10, 0], [161, 661387, 20, 0], [153, 661387, 25, 0], [150, 661387, 30, 0],
    [224, 617294, 0, 0], [204, 617294, 1, 0], [184, 617294, 5, 0], [168, 617294, 10, 0], [155, 617294, 20, 0], [147, 617294, 25, 0], [144, 617294, 30, 0],
    [219, 573202, 0, 0], [199, 573202, 1, 0], [178, 573202, 5, 0], [162, 573202, 10, 0], [150, 573202, 20, 0], [141, 573202, 25, 0], [139, 573202, 30, 0],
    [213, 529109, 0, 0], [193, 529109, 1, 0], [173, 529109, 5, 0], [155, 529109, 10, 0], [144, 529109, 20, 0], [136, 529109, 25, 0], [133, 529109, 30, 0],
    [208, 485017, 0, 0], [188, 485017, 1, 0], [168, 485017, 5, 0], [149, 485017, 10, 0], [138, 485017, 20, 0], [130, 485017, 25, 0], [127, 485017, 30, 0],
    [205, 440925, 0, 0], [185, 440925, 1, 0], [164, 440925, 5, 0], [144, 440925, 10, 0], [134, 440925, 20, 0], [124, 440925, 25, 0], [121, 440925, 30, 0],
    [271, 1014126, 0, 10000], [247, 1014126, 1, 10000], [227, 1014126, 5, 10000], [211, 1014126, 10, 10000], [197, 1014126, 20, 10000], [191, 1014126, 25, 10000], [187, 1014126, 30, 10000],
    [265, 970034, 0, 10000], [243, 970034, 1, 10000], [223, 970034, 5, 10000], [207, 970034, 10, 10000], [193, 970034, 20, 10000], [187, 970034, 25, 10000], [183, 970034, 30, 10000],
    [259, 925942, 0, 10000], [238, 925942, 1, 10000], [218, 925942, 5, 10000], [204, 925942, 10, 10000], [189, 925942, 20, 10000], [182, 925942, 25, 10000], [178, 925942, 30, 10000],
    [254, 881849, 0, 10000], [234, 881849, 1, 10000], [213, 881849, 5, 10000], [200, 881849, 10, 10000], [184, 881849, 20, 10000], [177, 881849, 25, 10000], [173, 881849, 30, 10000],
    [249, 837757, 0, 10000], [229, 837757, 1, 10000], [209, 837757, 5, 10000], [197, 837757, 10, 10000], [180, 837757, 20, 10000], [172, 837757, 25, 10000], [169, 837757, 30, 10000],
    [244, 793664, 0, 10000], [224, 793664, 1, 10000], [206, 793664, 5, 10000], [194, 793664, 10, 10000], [176, 793664, 20, 10000], [167, 793664, 25, 10000], [164, 793664, 30, 10000],
    [240, 749572, 0, 10000], [220, 749572, 1, 10000], [204, 749572, 5, 10000], [190, 749572, 10, 10000], [173, 749572, 20, 10000], [163, 749572, 25, 10000], [160, 749572, 30, 10000],
    [235, 705479, 0, 10000], [215, 705479, 1, 10000], [197, 705479, 5, 10000], [184, 705479, 10, 10000], [168, 705479, 20, 10000], [158, 705479, 25, 10000], [155, 705479, 30, 10000],
    [230, 661387, 0, 10000], [210, 661387, 1, 10000], [190, 661387, 5, 10000], [177, 661387, 10, 10000], [162, 661387, 20, 10000], [153, 661387, 25, 10000], [150, 661387, 30, 10000],
    [225, 617294, 0, 10000], [205, 617294, 1, 10000], [185, 617294, 5, 10000], [170, 617294, 10, 10000], [156, 617294, 20, 10000], [147, 617294, 25, 10000], [144, 617294, 30, 10000],
    [220, 573202, 0, 10000], [200, 573202, 1, 10000], [179, 573202, 5, 10000], [163, 573202, 10, 10000], [150, 573202, 20, 10000], [141, 573202, 25, 10000], [139, 573202, 30, 10000],
    [214, 529109, 0, 10000], [194, 529109, 1, 10000], [174, 529109, 5, 10000], [157, 529109, 10, 10000], [144, 529109, 20, 10000], [136, 529109, 25, 10000], [133, 529109, 30, 10000],
    [208, 485017, 0, 10000], [188, 485017, 1, 10000], [168, 485017, 5, 10000], [150, 485017, 10, 10000], [138, 485017, 20, 10000], [130, 485017, 25, 10000], [127, 485017, 30, 10000],
    [205, 440925, 0, 10000], [185, 440925, 1, 10000], [164, 440925, 5, 10000], [144, 440925, 10, 10000], [134, 440925, 20, 10000], [124, 440925, 25, 10000], [121, 440925, 30, 10000],
    [288, 1014126, 0, 20000], [252, 1014126, 1, 20000], [232, 1014126, 5, 20000], [219, 1014126, 10, 20000], [202, 1014126, 20, 20000], [191, 1014126, 25, 20000], [187, 1014126, 30, 20000],
    [280, 970034, 0, 20000], [247, 970034, 1, 20000], [227, 970034, 5, 20000], [215, 970034, 10, 20000], [198, 970034, 20, 20000], [187, 970034, 25, 20000], [183, 970034, 30, 20000],
    [271, 925942, 0, 20000], [242, 925942, 1, 20000], [222, 925942, 5, 20000], [209, 925942, 10, 20000], [194, 925942, 20, 20000], [182, 925942, 25, 20000], [178, 925942, 30, 20000],
    [263, 881849, 0, 20000], [237, 881849, 1, 20000], [217, 881849, 5, 20000], [204, 881849, 10, 20000], [189, 881849, 20, 20000], [177, 881849, 25, 20000], [173, 881849, 30, 20000],
    [255, 837757, 0, 20000], [232, 837757, 1, 20000], [214, 837757, 5, 20000], [200, 837757, 10, 20000], [184, 837757, 20, 20000], [172, 837757, 25, 20000], [169, 837757, 30, 20000],
    [250, 793664, 0, 20000], [227, 793664, 1, 20000], [214, 793664, 5, 20000], [197, 793664, 10, 20000], [180, 793664, 20, 20000], [167, 793664, 25, 20000], [164, 793664, 30, 20000],
    [246, 749572, 0, 20000], [223, 749572, 1, 20000], [211, 749572, 5, 20000], [193, 749572, 10, 20000], [177, 749572, 20, 20000], [163, 749572, 25, 20000], [160, 749572, 30, 20000],
    [238, 705479, 0, 20000], [218, 705479, 1, 20000], [203, 705479, 5, 20000], [186, 705479, 10, 20000], [171, 705479, 20, 20000], [158, 705479, 25, 20000], [155, 705479, 30, 20000],
    [233, 661387, 0, 20000], [213, 661387, 1, 20000], [196, 661387, 5, 20000], [180, 661387, 10, 20000], [165, 661387, 20, 20000], [153, 661387, 25, 20000], [150, 661387, 30, 20000],
    [227, 617294, 0, 20000], [207, 617294, 1, 20000], [188, 617294, 5, 20000], [173, 617294, 10, 20000], [159, 617294, 20, 20000], [147, 617294, 25, 20000], [144, 617294, 30, 20000],
    [221, 573202, 0, 20000], [201, 573202, 1, 20000], [181, 573202, 5, 20000], [166, 573202, 10, 20000], [153, 573202, 20, 20000], [141, 573202, 25, 20000], [139, 573202, 30, 20000],
    [215, 529109, 0, 20000], [195, 529109, 1, 20000], [175, 529109, 5, 20000], [158, 529109, 10, 20000], [146, 529109, 20, 20000], [136, 529109, 25, 20000], [133, 529109, 30, 20000],
    [209, 485017, 0, 20000], [189, 485017, 1, 20000], [169, 485017, 5, 20000], [151, 485017, 10, 20000], [139, 485017, 20, 20000], [130, 485017, 25, 20000], [127, 485017, 30, 20000],
    [205, 440925, 0, 20000], [185, 440925, 1, 20000], [164, 440925, 5, 20000], [145, 440925, 10, 20000], [134, 440925, 20, 20000], [124, 440925, 25, 20000], [121, 440925, 30, 20000],
]);
/** Holding Speeds, speed [kcas], weight [lb], flap position, pressure alt [feet] => lookup key = (weight, flap, zp) */
B748SpeedData.holding_speeds = new LerpLookupTable([
    [267, 1014126, 0, 1500], [269, 1014126, 0, 5000], [271, 1014126, 0, 10000], [277, 1014126, 0, 15000], [318, 1014126, 0, 20000], [323, 1014126, 0, 25000], [316, 1014126, 0, 30000],
    [261, 970034, 0, 1500], [263, 970034, 0, 5000], [265, 970034, 0, 10000], [269, 970034, 0, 15000], [311, 970034, 0, 20000], [315, 970034, 0, 25000], [316, 970034, 0, 30000],
    [257, 925942, 0, 1500], [257, 925942, 0, 5000], [259, 925942, 0, 10000], [262, 925942, 0, 15000], [303, 925942, 0, 20000], [307, 925942, 0, 25000], [312, 925942, 0, 30000],
    [252, 881849, 0, 1500], [252, 881849, 0, 5000], [254, 881849, 0, 10000], [255, 881849, 0, 15000], [296, 881849, 0, 20000], [299, 881849, 0, 25000], [304, 881849, 0, 30000], [283, 881849, 0, 35000],
    [248, 837757, 0, 1500], [248, 837757, 0, 5000], [249, 837757, 0, 10000], [250, 837757, 0, 15000], [288, 837757, 0, 20000], [291, 837757, 0, 25000], [295, 837757, 0, 30000], [283, 837757, 0, 35000],
    [243, 793664, 0, 1500], [243, 793664, 0, 5000], [244, 793664, 0, 10000], [246, 793664, 0, 15000], [280, 793664, 0, 20000], [283, 793664, 0, 25000], [287, 793664, 0, 30000], [283, 793664, 0, 35000],
    [239, 749572, 0, 1500], [239, 749572, 0, 5000], [240, 749572, 0, 10000], [242, 749572, 0, 15000], [272, 749572, 0, 20000], [275, 749572, 0, 25000], [278, 749572, 0, 30000], [283, 749572, 0, 35000],
    [235, 705479, 0, 1500], [235, 705479, 0, 5000], [235, 705479, 0, 10000], [237, 705479, 0, 15000], [263, 705479, 0, 20000], [266, 705479, 0, 25000], [269, 705479, 0, 30000], [273, 705479, 0, 35000], [252, 705479, 0, 40000],
    [230, 661387, 0, 1500], [230, 661387, 0, 5000], [230, 661387, 0, 10000], [231, 661387, 0, 15000], [254, 661387, 0, 20000], [257, 661387, 0, 25000], [260, 661387, 0, 30000], [264, 661387, 0, 35000], [252, 661387, 0, 40000],
    [224, 617294, 0, 1500], [224, 617294, 0, 5000], [225, 617294, 0, 10000], [226, 617294, 0, 15000], [246, 617294, 0, 20000], [248, 617294, 0, 25000], [250, 617294, 0, 30000], [254, 617294, 0, 35000], [252, 617294, 0, 40000], [235, 617294, 0, 43000],
    [219, 573202, 0, 1500], [219, 573202, 0, 5000], [220, 573202, 0, 10000], [220, 573202, 0, 15000], [236, 573202, 0, 20000], [238, 573202, 0, 25000], [241, 573202, 0, 30000], [244, 573202, 0, 35000], [247, 573202, 0, 40000], [235, 573202, 0, 43000],
    [213, 529109, 0, 1500], [213, 529109, 0, 5000], [214, 529109, 0, 10000], [214, 529109, 0, 15000], [227, 529109, 0, 20000], [228, 529109, 0, 25000], [231, 529109, 0, 30000], [233, 529109, 0, 35000], [237, 529109, 0, 40000], [234, 529109, 0, 43000],
    [208, 485017, 0, 1500], [208, 485017, 0, 5000], [208, 485017, 0, 10000], [209, 485017, 0, 15000], [217, 485017, 0, 20000], [218, 485017, 0, 25000], [220, 485017, 0, 30000], [223, 485017, 0, 35000], [226, 485017, 0, 40000], [228, 485017, 0, 43000],
    [205, 440925, 0, 1500], [205, 440925, 0, 5000], [205, 440925, 0, 10000], [205, 440925, 0, 15000], [208, 440925, 0, 20000], [209, 440925, 0, 25000], [210, 440925, 0, 30000], [212, 440925, 0, 35000], [215, 440925, 0, 40000], [216, 440925, 0, 43000],
    [245, 1014126, 1, 1500], [246, 1014126, 1, 5000], [247, 1014126, 1, 10000], [249, 1014126, 1, 15000], [252, 1014126, 1, 20000],
    [241, 970034, 1, 1500], [241, 970034, 1, 5000], [243, 970034, 1, 10000], [245, 970034, 1, 15000], [247, 970034, 1, 20000],
    [236, 925942, 1, 1500], [237, 925942, 1, 5000], [238, 925942, 1, 10000], [240, 925942, 1, 15000], [242, 925942, 1, 20000],
    [232, 881849, 1, 1500], [232, 881849, 1, 5000], [234, 881849, 1, 10000], [235, 881849, 1, 15000], [237, 881849, 1, 20000],
    [227, 837757, 1, 1500], [228, 837757, 1, 5000], [229, 837757, 1, 10000], [230, 837757, 1, 15000], [232, 837757, 1, 20000],
    [223, 793664, 1, 1500], [223, 793664, 1, 5000], [224, 793664, 1, 10000], [225, 793664, 1, 15000], [227, 793664, 1, 20000],
    [219, 749572, 1, 1500], [219, 749572, 1, 5000], [220, 749572, 1, 10000], [221, 749572, 1, 15000], [223, 749572, 1, 20000],
    [214, 705479, 1, 1500], [215, 705479, 1, 5000], [215, 705479, 1, 10000], [216, 705479, 1, 15000], [218, 705479, 1, 20000],
    [209, 661387, 1, 1500], [210, 661387, 1, 5000], [210, 661387, 1, 10000], [211, 661387, 1, 15000], [213, 661387, 1, 20000],
    [204, 617294, 1, 1500], [204, 617294, 1, 5000], [205, 617294, 1, 10000], [206, 617294, 1, 15000], [207, 617294, 1, 20000],
    [199, 573202, 1, 1500], [199, 573202, 1, 5000], [200, 573202, 1, 10000], [200, 573202, 1, 15000], [201, 573202, 1, 20000],
    [193, 529109, 1, 1500], [193, 529109, 1, 5000], [194, 529109, 1, 10000], [194, 529109, 1, 15000], [195, 529109, 1, 20000],
    [188, 485017, 1, 1500], [188, 485017, 1, 5000], [188, 485017, 1, 10000], [189, 485017, 1, 15000], [189, 485017, 1, 20000],
    [185, 440925, 1, 1500], [185, 440925, 1, 5000], [185, 440925, 1, 10000], [185, 440925, 1, 15000], [185, 440925, 1, 20000],
]);

/**
 * Automatically selects the best ADC for a Boeing 747-8.
 *
 * The selected ADC depends on the state of the AIR DATA source select knob. If the knob has Left, Center, or Right
 * selected, then that ADC will be selected. If the knob has Auto selected, then the most desirable from among all
 * three ADCs will be selected. Systems that are providing valid data are considered more desirable than those that
 * are not.
 */
class B748AdcSystemSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines the preferred ADC and which ADC candidates
     * are available from which to select.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        this.candidates = SetSubject.create([1, 2, 3]);
        this.selector = new AdcSystemSelector(1, this.bus, this.candidates, this.sourceSelectSide === 'right' ? [3, 2, 1] : [1, 2, 3]);
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best ADC among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('B748AdcSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b74_air_data_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            let left = false, center = false, right = false;
            switch (state) {
                case AirDataSourceKnobState.Left:
                    left = true;
                    break;
                case AirDataSourceKnobState.Right:
                    right = true;
                    break;
                default:
                    left = true;
                    center = true;
                    right = true;
            }
            this.candidates.toggle(1, left);
            this.candidates.toggle(2, center);
            this.candidates.toggle(3, right);
        });
        this.selector.init();
    }
}

/**
 * Automatically selects the best IRS for a Boeing 747-8.
 *
 * The selected IRS depends on the state of the IRS source select knob. If the knob has Left, Center, or Right
 * selected, then that IRS will be selected. If the knob has Auto selected, then the most desirable from among all
 * three IRSes will be selected. Desirability is as follows, in decreasing order:
 * 1. Providing all data (position, inertial, heading, attitude).
 * 2. Providing inertial, heading, and attitude data.
 * 3. Providing heading and attitude data.
 * 4. Providing attitude data only.
 * 5. Providing no data.
 */
class B748IrsSystemSelector {
    /**
     * Constructor.
     * @param bus The event bus.
     * @param sourceSelectSide The system source select side that determines the preferred IRS and which IRS candidates
     * are available from which to select.
     */
    constructor(bus, sourceSelectSide) {
        this.bus = bus;
        this.sourceSelectSide = sourceSelectSide;
        this.candidates = SetSubject.create([1, 2, 3]);
        this.selector = new IrsSystemSelector(1, this.bus, this.candidates, this.sourceSelectSide === 'right' ? [3, 2, 1] : [1, 2, 3]);
        this.isAlive = true;
        this.isInit = false;
    }
    /**
     * Initializes this selector. Once initialized, this selector will automatically select the best IRS among its
     * candidates.
     * @throws Error if this selector has been destroyed.
     */
    init() {
        if (!this.isAlive) {
            throw new Error('B748IrsSystemSelector: cannot initialize a dead selector');
        }
        if (this.isInit) {
            return;
        }
        this.isInit = true;
        this.bus.getSubscriber()
            .on(`b74_irs_source_knob_state_${this.sourceSelectSide === 'right' ? 2 : 1}`)
            .handle(state => {
            let left = false, center = false, right = false;
            switch (state) {
                case IrsSourceKnobState.Left:
                    left = true;
                    break;
                case IrsSourceKnobState.Center:
                    center = true;
                    break;
                case IrsSourceKnobState.Right:
                    right = true;
                    break;
                default:
                    left = true;
                    center = true;
                    right = true;
            }
            this.candidates.toggle(1, left);
            this.candidates.toggle(2, center);
            this.candidates.toggle(3, right);
        });
        this.selector.init();
    }
}

/**
 * A TCAS II implementation for the B748.
 */
class B748TCAS extends BoeingTCAS {
}

/// <reference types="@microsoft/msfs-types/js/avionics" />
/**
 * A common instrument for the B747-8i displays.
 */
class WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        this.instrument = instrument;
        this.config = config;
        this.isInstrumentPowered = false;
        this.isPowerValid = false;
        this.isPowered = undefined;
        this.bus = new EventBus();
        this.facRepo = FacilityRepository.getRepository(this.bus);
        this.facLoader = new FacilityLoader(this.facRepo);
        this.hEventPublisher = new HEventPublisher(this.bus);
        this.flightPathCalculator = new FlightPathCalculator(this.facLoader, {
            defaultClimbRate: 2000,
            defaultSpeed: 180,
            bankAngle: BoeingFlightPathUtils.flightPathBankAngleTable,
            holdBankAngle: null,
            courseReversalBankAngle: null,
            turnAnticipationBankAngle: null,
            maxBankAngle: 25,
            airplaneSpeedMode: FlightPathAirplaneSpeedMode.TrueAirspeedPlusWind
        }, this.bus);
        this.flightPlanner = FlightPlanner.getPlanner(this.bus, this.flightPathCalculator, BoeingFmsUtils.buildBoeingLegName);
        this.perfPlanRepository = new PerformancePlanRepository(this.flightPlanner, this.bus);
        this.activeRoutePerformancePlan = this.perfPlanRepository.getActivePlan();
        this.performanceMath = new B748PerformanceMath();
        this.pathPerformanceProvider = new DefaultBoeingPathPerformanceProvider(this.performanceMath);
        this.engineDataProvider = new B748EngineData(this.bus, this.performanceMath);
        this.windPlanner = new InterpolatingWindPlanner(this.bus, this.flightPlanner, {
            numberOfClimbAltitudes: 4,
            numberOfDescentAltitudes: 4,
            numberOfLegAltitudes: 4,
        });
        this.verticalPathCalculator = new BoeingPathCalculator(this.bus, this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX, this.pathPerformanceProvider, this.engineDataProvider, this.perfPlanRepository, this.windPlanner, this.getVerticalPathCalculatorOptions());
        this.activeRoutePredictor = new BoeingFlightPlanPredictionsProvider(this.bus, 1, BoeingFms.ACT_RTE_PLAN_INDEX, 1000, this.flightPlanner, this.windPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.pathPerformanceProvider, this.facLoader);
        this.backplane = new InstrumentBackplane();
        this.clock = new Clock(this.bus);
        this.baseInstrumentPublisher = new BaseInstrumentPublisher(this.instrument, this.bus);
        this.ambientPublisher = new AmbientPublisher(this.bus);
        this.gnssPublisher = new GNSSPublisher(this.bus);
        this.adcPublisher = new AdcPublisher(this.bus);
        this.ahrsPublisher = new AhrsPublisher(this.bus);
        this.boeingApPublisher = new BoeingAPSimVarPublisher(this.bus);
        this.lNavPublisher = new LNavSimVarPublisher(this.bus);
        this.lNavDataPublisher = new BoeingLNavDataSimVarPublisher(this.bus);
        this.vNavPublisher = new VNavSimVarPublisher(this.bus);
        this.boeingVNavPublisher = new BoeingVNavSimVarPublisher(this.bus);
        this.navComSimVarPublisher = new NavComSimVarPublisher(this.bus);
        this.cockpitVarsPublisher = new CockpitVarsPublisher(this.bus);
        this.electricalPublisher = new ElectricalPublisher(this.bus);
        this.eisPublisher = new EISPublisher(this.bus);
        this.timerPublisher = new FlightTimerPublisher(this.bus, 3);
        this.trafficInstrument = new TrafficInstrument(this.bus, { realTimeUpdateFreq: 2, simTimeUpdateFreq: 1, contactDeprecateTime: 10 });
        this.weightAndBalancePublisher = new WeightBalanceSimvarPublisher(this.bus);
        this.tcas = new B748TCAS(this.bus, this.trafficInstrument, 30, 2, 1);
        this.gameUnitsPublisher = new BoeingGameUnitsPublisher(this.bus);
        this.xpdrInstrument = new XPDRInstrument(this.bus);
        this.speedData = new B748SpeedData(this.bus);
        this.brakesPublisher = new BrakeSimvarPublisher(this.bus);
        this.fmsOperatingPhasePublisher = new FmsOperatingPhasePublisher(this.bus);
        this.flapComputer = new FlapComputer(this.bus, {
            flap_positions: [
                { label: 0, flapAngle: 0, slatAngle: 0, speedLimit: Infinity },
                { label: 1, flapAngle: 0, slatAngle: 21, speedLimit: 285 },
                { label: 5, flapAngle: 5, slatAngle: 21, speedLimit: 265 },
                { label: 10, flapAngle: 10, slatAngle: 21, speedLimit: 245 },
                { label: 20, flapAngle: 20, slatAngle: 21, speedLimit: 235 },
                { label: 25, flapAngle: 25, slatAngle: 21, speedLimit: 210 },
                { label: 30, flapAngle: 30, slatAngle: 21, speedLimit: 185 },
            ],
            speed_data: this.speedData,
        });
        /** Videos show the radio altimeter at about -8 on the ground,
         * the RADIO HEIGHT simvar is about +16 feet, so we use offset of -24. */
        this.radioAltimeterOffset = -24;
        this.apInstrument = new AutopilotInstrument(this.bus);
        this.apRadioNavInstrument = new APRadioNavInstrument(this.bus);
        this.systems = [];
        this.sourceSelectSide = this.getSourceSelectSide();
        this.irsSystemSelector = new B748IrsSystemSelector(this.bus, this.sourceSelectSide);
        this.adcSystemSelector = new B748AdcSystemSelector(this.bus, this.sourceSelectSide);
        /** Whether this instrument has started updating. */
        this.haveUpdatesStarted = false;
        this.backplane.addInstrument(InstrumentBackplaneNames.Clock, this.clock);
        this.backplane.addInstrument(InstrumentBackplaneNames.Autopilot, this.apInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.AutopilotRadioNav, this.apRadioNavInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Traffic, this.trafficInstrument);
        this.backplane.addInstrument(InstrumentBackplaneNames.Xpdr, this.xpdrInstrument);
        this.backplane.addPublisher(InstrumentBackplaneNames.Base, this.baseInstrumentPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.HEvents, this.hEventPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ambient, this.ambientPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Adc, this.adcPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Ahrs, this.ahrsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Gnss, this.gnssPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingAutopilot, this.boeingApPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNav, this.lNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.LNavData, this.lNavDataPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.VNav, this.vNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.BoeingVNav, this.boeingVNavPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.NavCom, this.navComSimVarPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.CockpitVars, this.cockpitVarsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Electrical, this.electricalPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Eis, this.eisPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.WeightAndBalance, this.weightAndBalancePublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Units, this.gameUnitsPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Timer, this.timerPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Brakes, this.brakesPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.FmsOperatingPhase, this.fmsOperatingPhasePublisher);
        this.tcas.init();
        // force enable animations
        document.documentElement.classList.add('animationsEnabled');
        // Wait until game has entered briefing or in-game mode before initializing the avionics status client. This
        // ensures that we do not publish any statuses based on erroneous power states.
        Wait.awaitSubscribable(GameStateProvider.get(), gameState => gameState === GameState.briefing || gameState === GameState.ingame, true).then(async () => {
            this.isPowerValid = true;
            // Wait until updates have started before initializing the power state because instrument power is not
            // initialized until the first update.
            await Wait.awaitCondition(() => this.haveUpdatesStarted);
            if (this.isPowered === undefined) {
                this.isPowered = this.isInstrumentPowered;
                this.onPowerChanged(this.isPowered, undefined);
            }
        });
    }
    /**
     * Gets configuration options for the vertical path calculator.
     * @returns Configuration options for the vertical path calculator.
     */
    getVerticalPathCalculatorOptions() {
        return {
            engineCount: 4
        };
    }
    /**
     * Whether to locally calculate predictions
     *
     * @returns a boolean
     */
    getLocallyCalculatePredictions() {
        return false;
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onSoundEnd(soundEventId) {
        // noop
    }
    /** @inheritdoc */
    Update() {
        this.haveUpdatesStarted = true;
        this.backplane.onUpdate();
        this.updateSystems();
    }
    /**
     * Updates this instrument's systems.
     */
    updateSystems() {
        for (let i = 0; i < this.systems.length; i++) {
            this.systems[i].onUpdate();
        }
    }
    /**
     * Creates this instrument's avionics systems. This method should be called after `this.iauIndex` has been defined.
     */
    createSystems() {
        // TODO the B787 doesn't have a magnetometer
        const magnetometers = [new MagnetometerSystem(1, this.bus, 'elec_master_battery')];
        const adcSystems = [1, 2, 3].map(index => {
            return new AdcSystem(index, this.bus, 1, 1, `elec_circuit_on_${132 + index}`);
        });
        const raSystems = this.config.sensors.radarAltimeterDefinitions.slice(1, this.config.sensors.radarAltimeterCount + 1).map((def, index) => {
            return new RASystem(index + 1, this.bus, this.radioAltimeterOffset, def.electricity);
        });
        const gpsSystems = [1, 2].map(index => new GpsReceiverSystem(index, this.bus, new GPSSatComputer(index, this.bus, 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_ephemeris.json', 'coui://html_ui/Pages/VCockpit/Instruments/Airliners/WTB747_8i/Assets/Data/gps_sbas.json', 5000, [], this.instrument.instrumentIndex === 3 ? 'primary' : 'replica')));
        const irsAlignTimeSetting = BoeingMsfsUserSettings.getManager(this.bus).getSetting('boeingMsfsIrsAlignTime');
        const irsAttitudeAndRealignDuration = irsAlignTimeSetting.map(setting => setting === BoeingIrsAlignTimeMode.Instant ? 0 : undefined);
        const irsFullAlignDuration = irsAlignTimeSetting.map(setting => {
            switch (setting) {
                case BoeingIrsAlignTimeMode.Instant:
                    return 0;
                case BoeingIrsAlignTimeMode.Realistic:
                    return undefined;
                default:
                    return 60000;
            }
        });
        const irsSystems = [1, 2, 3].map(index => {
            const modeSetting = ConsumerSubject.create(this.bus.getSubscriber().on(`b74_irs_knob_state_${index}`), IrsKnobState.Nav)
                .map(state => {
                switch (state) {
                    case IrsKnobState.Align:
                        return IrsSystemOperatingModeSetting.Align;
                    case IrsKnobState.Nav:
                        return IrsSystemOperatingModeSetting.Navigation;
                    case IrsKnobState.Att:
                        return IrsSystemOperatingModeSetting.Attitude;
                    default:
                        return IrsSystemOperatingModeSetting.Off;
                }
            });
            return new IrsSystem(index, this.bus, 1, 1, true, modeSetting, `elec_circuit_on_${124 + index}`, undefined, irsAttitudeAndRealignDuration, irsFullAlignDuration, irsAttitudeAndRealignDuration);
        });
        this.gpsReceiverSelector = new GpsReceiverSelector(this.bus, Array.from({ length: this.config.sensors.gpsCount }, (v, index) => index + 1), 1 // Math.min(this.iauIndex, this.config.sensors.gpsCount)
        );
        this.gpsReceiverSelector.init();
        // One FMS geo-positioning system for each PFD (technically IAU)
        const fmsPosSystems = [0].map(index => {
            return new FmsPositionSystem(index + 1, this.bus, 
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            this.gpsReceiverSelector.selectedIndex, 1, // pfdSettingManager.getSetting('pfdAdcIndex'),
            1);
        });
        this.systems.push(...magnetometers, ...adcSystems, ...raSystems, ...gpsSystems, ...irsSystems, ...fmsPosSystems, new AoaSystem(1, this.bus, 'elec_master_battery'), new MarkerBeaconSystem(1, this.bus, 'elec_master_battery'));
        this.irsSystemSelector.init();
        this.adcSystemSelector.init();
        this.activeRoutePredictor.init(this.getLocallyCalculatePredictions());
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        this.hEventPublisher.dispatchHEvent(args[0]);
    }
    /** @inheritdoc */
    onFlightStart() {
        SimVar.SetSimVarValue('L:WT_Flight_Started', SimVarValueType.Bool, true);
    }
    /**
     * Attempt to run onFlightStart in case the instrument was reloaded.
     */
    tryRunOnFlightStart() {
        // Only try to start if ingame during the constructor.
        // If not ingame, then user will get a briefing and will eventually trigger onFlightStart.
        if (GameStateProvider.get().get() === GameState.ingame) {
            this.onFlightStart();
        }
    }
    /** @inheritdoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onGameStateChanged(oldState, newState) {
        // TODO
    }
    /**
     * A callback which is executed when this instrument transitions from a power-off to power-on state.
     */
    onPowerOn() {
        this.isInstrumentPowered = true;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = true;
            if (old !== true) {
                this.onPowerChanged(true, old);
            }
        }
    }
    /**
     * A callback which is executed when this instrument transitions from a power-on to power-off state.
     */
    onPowerOff() {
        this.isInstrumentPowered = false;
        if (this.isPowerValid) {
            const old = this.isPowered;
            this.isPowered = false;
            if (old !== false) {
                this.onPowerChanged(false, old);
            }
        }
    }
    /**
     * Responds to when this instrument's power state changes.
     * @param current The current power state.
     * @param previous The previous power state, or `undefined` if the previous state was invalid.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onPowerChanged(current, previous) {
        //
    }
}

/**
 * The FmcPageFactory for the B748.
 */
class B748FmcPageFactory extends FmcPageFactory {
    /**
     * Ctor
     * @param fms the FMS
     */
    constructor(fms) {
        super();
        this.fms = fms;
    }
    /** @inheritDoc */
    createPage(pageCtor, bus, screen, renderCallback) {
        return new pageCtor(bus, screen, this.fms, renderCallback);
    }
}

/**
 * 787 FMC screen
 */
class B748FmcScreen extends BoeingFmcScreen {
    /**
     * Ctor
     * @param bus the event bus
     * @param cdu the cdu instance
     * @param fms the fms instance
     * @param cduScreen the cdu screen element
     */
    constructor(bus, cdu, fms, cduScreen) {
        super(bus, new B748FmcPageFactory(fms), {
            screenDimensions: {
                cellWidth: 24,
                cellHeight: 14,
            },
            textInputFieldDisallowedDeleteThrowValue: BoeingFmcErrorKeys.InvalidDelete,
            textInputFieldParseFailThrowValue: BoeingFmcErrorKeys.GenericInvalidEntry,
            enableScratchpad: true,
            eventPrefix: '',
        }, new SimpleFmcRenderer(bus, cduScreen, {
            screenPXWidth: 880,
            screenPXHeight: 800,
            screenCellWidth: 24,
            screenCellHeight: 14,
        }), new FmcScratchpad(bus, { cellWidth: 24 }, () => { }), fms);
        this.cdu = cdu;
        this.advisoryMessages = [];
        this.communicationsMessages = [];
        this.alertMessages = [];
        this.entryErrorAdvisoryMessages = [];
        this.alertMessageExists = Subject.create(false);
        this.scratchpadPub = this.bus.getPublisher();
        const sub = bus.getSubscriber();
        sub.on('post_message').handle(this.addScratchpadErrorMessage.bind(this));
        sub.on('clear_message').handle(this.clearScratchpadErrorMessage.bind(this));
        sub.on('clear_topmost_message_with_category').handle(this.clearTopmostScratchpadErrorMessageWithCategory.bind(this));
        // FMC MESSAGE
        CasAlertTransporter.create(this.bus, FmcCrewAlertIDs.FmcMessage, AnnunciationType.Advisory)
            .bind(this.alertMessageExists, (v) => v);
    }
    /**
     * Gets the index of the side this CDU is on.
     * @returns 1 if pilot side, 2 if co pilot side.
     */
    getSideIndex() {
        return this.cdu.cduSideIndex;
    }
    /**
     * Returns a facility (if applicable) given an ident. This presents a de-duplication screen to the user if needed.
     * @param ident the ident to use
     * @param referencePos The reference position to use to sort multiple matching facilities. Facilities are sorted
     * in order of increasing distance from the reference position.
     * @param filter the filter to apply to the facility search.
     * @param pickClosest whether to automatically return the closest facility in case multiple search results are found. otherwise,
     * the SELECT DESIRED XXX page is used.
     * @returns the facility or `null`
     */
    async selectWaypointByIdent(ident, referencePos, filter, pickClosest) {
        let facilityIcaos = await this.fms.facLoader.searchByIdent(filter !== null && filter !== void 0 ? filter : FacilitySearchType.All, ident);
        // Since searchByIdent returns fuzzy matches, we remove stuff that isn't exactly the ident we want
        facilityIcaos = facilityIcaos.filter((it) => ICAO.getIdent(it) === ident);
        if (facilityIcaos.length === 0) {
            return null;
        }
        const facilities = [];
        await Promise.all(facilityIcaos.map((it) => (this.fms.facLoader.getFacility(ICAO.getFacilityType(it), it).then((facility) => {
            if (facility) {
                facilities.push(facility);
            }
        }))));
        // Return the only result if there is only one exact match
        if (facilities.length === 1) {
            return facilities[0];
        }
        else if (facilities.length > 1) {
            facilities.sort((a, b) => referencePos.distance(a) - referencePos.distance(b));
        }
        else {
            return null;
        }
        if (pickClosest) {
            return facilities[0];
        }
        const initialRoute = this.currentRoute.get();
        const pageCount = this.currentSubpageCount.get();
        const initialPage = this.currentSubpageIndex.get();
        this.navigateTo('/select-wpt', { ident, facilities });
        const facility = await new Promise((resolve) => this.facilitySelectionResolveFn = resolve);
        if (pageCount > 1) {
            this.navigateTo(`${initialRoute.split('#')[0]}#${initialPage}`);
        }
        else {
            this.navigateTo(initialRoute);
        }
        return facility;
    }
    /**
     * Handles the CLR key being pressed
     */
    handleClearMessage() {
        let topMessageArray;
        if (this.entryErrorAdvisoryMessages.length > 0) {
            topMessageArray = this.entryErrorAdvisoryMessages;
        }
        else if (this.alertMessages.length > 0) {
            topMessageArray = this.alertMessages;
        }
        else if (this.communicationsMessages.length > 0) {
            topMessageArray = this.communicationsMessages;
        }
        else {
            topMessageArray = this.advisoryMessages;
        }
        if (topMessageArray.length > 0) {
            topMessageArray.pop();
        }
        this.refreshScratchpadMessageDisplay();
    }
    /**
     * Adds a scratchpad error message to the stack
     * @param packet The message package to add
     */
    addScratchpadErrorMessage(packet) {
        if (packet.targetCdu === 'any' || packet.targetCdu === this.getSideIndex()) {
            const category = BoeingFmcErrorKeysCategories[packet.key];
            packet.message.key = packet.key;
            const entry = packet.message;
            let array;
            switch (category) {
                case BoeingFmcErrorCategories.Advisory:
                    array = this.advisoryMessages;
                    break;
                case BoeingFmcErrorCategories.Communications:
                    array = this.communicationsMessages;
                    break;
                case BoeingFmcErrorCategories.Alert:
                    array = this.alertMessages;
                    break;
                case BoeingFmcErrorCategories.EntryErrorAdvisory:
                    array = this.entryErrorAdvisoryMessages;
                    break;
            }
            if (array) {
                this.addAndDeduplicateMessageToArray(entry, array);
            }
            this.refreshScratchpadMessageDisplay();
        }
    }
    /**
     * Clears a scratchpad error message
     * @param key Key of the message to clear
     */
    clearScratchpadErrorMessage(key) {
        const category = BoeingFmcErrorKeysCategories[key];
        let array;
        switch (category) {
            case BoeingFmcErrorCategories.Advisory:
                array = this.advisoryMessages;
                break;
            case BoeingFmcErrorCategories.Communications:
                array = this.communicationsMessages;
                break;
            case BoeingFmcErrorCategories.Alert:
                array = this.alertMessages;
                break;
            case BoeingFmcErrorCategories.EntryErrorAdvisory:
                array = this.entryErrorAdvisoryMessages;
                break;
        }
        if (array) {
            const existingIndex = array.findIndex((it) => it.key === key);
            if (existingIndex !== -1) {
                array.splice(existingIndex, 1);
            }
        }
        this.refreshScratchpadMessageDisplay();
    }
    /**
     * Clears the topmost message in the provided category
     *
     * @param category the category
     */
    clearTopmostScratchpadErrorMessageWithCategory(category) {
        let array;
        switch (category) {
            case BoeingFmcErrorCategories.Advisory:
                array = this.advisoryMessages;
                break;
            case BoeingFmcErrorCategories.Communications:
                array = this.communicationsMessages;
                break;
            case BoeingFmcErrorCategories.Alert:
                array = this.alertMessages;
                break;
            case BoeingFmcErrorCategories.EntryErrorAdvisory:
                array = this.entryErrorAdvisoryMessages;
                break;
        }
        if (array && array.length > 0) {
            array.pop();
            this.refreshScratchpadMessageDisplay();
        }
    }
    /**
     * Adds a scratchpad message entry to the stack, de-duplicating any existing messages with the same key (unless the key is Generic)
     *
     * @param message the scratchpad message entry
     * @param array the array
     */
    addAndDeduplicateMessageToArray(message, array) {
        const existingIndex = message.key !== BoeingFmcErrorKeys.Generic ? array.findIndex((it) => it.key === message.key) : -1;
        if (existingIndex !== -1) {
            array.splice(existingIndex, 1);
        }
        array.push(message);
    }
    /**
     * Refreshes the scratchpad message display
     */
    refreshScratchpadMessageDisplay() {
        let topMessageArray;
        if (this.entryErrorAdvisoryMessages.length > 0) {
            topMessageArray = this.entryErrorAdvisoryMessages;
        }
        else if (this.alertMessages.length > 0) {
            topMessageArray = this.alertMessages;
        }
        else if (this.communicationsMessages.length > 0) {
            topMessageArray = this.communicationsMessages;
        }
        else {
            topMessageArray = this.advisoryMessages;
        }
        if (topMessageArray.length > 0) {
            this.scratchpad.error(topMessageArray[topMessageArray.length - 1].body);
        }
        else {
            this.scratchpad.clearError();
        }
        this.alertMessageExists.set(this.alertMessages.length > 0);
    }
    /** @inheritDoc */
    clearScratchpad() {
        this.scratchpad.clear(false);
    }
    /** @inheritDoc */
    onLineSelectKeyError(error) {
        let key;
        let message;
        if (error in BoeingFmcErrorKeys && error !== BoeingFmcErrorKeys.Generic) {
            key = error;
            message = DefinedScratchpadMessages[error];
        }
        else if (typeof error === 'object') {
            console.error(error);
            return;
        }
        else {
            key = BoeingFmcErrorKeys.Generic;
            message = new ScratchpadMessage(true, error);
        }
        if (message !== undefined) {
            this.scratchpadPub.pub('post_message', { key, message, targetCdu: message.onlyOnside ? this.getSideIndex() : 'any' }, true);
            if (BoeingFmcErrorKeysCategories[key] === BoeingFmcErrorCategories.EntryErrorAdvisory) {
                setTimeout(() => this.scratchpadPub.pub('clear_topmost_message_with_category', BoeingFmcErrorCategories.EntryErrorAdvisory), 3000);
            }
        }
    }
}

/**
 * B748 XXXX ALTN page
 */
class B748AlternateDisplayPage extends BoeingAlternateDisplayPage {
}

/**
 * B748 ALTN list page
 */
class B748AlternateListPage extends BoeingAlternateListPage {
    constructor() {
        super(...arguments);
        /** @inheritDoc */
        this.altnRequestHeaderString = ' REQUEST[disabled]';
        /** @inheritDoc */
        this.altnRequestLinkString = '<SEND[disabled]';
        /** @inheritDoc */
        this.weatherRequestHeaderString = ' WXR REQUEST[disabled]';
        /** @inheritDoc */
        this.weatherRequestLinkString = '<SEND[disabled]';
    }
    /** @inheritDoc */
    getAlternateNullValueString() {
        return '----     ----z   --.-   ';
    }
    /** @inheritDoc */
    getAlternateFormattedString(identStr, etaStr, fobStr) {
        return `${identStr}     ${etaStr}  ${fobStr}  >`;
    }
}

/** A 748 APPROACH REF page. */
class B748ApproachRefPage extends BoeingApproachRefPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, new B748SpeedData(bus), false, 50, [25, 30]);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
}

/** B748 cdu common constants and functions. */
class B748CduCommon {
}
B748CduCommon.flightNumberMinLength = 2;
B748CduCommon.flightNumberMaxLength = 8;

/**
 * A 748 FMC page
 */
class B748FmcPage extends BoeingFmcPage {
}

/**
 * ATC Page
 */
class B748AtcPage extends B748FmcPage {
    constructor() {
        super(...arguments);
        this.tailIdSub = Subject.create(SimVar.GetSimVarValue('ATC ID', SimVarValueType.String));
        this.perfPlan = this.fms.performancePlanProxy;
        this.TailIdField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: tailId => tailId
            },
            onSelected: async () => this.tailIdSub.get(),
        }).bind(this.tailIdSub);
        this.OriginField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (icao) => icao === null ? '' : `${ICAO.getIdent(icao)} `,
            },
            onSelected: async () => {
                const airportIcao = this.perfPlan.takeoffAirportIcao.get();
                return airportIcao === null ? true : ICAO.getIdent(airportIcao);
            }
        }).bind(this.perfPlan.takeoffAirportIcao);
        this.DestField = new DisplayField(this, {
            formatter: {
                nullValueString: '',
                format: (icao) => icao === null ? '' : `${ICAO.getIdent(icao)} `,
            },
            onSelected: async () => {
                const airportIcao = this.perfPlan.approachAirportIcao.get();
                return airportIcao === null ? true : ICAO.getIdent(airportIcao);
            }
        }).bind(this.perfPlan.approachAirportIcao);
        this.FltNoInput = BoeingFmcComponentFactory.createFlightNumberTextInputField(this, B748CduCommon.flightNumberMinLength, B748CduCommon.flightNumberMaxLength, CockpitUserSettings.getManager(this.bus).getSetting('fltNumber'), false).bind(CockpitUserSettings.getManager(this.bus).getSetting('fltNumber'));
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '1/1[s-text] ', 'ATC LOGON/STATUS '],
                [' LOGON TO[s-text disabled]'],
                ['--------[disabled]'],
                [' FLT NO[s-text]', 'ORIGIN[s-text] '],
                [this.FltNoInput, this.OriginField],
                [' TAIL NO[s-text]', 'DESTINATION[s-text] '],
                [this.TailIdField, this.DestField],
                [' MAX U/L DELAY[s-text disabled]', 'ACT CTR[s-text disabled] '],
                ['---SEC[s-text disabled]', '----[disabled] '],
                [' ATC COMM[s-text disabled]', 'NEXT CTR[s-text disabled] '],
                ['', '----[disabled] '],
                ['-------------[disabled]', 'DATA LINK[s-text disabled] '],
                ['<ATC INDEX[disabled]', 'NO COMM[disabled] '],
            ]
        ];
    }
}

/**
 * Dep Arr Page
 */
class B748DepArrPage extends B748FmcPage {
    constructor() {
        super(...arguments);
        this.store = new BoeingDepArrPageStore();
        this.controller = new BoeingDepArrPageController(this.bus, this.fms, this.store, this);
        this.PrimaryOriginDeparture = new DisplayField(this, {
            formatter: new SimpleStringFormat('<DEP'),
            onSelected: async () => {
                if (this.fms.facilityInfo.originFacility) {
                    this.controller.displayDeparture();
                    return true;
                }
                return false;
            },
        });
        this.PrimaryDestinationArrival = new DisplayField(this, {
            formatter: new SimpleStringFormat('ARR>'),
            onSelected: async () => {
                if (this.fms.facilityInfo.destinationFacility) {
                    this.controller.displayArrival();
                    return true;
                }
                return false;
            },
        });
        this.primaryOrigin = new DisplayField(this, {
            formatter: IcaoIdentFormatter,
        });
        this.primaryDestination = new DisplayField(this, {
            formatter: IcaoIdentFormatter,
        });
    }
    /** @inheritDoc */
    isHudTakeoffAvailable() {
        return false;
    }
    /** @inheritDoc */
    getTitleDeparturesLeftPadding() {
        return 3;
    }
    /** @inheritDoc */
    getTitleArrivalsLeftPadding() {
        return 3;
    }
    /** @inheritDoc */
    getLeftColumnRightPadding() {
        return 6;
    }
    /** @inheritDoc */
    getRightColumnLeftPadding() {
        return 7;
    }
    /** @inheritDoc */
    onInit() {
        this.primaryOrigin.bind(this.store.origin);
        this.primaryDestination.bind(this.store.destination);
        this.controller.currentView.sub((view) => {
            this.changePage(view);
        });
    }
    /** @inheritDoc */
    onPause() {
        this.controller.destroy();
    }
    /** @inheritDoc */
    onResume() {
        this.controller.init();
    }
    /** @inheritDoc */
    onPageButtonPressed() {
        this.controller.currentView.set(DepArrView.INDEX);
    }
    /**
     * Method to Update When Changing Pages
     * @param view The new view
     */
    changePage(view) {
        if (view !== DepArrView.INDEX) {
            this.store.loadCurrentProcedureData(this.fms, this.controller.currentView.get());
        }
        this.invalidate();
    }
    /** @inheritDoc */
    render() {
        switch (this.controller.currentView.get()) {
            case DepArrView.INDEX:
                return [this.getIndexTemplate()];
            case DepArrView.ARR:
            case DepArrView.DEP:
                return [this.controller.renderDepArrTemplate(1)];
        }
    }
    /**
     * Handles paging for the dep/arr page
     * @param event The FmcPrevNextEvent
     * @returns whether this was handled.
     */
    async onHandleScrolling(event) {
        if (this.controller.currentView.get() !== DepArrView.INDEX) {
            const currentPage = this.controller.currentPage.get();
            const pageCount = this.controller.pageCount.get();
            if (event === 'pageRight') {
                if (currentPage < pageCount) {
                    this.controller.currentPage.set(currentPage + 1);
                }
                else {
                    this.controller.currentPage.set(1);
                }
            }
            else if (event === 'pageLeft') {
                if (currentPage > 1) {
                    this.controller.currentPage.set(currentPage - 1);
                }
                else {
                    this.controller.currentPage.set(pageCount);
                }
            }
        }
        return true;
    }
    /**
     * Returns the Index template
     * @returns the Index Template
     */
    getIndexTemplate() {
        return [
            ['', '', ' DEP/ARR INDEX'],
            ['', '', 'RTE 1  '],
            [this.PrimaryOriginDeparture, 'ARR>[disabled]', this.primaryOrigin],
            ['', ''],
            ['', this.PrimaryDestinationArrival, this.primaryDestination],
            ['--------RTE 2 -----------'],
            ['', ''],
            ['', ''],
            ['', ''],
            ['--------------------------'],
            ['', ''],
            [' DEP[disabled]', 'ARR[disabled] ', 'OTHER[disabled] '],
            [`<[disabled d-text]${inputBox('----[disabled]')}`, `${inputBox('----[disabled]')}>[disabled]`],
        ];
    }
}

/** A 748 DESCENT FORECAST page. */
class B748DescentForecastPage extends BoeingDescentForecastPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, 4, 1, 'TAI ON/OFF', '-----/-----', '--- FORECAST UPLINK ----');
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
    /** @inheritDoc */
    windAltTempFormatter(transitionAlt) {
        return {
            parse: (input) => {
                const alt = B787FmcParsers.Altitude(input);
                if (alt === null) {
                    return null;
                }
                return [alt, null];
            },
            nullValueString: '-----',
            format: (record) => {
                const altFormatter = B787FmcFormatters.Altitude('display', transitionAlt);
                return (record === null || record === void 0 ? void 0 : record.altitude) ? altFormatter(record.altitude) : '-----';
            },
        };
    }
}

/**
 * The 747-8 FIX INFO page.
 */
class B748FixInfoPage extends BaseBoeingFixInfoPage {
    /** @inheritdoc */
    getDtgEtaAltSeparator() {
        return '    ';
    }
    /** @inheritdoc */
    getFixBearingDistSuffix() {
        return '  ';
    }
    /** @inheritdoc */
    getEtaDtgAltitudeFormatter() {
        if (!this.etaDtgAltitudeFormatter) {
            this.etaDtgAltitudeFormatter = new B748EtaDtgAltitudeFormatter(this.controller.transitionAltitudeOrLevel);
        }
        return this.etaDtgAltitudeFormatter;
    }
    /** @inheritDoc */
    render() {
        const fixEntered = this.store.currentFixIdent.get() !== null;
        const abeamAvailable = fixEntered && this.store.activeRouteExists.get() && this.store.currentFixIsDatabaseItem.get();
        return [
            [
                ['', this.FixInfoPagingIndicator, 'FIX INFO'],
                [' FIX', 'BRG/DIS FR'],
                [this.FixField, this.FixBrgDistField],
                [' BRG/DIS', 'ETA  DTG   ALT'],
                [fixEntered ? this.BrgDistFields[0] : '', this.EtaDtgAltFields[0]],
                [''],
                [fixEntered ? this.BrgDistFields[1] : '', this.EtaDtgAltFields[1]],
                [''],
                [fixEntered ? this.BrgDistFields[2] : '', this.EtaDtgAltFields[2]],
                [this.store.currentAbeamPointCalculated ? ' ABEAM' : ''],
                [abeamAvailable ? this.AbeamField : '', this.AbeamEtaDtgAltField],
                ['', 'PRED ETA-ALT '],
                [this.EraseFixField, this.store.activeRouteExists.get() ? this.PredictedDtgEtaAltField : ''],
            ],
        ];
    }
}
/** Format for eta/dtg/alt predictions */
class B748EtaDtgAltitudeFormatter {
    /** @inheritDoc */
    constructor(transitionAltitudeOrLevel) {
        this.transitionAltitudeOrLevel = transitionAltitudeOrLevel;
        this.altitudeDisplayFormatter = B787FmcFormatters.Altitude('display', this.transitionAltitudeOrLevel);
        this.timeDisplayFormatter = B787FmcFormatters.UtcTime('display', '');
        this.nullValueString = '';
    }
    /** @inheritDoc */
    format([eta, dtg, altitude]) {
        if (dtg === null) {
            return this.nullValueString;
        }
        if (eta === null || altitude === null) {
            return `${Math.min(9999, dtg).toFixed(0).padStart(4)}[d-text]      [s-text]`;
        }
        return `${this.timeDisplayFormatter(eta)} ${Math.min(9999, dtg).toFixed(0).padStart(4)}[d-text] ${this.altitudeDisplayFormatter(altitude)}[s-text]`;
    }
}

/**
 * The 787 FMC COMM page
 */
class B748FmcCommPage extends BoeingFmcCommPage {
    /** @inheritDoc */
    ClbForecastLink() {
        return '';
    }
}

/** The 748 HOLD page. */
class B748HoldPage extends BoeingHoldPage {
    /**
     * Returns formatted title string for the B748 FMC Hold page
     * @param planInMod Whether the plan is in MOD status
     * @param routeNumber The route number (1 or 2)
     * @returns The title string
     */
    getTitleLineString(planInMod, routeNumber) {
        return `  [d-text]${(planInMod ? 'MOD[r-white]' : 'ACT')} RTE ${routeNumber} HOLD`;
    }
}

/** The 748 IDENT page. */
class B748IdentPage extends BoeingIdentPage {
    /** @inheritdoc */
    getAircraftModel() {
        return '747-8I';
    }
    /** @inheritdoc */
    getNavDataDisplayContent() {
        return 'WT10407001';
    }
    /** @inheritdoc */
    getActiveDateDisplayTitle() {
        return 'ACTIVE';
    }
    /** @inheritdoc */
    getEngineDisplayTitle() {
        return 'ENGINES';
    }
    /** @inheritdoc */
    getEngineDisplayContent() {
        return 'GENX-2B67/P';
    }
    /** @inheritdoc */
    getOpProgramDisplayTitle() {
        return ' OP PROGRAM';
    }
    /** @inheritdoc */
    getOpProgramDisplayContent() {
        return 'WT748 v0.1.9';
    }
}

/**
 * INDEX Page
 */
class B748InitRefPage extends B748FmcPage {
    constructor() {
        super(...arguments);
        this.IdentLink = PageLinkField.createLink(this, '<IDENT', '/ident');
        this.NavDataLink = PageLinkField.createLink(this, 'NAV DATA>', '/nav-data');
        this.PosRefLink = PageLinkField.createLink(this, '<POS', '/pos-init');
        this.AltnLink = PageLinkField.createLink(this, 'ALTN>', '/altn');
        this.PerfInitLink = PageLinkField.createLink(this, '<PERF', '/perf-init');
        this.ThrustLimLink = PageLinkField.createLink(this, '<THRUST LIM', '/thrust-lim');
        this.TakeoffRefLink = PageLinkField.createLink(this, '<TAKEOFF', '/takeoff-ref');
        this.ApproachRefLink = PageLinkField.createLink(this, '<APPROACH', '/approach-ref');
        this.SettingsLink = PageLinkField.createLink(this, 'SETTINGS>', '/settings');
        this.FmcCommLink = PageLinkField.createLink(this, 'FMC COMM>', '/fmc-comm');
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'INIT/REF INDEX '],
                [''],
                [this.IdentLink, this.NavDataLink],
                [''],
                [this.PosRefLink, this.AltnLink],
                [''],
                [this.PerfInitLink, this.FmcCommLink],
                [''],
                [this.ThrustLimLink],
                [''],
                [this.TakeoffRefLink],
                [''],
                [this.ApproachRefLink, this.SettingsLink],
            ]
        ];
    }
}

const mapSettings = [
    {
        name: 'mapFormatMFD_1',
        defaultValue: 'MAP'
    },
    {
        name: 'mapFormatMFD_2',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRangePFD_1',
        defaultValue: 20
    },
    {
        name: 'mapRangeMFD_1',
        defaultValue: 10
    },
    {
        name: 'mapRangeMFD_2',
        defaultValue: 10
    },
    {
        name: 'tfcEnabledPFD',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_1',
        defaultValue: false
    },
    {
        name: 'tfcEnabledMFD_2',
        defaultValue: false
    },
    {
        name: 'terrWxStatePFD',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_1',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxStateMFD_2',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxContrastMFD_1',
        defaultValue: 1,
    },
    {
        name: 'terrWxContrastMFD_2',
        defaultValue: 1,
    },
    {
        name: 'mapWaypointsDisplayPFD',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_1',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapWaypointsDisplayMFD_2',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'navAidLeftStateMFD_1',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidLeftStateMFD_2',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightStateMFD_1',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightStateMFD_2',
        defaultValue: 'VOR'
    },
    {
        name: 'mapPosShowPFD',
        defaultValue: false
    },
    {
        name: 'mapPosShowMFD_1',
        defaultValue: false
    },
    {
        name: 'mapPosShowMFD_2',
        defaultValue: false
    }
];
const mapSettingsPfdAliased = [
    {
        name: 'mapRange',
        defaultValue: 20
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'mapPosShow',
        defaultValue: false
    }
];
const mapSettingsMfdAliased = [
    {
        name: 'mapFormat',
        defaultValue: 'MAP'
    },
    {
        name: 'mapRange',
        defaultValue: 10
    },
    {
        name: 'tfcEnabled',
        defaultValue: false
    },
    {
        name: 'terrWxState',
        defaultValue: 'OFF'
    },
    {
        name: 'terrWxContrast',
        defaultValue: 1,
    },
    {
        name: 'mapWaypointsDisplay',
        defaultValue: MapWaypointsDisplay.MissedApproach
    },
    {
        name: 'navAidLeftState',
        defaultValue: 'VOR'
    },
    {
        name: 'navAidRightState',
        defaultValue: 'VOR'
    },
    {
        name: 'mapPosShow',
        defaultValue: false
    }
];
/** Utility class for retrieving map user setting managers. */
class MapUserSettings {
    /**
     * Retrieves a setting manager with all map user settings.
     * @param bus The event bus.
     * @returns A setting manager with all map user settings.
     */
    static getMasterManager(bus) {
        var _a;
        return (_a = MapUserSettings.INSTANCE_MASTER) !== null && _a !== void 0 ? _a : (MapUserSettings.INSTANCE_MASTER = new DefaultUserSettingManager(bus, mapSettings));
    }
    /* eslint-enable jsdoc/require-jsdoc */
    /**
     * Retrieves a setting manager with aliased map user settings specific to the PFD or MFD.
     * @param bus The event bus.
     * @param pfdOrMfd Whether to get the PFD or MFD setting manager.
     * @param index The map side index.
     * @returns A setting manager with aliased map user settings specific to the PFD or MFD.
     */
    static getAliasedManager(bus, pfdOrMfd, index) {
        return (pfdOrMfd === 'PFD' ? MapUserSettings.getPfdManager(bus) : MapUserSettings.getMfdManager(bus, index));
    }
    /**
     * Retrieves a setting manager with aliased PFD map user settings.
     * @param bus The event bus.
     * @returns A setting manager with aliased PFD map user settings.
     */
    static getPfdManager(bus) {
        if (MapUserSettings.INSTANCE_PFD === undefined) {
            MapUserSettings.INSTANCE_PFD = new AliasedUserSettingManager(bus, mapSettingsPfdAliased);
            MapUserSettings.INSTANCE_PFD.useAliases(MapUserSettings.getMasterManager(bus), {
                tfcEnabled: 'tfcEnabledPFD',
                terrWxState: 'terrWxStatePFD',
                mapWaypointsDisplay: 'mapWaypointsDisplayPFD',
                mapRange: 'mapRangePFD_1',
                mapPosShow: 'mapPosShowPFD',
            });
        }
        return MapUserSettings.INSTANCE_PFD;
    }
    /**
     * Retrieves a setting manager with aliased MFD map user settings.
     * @param bus The event bus.
     * @param index The MFD side index.
     * @returns A setting manager with aliased MFD map user settings.
     */
    static getMfdManager(bus, index) {
        if (MapUserSettings.INSTANCES_MFD[index] === undefined) {
            MapUserSettings.INSTANCES_MFD[index] = new AliasedUserSettingManager(bus, mapSettingsMfdAliased);
            MapUserSettings.INSTANCES_MFD[index].useAliases(MapUserSettings.getMasterManager(bus), {
                mapFormat: `mapFormatMFD_${index}`,
                tfcEnabled: `tfcEnabledMFD_${index}`,
                terrWxState: `terrWxStateMFD_${index}`,
                terrWxContrast: `terrWxContrastMFD_${index}`,
                mapWaypointsDisplay: `mapWaypointsDisplayMFD_${index}`,
                mapRange: `mapRangeMFD_${index}`,
                navAidLeftState: `navAidLeftStateMFD_${index}`,
                navAidRightState: `navAidRightStateMFD_${index}`,
                mapPosShow: `mapPosShowMFD_${index}`,
            });
        }
        return MapUserSettings.INSTANCES_MFD[index];
    }
}
MapUserSettings.INSTANCES_MFD = [];
MapUserSettings.mapFormatsMFD = ['MAP', 'MAPCTR', 'VOR', 'VORCTR', 'APP', 'APPCTR', 'PLAN'];
MapUserSettings.terrWxStates = ['OFF', 'TERR', 'WX'];
MapUserSettings.mapRanges = [0.25, 0.5, 1, 2, 5, 10, 20, 40, 80, 160, 320, 640, 1280];

/**
 * LEGS page
 */
class B748LegsPage extends BoeingLegsPage {
    constructor() {
        super(...arguments);
        this.mapSettings = MapUserSettings.getAliasedManager(this.bus, 'MFD', this.screen.getSideIndex());
    }
    /** @inheritDoc */
    getDiscontinuityLineString() {
        return '-- ROUTE DISCONTINUITY -';
    }
    /** @inheritDoc */
    getRouteHeaderString(isActive, isMod, routeNumber) {
        if (isMod) {
            return `  [white]MOD[r-white] RTE ${routeNumber} LEGS       `;
        }
        else {
            if (isActive) {
                return `  ACT RTE ${routeNumber} LEGS        `;
            }
            else {
                return `  RTE ${routeNumber} LEGS[cyan]            `;
            }
        }
    }
    /** @inheritDoc */
    getCtrString() {
        return ' <CTR>';
    }
    /** @inheritDoc */
    getBlankFooter() {
        return '------------------------';
    }
    /** @inheritDoc */
    getHoldAtFooter() {
        return '--------HOLD AT---------';
    }
    /** @inheritDoc */
    getIntcCrsFooter() {
        return '-------------INTC CRS TO';
    }
    /** @inheritDoc */
    shouldPadConstraintsString() {
        return false;
    }
    /** @inheritDoc */
    getAnnotationRowLeftPadding() {
        return 4;
    }
    /** @inheritDoc */
    planFormatActiveSub() {
        return this.mapSettings.getSetting('mapFormat').map((it) => it === 'PLAN');
    }
}

/**
 * A 748 maint page
 */
class B748MaintPage extends BoeingVnavDebugPage {
}

/**
 * MENU page
 */
class B748MenuPage extends B748FmcPage {
    constructor() {
        super(...arguments);
        this.fmcPageLink = PageLinkField.createLink(this, '<FMC', '/ident');
        this.settingsPageLink = PageLinkField.createLink(this, 'SETTINGS>', '/settings');
    }
    /** @inheritDoc */
    render() {
        return [
            [
                ['', '', 'MENU'],
                ['', 'EFIS CP[disabled]'],
                [this.fmcPageLink, '', ''],
                ['', 'DSP CTL[disabled]'],
                ['', '', ''],
                ['', 'CTL PNL[disabled]'],
                ['<SATCOM[disabled]', 'OFF[l-text][disabled]←→[l-text][disabled]ON>[s-text][disabled]', ''],
                ['', ''],
                ['', 'PA/CI>[disabled]', ''],
                ['', ''],
                ['<ACMS[disabled]', '', ''],
                ['', ''],
                ['<CMC[disabled]', this.settingsPageLink, ''],
            ]
        ];
    }
}

/**
 * The 748 NAV RADIO page.
 */
class B748NavRadioPage extends BoeingNavRadPage {
    /** @inheritdoc */
    getTitleIlsGls() {
        return ' ILS';
    }
    /** @inheritdoc */
    getFormattedParkText() {
        return 'PARK';
    }
    /** @inheritdoc */
    getFormattedEmptyCrsField() {
        return inputBox('');
    }
}

/** A B748 Performance Initialization Page */
class B748PerfInitPage extends BoeingPerfInitPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, 'MIN FUEL TEMP', ' REQUEST[disabled]', '<SEND[disabled]', () => ['-'.repeat(24)]);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
}

/// <reference types="@microsoft/msfs-types/JS/common" />
/** The 748 POS REF page. */
class B748PosRefPage extends BoeingPosRefPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, {
            refAirportPosPlaceholderAsBlank: true,
            utcFieldTitle: ' UTC(GPS)',
            zuluTimeSuffix: 'z',
            inertPosHeaderText: 'SET IRS POS',
            inertPosHasInputBox: false,
            fmcPosFieldTitle: ' FMC (GPS L)',
            updateArmFieldTitle: 'UPDATE',
            irsFieldTitle: ' IRS (3)',
            gpsFieldTitle: ' GPS',
            radioFieldTitle: ' RADIO',
            irsFieldContent: '---°/-.--[d-text]NM[s-text]',
            gpsFieldContent: '---°/-.--[d-text]NM[s-text]',
            radioFieldContent: '--- --- ',
            numberOfIRUs: 3,
        });
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
        this.L6LinkButton = PageLinkField.createLink(this, '<INDEX', '/init-ref');
        this.R5LinkButton = PageLinkField.createLink(this, 'NAV OPTIONS>', '/nav-options');
    }
    /** @inheritdoc */
    getPosRef24L6R6Row() {
        return [this.L6LinkButton, 'LAT/LON>'];
    }
    /** @inheritdoc */
    getPosRef34Page() {
        return [
            [' GPS L', ''],
            ['000/0.0NM[s-text]', ''],
            [' GPS R', ''],
            ['000/0.0NM[s-text]', ''],
            [' FMC L', ''],
            ['000/0.0NM[s-text]', ''],
            [' FMC R', ''],
            ['000/0.0NM[s-text]', ''],
            ['', ''],
            ['', this.R5LinkButton],
            ['------------------------'],
            [this.L6LinkButton, 'LAT/LON>'],
        ];
    }
    /** @inheritdoc */
    getPosRef44Page() {
        return [
            [' IRS L', 'GS'],
            ['<000°/0.0[d-text]NM[s-text]', ' --[d-text]KT[s-text]'],
            [' IRS C', ''],
            ['<000°/0.0[d-text]NM[s-text]', ' --[d-text]KT[s-text]'],
            [' IRS R', ''],
            ['<000°/0.0[d-text]NM[s-text]', ' --[d-text]KT[s-text]'],
            ['', ''],
            ['', ''],
            ['', ''],
            ['', ''],
            ['------------------------'],
            [this.L6LinkButton, 'LAT/LON>'],
        ];
    }
}

/**
 * B748 PROG Page
 */
class B748ProgPage extends BoeingProgPage {
    /** @inheritDoc */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getPredictionsNullValueString(doShowIdent) {
        return '';
    }
    /** @inheritDoc */
    getPredictionsFormattedString(doShowIdent, identStr, dtgStr, etaStr, fuelStr) {
        return `${doShowIdent ? identStr : ''} ${dtgStr} ${etaStr} ${fuelStr}`;
    }
    /** @inheritDoc */
    getPredictionsHeaderString() {
        return ' TO      DTG  ETA   FUEL';
    }
    /** @inheritDoc */
    getRnpFooterString() {
        return 'RNP-- APPROACH--VERT RNP';
    }
}

/** The 748 REF NAV DATA page. */
class B748RefNavDataPage extends BoeingRefNavDataPage {
    /** @inheritdoc */
    getIsShowNavIdInhibit() {
        return false;
    }
    /** @inheritdoc */
    getIsShowVorOnlyInhibit() {
        return false;
    }
    /** @inheritdoc */
    getR6Button() {
        return PageLinkField.createLink(this, 'NAV OPTIONS>', '/nav-options');
    }
}

/** The RTE DATA page. Displays ETA, FUEL level at the ETA, and links to WIND data of each waypoint. */
class B748RteDataPage extends BoeingRteDataPage {
    constructor() {
        super(...arguments);
        this.activeHeaderString = '  ACT RTE 1 DATA';
        this.modHeaderString = '  MOD[r-white] RTE 1 DATA';
        this.inactiveHeaderString = '      RTE 1 DATA[cyan]';
        this.renderTitleOnLeftSide = true;
    }
    /** @inheritdoc */
    getMapSettings() {
        return MapUserSettings.getAliasedManager(this.bus, 'MFD', this.screen.getSideIndex());
    }
    /** @inheritdoc */
    getIsDiscontinuityLegsHidden() {
        return false;
    }
    /** @inheritdoc */
    getFuelWindHeaderString() {
        return '    WPT   FUEL  ';
    }
    /** @inheritdoc */
    getDiscontinuityLineString() {
        return '-- ROUTE DISCONTINUITY -';
    }
    /** @inheritdoc */
    getBottomSeparatorLineString() {
        return '----------------[white] REQUEST[disabled]';
    }
    /** @inheritdoc */
    getR6ButtonNameString() {
        return 'SEND>[disabled]';
    }
    /** @inheritdoc */
    getWptPadEnd() {
        return 8;
    }
    /** @inheritdoc */
    getWptPadLeft() {
        return 1;
    }
}

/** The 748 RTE page. */
class B748RtePage extends BoeingRtePage {
    /** @inheritdoc */
    getRenderPageTitleRowWith2Columns() {
        return true;
    }
    /** @inheritdoc */
    getPlanInModPageTitle() {
        return '  [white]MOD[r-white] RTE 1';
    }
    /** @inheritdoc */
    getRteInactivatedPageTitle() {
        return '      RTE 1[cyan]';
    }
    /** @inheritdoc */
    getRteActivatedPageTitle() {
        return '  ACT RTE 1';
    }
    /** @inheritdoc */
    getSeparatorLineString() {
        return '------------------------';
    }
    /** @inheritdoc */
    getIsCorouteFieldDisabled() {
        return true;
    }
    /** @inheritdoc */
    getCorouteFieldTitle() {
        return 'CO ROUTE[disabled]';
    }
    /** @inheritdoc */
    getCorouteFieldPlaceholderContent() {
        return '----------[disabled]';
    }
    /** @inheritdoc */
    getDiscontinuityLineString() {
        return '--ROUTE DISCONTINUITY---';
    }
    /** @inheritdoc */
    getFlightNumberMinLength() {
        return B748CduCommon.flightNumberMinLength;
    }
    /** @inheritdoc */
    getFlightNumberMaxLength() {
        return B748CduCommon.flightNumberMaxLength;
    }
    /** @inheritdoc */
    useInputBox() {
        return false;
    }
}

const SELECT_WPT_PAGE_LENGTH = 5;
/**
 * The 747-8 SELECT WPT page.
 */
class B748SelectWaypointPage extends B748FmcPage {
    constructor() {
        super(...arguments);
        this.dmsFormatter = new DmsFormatter();
    }
    /**
     * Gets the facilities from the params
     *
     * @returns an array of facilities
     */
    get facilities() {
        return this.params.get('facilities');
    }
    /** @inheritDoc */
    render() {
        const numPages = Math.ceil(this.facilities.length / SELECT_WPT_PAGE_LENGTH);
        const pages = [];
        for (let i = 0; i < numPages; i++) {
            const offset = SELECT_WPT_PAGE_LENGTH * i;
            const page = [
                ['', '', 'SELECT DESIRED WPT'],
            ];
            for (let j = 0; j < SELECT_WPT_PAGE_LENGTH; j++) {
                const facility = (this.facilities)[offset + j];
                if (facility) {
                    const facilityTypeStr = BoeingFmsUtils.formatFacilityType(facility).padEnd(8, ' ');
                    let frequencyStr = '';
                    if (FacilityUtils.isFacilityType(facility, FacilityType.VOR) || FacilityUtils.isFacilityType(facility, FacilityType.NDB)) {
                        frequencyStr = facility.freqMHz.toFixed(1);
                    }
                    const facilityNameStr = ICAO.getIdent(facility.icao);
                    const latStr = this.dmsFormatter.getLatDmsStr(facility.lat, false, false, 1, 2);
                    const lonStr = this.dmsFormatter.getLonDmsStr(facility.lon, false, 1, 2);
                    page.push([` ${facilityNameStr} ${facilityTypeStr}`], [frequencyStr, `${latStr} ${lonStr}`]);
                }
                else {
                    break;
                }
            }
            while (page.length < 14) {
                page.push(['']);
            }
            pages.push(page);
        }
        return pages;
    }
    /** @inheritDoc */
    async onHandleSelectKey(event) {
        const index = this.rowToLsk(event.row);
        const currentPageIndex = this.screen.currentSubpageIndex.get() - 1;
        const offset = SELECT_WPT_PAGE_LENGTH * currentPageIndex;
        const matchingFacility = this.facilities[offset + (index - 1)];
        if (matchingFacility) {
            this.screen.facilitySelectionResolveFn(matchingFacility);
            return true;
        }
        return super.onHandleSelectKey(event);
    }
}

/** SETTINGS page */
class B748SettingsPage extends BoeingSettingsPage {
}

/* eslint-disable max-len */
/**
 * V-Speed data for the B747-8i.
 */
class B748VSpeedData {
    /** @inheritDoc */
    getVSpeed(weight, pressAlt, temperature, flaps, slope, headwind, takeoffThrustMode, isRwyWet) {
        // TODO WET tables
        let vSpeedsTable;
        let altTempAdjustmentsTable;
        const slopeAdjustmentsTable = B748VSpeedData.MAX_TO_DRY_SLOPE_ADJUST;
        const windAdjustmentsTable = B748VSpeedData.MAX_TO_DRY_WIND_ADJUST;
        let v1McgTable;
        let vrMinTable;
        let v2MinTable;
        // TAKEOFF REF page FLAPS field only allow flaps 10 or 20
        if (flaps === 10) {
            vSpeedsTable = B748VSpeedData.MAX_TO_DRY_FLAPS_10_VSPEEDS_TABLE;
            altTempAdjustmentsTable = B748VSpeedData.MAX_TO_DRY_FLAPS_10_VSPEED_ADJUSTMENTS_TABLE;
            v1McgTable = B748VSpeedData.MAX_TO_DRY_FLAPS_10_V1MCG_TABLE;
            vrMinTable = B748VSpeedData.MAX_TO_DRY_FLAPS_10_MINIMUM_VR;
            v2MinTable = B748VSpeedData.MAX_TO_DRY_FLAPS_10_MINIMUM_V2;
        }
        else {
            // Flaps 20
            vSpeedsTable = B748VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEEDS_TABLE;
            altTempAdjustmentsTable = B748VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEED_ADJUSTMENTS_TABLE;
            v1McgTable = B748VSpeedData.MAX_TO_DRY_FLAPS_20_V1MCG_TABLE;
            vrMinTable = B748VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_VR;
            v2MinTable = B748VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_V2;
        }
        //     1. Determine V1, VR, and V2 from the Takeoff Speeds table (Table 1) with brake release weight.
        const vSpeeds = B748VSpeedData.mapValuesToSpeedType(vSpeedsTable.get(B748VSpeedData.TMP_DATA, weight));
        const adjustments = B748VSpeedData.mapValuesToSpeedType(altTempAdjustmentsTable.get(B748VSpeedData.TMP_DATA, pressAlt, temperature));
        let thrustReduction;
        switch (takeoffThrustMode) {
            case TakeoffThrustMode.TO:
            case TakeoffThrustMode.DTO:
                thrustReduction = 0;
                break;
            case TakeoffThrustMode.TO1:
            case TakeoffThrustMode.DTO1:
                thrustReduction = 1;
                break;
            case TakeoffThrustMode.TO2:
            case TakeoffThrustMode.DTO2:
                thrustReduction = 2;
                break;
        }
        let v1Modifier = isRwyWet ? -9 : 0;
        v1Modifier += 2 * thrustReduction;
        vSpeeds[VSpeedType.V1] += v1Modifier;
        const vrModifier = 1 * thrustReduction;
        vSpeeds[VSpeedType.Vr] += vrModifier;
        const v2Modifier = 1 * thrustReduction;
        vSpeeds[VSpeedType.V2] += v2Modifier;
        // 2. Adjust V1, VR, and V2 for temperature and pressure altitude from the V1, VR, V2 Adjustments table (Table 2).
        for (const key in vSpeeds) {
            // apply adjustments
            const adjustedKey = key;
            vSpeeds[adjustedKey] += adjustments[adjustedKey];
        }
        // 3. Adjust V1 for wind and slope from the Slope and Wind V1 Adjustments table (Table 3).
        vSpeeds[VSpeedType.V1] += slopeAdjustmentsTable.get(weight, slope);
        vSpeeds[VSpeedType.V1] += windAdjustmentsTable.get(weight, -(headwind));
        // Make sure v1 is <= vr
        if (vSpeeds[VSpeedType.V1] > vSpeeds[VSpeedType.Vr]) {
            vSpeeds[VSpeedType.V1] = vSpeeds[VSpeedType.Vr];
        }
        // Make sure v2 is >= vr
        if (vSpeeds[VSpeedType.V2] < vSpeeds[VSpeedType.Vr]) {
            vSpeeds[VSpeedType.V2] = vSpeeds[VSpeedType.Vr];
        }
        // 4. Determine the V1(MCG) from the V1(MCG) table (Table 4).
        const v1Mcg = v1McgTable.get(temperature, pressAlt);
        // 5. If V1 from Step 3 is less than V1(MCG), set V1=V1(MCG).
        if (vSpeeds[VSpeedType.V1] < v1Mcg) {
            vSpeeds[VSpeedType.V1] = v1Mcg;
        }
        // 6. Determine Minimum VR (MIN VR) from the Minimum VR table (Table 4).
        const minVr = vrMinTable.get(temperature, pressAlt);
        // 7. Using (MIN VR from Step (6), determine Minimum V2 (MIN V2) from the Minimum V2 table (Table 5).
        const minV2 = v2MinTable.get(weight, minVr);
        // 8. If VR from Step 2 is less than MIN VR, set VR=MIN VR.
        if (vSpeeds[VSpeedType.Vr] < minVr) {
            vSpeeds[VSpeedType.Vr] = minVr;
        }
        // 9. If V2 from Step 2 is less than MIN V2, set V2=MIN V2.
        if (vSpeeds[VSpeedType.V2] < minV2) {
            vSpeeds[VSpeedType.V2] = minV2;
        }
        vSpeeds[VSpeedType.V1] = MathUtils.round(vSpeeds[VSpeedType.V1]);
        vSpeeds[VSpeedType.Vr] = MathUtils.round(vSpeeds[VSpeedType.Vr]);
        vSpeeds[VSpeedType.V2] = MathUtils.round(vSpeeds[VSpeedType.V2]);
        return vSpeeds;
    }
    /**
     * Maps values to VSpeedType.
     * 0 = V1, 1 = Vr, 2 = V2
     * @param values The values to map.
     * @returns The mapped values.
     */
    static mapValuesToSpeedType(values) {
        return {
            [VSpeedType.V1]: values[0],
            [VSpeedType.Vr]: values[1],
            [VSpeedType.V2]: values[2]
        };
    }
}
/** weight -> [v1,vr,v2] at flaps 10 */
B748VSpeedData.MAX_TO_DRY_FLAPS_10_VSPEEDS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 168, 184, 197), 1014000],
    [VecNMath.create(3, 164, 180, 194), 970000],
    [VecNMath.create(3, 160, 175, 190), 926000],
    [VecNMath.create(3, 156, 170, 186), 882000],
    [VecNMath.create(3, 151, 165, 182), 838000],
    [VecNMath.create(3, 146, 159, 178), 794000],
    [VecNMath.create(3, 141, 154, 173), 750000],
    [VecNMath.create(3, 136, 148, 168), 706000],
    [VecNMath.create(3, 129, 142, 163), 662000],
    [VecNMath.create(3, 123, 136, 158), 617000],
    [VecNMath.create(3, 116, 128, 152), 573000],
    [VecNMath.create(3, 109, 122, 146), 529000],
    [VecNMath.create(3, 101, 115, 141), 485000],
    [VecNMath.create(3, 92, 107, 134), 441000],
]);
/** weight -> [v1,vr,v2] at flaps 20 */
B748VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEEDS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 157, 170, 182), 1014000],
    [VecNMath.create(3, 153, 166, 179), 970000],
    [VecNMath.create(3, 149, 162, 175), 926000],
    [VecNMath.create(3, 145, 157, 172), 882000],
    [VecNMath.create(3, 141, 152, 168), 838000],
    [VecNMath.create(3, 136, 147, 164), 794000],
    [VecNMath.create(3, 131, 142, 160), 750000],
    [VecNMath.create(3, 125, 137, 155), 706000],
    [VecNMath.create(3, 119, 131, 151), 662000],
    [VecNMath.create(3, 114, 125, 146), 617000],
    [VecNMath.create(3, 107, 118, 140), 573000],
    [VecNMath.create(3, 99, 112, 135), 529000],
    [VecNMath.create(3, 92, 106, 130), 485000],
    [VecNMath.create(3, 84, 98, 124), 441000],
]);
/**
 * adjustments altitude, temp -> adjustment value at flaps 10
 * columns are temps, rows are pressure altitude
 */
B748VSpeedData.MAX_TO_DRY_FLAPS_10_VSPEED_ADJUSTMENTS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 16, 8, -2), -2000, 70], [VecNMath.create(3, 12, 6, -2), -2000, 60], [VecNMath.create(3, 7, 4, -1), -2000, 50], [VecNMath.create(3, 3, 2, -1), -2000, 40], [VecNMath.create(3, 1, 1, 0), -2000, 35], [VecNMath.create(3, 0, 0, 0), -2000, 30], [VecNMath.create(3, 0, 0, 0), -2000, 20], [VecNMath.create(3, 0, 0, 0), -2000, 10], [VecNMath.create(3, 0, 0, 0), -2000, -40], [VecNMath.create(3, 1, 0, 0), -2000, -60],
    [VecNMath.create(3, 17, 8, -3), 0, 70], [VecNMath.create(3, 12, 6, -2), 0, 60], [VecNMath.create(3, 8, 4, -1), 0, 50], [VecNMath.create(3, 4, 2, -1), 0, 40], [VecNMath.create(3, 1, 1, 0), 0, 35], [VecNMath.create(3, 0, 0, 0), 0, 30], [VecNMath.create(3, 0, 0, 0), 0, 20], [VecNMath.create(3, 0, 0, 0), 0, 10], [VecNMath.create(3, 0, 0, 0), 0, -40], [VecNMath.create(3, 1, 0, 0), 0, -60],
    /*                                 */ [VecNMath.create(3, 15, 8, -2), 2000, 60], [VecNMath.create(3, 11, 6, -2), 2000, 50], [VecNMath.create(3, 7, 4, -1), 2000, 40], [VecNMath.create(3, 3, 3, -1), 2000, 35], [VecNMath.create(3, 3, 2, 0), 2000, 30], [VecNMath.create(3, 1, 1, 0), 2000, 20], [VecNMath.create(3, 2, 1, 0), 2000, 10], [VecNMath.create(3, 3, 1, 0), 2000, -40], [VecNMath.create(3, 4, 1, 0), 2000, -60],
    /*                                 */ [VecNMath.create(3, 17, 9, -3), 4000, 60], [VecNMath.create(3, 13, 7, -2), 4000, 50], [VecNMath.create(3, 9, 5, -1), 4000, 40], [VecNMath.create(3, 7, 4, -1), 4000, 35], [VecNMath.create(3, 6, 4, -1), 4000, 30], [VecNMath.create(3, 3, 2, 0), 4000, 20], [VecNMath.create(3, 4, 2, 0), 4000, 10], [VecNMath.create(3, 5, 2, 0), 4000, -40], [VecNMath.create(3, 6, 2, 0), 4000, -60],
    /*                                                                            */ [VecNMath.create(3, 15, 8, -2), 6000, 50], [VecNMath.create(3, 12, 7, -2), 6000, 40], [VecNMath.create(3, 10, 6, -1), 6000, 35], [VecNMath.create(3, 8, 5, -1), 6000, 30], [VecNMath.create(3, 5, 3, -1), 6000, 20], [VecNMath.create(3, 5, 3, -1), 6000, 10], [VecNMath.create(3, 7, 3, -1), 6000, -40], [VecNMath.create(3, 7, 3, -1), 6000, -60],
    /*                                                                            */ [VecNMath.create(3, 18, 9, -3), 8000, 50], [VecNMath.create(3, 14, 8, -2), 8000, 40], [VecNMath.create(3, 13, 7, -2), 8000, 35], [VecNMath.create(3, 11, 7, -2), 8000, 30], [VecNMath.create(3, 8, 5, -1), 8000, 20], [VecNMath.create(3, 8, 5, -1), 8000, 10], [VecNMath.create(3, 9, 5, -1), 8000, -40], [VecNMath.create(3, 10, 5, -1), 8000, -60],
    /*                                                                            */ [VecNMath.create(3, 21, 12, -3), 10000, 50], [VecNMath.create(3, 18, 9, -3), 10000, 40], [VecNMath.create(3, 15, 9, -2), 10000, 35], [VecNMath.create(3, 14, 8, -2), 10000, 30], [VecNMath.create(3, 12, 7, -2), 10000, 20], [VecNMath.create(3, 10, 6, -1), 10000, 10], [VecNMath.create(3, 11, 6, -1), 10000, -40], [VecNMath.create(3, 12, 6, -1), 10000, -60],
]);
/**
 * adjustments altitude, temp -> adjustment value at flaps 20
 * columns are temps, rows are pressure altitude
 */
B748VSpeedData.MAX_TO_DRY_FLAPS_20_VSPEED_ADJUSTMENTS_TABLE = new LerpVectorLookupTable([
    [VecNMath.create(3, 16, 8, -2), -2000, 70], [VecNMath.create(3, 12, 6, -2), -2000, 60], [VecNMath.create(3, 7, 4, -1), -2000, 50], [VecNMath.create(3, 3, 2, -1), -2000, 40], [VecNMath.create(3, 1, 1, 0), -2000, 35], [VecNMath.create(3, 0, 0, 0), -2000, 30], [VecNMath.create(3, 0, 0, 0), -2000, 20], [VecNMath.create(3, 0, 0, 0), -2000, 10], [VecNMath.create(3, 0, 0, 0), -2000, -40], [VecNMath.create(3, 1, 0, 0), -2000, -60],
    [VecNMath.create(3, 17, 8, -3), 0, 70], [VecNMath.create(3, 12, 6, -2), 0, 60], [VecNMath.create(3, 8, 4, -1), 0, 50], [VecNMath.create(3, 4, 2, -1), 0, 40], [VecNMath.create(3, 1, 1, 0), 0, 35], [VecNMath.create(3, 0, 0, 0), 0, 30], [VecNMath.create(3, 0, 0, 0), 0, 20], [VecNMath.create(3, 0, 0, 0), 0, 10], [VecNMath.create(3, 0, 0, 0), 0, -40], [VecNMath.create(3, 1, 0, 0), 0, -60],
    /*                                 */ [VecNMath.create(3, 15, 8, -2), 2000, 60], [VecNMath.create(3, 11, 6, -2), 2000, 50], [VecNMath.create(3, 7, 4, -1), 2000, 40], [VecNMath.create(3, 3, 3, -1), 2000, 35], [VecNMath.create(3, 3, 2, 0), 2000, 30], [VecNMath.create(3, 1, 1, 0), 2000, 20], [VecNMath.create(3, 2, 1, 0), 2000, 10], [VecNMath.create(3, 3, 1, 0), 2000, -40], [VecNMath.create(3, 4, 1, 0), 2000, -60],
    /*                                 */ [VecNMath.create(3, 17, 9, -3), 4000, 60], [VecNMath.create(3, 13, 7, -2), 4000, 50], [VecNMath.create(3, 9, 5, -1), 4000, 40], [VecNMath.create(3, 7, 4, -1), 4000, 35], [VecNMath.create(3, 6, 4, -1), 4000, 30], [VecNMath.create(3, 3, 2, 0), 4000, 20], [VecNMath.create(3, 4, 2, 0), 4000, 10], [VecNMath.create(3, 5, 2, 0), 4000, -40], [VecNMath.create(3, 6, 2, 0), 4000, -60],
    /*                                                                            */ [VecNMath.create(3, 15, 8, -2), 6000, 50], [VecNMath.create(3, 12, 7, -2), 6000, 40], [VecNMath.create(3, 10, 6, -1), 6000, 35], [VecNMath.create(3, 8, 5, -1), 6000, 30], [VecNMath.create(3, 5, 3, -1), 6000, 20], [VecNMath.create(3, 5, 3, -1), 6000, 10], [VecNMath.create(3, 7, 3, -1), 6000, -40], [VecNMath.create(3, 7, 3, -1), 6000, -60],
    /*                                                                            */ [VecNMath.create(3, 18, 9, -3), 8000, 50], [VecNMath.create(3, 14, 8, -2), 8000, 40], [VecNMath.create(3, 13, 7, -2), 8000, 35], [VecNMath.create(3, 11, 7, -2), 8000, 30], [VecNMath.create(3, 8, 5, -1), 8000, 20], [VecNMath.create(3, 8, 5, -1), 8000, 10], [VecNMath.create(3, 9, 5, -1), 8000, -40], [VecNMath.create(3, 10, 5, -1), 8000, -60],
    /*                                                                            */ [VecNMath.create(3, 21, 12, -3), 10000, 50], [VecNMath.create(3, 18, 9, -3), 10000, 40], [VecNMath.create(3, 15, 9, -2), 10000, 35], [VecNMath.create(3, 14, 8, -2), 10000, 30], [VecNMath.create(3, 12, 7, -2), 10000, 20], [VecNMath.create(3, 10, 6, -1), 10000, 10], [VecNMath.create(3, 11, 6, -1), 10000, -40], [VecNMath.create(3, 12, 6, -1), 10000, -60],
]);
/** V1 MCG for temp, altitude -> v1 mcg at flaps 10 */
B748VSpeedData.MAX_TO_DRY_FLAPS_10_V1MCG_TABLE = new LerpLookupTable([
    [122, 60, -2000], [126, 50, -2000], [133, 40, -2000], [138, 30, -2000], [138, 20, -2000], [139, 0, -2000], [140, -60, -2000],
    [121, 60, 0], [124, 50, 0], [132, 40, 0], [138, 30, 0], [138, 20, 0], [138, 0, 0], [139, -60, 0],
    /*          */ [119, 50, 2000], [126, 40, 2000], [132, 30, 2000], [134, 20, 2000], [135, 0, 2000], [135, -60, 2000],
    /*          */ [116, 50, 4000], [121, 40, 4000], [127, 30, 4000], [130, 20, 4000], [131, 0, 4000], [131, -60, 4000],
    /*          */ [114, 50, 6000], [116, 40, 6000], [121, 30, 6000], [126, 20, 6000], [127, 0, 6000], [128, -60, 6000],
    /*                           */ [111, 40, 8000], [116, 30, 8000], [121, 20, 8000], [123, 0, 8000], [123, -60, 8000],
    /*                           */ [108, 40, 10000], [110, 30, 10000], [114, 20, 10000], [118, 0, 10000], [119, -60, 10000],
]);
/** V1 MCG for temp, altitude -> v1 mcg at flaps 20 */
B748VSpeedData.MAX_TO_DRY_FLAPS_20_V1MCG_TABLE = new LerpLookupTable([
    [122, 60, -2000], [126, 50, -2000], [133, 40, -2000], [138, 30, -2000], [138, 20, -2000], [139, 0, -2000], [140, -60, -2000],
    [121, 60, 0], [124, 50, 0], [132, 40, 0], [138, 30, 0], [138, 20, 0], [138, 0, 0], [139, -60, 0],
    /*          */ [119, 50, 2000], [126, 40, 2000], [132, 30, 2000], [134, 20, 2000], [135, 0, 2000], [135, -60, 2000],
    /*          */ [116, 50, 4000], [121, 40, 4000], [127, 30, 4000], [130, 20, 4000], [131, 0, 4000], [131, -60, 4000],
    /*          */ [114, 50, 6000], [116, 40, 6000], [121, 30, 6000], [126, 20, 6000], [127, 0, 6000], [128, -60, 6000],
    /*                           */ [111, 40, 8000], [116, 30, 8000], [121, 20, 8000], [123, 0, 8000], [123, -60, 8000],
    /*                           */ [108, 40, 10000], [110, 30, 10000], [114, 20, 10000], [118, 0, 10000], [119, -60, 10000],
]);
/** Minimum VR for temp, altitude -> min vr at flaps 10 */
B748VSpeedData.MAX_TO_DRY_FLAPS_10_MINIMUM_VR = new LerpLookupTable([
    [126, 60, -2000], [129, 50, -2000], [136, 40, -2000], [141, 30, -2000], [141, 20, -2000], [141, 0, -2000], [141, -60, -2000],
    [124, 60, 0], [127, 50, 0], [135, 40, 0], [140, 30, 0], [141, 20, 0], [141, 0, 0], [140, -60, 0],
    /*          */ [123, 50, 2000], [129, 40, 2000], [135, 30, 2000], [137, 20, 2000], [137, 0, 2000], [137, -60, 2000],
    /*          */ [120, 50, 4000], [125, 40, 4000], [130, 30, 4000], [134, 20, 4000], [134, 0, 4000], [134, -60, 4000],
    /*          */ [118, 50, 6000], [120, 40, 6000], [125, 30, 6000], [130, 20, 6000], [130, 0, 6000], [131, -60, 6000],
    /*                          */ [116, 40, 8000], [120, 30, 8000], [125, 20, 8000], [127, 0, 8000], [127, -60, 8000],
    /*                          */ [112, 40, 10000], [114, 30, 10000], [118, 20, 10000], [122, 0, 10000], [122, -60, 10000],
]);
/** Minimum VR for temp, altitude -> min vr at flaps 20 */
B748VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_VR = new LerpLookupTable([
    [126, 60, -2000], [129, 50, -2000], [136, 40, -2000], [141, 30, -2000], [141, 20, -2000], [141, 0, -2000], [141, -60, -2000],
    [124, 60, 0], [127, 50, 0], [135, 40, 0], [140, 30, 0], [141, 20, 0], [141, 0, 0], [140, -60, 0],
    /*          */ [123, 50, 2000], [129, 40, 2000], [135, 30, 2000], [137, 20, 2000], [137, 0, 2000], [137, -60, 2000],
    /*          */ [120, 50, 4000], [125, 40, 4000], [130, 30, 4000], [134, 20, 4000], [134, 0, 4000], [134, -60, 4000],
    /*          */ [118, 50, 6000], [120, 40, 6000], [125, 30, 6000], [130, 20, 6000], [130, 0, 6000], [131, -60, 6000],
    /*                           */ [116, 40, 8000], [120, 30, 8000], [125, 20, 8000], [127, 0, 8000], [127, -60, 8000],
    /*                           */ [112, 40, 10000], [114, 30, 10000], [118, 20, 10000], [122, 0, 10000], [122, -60, 10000],
]);
/** Minimum V2 for weight, minVR -> min v2 at flaps 10 */
B748VSpeedData.MAX_TO_DRY_FLAPS_10_MINIMUM_V2 = new LerpLookupTable([
    [166, 706000, 110], [160, 662000, 110], [155, 617000, 110], [148, 573000, 110], [142, 529000, 110], [136, 485000, 110], [127, 441000, 110],
    [167, 706000, 115], [160, 662000, 115], [155, 617000, 115], [149, 573000, 115], [143, 529000, 115], [137, 485000, 115], [132, 441000, 115],
    [167, 706000, 120], [161, 662000, 120], [155, 617000, 120], [149, 573000, 120], [143, 529000, 120], [138, 485000, 120], [137, 441000, 120],
    [167, 706000, 125], [161, 662000, 125], [156, 617000, 125], [150, 573000, 125], [144, 529000, 125], [143, 485000, 125], [141, 441000, 125],
    [167, 706000, 130], [161, 662000, 130], [156, 617000, 130], [150, 573000, 130], [148, 529000, 130], [147, 485000, 130], [146, 441000, 130],
    [168, 706000, 135], [161, 662000, 135], [156, 617000, 135], [154, 573000, 135], [153, 529000, 135], [152, 485000, 135], [151, 441000, 135],
    [168, 706000, 140], [162, 662000, 140], [160, 617000, 140], [159, 573000, 140], [158, 529000, 140], [156, 485000, 140], [155, 441000, 140],
    [168, 706000, 145], [165, 662000, 145], [165, 617000, 145], [164, 573000, 145], [163, 529000, 145], [161, 485000, 145], [160, 441000, 145],
]);
/** Minimum V2 for weight, minVR -> min v2 at flaps 20 */
B748VSpeedData.MAX_TO_DRY_FLAPS_20_MINIMUM_V2 = new LerpLookupTable([
    [162, 794000, 110], [157, 750000, 110], [152, 706000, 110], [147, 662000, 110], [142, 617000, 110], [137, 573000, 110], [131, 529000, 110], [124, 485000, 110], [123, 441000, 110],
    [163, 794000, 115], [157, 750000, 115], [152, 706000, 115], [148, 662000, 115], [143, 617000, 115], [137, 573000, 115], [132, 529000, 115], [128, 485000, 115], [128, 441000, 115],
    [163, 794000, 120], [157, 750000, 120], [153, 706000, 120], [148, 662000, 120], [143, 617000, 120], [137, 573000, 120], [134, 529000, 120], [133, 485000, 120], [132, 441000, 120],
    [163, 794000, 125], [158, 750000, 125], [153, 706000, 125], [148, 662000, 125], [144, 617000, 125], [140, 573000, 125], [139, 529000, 125], [138, 485000, 125], [137, 441000, 125],
    [163, 794000, 130], [158, 750000, 130], [153, 706000, 130], [149, 662000, 130], [146, 617000, 130], [144, 573000, 130], [144, 529000, 130], [143, 485000, 130], [142, 441000, 130],
    [164, 794000, 135], [158, 750000, 135], [154, 706000, 135], [151, 662000, 135], [150, 617000, 135], [149, 573000, 135], [149, 529000, 135], [147, 485000, 135], [146, 441000, 135],
    [164, 794000, 140], [159, 750000, 140], [157, 706000, 140], [156, 662000, 140], [155, 617000, 140], [154, 573000, 140], [153, 529000, 140], [152, 485000, 140], [151, 441000, 140],
    [164, 794000, 145], [162, 750000, 145], [161, 706000, 145], [161, 662000, 145], [160, 617000, 145], [159, 573000, 145], [158, 529000, 145], [157, 485000, 145], [156, 441000, 145],
]);
/**
 * Slope adjustments for weight, slope -> adjustment
 * The table is the same for all flaps settings
 */
B748VSpeedData.MAX_TO_DRY_SLOPE_ADJUST = new LerpLookupTable([
    [-6, 1014000, -2], [-6, 970000, -2], [-5, 926000, -2], [-5, 882000, -2], [-4, 838000, -2], [-4, 794000, -2], [-4, 750000, -2], [-3, 706000, -2], [-3, 662000, -2], [-3, 617000, -2], [-3, 573000, -2], [-3, 529000, -2], [-2, 485000, -2], [-2, 441000, -2],
    [-3, 1014000, -1], [-3, 970000, -1], [-2, 926000, -1], [-2, 882000, -1], [-2, 838000, -1], [-2, 794000, -1], [-2, 750000, -1], [-2, 706000, -1], [-2, 662000, -1], [-1, 617000, -1], [-1, 573000, -1], [-1, 529000, -1], [-1, 485000, -1], [-1, 441000, -1],
    [0, 1014000, 0], [0, 970000, 0], [0, 926000, 0], [0, 882000, 0], [0, 838000, 0], [0, 794000, 0], [0, 750000, 0], [0, 706000, 0], [0, 662000, 0], [0, 617000, 0], [0, 573000, 0], [0, 529000, 0], [0, 485000, 0], [0, 441000, 0],
    [3, 1014000, 1], [3, 970000, 1], [3, 926000, 1], [2, 882000, 1], [2, 838000, 1], [2, 794000, 1], [2, 750000, 1], [2, 706000, 1], [2, 662000, 1], [2, 617000, 1], [2, 573000, 1], [1, 529000, 1], [1, 485000, 1], [1, 441000, 1],
    [6, 1014000, 2], [5, 970000, 2], [5, 926000, 2], [5, 882000, 2], [4, 838000, 2], [4, 794000, 2], [4, 750000, 2], [3, 706000, 2], [3, 662000, 2], [3, 617000, 2], [3, 573000, 2], [3, 529000, 2], [3, 485000, 2], [2, 441000, 2],
]);
/**
 * Wind adjustments for weight, wind -> adjustment
 * * The table is the same for all flaps settings
 */
B748VSpeedData.MAX_TO_DRY_WIND_ADJUST = new LerpLookupTable([
    [-4, 1014000, -15], [-4, 970000, -15], [-4, 926000, -15], [-4, 882000, -15], [-4, 838000, -15], [-4, 794000, -15], [-4, 750000, -15], [-4, 706000, -15], [-4, 662000, -15], [-3, 617000, -15], [-3, 573000, -15], [-3, 529000, -15], [-3, 485000, -15], [-3, 441000, -15],
    [-3, 1014000, -10], [-3, 970000, -10], [-3, 926000, -10], [-3, 882000, -10], [-2, 838000, -10], [-2, 794000, -10], [-2, 750000, -10], [-2, 706000, -10], [-2, 662000, -10], [-2, 617000, -10], [-2, 573000, -10], [-2, 529000, -10], [-2, 485000, -10], [-2, 441000, -10],
    [-1, 1014000, -5], [-1, 970000, -5], [-1, 926000, -5], [-1, 882000, -5], [-1, 838000, -5], [-1, 794000, -5], [-1, 750000, -5], [-1, 706000, -5], [-1, 662000, -5], [-1, 617000, -5], [-1, 573000, -5], [-1, 529000, -5], [-1, 485000, -5], [-1, 441000, -5],
    [0, 1014000, 0], [0, 970000, 0], [0, 926000, 0], [0, 882000, 0], [0, 838000, 0], [0, 794000, 0], [0, 750000, 0], [0, 706000, 0], [0, 662000, 0], [0, 617000, 0], [0, 573000, 0], [0, 529000, 0], [0, 485000, 0], [0, 441000, 0],
    [1, 1014000, 10], [1, 970000, 10], [1, 926000, 10], [1, 882000, 10], [1, 838000, 10], [1, 794000, 10], [1, 750000, 10], [1, 706000, 10], [1, 662000, 10], [1, 617000, 10], [1, 573000, 10], [1, 529000, 10], [1, 485000, 10], [1, 441000, 10],
    [2, 1014000, 20], [2, 970000, 20], [2, 926000, 20], [2, 882000, 20], [2, 838000, 20], [2, 794000, 20], [2, 750000, 20], [2, 706000, 20], [2, 662000, 20], [2, 617000, 20], [2, 573000, 20], [2, 529000, 20], [2, 485000, 20], [2, 441000, 20],
    [3, 1014000, 30], [3, 970000, 30], [3, 926000, 30], [2, 882000, 30], [2, 838000, 30], [2, 794000, 30], [2, 750000, 30], [2, 706000, 30], [2, 662000, 30], [2, 617000, 30], [2, 573000, 30], [2, 529000, 30], [2, 485000, 30], [2, 441000, 30],
    [4, 1014000, 40], [3, 970000, 40], [3, 926000, 40], [3, 882000, 40], [3, 838000, 40], [3, 794000, 40], [3, 750000, 40], [3, 706000, 40], [3, 662000, 40], [3, 617000, 40], [3, 573000, 40], [3, 529000, 40], [3, 485000, 40], [3, 441000, 40],
]);
B748VSpeedData.TMP_DATA = new Float64Array(3);

/** A B748 TAKEOFF REF page. */
class B748TakeoffRefPage extends BoeingTakeoffRefPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, {
            messenger: new B748MessageTransmitter(bus),
            titleRightPadding: true,
            takeoffFlapSettings: ['10', '20'],
            thrustFieldFormatter: () => B748FmcFormatters.AssumedTempInput,
            cgFieldFormatter: () => B748FmcFormatters.CenterOfGravityTrim,
            vSpeedData: new B748VSpeedData(),
            RunwayHeader: ' RWY/POS',
            RequestHeader: ' REQUEST[disabled]',
            RequestPrompt: '<SEND[disabled]',
            PendingUplinkHeader: '      TAKEOFF DATA     ',
            grossWeightSpacing: 2,
            refOatPad: 2,
            rwyWindNullValueString: '--',
            showRefSpeeds: true,
            refAndVSpeedFieldFormat: ([vSpeed, refSpeed, showRefSpeed, refSpeedsExist]) => {
                const refSpeedStr = refSpeed.toString();
                const refSpeedFormattedStr = showRefSpeed && refSpeedsExist ? `${refSpeedStr}[s-text]` : '';
                // If a V speed is non-zero...
                const vSpeedStr = vSpeed ?
                    // ...show it...
                    vSpeed.toString() :
                    // ...otherwise if there's no V speed, but a ref speed exists and is being shown...
                    (refSpeedsExist && showRefSpeed ?
                        // ...show it in small text...
                        `${refSpeedStr}>[s-text]` :
                        // ...and if there's no V speed or ref speed, show dashes.
                        '---');
                return `${refSpeedFormattedStr}   ${vSpeedStr.padStart(4, ' ')}`.trim();
            },
            v1Header: 'REF     V1',
            line6HeaderGen: (preflightComplete) => {
                return preflightComplete ?
                    ['--------------------------------------'] :
                    ['--------------------------------------', ' PRE-FLT'];
            },
        });
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
    /** @inheritDoc */
    pageTwoRenderTemplate() {
        return [
            ['', this.PagingIndicator, 'TAKEOFF REF'],
            [' ALTN THRUST[disabled]', 'EO ACCEL HT'],
            ['', this.EoAccelHtField],
            [' REF OAT', 'ACCEL HT'],
            [this.RefOatField, this.AccelHtField],
            [' WIND', 'THR REDUCTION'],
            [this.WindField, this.ThrReductionField],
            [' RWY WIND'],
            [this.RwyWindField],
            [' SLOPE/COND', 'STD LIM TOGW[disabled]'],
            [this.SlopeCondField],
            ['Q-CLB'.padStart(24, '-')],
            [this.IndexLink, 'OFF←→[d-text disabled]ARMED[s-text disabled]>[d-text disabled]'],
        ];
    }
}

/** A B748 THRUST LIM page. */
class B748ThrustLimPage extends BoeingThrustLimPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, ' SEL      OAT', B748FmcFormatters.AssumedOatTempPair, 3, 'N1', 'Q-CLB [s-text disabled]', 'OFF←→[d-text disabled]ARMED[s-text disabled]>[d-text disabled]', () => ['-'.repeat(24)]);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
}

/** 748 VNAV pages. */
class B748VnavPage extends BoeingVnavPage {
    /** @inheritDoc */
    constructor(bus, screen, fms, renderCallback) {
        super(bus, screen, fms, renderCallback, new B748EngineData(bus, new B748PerformanceMath()), ' N1[disabled]', 2, false);
        this.bus = bus;
        this.screen = screen;
        this.fms = fms;
        this.renderCallback = renderCallback;
    }
    /** @inheritDoc */
    publishMaxAltMessage(maxAltStr) {
        this.bus.getPublisher().pub('post_message', {
            key: BoeingFmcErrorKeys.Generic,
            message: new ScratchpadMessage(true, `MAX ALT ${maxAltStr}`),
            targetCdu: this.screen.getSideIndex()
        }, true);
    }
    /** @inheritDoc */
    constraintFormatter(page) {
        return B748FmcFormatters.ConstraintField(page);
    }
}

/** The 748 WIND (at a waypoint) page. */
class B748WindPage extends BoeingWindPage {
    /** @inheritdoc */
    getPageHeaderString() {
        return 'WINDS';
    }
    /** @inheritdoc */
    getIsPagePrefixEnabled() {
        return false;
    }
    /** @inheritdoc */
    getBasePaddingLeft() {
        return 2;
    }
    /** @inheritdoc */
    getAltOatHeaderNames() {
        return ' ALT    OAT';
    }
    /** @inheritdoc */
    getDirSpdFieldName() {
        return 'DIR/SPD';
    }
    /** @inheritdoc */
    getAltOatFieldName() {
        return 'ALT/OAT';
    }
    /** @inheritdoc */
    getWindAltitudeTemperatureNullValueString() {
        return '-----/---°[d-text]C[s-text]';
    }
}

/**
 * B748 CDU component.
 */
class B748Cdu extends DisplayComponent {
    constructor() {
        super(...arguments);
        this.cduScreenRef = FSComponent.createRef();
        this.cduHEventPrefix = `B747_8_FMC_${this.props.index}_BTN_`;
        this.fmcEventsPub = this.props.bus.getPublisher();
        /** The CDU index. */
        this.cduIndex = this.props.index;
        /** The CDU side index. */
        this.cduSideIndex = this.props.index === 2 ? 2 : 1;
        this.isOnGround = ConsumerValue.create(this.props.bus.getSubscriber()
            .on('on_ground').whenChanged(), true);
        this.posIsInitialized = ConsumerSubject.create(this.props.bus.getSubscriber().on('all_irs_systems_operating'), true);
        this.flightPhase = ConsumerValue.create(this.props.bus.getSubscriber()
            .on('fms_operating_phase'), FmsOperatingPhase.PREFLIGHT);
    }
    /** @inheritDoc */
    onAfterRender(node) {
        super.onAfterRender(node);
        this.fmcScreen = new B748FmcScreen(this.props.bus, this, this.props.fms, this.cduScreenRef.instance);
        // Listen for FMC HEvents, handle some
        this.props.bus.getSubscriber().on('hEvent').handle((event) => {
            if (event.startsWith(this.cduHEventPrefix)) {
                const eventName = event.replace(this.cduHEventPrefix, '');
                this.handleCduHEvent(eventName);
            }
        });
        const indexedFmcInteractionEventsSub = this.props.bus.getSubscriber();
        indexedFmcInteractionEventsSub.on('scratchpad_plus_minus').handle(() => {
            var _a, _b, _c, _d;
            const currentContents = (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.scratchpad.contents.get();
            if (currentContents !== undefined) {
                switch (currentContents[currentContents.length - 1]) {
                    case '+':
                        (_b = this.fmcScreen) === null || _b === void 0 ? void 0 : _b.scratchpad.contents.set(`${currentContents.substring(0, currentContents.length - 1)}-`);
                        break;
                    case '-':
                        (_c = this.fmcScreen) === null || _c === void 0 ? void 0 : _c.scratchpad.contents.set(`${currentContents.substring(0, currentContents.length - 1)}+`);
                        break;
                    default:
                        (_d = this.fmcScreen) === null || _d === void 0 ? void 0 : _d.scratchpad.typeContents('-');
                        break;
                }
            }
        });
        indexedFmcInteractionEventsSub.on('scratchpad_type').handle((char) => {
            var _a;
            (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.scratchpad.typeContents(char);
        });
        indexedFmcInteractionEventsSub.on('scratchpad_delete').handle(() => {
            var _a;
            (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.scratchpad.delete();
        });
        indexedFmcInteractionEventsSub.on('scratchpad_clear').handle(() => {
            var _a, _b, _c, _d, _e;
            if ((_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.scratchpad.errorContents.get()) {
                (_b = this.fmcScreen) === null || _b === void 0 ? void 0 : _b.handleClearMessage();
            }
            else {
                (_c = this.fmcScreen) === null || _c === void 0 ? void 0 : _c.scratchpad.backspace();
                if (((_d = this.fmcScreen) === null || _d === void 0 ? void 0 : _d.scratchpad.contents.get().length) === 0) {
                    (_e = this.fmcScreen) === null || _e === void 0 ? void 0 : _e.refreshScratchpadMessageDisplay();
                }
            }
        });
        indexedFmcInteractionEventsSub.on('scratchpad_clear_long').handle(() => {
            var _a;
            (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.scratchpad.clear();
        });
        indexedFmcInteractionEventsSub.on('key_exec').handle(() => {
            this.props.fms.execute();
        });
        this.initialiseFmcScreen();
    }
    /**
     * Handle an event sent to this CDU
     *
     * @param event the event string
     */
    handleCduHEvent(event) {
        if (event.match(/[LR]\d/)) {
            const side = event[0];
            const index = event[1];
            this.fmcEventsPub.pub(`lsk_${index}_${side}`, undefined);
            return;
        }
        switch (event) {
            case 'INIT': {
                this.fmcEventsPub.pub('page_init_ref', undefined);
                break;
            }
            case 'RTE': {
                this.fmcEventsPub.pub('page_rte', undefined);
                break;
            }
            case 'DEPARR': {
                this.fmcEventsPub.pub('page_dep_arr', undefined);
                break;
            }
            case 'ATC': {
                this.fmcEventsPub.pub('page_atc', undefined);
                break;
            }
            case 'VNAV': {
                this.fmcEventsPub.pub('page_vnav', undefined);
                break;
            }
            case 'FIX': {
                this.fmcEventsPub.pub('page_fix', undefined);
                break;
            }
            case 'LEGS': {
                this.fmcEventsPub.pub('page_legs', undefined);
                break;
            }
            case 'HOLD': {
                this.fmcEventsPub.pub('page_hold', undefined);
                break;
            }
            case 'FMCCOMM': {
                this.fmcEventsPub.pub('page_fmc_comm', undefined);
                break;
            }
            case 'PROG': {
                this.fmcEventsPub.pub('page_prog', undefined);
                break;
            }
            case 'EXEC': {
                this.fmcEventsPub.pub('key_exec', undefined);
                break;
            }
            case 'MENU':
                this.fmcEventsPub.pub('page_menu', undefined);
                break;
            case 'NAVRAD': {
                this.fmcEventsPub.pub('page_nav_rad', undefined);
                break;
            }
            case 'PREVPAGE': {
                this.fmcEventsPub.pub('key_prev_page', undefined);
                break;
            }
            case 'NEXTPAGE': {
                this.fmcEventsPub.pub('key_next_page', undefined);
                break;
            }
            case 'DOT': {
                this.fmcEventsPub.pub('scratchpad_type', '.');
                break;
            }
            case 'PLUSMINUS': {
                this.fmcEventsPub.pub('scratchpad_plus_minus', undefined);
                break;
            }
            case 'SP': {
                this.fmcEventsPub.pub('scratchpad_type', ' ');
                break;
            }
            case 'DEL': {
                this.fmcEventsPub.pub('scratchpad_delete', undefined);
                break;
            }
            case 'DIV': {
                this.fmcEventsPub.pub('scratchpad_type', '/');
                break;
            }
            case 'CLR': {
                this.fmcEventsPub.pub('scratchpad_clear', undefined);
                break;
            }
            case 'CLR_Long': {
                this.fmcEventsPub.pub('scratchpad_clear_long', undefined);
                break;
            }
            case 'ENTER': {
                this.fmcEventsPub.pub('scratchpad_enter', undefined);
                break;
            }
            case 'SYS':
            case 'CDU':
            case 'INFO':
            case 'CHKL':
            case 'COMM':
            case 'HD': // Ignore pane select keys
                break;
            default:
                this.fmcEventsPub.pub('scratchpad_type', event);
        }
    }
    /**
     * Initialises the FMC screen
     */
    initialiseFmcScreen() {
        if (!this.fmcScreen) {
            return;
        }
        this.fmcScreen.addLskEvents([
            ['lsk_1_L', 2, 0], ['lsk_1_R', 2, 1],
            ['lsk_2_L', 4, 0], ['lsk_2_R', 4, 1],
            ['lsk_3_L', 6, 0], ['lsk_3_R', 6, 1],
            ['lsk_4_L', 8, 0], ['lsk_4_R', 8, 1],
            ['lsk_5_L', 10, 0], ['lsk_5_R', 10, 1],
            ['lsk_6_L', 12, 0], ['lsk_6_R', 12, 1],
        ]);
        this.fmcScreen.addPagingEvents({
            pageLeft: 'key_prev_page',
            pageRight: 'key_next_page',
        });
        this.fmcScreen.addPageRoute('/menu', B748MenuPage, 'page_menu');
        this.fmcScreen.addPageRoute('/settings', B748SettingsPage);
        this.fmcScreen.addPageRoute('/atc', B748AtcPage, 'page_atc');
        this.fmcScreen.addPageRoute('/init-ref', B748InitRefPage);
        this.fmcScreen.addPageRoute('/rte', B748RtePage, 'page_rte');
        this.fmcScreen.addPageRoute('/vnav', B748VnavPage);
        this.fmcScreen.addPageRoute('/fix-info', B748FixInfoPage, 'page_fix');
        this.fmcScreen.addPageRoute('/prog', B748ProgPage, 'page_prog');
        this.fmcScreen.addPageRoute('/legs', B748LegsPage, 'page_legs');
        this.fmcScreen.addPageRoute('/rte-data', B748RteDataPage);
        this.fmcScreen.addPageRoute('/wind', B748WindPage);
        this.fmcScreen.addPageRoute('/altn', B748AlternateListPage);
        this.fmcScreen.addPageRoute('/altn-display', B748AlternateDisplayPage);
        this.fmcScreen.addPageRoute('/nav-radio', B748NavRadioPage, 'page_nav_rad');
        // this.fmcScreen.addPageRoute('/ofst', B787OfstPage, 'page_ofst');
        this.fmcScreen.addPageRoute('/hold', B748HoldPage);
        this.fmcScreen.addPageRoute('/fmc-comm', B748FmcCommPage, 'page_fmc_comm');
        this.fmcScreen.addPageRoute('/dep-arr', B748DepArrPage, 'page_dep_arr');
        // this.fmcScreen.addPageRoute('/prog#3', B787ProgPage, 'page_rta');
        this.fmcScreen.addPageRoute('/takeoff-ref', B748TakeoffRefPage);
        this.fmcScreen.addPageRoute('/approach-ref', B748ApproachRefPage);
        this.fmcScreen.addPageRoute('/perf-init', B748PerfInitPage);
        this.fmcScreen.addPageRoute('/pos-init', B748PosRefPage);
        this.fmcScreen.addPageRoute('/ident', B748IdentPage);
        // this.fmcScreen.addPageRoute('/pos-report', B787PosReportPage);
        this.fmcScreen.addPageRoute('/select-wpt', B748SelectWaypointPage);
        this.fmcScreen.addPageRoute('/thrust-lim', B748ThrustLimPage);
        this.fmcScreen.addPageRoute('/nav-data', B748RefNavDataPage);
        this.fmcScreen.addPageRoute('/maint', B748MaintPage);
        this.fmcScreen.addPageRoute('/des-forecast', B748DescentForecastPage);
        this.fmcScreen.navigateTo('/ident');
        this.fmcScreen.onPrefixedEvent('page_init_ref').handle(() => {
            var _a, _b, _c, _d;
            if (this.isOnGround.get()) {
                if (!this.posIsInitialized.get()) {
                    (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.navigateTo('/pos-init');
                }
                else if (!this.props.fms.preflightComplete.get()) {
                    (_b = this.fmcScreen) === null || _b === void 0 ? void 0 : _b.navigateTo('/perf-init');
                }
                else {
                    // Not mentioned in the manuals, but is shown in videos
                    (_c = this.fmcScreen) === null || _c === void 0 ? void 0 : _c.navigateTo('/takeoff-ref');
                }
            }
            else {
                (_d = this.fmcScreen) === null || _d === void 0 ? void 0 : _d.navigateTo('/approach-ref');
            }
        });
        this.fmcScreen.onPrefixedEvent('page_vnav').handle(() => {
            var _a, _b, _c;
            if (this.flightPhase.get() <= FmsOperatingPhase.CLIMB) {
                (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.navigateTo('/vnav#1');
            }
            else if (this.flightPhase.get() === FmsOperatingPhase.CRUISE) {
                (_b = this.fmcScreen) === null || _b === void 0 ? void 0 : _b.navigateTo('/vnav#2');
            }
            else {
                (_c = this.fmcScreen) === null || _c === void 0 ? void 0 : _c.navigateTo('/vnav#3');
            }
        });
        this.fmcScreen.onPrefixedEvent('page_hold').handle(() => {
            var _a, _b;
            const flightPlan = this.props.fms.getPlanForFmcRender();
            const holdsInPlan = BoeingFmsUtils.getPlanHolds(flightPlan);
            if (holdsInPlan.length) {
                (_a = this.fmcScreen) === null || _a === void 0 ? void 0 : _a.navigateTo('/hold', { atLeg: flightPlan.getLegIndexFromLeg(holdsInPlan[0]) - 1 });
            }
            else {
                (_b = this.fmcScreen) === null || _b === void 0 ? void 0 : _b.navigateTo('/legs', { isForHoldSelection: true });
            }
        });
    }
    /** @inheritDoc */
    render() {
        return FSComponent.buildComponent("div", { ref: this.cduScreenRef });
    }
}

/**
 * A Boeing 747-8i CDU instrument.
 * Primary Flight Display showing the basic flight instruments.
 */
class WTB748CduInstrument extends WTB748FsInstrument {
    /**
     * Constructor.
     * @param instrument This instrument's parent BaseInstrument.
     * @param config This instrument's avionics config
     */
    constructor(instrument, config) {
        super(instrument, config);
        /** @inheritdoc */
        this.iauIndex = this.instrument.instrumentIndex;
        // TODO: Support switching between IAU and ADC indices with a switch.
        this.iauAdcIndex = this.instrument.instrumentIndex;
        // FIXME: Provide appropriate way to source AOA Index used for DefaultAoaProvider.
        this.aoaIndex = 1;
        this.messageService = new MessageService();
        this.messageTransmitter = new B748MessageTransmitter(this.bus);
        this.stabTrimCalculator = new B748StabTrimCalculator(this.bus, this.activeRoutePerformancePlan, new B748StabTrimData());
        this.fixInfoManager = new BoeingFixInfoManager(this.bus, this.facLoader, BoeingFms.ACT_RTE_PLAN_INDEX, this.activeRoutePredictor, this.flightPlanner);
        this.fms = new BoeingFms(this.bus, this.flightPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.windPlanner, this.performanceMath, this.engineDataProvider, this.iauIndex === 1, this.activeRoutePredictor, this.fixInfoManager, this.messageTransmitter);
        this.fadec = undefined;
        this.autothrottle = undefined;
        this.thrustModeManager = undefined;
        this.apConfig = undefined;
        this.ap = undefined;
        this.fmsOperatingPhaseController = undefined;
        this.vorManager = null;
        this.irsSystemGroupStatusPublisher = new IrsSystemGroupStatusPublisher(this.bus, 3);
        this.lastCalculate = 0;
        this.createSystems();
        this.controlSurfacesPublisher = new ControlSurfacesPublisher(this.bus, 3);
        this.backplane.addPublisher(InstrumentBackplaneNames.ControlSurfaces, this.controlSurfacesPublisher);
        this.backplane.addPublisher(InstrumentBackplaneNames.Fadec, new BoeingFadecPublisher(this.bus, 4));
        if (this.iauIndex === 1) {
            // Do init that should only happen on CDU 1
            // This tells the vfr map that we are using the nextgen flight plan
            SimVar.SetSimVarValue('L:XMLVAR_NEXTGEN_FLIGHTPLAN_ENABLED', SimVarValueType.Bool, true);
            this.apConfig = new BoeingAPConfig(this.bus, this.flightPlanner, this.messageTransmitter, this.verticalPathCalculator, this.fms.activePerformancePlan, { primaryPlanIndex: BoeingFms.ACT_RTE_PLAN_INDEX, vmo: this.speedData.getVmo.bind(this.speedData), mmo: this.speedData.getMmo() }, {
                setInternalFlightDirector: true,
                autoCoordinationEnabled: true,
                maxRudderDeflection: 25,
                rudderBankFactor: 0.075,
                rudderServoRate: 1,
                zeroRollHeight: 25 + this.radioAltimeterOffset,
            }, 
            // fudged RA as while the offset reads correctly at zero pitch on the ground, it does not read 0 at touchdown pitch as it should
            this.radioAltimeterOffset + 3, {
                kP: 1.8,
                kI: 0.000001,
                kD: 0.00,
                maxOut: 10,
                minOut: -10
            }, 
            // low momentum 472,000 lbs * 500 fpm... high momentum 688,000 lbs * 1000 fpm
            (height, weight, inertialVs) => height <= MathUtils.lerp(weight * -inertialVs, 236000000, 688000000, 58, 65)
                ? MathUtils.lerp(height, 0, 50, -100, -400, true, false)
                : -800, {
                angleClosureRate: (gsAngleError, gsAngle, currentAngleRate, distance) => {
                    // Full sensitivity scaling down to half-sensitivity as distance to glideslope antenna decreases from 2km to 1km.
                    gsAngleError *= MathUtils.lerp(distance, 2000, 1000, 1, 0.5, true, true);
                    const gsAngleErrorAbs = Math.abs(gsAngleError);
                    if (gsAngleErrorAbs <= 0.175) {
                        return MathUtils.lerp(gsAngleError * gsAngleError, 0, 0.030625, 0, 0.00875, true, true);
                    }
                    else {
                        return MathUtils.lerp(gsAngleErrorAbs, 0.175, 0.7, 0.00875, 0.06125, true, true);
                    }
                }
            });
            this.ap = new BoeingAutopilot(this.bus, this.flightPlanner, this.apConfig, new B748APStateManager(this.bus, this.apConfig), this.messageTransmitter);
            this.fmsOperatingPhaseController = new FmsOperatingPhaseController(this.bus, this.fms);
            this.navDataComputer = new BoeingNavDataComputer(this.bus, this.flightPlanner, this.fms.activePerformancePlan, this.facLoader, this.messageService);
            this.vorManager = new BoeingVorManager(this.bus, this.flightPlanner, this.facLoader);
            new BoeingIanManager(this.bus, this.fms, this.flightPlanner, BoeingFms.ACT_RTE_PLAN_INDEX);
            this.b748DoorPositionPublisher = new B748DoorPositionPublisher(this.bus);
            this.backplane.addPublisher('b74DoorPositionPublisher', this.b748DoorPositionPublisher);
            this.b748DoorInstrument = new B748DoorDataInstrument(this.bus);
            this.backplane.addInstrument('b74DoorInstrument', this.b748DoorInstrument);
            this.b748PressurizationSystem = new B748PressurizationSystem(this.bus, this.fms);
            this.backplane.addInstrument('b748PressurizationSystem', this.b748PressurizationSystem);
            // THRUST, FADEC & AUTOTHROTTLE
            this.thrustModeManager = new BoeingThrustModeManager(this.bus, this.fms.activePerformancePlan);
            const aoaDataProvider = new DefaultAoaDataProvider(this.bus, this.aoaIndex, this.iauAdcIndex);
            aoaDataProvider.init();
            // Use offset of 4 because first eng fuel switch simvar index is at 5 (FUELSYSTEM VALVE SWITCH:5)
            this.fadec = new BoeingFadec(this.bus, this.engineDataProvider, this.performanceMath, this.thrustModeManager, false, 4);
            this.autothrottle = new BoeingAutothrottle(this.bus, this.fadec, aoaDataProvider, this.speedData, this.performanceMath, this.thrustModeManager, 'CIRCUIT ON:27', this.ap.apValues, {
                autoActivateOnArm: true,
            });
            this.autothrottle.init();
            // Handle V speed conditions:
            this.vSpeedConditionsController = new VSpeedConditionsController(this.bus, this.fms);
            this.speedManager = new FmsSpeedManager(this.bus, this.flightPlanner, this.verticalPathCalculator, this.perfPlanRepository, this.speedData, this.pathPerformanceProvider, this.messageTransmitter, this.engineDataProvider, this.windPlanner, Subject.create(1), Subject.create(1));
            this.xpdrManager = new B748TCASTransponderManager(this.bus);
            this.mcpRunwayHeadingManager = new BoeingMcpRunwayHeadingManager(this.bus);
        }
        this.doInit();
    }
    /** @inheritdoc */
    getSourceSelectSide() {
        // The FCOM doesn't specify preferred IRS for CDUs, so we will just use the standard left/right logic.
        return this.instrument.instrumentIndex === 2 ? 'right' : 'left';
    }
    /** @inheritdoc */
    getVerticalPathCalculatorOptions() {
        return {
            enablePathCalc: this.instrument.instrumentIndex === 1,
            engineCount: 4
        };
    }
    /** @inheritDoc */
    getLocallyCalculatePredictions() {
        return this.iauIndex === 1;
    }
    /** Performs initialization tasks. */
    async doInit() {
        var _a, _b;
        this.backplane.init();
        // Make sure to init plan and await it before rendering anything, to avoid plan doesn't exist errors
        await this.initFlightPlan();
        (_a = this.speedManager) === null || _a === void 0 ? void 0 : _a.init();
        FSComponent.render(this.renderComponents(), document.getElementById('Electricity'));
        if (this.iauIndex === 1) {
            this.initNearestContext();
            (_b = this.xpdrManager) === null || _b === void 0 ? void 0 : _b.init();
        }
        this.tryRunOnFlightStart();
    }
    /** @inheritdoc */
    onFlightStart() {
        var _a, _b;
        super.onFlightStart();
        // These only exist on the primary CDU
        (_a = this.fadec) === null || _a === void 0 ? void 0 : _a.onFlightStart();
        (_b = this.ap) === null || _b === void 0 ? void 0 : _b.stateManager.initialize();
    }
    /** Initializes this instrument's nearest context. */
    async initNearestContext() {
        await this.facLoader.awaitInitialization();
        // TODO provide FMS pos
        NearestContext.initialize(this.facLoader, this.bus);
        this.bus.getSubscriber().on('realTime').atFrequency(0.5).handle(() => {
            NearestContext.getInstance().update();
        });
    }
    /** @inheritdoc */
    onInteractionEvent(args) {
        super.onInteractionEvent(args);
    }
    /**
     * Renders this instrument's components.
     * @returns This instrument's rendered components, as a VNode.
     */
    renderComponents() {
        return (FSComponent.buildComponent(B748Square, { pfdOrMfd: "CDU", instrumentIndex: this.iauIndex },
            FSComponent.buildComponent(B748Cdu, { bus: this.bus, index: this.iauIndex, fms: this.fms })));
    }
    /** Makes sure that we have the flight plan, requesting sync if needed. */
    async initFlightPlan() {
        // If not index 1, wait for index 1 to create the plan
        if (this.iauIndex !== 1) {
            await Wait.awaitDelay(2000);
        }
        // Request a sync from any other instrument in case of an instrument reload
        this.fms.flightPlanner.requestSync();
        await Wait.awaitDelay(500);
        // Only CDU 1 should create the flight plan
        if (this.iauIndex === 1) {
            // Initialize the primary plan in case one was not synced.
            await this.fms.initPrimaryFlightPlan();
            // Never await the dev plan
            // DevPlan.setupDevPlan(this.fms).catch(error => console.error(error));
        }
    }
    /** @inheritdoc */
    Update() {
        var _a;
        super.Update();
        (_a = this.navDataComputer) === null || _a === void 0 ? void 0 : _a.update();
        if (this.ap) {
            this.ap.update();
            // Planner update
            const now = Date.now();
            if (now - this.lastCalculate > 3000) {
                const planInMod = this.fms.planInMod.get();
                if (this.flightPlanner.hasFlightPlan(0)) {
                    this.flightPlanner.getFlightPlan(0).calculate();
                }
                if (planInMod && this.flightPlanner.hasFlightPlan(1)) {
                    this.flightPlanner.getFlightPlan(1).calculate();
                }
                SimVar.SetSimVarValue('K:HEADING_GYRO_SET', SimVarValueType.Number, 0);
                this.lastCalculate = now;
            }
        }
        if (this.fmsOperatingPhaseController) {
            this.fmsOperatingPhaseController.update();
        }
    }
}

/// <reference types="@microsoft/msfs-types/js/common" />
/**
 * A Boeing 747-8i CDU BaseInstrument.
 */
class WTB748_CDU extends FsBaseInstrument {
    /** @inheritdoc */
    get isInteractive() {
        return true; // Enabling touch for all instruments for development.
    }
    /** @inheritdoc */
    constructInstrument() {
        return new WTB748CduInstrument(this, new AvionicsConfig(this, this.xmlConfig));
    }
    /** @inheritdoc */
    get templateID() {
        return 'WTB748_CDU';
    }
    /** @inheritdoc */
    onPowerOn() {
        super.onPowerOn();
        this.fsInstrument.onPowerOn();
    }
    /** @inheritdoc */
    onShutDown() {
        super.onShutDown();
        this.fsInstrument.onPowerOff();
    }
}
registerInstrument('wtb748-cdu', WTB748_CDU);
